 2/1: runfile('C:/Users/Radu/Documents/MATLAB/GIT/wild_python/compElektro.py', wdir='C:/Users/Radu/Documents/MATLAB/GIT/wild_python')
 2/2: !pip install gmsh
 2/3: runfile('C:/Users/Radu/Documents/MATLAB/GIT/wild_python/compElektro.py', wdir='C:/Users/Radu/Documents/MATLAB/GIT/wild_python')
 6/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
 6/2: !pip install ngsolve
 6/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
 6/4: !pip install ngsolve
 7/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
 7/2: !pip install ngsolve
 7/3: !pip install gmsh
 7/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
 8/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
 8/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
10/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
10/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
10/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
11/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
11/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
11/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
12/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
12/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
12/3: !pip install ngsolve
12/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
12/5: import ngsolve
12/6: !pip remove ngsolve
12/7: !pip uninstall ngsolve
12/8: !conda install -c ngsolve ngsolve
12/9: import ngsolve
12/10: !pip install ngsolve
12/11: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
12/12: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
15/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
15/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
15/3: !which pip
15/4: !where pop
15/5: !where pip
15/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
15/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
15/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
15/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
15/10: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
15/11: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
15/12: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
16/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
16/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
16/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
16/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
16/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
16/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
16/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
16/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
16/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
16/10: writer.setup(fig, "writer_test.mp4", 500)
16/11: writer.setup(fig, "writer_test.mp4", 500)
16/12: fig.show()
16/13: writer.setup(fig, "writer_test.mp4", 500)
16/14: fig.show()
16/15: ax1 = fig.add_subplot(221)
16/16: ax2 = fig.add_subplot(222)
16/17:
if k == 0:
    fig = plt.figure()
    writer.setup(fig, "writer_test.mp4", 500)
    fig.show()
    ax1 = fig.add_subplot(221)
    ax2 = fig.add_subplot(222)
    ax3 = fig.add_subplot(223)
    ax4 = fig.add_subplot(224)

tm = time.monotonic()
ax1.cla()
ax1.set_aspect(aspect = 'equal')
MESH.pdesurf2(u[:MESH.np], ax = ax1)
# MESH.pdemesh2(ax = ax)
MESH.pdegeom(ax = ax1)
Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
ax1.tricontour(Triang, u[:MESH.np], levels = 25, colors = 'k', linewidths = 0.5, linestyles = 'solid')

ax2.cla()
ax2.set_aspect(aspect = 'equal')
MESH.pdesurf2(ux**2+uy**2, ax = ax2)
# MESH.pdemesh2(ax = ax)
MESH.pdegeom(ax = ax2)
# Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])

ax3.cla()
# ax3.set_aspect(aspect = 'equal')
ax3.plot(tor)
ax3.plot((energy[2:]-energy[1:-1])*(ident_points_gap.shape[0]))

ax4.cla()
# ax3.set_aspect(aspect = 'equal')
ax4.plot(energy)
16/18:
if k == 0:
    fig = plt.figure()
    # writer.setup(fig, "writer_test.mp4", 500)
    fig.show()
    ax1 = fig.add_subplot(221)
    ax2 = fig.add_subplot(222)
    ax3 = fig.add_subplot(223)
    ax4 = fig.add_subplot(224)

tm = time.monotonic()
ax1.cla()
ax1.set_aspect(aspect = 'equal')
MESH.pdesurf2(u[:MESH.np], ax = ax1)
# MESH.pdemesh2(ax = ax)
MESH.pdegeom(ax = ax1)
Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
ax1.tricontour(Triang, u[:MESH.np], levels = 25, colors = 'k', linewidths = 0.5, linestyles = 'solid')

ax2.cla()
ax2.set_aspect(aspect = 'equal')
MESH.pdesurf2(ux**2+uy**2, ax = ax2)
# MESH.pdemesh2(ax = ax)
MESH.pdegeom(ax = ax2)
# Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])

ax3.cla()
# ax3.set_aspect(aspect = 'equal')
ax3.plot(tor)
ax3.plot((energy[2:]-energy[1:-1])*(ident_points_gap.shape[0]))

ax4.cla()
# ax3.set_aspect(aspect = 'equal')
ax4.plot(energy)
22/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/geometry_nogap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/geometry_nogap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/geometry_nogap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/geometry_nogap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/10: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/11: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/12: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/13: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/14: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/15: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/16: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/17: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/18: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/19: MESH
22/20: MESH.dsadas = 1
22/21: MESH.dsadas
22/22: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/23: getPointsMESH(MESH)
22/24: MESH.ident_edges_gap
22/25: jumps
22/26: jumps
22/27: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/28: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/31: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/32: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/33: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/34: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/35: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/36: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/37: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/38: RS
22/39: RS.shape
22/40: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/41: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/42: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/43: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/44: R0
22/45: RS
22/46: RSS
22/47: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/48: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/49: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/50: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/51: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/52: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/53: writer.setup(fig, "writer_test.mp4", 500)
22/54: runfile('C:/Users/Radu/anaconda/envs/fem39/lib/site-packages/matplotlib/animation.py', wdir='C:/Users/Radu/anaconda/envs/fem39/lib/site-packages/matplotlib')
22/55: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/56: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/57: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/58: MESH.pdesurf2(u,ax=ax)
22/59: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/60: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/61: pde.pdesurf2
22/62: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/63: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/64: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/65: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/66: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/67: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/68: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/69: MESH.pdemesh2(ax = ax)
22/70: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/71: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/72:
ax = fig.add_subplot(111)
ax.cla()
MESH.pdesurf2(u,ax = ax)
MESH.pdegeom(ax = ax)
MESH.pdemesh2(ax = ax)
plt.pause(0.01)
22/73:
MESH.pdesurf2(u,ax = ax)
MESH.pdegeom(ax = ax)
MESH.pdemesh2(ax = ax)
22/74: ax
22/75: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/76: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/77: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/78: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/79: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
22/80: MESH.pdesurf2(u)
22/81: MESH.pdesurf2(u,cmap)
22/82: MESH.pdesurf2(u,cmap='jet')
22/83: cmap
22/84: cmap='hot'
22/85: cmap
22/86: MESH.pdesurf2(u,cmap='hot')
22/87: MESH.pdesurf2(u,cmap='rainbow')
22/88: cmap
22/89: cmap = 'rainbow'
22/90: cmap
22/91: cmap = plt.cm.rainbow
22/92: cmap
22/93: MESH.pdesurf2(u,cmap=plt.cm.rainbow)
22/94: MESH.pdesurf2(u,cmap=plt.cm.rainbow)
22/95: MESH.pdesurf2(u,cmap=plt.cm.rainbow)
22/96: ax = MESH.pdesurf2(u,cmap=plt.cm.rainbow)
22/97: MESH.pdemesh2(ax=ax)
22/98: MESH.pdemesh2(ax=ax)
22/99: ax = MESH.pdesurf2(u,cmap=plt.cm.rainbow)
22/100: MESH.pdemesh2(ax=ax)
22/101: MESH.pdegeom(ax=ax)
22/102: ax.cmap
22/103: ax = MESH.pdesurf2(u,cmap=plt.cm.rainbow)
22/104: plt.cm.rainbow
22/105: ax = MESH.pdesurf2(u,cmap=plt.cm.rainbow)
22/106: plt.cm
22/107: plt.cm.Accent
22/108: plt.cm.ColormapRegistry
22/109: plt.cm.Purples
22/110: plt.cm.hot
22/111: ax = MESH.pdesurf2(u,cmap=plt.cm.hot)
22/112: plt.cm.bone
22/113: plt.cm.Oranges
22/114: ax = MESH.pdesurf2(u,cmap=plt.cm.Oranges)
23/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/10: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/11: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/12:
if k == 0:
    fig = plt.figure()
    writer.setup(fig, "writer_test.mp4", 500)
    fig.show()
    
    ax1 = fig.add_subplot(221)
    ax2 = fig.add_subplot(222)
    ax3 = fig.add_subplot(223)
    ax4 = fig.add_subplot(224)

tm = time.monotonic()
ax1.cla()
ax1.set_aspect(aspect = 'equal')
MESH.pdesurf2(A, ax = ax1)
# MESH.pdemesh2(ax = ax)
MESH.pdegeom(ax = ax1)
Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
# ax1.tricontour(Triang, u[:MESH.np], levels = 25, colors = 'k', linewidths = 0.5, linestyles = 'solid')

ax2.cla()
ax2.set_aspect(aspect = 'equal')
MESH.pdesurf2(Bx**2+By**2, ax = ax2)
# MESH.pdemesh2(ax = ax)
MESH.pdegeom(ax = ax2)
Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])

ax3.cla()
# ax3.set_aspect(aspect = 'equal')
ax3.plot(tor)
ax3.plot((energy[2:]-energy[1:-1])*(MESH.ident_points_gap.shape[0]))

ax4.cla()
# ax3.set_aspect(aspect = 'equal')
ax4.plot(energy)

writer.grab_frame()
23/13: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/14: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/15: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/16: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/17: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/18: "Hello, %s!" % name
23/19: "Hello, %s!"
23/20: "Hello, %s!" % 'a'
23/21: "Hello, %f!" % 1231
23/22: "Hello, %.2f!" % 1231
23/23: "Hello, %2.2f!" % 1231
23/24: "Hello, %0.2f!" % 1231
23/25: print("Hello, %0.2f!" % 1231)
23/26: print("Hello, %0.2f!" % 1231, end = '')
23/27: print("Hello, %0.2f!" % 1231, end = '', 'dsa')
23/28: print("Hello, %0.2f!" % 1231, end = "")
23/29:
for i in range(0,9):
    print(f"{i} ", end='')
23/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/31: print('Inverting took %.2f ' % time.monotonic()-tm)
23/32: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/33:

print('Inverting took %.2f ' % (time.monotonic()-tm))
23/34: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/35: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/36: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/37: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/38: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/39: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/nonlinLaws_brauer_fit.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/40: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/41: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/42: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/43: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/44: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/45: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/46: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/47: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/48: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/49: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/50: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/51: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/52: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/53: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/54: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/55: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/56: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/57: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/58: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/59: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/60: mu
23/61: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/62: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/63: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/64: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/65: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/66: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/67: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/68: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/69: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/70: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
23/71: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/10: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/findPoints.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/11: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/12: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/13: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/14: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/findPoints.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/15: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/16: MESH.jumps
26/17: MESH.ident_points.shape[0]
26/18: MESH.ident_points
26/19: MESH.ident_points.shape[0]
26/20: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/findPoints.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/21: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/22: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/23: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/24: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/25: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/26: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/27: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/28: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/31: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/32: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/33: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/34: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/35: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/36: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/37: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/38: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
26/39: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/4: gss(u)
25/5: plt.spy(gss(u))
25/6: plt.spy(gss(u),markersize=1)
25/7: plt.spy(gss(u),markersize=1)
25/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/9: plt.spy(gss(u)[1],markersize=1)
25/10: gss(u)[1]
25/11: AA = gss(u)[1]
25/12: AA
25/13: IAA = sps.linalg.inv(AA)
25/14: iAA = sps.linalg.inv(AA)
25/15: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/16: AA = gss(u)[1]
25/17: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/18: AA = gss(u)[1]
25/19: iAA = sps.linalg.inv(AA)
25/20: plt.spy(iAA)
25/21: iAA2 = pde.tools.fastBlockInverse(AA)
25/22: iAA2
25/23: AA
25/24: AA = gss(u)[1]
25/25: AA
25/26: plt.spy(AA)
25/27: sps.diags(100)
25/28: sps.diags(1)
25/29: sps.diags()
25/30: sps.diags([1,2,3,4,5])
25/31: D1 = sps.diags([1,2,3,4,5])
25/32: E = bmat[[D1,2*D1],[3*D1,4*D1]]
25/33: E = bmat([[D1,2*D1],[3*D1,4*D1]])
25/34: E
25/35: spy(E)
25/36: plt.spy(E)
25/37: pde.tools.fastBlockInverse(E)
25/38: sps.linalg.inv(E)
25/39: plt.spy(sps.linalg.inv(E))
25/40: D1 = sps.diags([1,2,3,4,5,6,7,8,9,123,124,123,124,412,123,123,12,312,312,4,1234,123,123,12,312,4,123,123,12,312,3412,3,123,123,12])
25/41: E = bmat([[D1,2*D1],[3*D1,4*D1]])
25/42: sps.linalg.inv(E)
25/43: plt.spy(sps.linalg.inv(E))
25/44: E
25/45: plt.spy(E)
25/46: plt.spy(E)
25/47: plt.spy(sps.linalg.inv(E))
25/48: plt.spy(sps.linalg.inv(E))
25/49: b
25/50: u
25/51: size(u)
25/52: len(u)
25/53: len(u)/2
25/54: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/55: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/56: gss(u)
25/57: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/58: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/59: len(b)
25/60: len(b)/2
25/61: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/62: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/63: debugfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/64: debugfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/65: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/66: gss(b)
25/67: gs(b).shape
25/68: gs(b,psi).shape
25/69: plt.spy(gss(b))
25/70: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/71: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/72: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/73: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/74: A
25/75: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/76: A.shape
25/77: b.shape
25/78: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/79: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/80: w
25/81: MESH.pdesurf2(w)
25/82: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/83: MESH.pdesurf2(w)
25/84: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/85: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/86: wb.shape
25/87: b.shape
25/88: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/89: iR.shape
25/90: wb.shape
25/91: b.shape
25/92: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/93: b.shape
25/94: wb.shape
25/95: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/96: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/97: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/98: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/99: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/100: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/101: gs(b,psi)
25/102: *gs(b,psi)
25/103: gs(b,psi)
25/104: gs(b,psi)[0]
25/105: gs(b,psi)[1]
25/106: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/107: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/108: (r1@wb+r2@wpsi)
25/109: J(b)
25/110: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/111: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/112: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/113: J(b)
25/114: J(b_old_i)
25/115: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/116: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/117: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/118: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/119: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/120: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/121: r1
25/122: r2
25/123: r1@wb
25/124: r1@wb+r2@psi
25/125: r1@wb
25/126: wb
25/127: e1
25/128: wb
25/129: wb.shape
25/130: MESH.pdesurf2(wb[:len(wb)//2])
25/131: MESH.pdesurf2(wb[len(wb)//2:])
25/132: r2.shape
25/133: wS.shape
25/134: RS.shape
25/135: RS@r2
25/136: (RS@r2).shape
25/137: (RS@r2)@wS
25/138: r2@wb
25/139: r2@wpsi
25/140: np.abs(J(b))*float_eps
25/141: alpha*mu*(r1@wb+r2@wpsi)
25/142: J(b+alpha*wb)-J(b)
25/143: alpha*mu*(r1@wb+r2@wpsi) + np.abs(J(b))*float_eps
25/144: J(b+alpha*wb)-J(b)
25/145: alpha
25/146: mu*(r1@wb+r2@wpsi)
25/147: wb
25/148: alpha
25/149: alpha
25/150: J(b+wb)-J(b)
25/151: mu*(r1@wb+r2@wpsi)
25/152: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/153: MESH.pdesurf2(psi)
25/154: wpsi
25/155: J(psi+wpsi)-J(psi)
25/156: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/157: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/158: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/159: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/160: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/161: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/162: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/163: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/164: MESH.pdesurf2(bx**2+by**2)
25/165: bx = b[:len(b)//2]; by = b[len(b)//2:]
25/166: MESH.pdesurf2(bx**2+by**2)
25/167: 2*np.cos(2)+np.sin(2)-2*np.exp(1)
25/168: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/169: plt
25/170: plt.cm.jet
25/171: plt.cm.rainbow
25/172: plt.cm.Pastel2
25/173: plt.cm.jet
25/174: clear
25/175: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/176: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/177: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/178: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/179: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/180: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/181: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/182: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/183: int(3.1)
25/184: int(3.4)
25/185: int(3.5)
25/186: int(3.6)
25/187: int(3.99)
25/188: int(3.99)
25/189: int(3.99999999999999999999999999999999999999999999999)
25/190: int(3.999999999999999999999999)
25/191: int(3.99999999999999)
25/192: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/193: Hj
25/194: Hjx
25/195: Hjy
25/196: MESH.pdesurf2(Hjx**2+Hjy**2)
25/197: MESH
25/198: Hjx.shape
25/199: Hj.shape
25/200: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/201: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/202: MESH.pdesurf2(Hjx**2+Hjy**2)
25/203: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/204: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/205: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/206: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/207: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/208: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/209: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/210: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/211: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/212: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/213: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/214: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/215: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/216: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/217: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/218: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/219: J(psi)
25/220: J(psi_old_i)
25/221: alpha
25/222: Hjx
25/223: Hjx.shape
25/224: MESH
25/225: MESH.pdesurf2(Hjx**2+Hjy**2)
25/226: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/227: MESH.pdesurf2(psi)
25/228: MESH.pdesurf2(psix)
25/229: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/230: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/231: MESH.pdesurf2(psi)
25/232: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/233: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/234: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/235: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/236: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/237: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/238: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/239: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/240: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/241: clsoe all
25/242:

from mixedEM_linear_gap import H as Hj
phix_Hcurl, phiy_Hcurl = pde.hcurl.assemble(MESH, space = 'N0', matrix = 'phi', order = order_dphidphi)
Hjx = phix_Hcurl.T@Hj
Hjy = phiy_Hcurl.T@Hj
25/243: MESH.pdesurf2(Hjx**2+Hjy**2)
25/244: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/245: MESH.pdesurf2(psi)
25/246: MESH.pdesurf2(psi)
25/247: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/248: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/249: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/250: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/251: A
25/252: eig
25/253: chol(A)
25/254: chol(-A)
25/255: chol(-2*A)
25/256: chol(-312312312312321312312312*A)
25/257: chol(-312312312312*A)
25/258: chol(A)
25/259: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/260: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/261: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/262: psix = dphix_H1.T@psi; psiy = dphiy_H1.T@psi
25/263: MESH.pdesurf2(psix*
25/264: MESH.pdesurf2(psix**2+psiy**2)
25/265: MESH.pdesurf2(psi)
25/266: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/267: MESH.pdesurf2(psi)
25/268: MESH.pdesurf2(wpsi)
25/269: MESH.pdesurf2(wpsi)
25/270: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/271: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/272: MESH.pdesurf2(wpsi)
25/273: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/274: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/275: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/276: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/277: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/278: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/279: J(psi)
25/280: J(psi_old_i)
25/281: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/282: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/283: MESH.pdesurf2(psi)
25/284: r1@b+r2@psi
25/285: r2@psi
25/286: psi
25/287: psi
25/288: r1@b
25/289: r2@psi
25/290: %J(psi)
25/291: J(psi)
25/292: MESH.pdesurf2(psi)
25/293: pde.tools.fastBlockInverse(R)
25/294: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/295: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/296: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/297: J(0*psi)
25/298: J(wpsi)
25/299: alpha
25/300: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/301: J(wpsi)
25/302: J(psi)
25/303: psi-wpsi
25/304: psi
25/305: wpsi
25/306: plt.plot(psi-wpsi)
25/307: psi
25/308: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/309: psi
25/310: wpsi
25/311: plt.plot(wpsi)
25/312: MESH.pdesurf2(wpsi)
25/313: ax = MESH.pdesurf2(wpsi)
25/314: ax
25/315: fig.colorbar(s, ax=ax, cax=ax)
25/316: fig.colorbar(wpsi, ax=ax, cax=ax)
25/317: fig.colorbar(plt.cmap, ax=ax, cax=ax)
25/318: J(psi)
25/319: J(psi+alpha*wpsi)
25/320: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/321: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/322: np.r_[wb,wS]
25/323: rhs
25/324: rhs@np.r_[wb,wS]
25/325: rhs@(np.r_[wb,wS])
25/326: rhs.shape
25/327: np.r_[wb,wS].shape
25/328: wS.shape
25/329: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/330: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/331: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/332: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/333: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/334: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/335: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/336: MESH.pdesurf2(wpsi)
25/337: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/338: MESH.pdesurf2(np.abs(wpsi))
25/339: rhs@wS
25/340: np.abs(J(psi))*float_eps
25/341: alpha*mu*(rhs@wS)
25/342: J(psi+alpha*wpsi)
25/343: J(psi)
25/344: alpha
25/345: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/346: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/347: alpha
25/348: J(psi+alpha*wpsi)
25/349: J(psi)
25/350: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/351: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/352: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/353: MESH.pdesurf2(Hjx**2+Hjy**2)
25/354: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/355: MESH.pdesurf2(Hjx**2+Hjy**2)
25/356: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/357: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/358: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/359: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/360: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/361: gs(b+alpha*wb,psi+alpha*wpsi)
25/362: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/363: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/364: gs(b+alpha*wb,psi+alpha*wpsi)
25/365: np.array(gs(b+alpha*wb,psi+alpha*wpsi))
25/366: np.array(*gs(b+alpha*wb,psi+alpha*wpsi))
25/367: np.array(gs(b+alpha*wb,psi+alpha*wpsi))
25/368: gs(b+alpha*wb,psi+alpha*wpsi)
25/369: np.r_[gs(b+alpha*wb,psi+alpha*wpsi)]
25/370: np.r_[gs(b+alpha*wb,psi+alpha*wpsi)].shape
25/371: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/372: alpha
25/373: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/374: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/375: Hx
25/376: Hy
25/377: MESH.pdesurf(Hx**2+Hy**2)
25/378: MESH.pdesurf(Hx**2+Hy**2)
25/379: MESH.pdesurf2(Hx**2+Hy**2)
25/380: MESH
25/381: Hx
25/382: Hx.shape
25/383: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/384: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/385: MESH
25/386: H.shape
25/387: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/388: MESH.pdesurf2(Hx**2+Hy**2)
25/389: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/390: MESH.pdesurf2(Hx**2+Hy**2)
25/391: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/392: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/393: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/394: np.r_[gs(b,psi)]
25/395: plt.plot(np.r_[gs(b,psi)])
25/396: np.linalg.norm(np.r_[gs(b,psi)],np.inf)
25/397: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/398: np.linalg.norm(np.r_[gs(b,psi)],np.inf)
25/399: abs(np.r_[gs(b,psi)])
25/400: max(np.r_[gs(b,psi)])
25/401: np.abs(np.r_[gs(b,psi)])
25/402: max(np.abs(np.r_[gs(b,psi)]))
25/403: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/404: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/405: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/406: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/407: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/408: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/409: rhs@wS
25/410: rhs
25/411: rhs@wS
25/412: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/413: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/414: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/415: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/416: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/417: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/418:

R,C,A = gss(b)
r1,r2,r = gs(b,psi)

# iR = pde.tools.fastBlockInverse(R)            
# A = -RS@C.T@iR@C@RS.T
# rhs = RS@(C.T@iR@r1-r2)


tm = time.monotonic()
# wS = chol(A).solve_A(-rhs)
# wS = sps.linalg.spsolve(A,-rhs)
w = sps.linalg.spsolve(A,-r)
print('Solving took ', time.monotonic()-tm)
25/419: RS.shape
25/420: C.shape
25/421: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/422: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/423: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/424: MESH.pdesurf(wpsi)
25/425: MESH.pdesurf(RS@wpsi)
25/426: MESH.pdesurf(RS.T@wpsi)
25/427: wpsi
25/428: wpsi.shape
25/429: MESH
25/430: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/431: MESH.pdesurf(RS.T@wpsi)
25/432: MESH.pdesurf(wpsi)
25/433: MESH.pdesurf2(wpsi)
25/434: RS@C
25/435: RS.T@C
25/436: C@RS
25/437: C@RS.T
25/438: RS@C.T
25/439: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/440: r2.shape
25/441: RS@r2
25/442: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/443: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/444: MESH.pdesurf(wpsi)
25/445: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/446: MESH.pdesurf(wpsi)
25/447: MESH.pdesurf(wpsi,u_height=1)
25/448: MESH.pdesurf_hybrid(wpsi,u_height=1)
25/449: MESH.pdesurf_hybrid(u=wpsi,u_height=1)
25/450: MESH.pdesurf_hybrid(u=wpsi,[],u_height=1)
25/451: MESH.pdesurf2(wpsi)
25/452: MESH.pdesurf2(wpsi,cmin=-4000,cmax = 4000)
25/453: MESH.pdesurf(wpsi,cmin=-4000,cmax = 4000)
25/454: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/455: MESH.pdesurf(wpsi,cmin=-4000,cmax = 4000)
25/456: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/457: MESH.pdesurf(wpsi,cmin=-4000,cmax = 4000)
25/458: RS@R2
25/459: RS@r2
25/460: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/461: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/462: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/463: r@w
25/464: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/465: r1
25/466: plt.plot(r)
25/467: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/468: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/469: J(psi)
25/470: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/471: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/472: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/473: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/474: MESH.pdesurf2(psi)
25/475: MESH.pdesurf2(psix)
25/476: MESH.pdesurf2(psix**2+psiy**2)
25/477: MESH.pdesurf2(hjx**2+psix**2+psiy**2)
25/478: MESH.pdesurf2(Hjx**2+psix**2+psiy**2)
25/479: MESH.pdesurf2(Hjx**2+psix**2+Hjy**2psiy**2)
25/480: MESH.pdesurf2(Hjx**2+psix**2+Hjy**2+psiy**2)
25/481: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/482: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/483: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/484: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/485: MESH.pdesurf2(psi)
25/486: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/487: MESH.pdesurf2(psi)
25/488: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/489: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/490: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/491: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/492: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/493: w[sb:]
25/494: plt.plot(w[sb:])
25/495: plt.plot(w[sb:])
25/496: plt.plot(RS.T@w[sb:])
25/497: MESH.pdesurf2(psi)
25/498: g_linear
25/499: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/nonlinLaws_brauer_fit.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/500: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/nonlinLaws_brauer_fit.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/501: plt.plot(yy,mu.derivative()(yy),'*')
25/502: plt.plot(yy,mu.derivative()(yy),'*')
25/503: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/504: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/505: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/nonlinLaws_brauer_fit.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/506: plt.plot(yy,mu.derivative(1)(yy),'*')
25/507: plt.plot(yy,-mu.derivative(1)(yy),'*')
25/508: plt.plot(yy,mu(yy),'*')
25/509:
yy = np.exp(np.linspace(0,np.log(1e8),300))-1
plt.figure()
plt.plot(yy,mu(yy),'*')
plt.plot(yy,mu.derivative()(yy),'*')
plt.plot(yy,1/nu0+0*yy)
plt.plot(xx,dx_nu.antiderivative(0)(xx)*xx,'.')
25/510: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/511: 1/2*nu.antiderivative(1)(x**2+y**2)
25/512:
plt.figure()
plt.plot(mu(yy**2)*nu(mu(yy**2)**2*yy**2))
25/513: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/nonlinLaws_brauer_fit.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/514: plt.plot(mu(yy**2)*nu(mu(yy**2)**2*yy**2))
25/515: plt.plot(xx,dx_nu.antiderivative(0)(xx)*xx,'.')
25/516: plt.plot(yy,nu.antiderivative()(yy),'*')
25/517: plt.plot(xx,nu.antiderivative()(xx),'*')
25/518: plt.plot(xx,mu.antiderivative()(xx),'*')
25/519: plt.plot(yy,mu.antiderivative()(yy),'*')
25/520: plt.plot(yy,mu.antiderivative()(yy),'*')
25/521: plt.plot(yy,mu(yy),'*')
25/522: plt.plot(yy,mu(yy),'*')
25/523: yy
25/524: plt.plot(yy,mu(yy),'*')
25/525: plt.plot(yy,mu(yy),'*')
25/526: plt.plot(yy,mu.antiderivative()(yy),'*')
25/527: plt.plot(yy,mu.antiderivative()(yy),'*')
25/528: plt.plot(yy,mu.antiderivative()(yy),'*')
25/529: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/530: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/531: M0_dphi
25/532: plt.plot(M0_dphi)
25/533: plt.plot(M0_dphi)
25/534: plt.plot(M0_dphi)
25/535: plt.plot(M1_dphi)
25/536: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/537: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/538: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/539: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/540: Hjx.max()
25/541: Hjx.min()
25/542: psix
25/543: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/544: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/545: psi
25/546: plt.plot(psi)
25/547: plt.plot(psi)
25/548: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/549: alpha
25/550: J(psi)
25/551: J(psi+1/2*wpsi)
25/552: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/553: J(psi+1/2*wpsi)
25/554: J(psi)
25/555: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/556: xx
25/557: g_nonlinear(xx,xx)
25/558: plt.plot(g_nonlinear(xx,xx))
25/559: xx
25/560: xx = np.linspace(-10,10,1)
25/561: xx
25/562: xx = np.linspace(-10,10,0.1)
25/563: xx = np.linspace(-10,10,1000)
25/564: xx
25/565: xx = np.linspace(-1e8,1e8,1000)
25/566: xx = np.linspace(-1e8,1e8,1e16)
25/567: xx = np.linspace(-1e8,1e8,int(1e16))
25/568: xx = np.linspace(-1e8,1e8,int(1e8))
25/569: xx
25/570: plt.plot(g_nonlinear(xx,xx))
25/571: plt.plot(xx,g_nonlinear(xx,xx))
25/572: plt.plot(xx,f_nonlinear(xx,xx))
25/573: plt.plot(xx,f_nonlinear(xx,xx))
25/574: xx = np.linspace(-1,1,int(1000))
25/575: plt.plot(xx,f_nonlinear(xx,xx))
25/576: plt.plot(xx,g_nonlinear(xx,xx))
25/577: plt.plot(xx,g_linear(xx,xx))
25/578: plt.plot(xx,g_nonlinear(xx,xx))
25/579: plt.plot(xx,g_linear(xx,xx))
25/580: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/581: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/582: J(psi)
25/583: J(psi+1/2*wpsi)
25/584: J(psi+wpsi)
25/585: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/586: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/587: MESH.pdesurf2(psi)
25/588: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/589: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/590: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/591: MESH.pdesurf2(psi)
25/592: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/593: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/594: r@w
25/595: np.linalg.norm(r,np.inf)
25/596: r
25/597: plt.plot(r)
25/598: plt.plot(r)
25/599: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/600: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/601: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/602: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/603: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/604: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/605: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/606: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/607: Hjx
25/608: J(psi+alpha*wpsi)
25/609: J(psi)
25/610: J(psi+wpsi)
25/611: J(psi+1/2*wpsi)
25/612: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/613: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/614: MESH.pdesurf2(psi)
25/615: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/616: MESH.pdesurf2(psi)
25/617: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/618: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/619: MESH.pdesurf2(psi)
25/620: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/621: MESH.pdesurf2(psi)
25/622: MESH.pdesurf2(psix)
25/623: MESH.pdesurf2(psix**2+psiy**2)
25/624: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
25/625: MESH.pdesurf2(psix**2+psiy**2)
25/626: MESH.pdesurf2(psix**2+psiy**2)
25/627: MESH.pdesurf2(psi)
25/628: MESH.pdesurf2(psi,cmin=1)
25/629: MESH.pdesurf2(psi)
25/630: MESH.pdesurf2(psi,cmax=1)
25/631: runfile('C:/Users/Radu/Documents/GitHub/fem/pde/mesh_class.py', wdir='C:/Users/Radu/Documents/GitHub/fem/pde')
25/632: MESH.pdesurf2(psi,cmax=1)
25/633: MESH.pdesurf2(psi,cmax=1)
25/634: MESH.pdesurf2(psi,cmax=1)
27/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/3: MESH.pdesurf2(psi)
27/4: MESH.pdesurf2(psi,cmin=1)
27/5: MESH.pdesurf2(psi,cmin=1,cmax=1)
27/6: MESH.pdesurf2(psi,cmin=-1000,cmax=1000)
27/7: MESH.pdesurf2(psi,cmin=-1e5,cmax=1000)
27/8: MESH.pdesurf2(psi,cmin=-1e5,cmax=1e5)
27/9: MESH.pdesurf2(psi,cmin=-1e4,cmax=1e4)
27/10: MESH.pdesurf2(psi,cmin=-1e3,cmax=1e3)
27/11: MESH.pdesurf2(psi,cmin=-4*1e3,cmax=4*1e3)
27/12: MESH.pdesurf2(psi,cmin=-4*1e3,cmax=4*1e3)
27/13: MESH.pdesurf2(psi)
27/14: max(psi)
27/15: min(psi)
27/16: MESH.pdesurf2(psi,cmin=-3844,cmax=3844)
27/17: MESH.pdesurf2(psix**2+psiy**2,cmin=-3844,cmax=3844)
27/18: psix = dphix_H1.T@psi; psiy = dphiy_H1.T@psi
27/19: MESH.pdesurf2(psix**2+psiy**2,cmin=-3844,cmax=3844)
27/20: MESH.pdesurf2(psix**2+psiy**2,cmin=0,cmax=10)
27/21: MESH.pdesurf2(psix**2+psiy**2,cmin=0,cmax=1)
27/22: max(psix**2+psiy**2)
27/23: MESH.pdesurf2(psix**2+psiy**2,cmin=0,cmax=1e10)
27/24: MESH.pdesurf2(psix**2+psiy**2,cmin=0,cmax=1e7)
27/25: MESH.pdesurf2(psix**2+psiy**2,cmin=0,cmax=1e8)
27/26: MESH.pdesurf2(psix**2+psiy**2,cmin=0,cmax=1e9)
27/27: MESH.pdesurf2(psix**2+psiy**2)
27/28: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_nonlinear_gap_hybrid.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/31: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/32: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/33: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/34: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/35: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/36: MESH.pdesurf2(psi)
27/37: MESH.pdesurf2(psi,cmax=1000,cmin=1000)
27/38: MESH.pdesurf2(psi,cmax=-4000,cmin=4000)
27/39: MESH.pdesurf2(psi,cmax=4000,cmin=-4000)
27/40: MESH.pdesurf2(psi,cmax=3000,cmin=-3000)
27/41: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/42: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/43: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/44: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/45: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/46: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/47: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/48: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/49: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/50: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/51: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/52: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/53: ax = MESH.pdesurf2(psi)
27/54: ax.colorbar(neg, ax=ax2, location='right', anchor=(0, 0.3), shrink=0.7)
27/55: plt.colorbar
27/56: plt.colorbar()
27/57: ax
27/58: plt.colorbar(ax=ax)
27/59: ax = MESH.pdesurf2(psi)
27/60: ax = MESH.pdesurf2(psi)
27/61: psi
27/62: ax = MESH.pdesurf2(wpsi)
27/63: ax = MESH.pdesurf2(wpsi)
27/64: MESH.pdesurf2(wpsi)
27/65: MESH.pdesurf2(wpsi,cbar=1)
27/66: MESH.pdesurf2(wpsi,cbar=1)
27/67: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/68: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/69: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/70: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/71: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/72: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/73: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/74: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/75: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/76: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/77: MESH.pdesurf2(wpsi)
27/78: MESH.pdesurf2(psi)
27/79: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/80: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/81: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/82: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/83: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/84: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/85: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/86: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/87: gsu@wS
27/88: J(u)
27/89: J(u+alpha*w)
27/90: J(u+1/2*w)
27/91: J(u+1/16*w)
27/92: J(u-1/16*w)
27/93: J(u-1/2*w)
27/94: runcell(0, 'C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py')
27/95: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/96: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/97: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/98: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/99: gsu@wS
27/100: np.abs(J(u))
27/101: np.abs(J(u))*float_eps
27/102: J(u)
27/103: J(u+alpha*w)
27/104: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/105: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/106: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/107: runcell(0, 'C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py')
27/108: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/109: MESH.pdesurf2(psi)
27/110: MESH.pdesurf2(wpsi)
27/111: J(psi)
27/112: J(psi_old_i)
27/113: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/114: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/115: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/116: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/117: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/118: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/119: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/120: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/121: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/122: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/123: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/124: gsu@wS
27/125: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/126: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/127: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/128: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/129: gsu@wS
27/130: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/131: RS@RS.T
27/132: (RS@RS.T)[1,1]
27/133: (RS@RS.T)[0,0]
27/134: (RS@RS.T)[3,0]
27/135: (RS@RS.T)[3,3]
27/136: (RS@RS.T)[100,100]
27/137: RS
27/138: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/139: r@w
27/140: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/141: r@w
27/142: J(psi)
27/143: J(psi+alpha*wpsi)
27/144: J(psi+wpsi)
27/145: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/146: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/147: alpha
27/148: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/149: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/150: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/151: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/152: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/153: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/154: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/155: Cx
27/156: Rs
27/157: RS
27/158: RS@psi
27/159: RS
27/160: C@psi
27/161: RS.T@RS
27/162: RS@RS.T
27/163: (Cx@psi).shape
27/164: RS.shape
27/165: Cx
27/166: Cx@RS.T
27/167: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/168: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/169: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/170: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/171: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/172: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/173: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/nonlinLaws_brauer_fit.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/174: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/nonlinLaws_brauer_fit.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/175: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/176: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/177: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/178: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/179: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/180: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/181: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/182: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
27/183: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/saveMeshes.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/6: runcell(0, 'C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py')
30/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/10: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/11: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/12: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/13: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/14: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/15: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/16: RS
30/17: RS2
30/18: RS-RS2
30/19: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/20: RS
30/21: phi_Hcurl.shape
30/22: phi_Hcurl[0].shape
30/23: phi_Hcurl(0).shape
30/24: phi_Hcurl(0)[0].shape
30/25: MESH
30/26: MESH.ne
30/27: MESH.ne_all
30/28: MESH.NoEdges
30/29: sps.eye(MESH.NoEdges)
30/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/31: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/32:
.cla()
ax2.set_aspect(aspect = 'equal')
MESH.pdesurf2(Hx**2+Hy**2, ax = ax2)
# MESH.pdemesh2(ax = ax)
MESH.pdegeom(ax = ax2)
Triang = matplotlib.t
30/33:
ax2.cla()
ax2.set_aspect(aspect = 'equal')
MESH.pdesurf2(Hx**2+Hy**2, ax = ax2)
# MESH.pdemesh2(ax = ax)
MESH.pdegeom(ax = ax2)
Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
30/34:
ax2.cla()
ax2.set_aspect(aspect = 'equal')
MESH.pdesurf2(Hx**2+Hy**2, ax = ax2)
# MESH.pdemesh2(ax = ax)
MESH.pdegeom(ax = ax2)
Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
30/35:
fig = plt.figure()
writer.setup(fig, "writer_test.mp4", 500)
fig.show()
ax1 = fig.add_subplot(111)
30/36:
tm = time.monotonic()
ax1.cla()
ax1.set_aspect(aspect = 'equal')
MESH.pdesurf2(A, ax = ax1)
# MESH.pdemesh2(ax = ax)
MESH.pdegeom(ax = ax1)
Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
# ax1.tricontour(Triang, u[:MESH.np], levels = 25, colors = 'k', linewidths = 0.5, linestyles = 'solid')
30/37: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/38: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/39: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/40: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/41: RS = getRS_H1_nonzero(MESH,ORDER,poly,k,rot_speed)
30/42: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/43: gss(u)
30/44: RS
30/45: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/46: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/47: RS
30/48: gss(u)
30/49: R_out, R_int = pde.h1.assembleR(MESH, space = poly, edges = 'stator_outer,left,right,airL,airR')
30/50: R_out, R_int = pde.h1.assembleR(MESH, space = poly, edges = 'stator_outer')
30/51: R_int
30/52: R_out
30/53: R_int
30/54: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/55: edges = 'stator_outer'
30/56: R_out
30/57: R_in
30/58: R_int
30/59: bmat
30/60: bmat([R_int,R_out])
30/61: bmat([R_int],[R_out]])
30/62: bmat([[R_int],[R_out]])
30/63: bmat([[R_int[1:]],[R_out]])
30/64: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/65: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/66: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/67: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/68: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/69: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/mixedEM_linear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/70: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/71: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/72: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/73: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
30/74: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/2: MESH.pdesurf2(psi)
29/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/10: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/11: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/12: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/13: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/14: MESH.pdesurf(psi)
29/15: MESH.pdesurf2(psi)
29/16:

dphix_H1_o1, dphiy_H1_o1 = pde.h1.assemble(MESH, space = poly, matrix = 'K', order = 0)
ux = dphix_H1_o1.T@u; uy = dphiy_H1_o1.T@u

Hx = Hjx + psix
Hy = Hjy + psiy

allH = g_nonlinear_all(Hx,Hy)
gx_H_l  = allH[1]; gy_H_l  = allH[2];
gx_H_nl = allH[8]; gy_H_nl = allH[9];

fem_linear = pde.int.evaluate(MESH, order = 0, regions = linear).diagonal()
fem_nonlinear = pde.int.evaluate(MESH, order = 0, regions = nonlinear).diagonal()

Bx = (gx_H_l*fem_linear + gx_H_nl*fem_nonlinear) + 1/nu0*M00
By = (gy_H_l*fem_linear + gy_H_nl*fem_nonlinear) + 1/nu0*M10

# fig = MESH.pdesurf((ux-1/nu0*M1_dphi)**2+(uy+1/nu0*M0_dphi)**2, u_height = 0, cmax = 5)
# fig.show()

# fig = MESH.pdesurf_hybrid(dict(trig = 'P1',quad = 'Q0',controls = 1), u[0:MESH.np], u_height=1)
# fig.show()


# ax.cla()
# MESH.pdesurf2(u[:MESH.np],ax = ax)

# fig.canvas.draw()
# fig.canvas.flush_events()
# time.sleep(0.1)

# input()

if plot == 1:
    if k == 0:
        fig = plt.figure()
        # writer.setup(fig, "writer_test.mp4", 500)
        fig.show()
        ax1 = fig.add_subplot(221)
        ax2 = fig.add_subplot(222)
        ax3 = fig.add_subplot(223)
        ax4 = fig.add_subplot(224)
    
    tm = time.monotonic()
    ax1.cla()
    ax1.set_aspect(aspect = 'equal')
    MESH.pdesurf2(u[:MESH.np], ax = ax1)
    # MESH.pdemesh2(ax = ax)
    MESH.pdegeom(ax = ax1)
    Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
    ax1.tricontour(Triang, u[:MESH.np], levels = 25, colors = 'k', linewidths = 0.5, linestyles = 'solid')
    
    ax2.cla()
    ax2.set_aspect(aspect = 'equal')
    MESH.pdesurf2((Bx)**2+(By)**2, ax = ax2)
    # MESH.pdesurf2((Hjx+ux)**2+(Hjy+uy)**2, ax = ax2)
    # MESH.pdemesh2(ax = ax)
    MESH.pdegeom(ax = ax2)
    # Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
    
    ax3.cla()
    # ax3.set_aspect(aspect = 'equal')
    ax3.plot(tor)
    ax3.plot((energy[2:]-energy[1:-1])*(ident_points_gap.shape[0]))
    
    ax4.cla()
    # ax3.set_aspect(aspect = 'equal')
    ax4.plot(energy)
    
    
    
    
    print('Plotting took  ', time.monotonic()-tm)
    
    tm = time.monotonic()
    # writer.grab_frame()
    print('Grabbing took  ', time.monotonic()-tm)
    # stop
29/17:

dphix_H1_o1, dphiy_H1_o1 = pde.h1.assemble(MESH, space = poly, matrix = 'K', order = 0)
psix = dphix_H1_o1.T@psi; psiy = dphiy_H1_o1.T@psi

Hx = Hjx + psix
Hy = Hjy + psiy

allH = g_nonlinear_all(Hx,Hy)
gx_H_l  = allH[1]; gy_H_l  = allH[2];
gx_H_nl = allH[8]; gy_H_nl = allH[9];

fem_linear = pde.int.evaluate(MESH, order = 0, regions = linear).diagonal()
fem_nonlinear = pde.int.evaluate(MESH, order = 0, regions = nonlinear).diagonal()

Bx = (gx_H_l*fem_linear + gx_H_nl*fem_nonlinear) + 1/nu0*M00
By = (gy_H_l*fem_linear + gy_H_nl*fem_nonlinear) + 1/nu0*M10

# fig = MESH.pdesurf((ux-1/nu0*M1_dphi)**2+(uy+1/nu0*M0_dphi)**2, u_height = 0, cmax = 5)
# fig.show()

# fig = MESH.pdesurf_hybrid(dict(trig = 'P1',quad = 'Q0',controls = 1), u[0:MESH.np], u_height=1)
# fig.show()


# ax.cla()
# MESH.pdesurf2(u[:MESH.np],ax = ax)

# fig.canvas.draw()
# fig.canvas.flush_events()
# time.sleep(0.1)

# input()

if plot == 1:
    if k == 0:
        fig = plt.figure()
        # writer.setup(fig, "writer_test.mp4", 500)
        fig.show()
        ax1 = fig.add_subplot(221)
        ax2 = fig.add_subplot(222)
        ax3 = fig.add_subplot(223)
        ax4 = fig.add_subplot(224)
    
    tm = time.monotonic()
    ax1.cla()
    ax1.set_aspect(aspect = 'equal')
    MESH.pdesurf2(psi[:MESH.np], ax = ax1)
    # MESH.pdemesh2(ax = ax)
    MESH.pdegeom(ax = ax1)
    # Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
    # ax1.tricontour(Triang, u[:MESH.np], levels = 25, colors = 'k', linewidths = 0.5, linestyles = 'solid')
    
    ax2.cla()
    ax2.set_aspect(aspect = 'equal')
    MESH.pdesurf2((Bx)**2+(By)**2, ax = ax2)
    # MESH.pdesurf2((Hjx+ux)**2+(Hjy+uy)**2, ax = ax2)
    # MESH.pdemesh2(ax = ax)
    MESH.pdegeom(ax = ax2)
    # Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
    
    ax3.cla()
    # ax3.set_aspect(aspect = 'equal')
    ax3.plot(tor)
    ax3.plot((energy[2:]-energy[1:-1])*(ident_points_gap.shape[0]))
    
    ax4.cla()
    # ax3.set_aspect(aspect = 'equal')
    ax4.plot(energy)
    
    
    
    
    print('Plotting took  ', time.monotonic()-tm)
    
    tm = time.monotonic()
    # writer.grab_frame()
    print('Grabbing took  ', time.monotonic()-tm)
    # stop
29/18: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/19: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/20: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/21: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/22: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/23: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/24: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/25: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/26: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/27: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/28: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/31: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/32: MESH.pdesurf2(u[:MESH.np], ax = ax1, cbar=1)
29/33: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/34: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/35: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/36:
dphix_H1_o1, dphiy_H1_o1 = pde.h1.assemble(MESH, space = poly, matrix = 'K', order = 0)
psix = dphix_H1_o1.T@psi; psiy = dphiy_H1_o1.T@psi

Hx = Hjx + psix
Hy = Hjy + psiy

allH = g_nonlinear_all(Hx,Hy)
gx_H_l  = allH[1]; gy_H_l  = allH[2];
gx_H_nl = allH[8]; gy_H_nl = allH[9];

fem_linear = pde.int.evaluate(MESH, order = 0, regions = linear).diagonal()
fem_nonlinear = pde.int.evaluate(MESH, order = 0, regions = nonlinear).diagonal()

Bx = (gx_H_l*fem_linear + gx_H_nl*fem_nonlinear) + 0*1/nu0*M00
By = (gy_H_l*fem_linear + gy_H_nl*fem_nonlinear) + 0*1/nu0*M10
29/37:
dphix_H1_o1, dphiy_H1_o1 = pde.h1.assemble(MESH, space = poly, matrix = 'K', order = 0)
psix = dphix_H1_o1.T@psi; psiy = dphiy_H1_o1.T@psi

Hx = Hjx + psix
Hy = Hjy + psiy

allH = g_nonlinear_all(Hx,Hy)
gx_H_l  = allH[1]; gy_H_l  = allH[2];
gx_H_nl = allH[8]; gy_H_nl = allH[9];

fem_linear = pde.int.evaluate(MESH, order = 0, regions = linear).diagonal()
fem_nonlinear = pde.int.evaluate(MESH, order = 0, regions = nonlinear).diagonal()

Bx = (gx_H_l*fem_linear + gx_H_nl*fem_nonlinear) + 0*1/nu0*M00
By = (gy_H_l*fem_linear + gy_H_nl*fem_nonlinear) + 0*1/nu0*M10

# fig = MESH.pdesurf((ux-1/nu0*M1_dphi)**2+(uy+1/nu0*M0_dphi)**2, u_height = 0, cmax = 5)
# fig.show()

# fig = MESH.pdesurf_hybrid(dict(trig = 'P1',quad = 'Q0',controls = 1), u[0:MESH.np], u_height=1)
# fig.show()


# ax.cla()
# MESH.pdesurf2(u[:MESH.np],ax = ax)

# fig.canvas.draw()
# fig.canvas.flush_events()
# time.sleep(0.1)

# input()

if plot == 1:
    if k == 0:
        fig = plt.figure()
        # writer.setup(fig, "writer_test.mp4", 500)
        fig.show()
        ax1 = fig.add_subplot(121)
        ax2 = fig.add_subplot(122)
        # ax3 = fig.add_subplot(223)
        # ax4 = fig.add_subplot(224)
    
    tm = time.monotonic()
    ax1.cla()
    ax1.set_aspect(aspect = 'equal')
    MESH.pdesurf2(psi[:MESH.np], ax = ax1, cbar=1)
    # MESH.pdemesh2(ax = ax)
    MESH.pdegeom(ax = ax1)
    # Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
    # ax1.tricontour(Triang, u[:MESH.np], levels = 25, colors = 'k', linewidths = 0.5, linestyles = 'solid')
    
    ax2.cla()
    ax2.set_aspect(aspect = 'equal')
    MESH.pdesurf2((Bx)**2+(By)**2, ax = ax2)
    # MESH.pdesurf2((Hjx+ux)**2+(Hjy+uy)**2, ax = ax2)
    # MESH.pdemesh2(ax = ax)
    MESH.pdegeom(ax = ax2)
    # Triang = matplotlib.tri.Triangulation(MESH.p[:,0], MESH.p[:,1], MESH.t[:,0:3])
    
    # ax3.cla()
    # # ax3.set_aspect(aspect = 'equal')
    # ax3.plot(tor)
    # ax3.plot((energy[2:]-energy[1:-1])*(ident_points_gap.shape[0]))
    
    # ax4.cla()
    # # ax3.set_aspect(aspect = 'equal')
    # ax4.plot(energy)
    
    
    
    
    print('Plotting took  ', time.monotonic()-tm)
    
    tm = time.monotonic()
    # writer.grab_frame()
    print('Grabbing took  ', time.monotonic()-tm)
    # stop
29/38: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/39: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/40: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/41: runcell(0, 'C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py')
29/42: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/43: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/44: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/45: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/46: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/47: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/48: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/49: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/50: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/51: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/52: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/53: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/54: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/55: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/56: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/57: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/58: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/59: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/60: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/61: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/62: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/63: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/64: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
29/65: R
29/66: pde.tools.fastBlockInverse(R)
29/67: R-1/2(R+R.T)
29/68: R-1/2*(R+R.T)
29/69: pde.tools.fastBlockInverse(1/2*(R+R.T))
31/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/2: R
31/3: iR = pde.tools.fastBlockInverse(R)
31/4: plt.spy(R,markersize=1)
31/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/10: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/11: bx
31/12: by
31/13: b
31/14: byx
31/15: b
31/16: psi
31/17: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/18: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/19: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/20: plt.spy(iR,markersize=1)
31/21: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/22: rhs
31/23: rhs.shape
31/24: wpsi.shape
31/25: RS@wpsi
31/26: (RS@wpsi).shape
31/27: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/28: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/31: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/32: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/33: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
31/34: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/10: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/11: bx
32/12: b
32/13: b.shape
32/14: bx = b[:len(b)//2]; by = b[len(b)//2:]
32/15: f_linear(bx,by)
32/16: f_nonlinear(bx,by)
32/17: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/18: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/19: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/20: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/21: J(b+alpha*wb)
32/22: J(b)
32/23: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/24: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/25: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/26: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/27: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/28: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/31: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/32: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/33: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/34: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/35: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/36: chol(AA)
32/37: chol(-AA)
32/38: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/39: chol(AA)
32/40: chol(-AA)
32/41: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/42:
tm = time.monotonic()
wpsi2 = sps.linalg.spsolve(AA,-rr)
wb2 = iR@(C@wpsi2+r1)
print('Solving took ', time.monotonic()-tm)

wb = w[:sb]
wpsi = RS.T@w[sb:]

print('dif:',wb-wb2,wpsi-wpsi2)
32/43: wpsi2
32/44: C@wpsi2
32/45: wpsi2.shape
32/46: C.shape
32/47: RS@psi2
32/48: RS@wpsi2
32/49: RS.T@wpsi2
32/50: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/51: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/52: print('dif:',np.linalg.norm(wb-wb2),np.linalg.norm(wpsi-wpsi2))
32/53:
R,C = gss(b)
r1,r2 = gs(b,psi)

A = bmat([[R,-C@RS.T],
          [RS@C.T,None]]).tocsc()

r = np.r_[r1,0*RS@r2]

iR = pde.tools.fastBlockInverse2(R)

AA = RS@C.T@iR@C@RS.T
rr = RS@(C.T@iR@r1-r2)

tm = time.monotonic()
# wS = chol(AA).solve_A(-rr)
w = sps.linalg.spsolve(A,-r)
print('Solving took ', time.monotonic()-tm)


tm = time.monotonic()
wpsi2 = RS.T@sps.linalg.spsolve(AA,rr)
wb2 = iR@(C@wpsi2+r1)
print('Solving took ', time.monotonic()-tm)

wb = w[:sb]
wpsi = RS.T@w[sb:]

print('dif:',np.linalg.norm(wb-wb2),np.linalg.norm(wpsi-wpsi2))
32/54:
R,C = gss(b)
r1,r2 = gs(b,psi)

A = bmat([[R,-C@RS.T],
          [RS@C.T,None]]).tocsc()

r = np.r_[r1,0*RS@r2]

iR = pde.tools.fastBlockInverse2(R)

AA = RS@C.T@iR@C@RS.T
rr = RS@(C.T@iR@r1+0*r2)

tm = time.monotonic()
# wS = chol(AA).solve_A(-rr)
w = sps.linalg.spsolve(A,-r)
print('Solving took ', time.monotonic()-tm)


tm = time.monotonic()
wpsi2 = RS.T@sps.linalg.spsolve(AA,rr)
wb2 = iR@(C@wpsi2+r1)
print('Solving took ', time.monotonic()-tm)

wb = w[:sb]
wpsi = RS.T@w[sb:]

print('dif:',np.linalg.norm(wb-wb2),np.linalg.norm(wpsi-wpsi2))
32/55: np.linalg.norm(wb+wb2)
32/56: np.linalg.norm(wb-wb2)
32/57:
R,C = gss(b)
r1,r2 = gs(b,psi)

A = bmat([[R,-C@RS.T],
          [RS@C.T,None]]).tocsc()

r = np.r_[r1,0*RS@r2]

tm = time.monotonic()
# wS = chol(AA).solve_A(-rr)
w = sps.linalg.spsolve(A,-r)
print('Solving took ', time.monotonic()-tm)


tm = time.monotonic()

iR = pde.tools.fastBlockInverse2(R)
AA = RS@C.T@iR@C@RS.T
rr = RS@(-C.T@iR@r1+0*r2)

wpsi2 = RS.T@sps.linalg.spsolve(AA,-rr)
wb2 = iR@(C@wpsi2-r1)
print('Solving took ', time.monotonic()-tm)

wb = w[:sb]
wpsi = RS.T@w[sb:]

print('dif:',np.linalg.norm(wb-wb2),np.linalg.norm(wpsi-wpsi2))
32/58: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/59: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/60: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/61: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/62: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/63: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/64: R
32/65: iR = pde.tools.fastBlockInverse(R)
32/66: iR = pde.tools.fastBlockInverse2(R)
32/67: iR = pde.tools.fastBlockInverse(R)
32/68: R
32/69: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/70: R
32/71: R-1/2*(R+R.T)
32/72: iR = pde.tools.fastBlockInverse(1/2*(R+R.T))
32/73: iR = pde.tools.fastBlockInverse(R)
32/74: iR = pde.tools.fastBlockInverse(-R)
32/75: iR = pde.tools.fastBlockInverse(R)
32/76: iR = pde.tools.fastBlockInverse(R)
32/77: pde.tools.fastBlockInverse(R)
32/78: pde.tools.fastBlockInverse2(R)
32/79: scipy.sparse.linalg.eigs
32/80: scipy.sparse.linalg.eigs(R,1)
32/81: scipy.sparse.linalg.eigs(R,1,which='SR')
32/82: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/83: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/84: R
32/85: R
32/86: scipy.sparse.linalg.eigs(R,1,which='SR')
32/87: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/88: scipy.sparse.linalg.eigs(R,1,which='SR')
32/89: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/90: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/91: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/92: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/93: bx
32/94: by
32/95: f_linear(bx,by)
32/96: plt.plot(f_linear(bx,by))
32/97: bx
32/98: by
32/99: b
32/100: bx = b[:len(b)//2]; by = b[len(b)//2:]
32/101: plt.plot(f_linear(bx,by))
32/102: plt.plot(f_nonlinear(bx,by))
32/103: f_nonlinear(bx,by)>0
32/104: np.where(f_nonlinear(bx,by)<0)
32/105: np.where(f_linear(bx,by)<0)
32/106: pde.tools.fastBlockInverse(R1)
32/107: b
32/108: bx = b[:len(b)//2]; by = b[len(b)//2:]
32/109: fxx_linear(bx,by)
32/110: fxx_linear(bx,by)
32/111: plt.plot(fxx_linear(bx,by))
32/112: plt.plot(fxx_nonlinear(bx,by))
32/113: np.where(fxx_nonlinear(bx,by)<)
32/114: np.where(fxx_nonlinear(bx,by)<0)
32/115: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/nonlinLaws_brauer_fit.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/116: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/nonlinLaws_brauer_fit.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/117:
xx = np.linspace(0,8,3000)
plt.figure()
plt.plot(xx,dx_nu.antiderivative(0)(xx),'.')
plt.plot(xx,dx_nu.antiderivative(1)(xx),'.')
plt.plot(xx,dx_nu.antiderivative(2)(xx),'.')
plt.plot(xx,nu0+0*xx)
32/118: plt.plot(xx,dx_nu.antiderivative(0)(xx),'.')
32/119: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/nonlinLaws_brauer_fit.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/120: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/121: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/nonlinLaws_brauer_fit.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/122: plt.plot(xx,dx_nu.antiderivative(0)(xx),'.')
32/123: plt.plot(xx,dx_nu.antiderivative(0)(xx)*xx,'.')
32/124: plt.plot(yy,dx_mu.antiderivative(0)(yy),'.')
32/125: plt.plot(yy,dx_mu.antiderivative(0)(yy),'.')
32/126: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/127: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/128: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/129: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/130: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/131: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/132: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_nonlinear_gap.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/133: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM/primalEM_scalarPOT_mixed_nonlinear.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/mixed.EM')
32/134: 1271712/2
32/135: 160_592/2
35/1: runfile('C:/Users/Radu/Desktop/t13/conversion.py', wdir='C:/Users/Radu/Desktop/t13')
35/2: %pip install meshio
34/1: runfile('C:/Users/Radu/Desktop/t13/conversion.py', wdir='C:/Users/Radu/Desktop/t13')
34/2: runfile('C:/Users/Radu/Desktop/t13/conversion.py', wdir='C:/Users/Radu/Desktop/t13')
34/3: runfile('C:/Users/Radu/Desktop/t13/conversion.py', wdir='C:/Users/Radu/Desktop/t13')
34/4: runfile('C:/Users/Radu/Desktop/t13/conversion.py', wdir='C:/Users/Radu/Desktop/t13')
34/5: runfile('C:/Users/Radu/Desktop/t13/conversion.py', wdir='C:/Users/Radu/Desktop/t13')
34/6: runfile('C:/Users/Radu/Desktop/t13/conversion.py', wdir='C:/Users/Radu/Desktop/t13')
34/7: mesh.points
34/8: mesh.cells
34/9: mesh.vtk.read()
34/10: mesh.write('kekw.msh')
34/11: msh
34/12: mesh
34/13: mesh.write('kekw.vtk')
34/14: runfile('C:/Users/Radu/Desktop/t13/conversion.py', wdir='C:/Users/Radu/Desktop/t13')
34/15: runfile('C:/Users/Radu/Desktop/t13/conversion.py', wdir='C:/Users/Radu/Desktop/t13')
34/16: mesh.write('kekw.msh',file_format="gmsh")
34/17: runfile('C:/Users/Radu/Desktop/t13/team13.py', wdir='C:/Users/Radu/Desktop/t13')
36/1: runfile('C:/Users/Radu/Desktop/t13/team13.py', wdir='C:/Users/Radu/Desktop/t13')
37/1: runfile('C:/Users/Radu/Desktop/t13/team13.py', wdir='C:/Users/Radu/Desktop/t13')
37/2: meshsize
37/3: Plane
37/4: runfile('C:/Users/Radu/Desktop/t13/team13.py', wdir='C:/Users/Radu/Desktop/t13')
38/1: runfile('C:/Users/Radu/Desktop/t13/team13.py', wdir='C:/Users/Radu/Desktop/t13')
38/2: csg
38/3: csg.Plane
38/4:

left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

cube = left * right * front * back * bot * top
38/5:

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
38/6:
left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

cube = left * right * front * back * bot * top



geo = csg.CSGeometry()
geo.Add (cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
38/7: from netgen.gui import gui
38/8: runfile('C:/Users/Radu/Desktop/t13/team13.py', wdir='C:/Users/Radu/Desktop/t13')
39/1: runfile('C:/Users/Radu/Desktop/t13/team13.py', wdir='C:/Users/Radu/Desktop/t13')
40/1: runfile('C:/Users/Radu/Desktop/t13/team13.py', wdir='C:/Users/Radu/Desktop/t13')
41/1:
import ngsolve as ng
import netgen.csg as csg
# import netgen.gui



left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

cube = left * right * front * back * bot * top



geo = csg.CSGeometry()
geo.Add (cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
41/2: import netgen.gui
42/1: runfile('C:/Users/Radu/Desktop/t13/team13.py', wdir='C:/Users/Radu/Desktop/t13')
42/2: import netgen.gui
42/3: import ngsolve as ng
42/4: import netgen.csg as csg
42/5: import netgen.gui
43/1: import netgen.gui
44/1: runfile('C:/Users/Radu/Desktop/t13/team13.py', wdir='C:/Users/Radu/Desktop/t13')
47/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui



left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

cube = left * right * front * back * bot * top



geo = csg.CSGeometry()
geo.Add (cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
47/2: geo
47/3:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui



left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

cube = left * right * front * back * bot * top



geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
47/4:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui



left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

cube = left * right * front * back * bot * top



geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
47/5:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui



left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

cube = left * right * front * back * bot * top

cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )

geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
47/6:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui



left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

cube = left * right * front * back * bot * top

cube = csg.OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )

geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
47/7:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui



left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

cube = left * right * front * back * bot * top

cube = csg.OrthoBrick( csg.Pnt(0,0,0), csg.Pnt(1,1,1) )

geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
47/8:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


Cylinder(Pnt a, Pnt b, float r)



# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube = csg.OrthoBrick( csg.Pnt(0,0,0), csg.Pnt(1,1,1) )

geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
47/9:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50) )

geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
48/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50) )

geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
49/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50) )

geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
50/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50) )

geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=0.25)
ng.Redraw()
51/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50) )

geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
51/2:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1-cube2

# cyl1 = csg.Cylinder(csg.Pnt(

geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
51/3:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1-cube2

cyl1 = csg.Cylinder(csg.Pnt(50,50,0),csg.Pnt(50,50,1),50)

geo = csg.CSGeometry()
geo.Add(cube*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
51/4:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1-cube2

# cyl1 = csg.Cylinder(csg.Pnt(50,50,0),csg.Pnt(50,50,1),50)

geo = csg.CSGeometry()
geo.Add(cube+cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
52/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1-cube2

cyl1 = csg.Cylinder(csg.Pnt(50,50,0),csg.Pnt(50,50,1),50)

geo = csg.CSGeometry()
geo.Add(cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
53/1:
cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )
hole = Cylinder ( Pnt(0.5, 0.5, 0), Pnt(0.5, 0.5, 1), 0.2)

geo = CSGeometry()
geo.Add (cube-hole.maxh(0.05))
mesh = geo.GenerateMesh(maxh=0.1)
Redraw()
53/2:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui

cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )
hole = Cylinder ( Pnt(0.5, 0.5, 0), Pnt(0.5, 0.5, 1), 0.2)

geo = CSGeometry()
geo.Add (cube-hole.maxh(0.05))
mesh = geo.GenerateMesh(maxh=0.1)
Redraw()
53/3:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui

cube = csg.OrthoBrick(csg.Pnt(0,0,0),csg.Pnt(1,1,1) )
hole = csg.Cylinder(csg.Pnt(0.5, 0.5, 0),csg.Pnt(0.5, 0.5, 1), 0.2)

geo = CSGeometry()
geo.Add (cube-hole.maxh(0.05))
mesh = geo.GenerateMesh(maxh=0.1)
Redraw()
53/4:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui

cube = csg.OrthoBrick(csg.Pnt(0,0,0),csg.Pnt(1,1,1) )
hole = csg.Cylinder(csg.Pnt(0.5, 0.5, 0),csg.Pnt(0.5, 0.5, 1), 0.2)

geo = csg.CSGeometry()
geo.Add (cube-hole.maxh(0.05))
mesh = geo.GenerateMesh(maxh=0.1)
Redraw()
53/5:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui

cube = csg.OrthoBrick(csg.Pnt(0,0,0),csg.Pnt(1,1,1) )
hole = csg.Cylinder(csg.Pnt(0.5, 0.5, 0),csg.Pnt(0.5, 0.5, 1), 0.2)

geo = csg.CSGeometry()
geo.Add (cube-hole.maxh(0.05))
mesh = geo.GenerateMesh(maxh=0.1)
ng.Redraw()
53/6:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1-cube2

cyl1 = csg.Cylinder(csg.Pnt(50,50,0),csg.Pnt(50,50,10),10)

geo = csg.CSGeometry()
geo.Add(cube*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
53/7:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1-cube2

cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),10)

geo = csg.CSGeometry()
geo.Add(cube*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1-cube2

cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),10)

geo = csg.CSGeometry()
geo.Add(cube*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/2:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1#-cube2

cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),10)

geo = csg.CSGeometry()
geo.Add(cube*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/3:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1#-cube2

cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),10)

geo = csg.CSGeometry()
geo.Add(cube-cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/4:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1#-cube2

cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

geo = csg.CSGeometry()
geo.Add(cube-cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/5:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1-cube2

cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

geo = csg.CSGeometry()
geo.Add(cube-cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/6:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))

cube = cube1-cube2

cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/7:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube2-cyl1


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/8:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube2*cyl1


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/9:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1*cyl1-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/10:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/11:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/12:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/13:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
54/14:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(60,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
55/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(60,50,-50),csg.Pnt(50,50,50),50)

cube = cube1*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
55/2:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
55/3:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1*cyl1+cube1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
55/4:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube1*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
55/5:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
55/6:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
# cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
55/7:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
# cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube2#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
55/8:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
# cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = (cube1-cube2)*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
55/9:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
# cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = (cube1-cube2)+cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
56/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
# cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = (cube1-cube2)*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
56/2:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = (cube1-cube2)*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
56/3:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = (cube1-cube2)#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
56/4:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube2#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
57/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube2#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
57/2:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1#-cube2#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
57/3:

from netgen.csg import *

cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )
hole = Cylinder ( Pnt(0.5, 0.5, 0), Pnt(0.5, 0.5, 1), 0.2)

geo = CSGeometry()
geo.Add (cube-hole)
geo.Add (cube*hole)

mesh = geo.GenerateMesh(maxh=0.1)
ng.Redraw()
58/1:

from netgen.csg import *

cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )
hole = Cylinder ( Pnt(0.5, 0.5, 0), Pnt(0.5, 0.5, 1), 0.2)

geo = CSGeometry()
geo.Add (cube-hole)
geo.Add (cube*hole)

mesh = geo.GenerateMesh(maxh=0.1)
ng.Redraw()
58/2:
import ngsolve as ng
from netgen.csg import *

cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )
hole = Cylinder ( Pnt(0.5, 0.5, 0), Pnt(0.5, 0.5, 1), 0.2)

geo = CSGeometry()
geo.Add (cube-hole)
geo.Add (cube*hole)

mesh = geo.GenerateMesh(maxh=0.1)
ng.Redraw()
58/3:
import ngsolve as ng
from netgen.csg import *
import netgen.gui

cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )
hole = Cylinder ( Pnt(0.5, 0.5, 0), Pnt(0.5, 0.5, 1), 0.2)

geo = CSGeometry()
geo.Add (cube-hole)
geo.Add (cube*hole)

mesh = geo.GenerateMesh(maxh=0.1)
ng.Redraw()
58/4:
import ngsolve as ng
from netgen.csg import *
import netgen.gui

cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )
sphere = Sphere ( Pnt(0.5, 0.5, 0.5), 0.75)

geo = CSGeometry()
geo.Add (cube-hole)
geo.Add (cube*hole)

mesh = geo.GenerateMesh(maxh=0.1)
ng.Redraw()
59/1:
import ngsolve as ng
from netgen.csg import *
import netgen.gui

cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )
sphere = Sphere ( Pnt(0.5, 0.5, 0.5), 0.75)

geo = CSGeometry()
geo.Add (cube-hole)
geo.Add (cube*hole)

mesh = geo.GenerateMesh(maxh=0.1)
ng.Redraw()
59/2:
import ngsolve as ng
from netgen.csg import *
import netgen.gui

cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )
sphere = Sphere ( Pnt(0.5, 0.5, 0.5), 0.75)

geo = CSGeometry()
geo.Add (cube-sphere)
geo.Add (cube*sphere)

mesh = geo.GenerateMesh(maxh=0.1)
ng.Redraw()
60/1:
import ngsolve as ng
from netgen.csg import *
import netgen.gui

cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )
sphere = Sphere ( Pnt(0.5, 0.5, 0.5), 0.75)

geo = CSGeometry()
geo.Add (cube-sphere)
# geo.Add (cube*sphere)

mesh = geo.GenerateMesh(maxh=0.1)
ng.Redraw()
60/2:
import ngsolve as ng
from netgen.csg import *
import netgen.gui

cube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )
sphere = Sphere ( Pnt(0.5, 0.5, 0.5), 0.75)

geo = CSGeometry()
# geo.Add (cube-sphere)
geo.Add (cube*sphere)

mesh = geo.GenerateMesh(maxh=0.1)
ng.Redraw()
60/3:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1#-cube2#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/4:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1*cyl1#-cube2#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/5:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1*cyl1+cube1#-cube2#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/6:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1*cyl1+cube1-cyl1#-cube2#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/7:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1*cyl1#-cube2#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/8:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cyl1#-cube2#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/9:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cyl1-cube2#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/10:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube2#*cyl1#-cube2


geo = csg.CSGeometry()
geo.Add(cube)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/11:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube*cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/12:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),60)

cube = cube1-cube2#*cyl1#-cube2

model = cube*cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/13:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(90,90,-50),csg.Pnt(90,90,50),60)

cube = cube1-cube2#*cyl1#-cube2

model = cube*cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/14:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(90,90,-50),csg.Pnt(90,90,50),5)

cube = cube1-cube2#*cyl1#-cube2

model = cube*cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/15:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube*cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/16:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick( csg.Pnt(-100,-100,-50), csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick( csg.Pnt(-75,-75,-50), csg.Pnt(75,75,50))
# cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/17:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))
# cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/18:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(50,50,-50),csg.Pnt(50,50,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/19:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

d = 50
cyl1 = csg.Cylinder(csg.Pnt(d,d,-50),csg.Pnt(d,d,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/20:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

d = 60
cyl1 = csg.Cylinder(csg.Pnt(d,d,-50),csg.Pnt(d,d,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/21:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

d = 55
cyl1 = csg.Cylinder(csg.Pnt(d,d,-50),csg.Pnt(d,d,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/22:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

d = 53
cyl1 = csg.Cylinder(csg.Pnt(d,d,-50),csg.Pnt(d,d,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/23:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

d = 53.5
cyl1 = csg.Cylinder(csg.Pnt(d,d,-50),csg.Pnt(d,d,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/24:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

d = 54
cyl1 = csg.Cylinder(csg.Pnt(d,d,-50),csg.Pnt(d,d,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/25:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

d = 54.4
cyl1 = csg.Cylinder(csg.Pnt(d,d,-50),csg.Pnt(d,d,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/26:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

d = 54.6
cyl1 = csg.Cylinder(csg.Pnt(d,d,-50),csg.Pnt(d,d,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/27:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

d = 54.3
cyl1 = csg.Cylinder(csg.Pnt(d,d,-50),csg.Pnt(d,d,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/28:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

d = 54.2
cyl1 = csg.Cylinder(csg.Pnt(d,d,-50),csg.Pnt(d,d,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/29:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))

d = 54.2
cyl1 = csg.Cylinder(csg.Pnt(d,d,-50),csg.Pnt(d,d,50),50)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/30:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/31:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),12)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/32:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),20)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/33:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),22)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/34:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = corner1-cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/35:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model = cube#*cyl1
model = cube-(corner1-cyl1)

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/36:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model = corner1-cyl1#*cyl1
model = cube-model

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/37:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),24)

cube = cube1-cube2#*cyl1#-cube2

model = corner1-cyl1#*cyl1
model = cube-model

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/38:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),24)

cube = cube1-cube2#*cyl1#-cube2

model = corner1-cyl1#*cyl1
# model = cube-model

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/39:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),26)

cube = cube1-cube2#*cyl1#-cube2

model = corner1-cyl1#*cyl1
# model = cube-model

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/40:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.1)

cube = cube1-cube2#*cyl1#-cube2

model = corner1-cyl1#*cyl1
# model = cube-model

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/41:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model = corner1-cyl1#*cyl1
# model = cube-model

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/42:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model = corner1-cyl1#*cyl1
# model = cube-model

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/43:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model = corner1-cyl1#*cyl1
model = cube-model

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/44:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model = corner1-cyl1#*cyl1
model = cube

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/45:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model = corner1-cyl1#*cyl1
model = cube1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/46:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1-cyl1#*cyl1
model = cube1-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/47:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1-cyl1#*cyl1
model = cube1*model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/48:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1-cyl1#*cyl1
model = cube1-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/49:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1-cyl1#*cyl1
model = cube1+model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/50:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1-cyl1#*cyl1
model = cube1-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
60/51:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1-cyl1#*cyl1
model = cube1-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
61/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1-cyl1#*cyl1
model = cube1-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
61/2:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1-cyl1#*cyl1
model = model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
61/3:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25.01)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
model = model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
61/4:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
model = model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
61/5:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
model = model-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
61/6:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
model = model-model

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
61/7:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
model = model+model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
61/8:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
model = model*model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
61/9:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
model = model#*model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
61/10:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
model = model#*model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
61/11:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
model = model#*model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=5)
ng.Redraw()
61/12:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

# model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=5)
ng.Redraw()
61/13:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=5)
ng.Redraw()
62/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=5)
ng.Redraw()
63/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
63/2:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
63/3:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
64/1:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube#-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
64/2:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(75,75,-50),csg.Pnt(75,75,50),25)

cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube#-model1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
64/3:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),100)


cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube*cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
64/4:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),200)


cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube*cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
64/5:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),150)


cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube*cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
64/6:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)


cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cube*cyl1

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
64/7:
import ngsolve as ng
import netgen.csg as csg
import netgen.gui


# Cylinder(Pnt a, Pnt b, float r)

# left  = csg.Plane (csg.Pnt(0,0,0), csg.Vec(-1,0,0) )
# right = csg.Plane (csg.Pnt(1,1,1), csg.Vec( 1,0,0) )
# front = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,-1,0) )
# back  = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0, 1,0) )
# bot   = csg.Plane (csg.Pnt(0,0,0), csg.Vec(0,0,-1) )
# top   = csg.Plane (csg.Pnt(1,1,1), csg.Vec(0,0, 1) )

# cube = left * right * front * back * bot * top

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)


cube = cube1-cube2#*cyl1#-cube2

model1 = corner1*cyl1#*cyl1
# model = model#*model1

model = cyl1-cube

geo = csg.CSGeometry()
geo.Add(model)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/1:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ import occ
import netgen.gui

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)



# cube = cube1-cube2#*cyl1#-cube2

# model1 = corner1*cyl1#*cyl1
# # model = model#*model1

# model = cyl1-cube

# geo = csg.CSGeometry()
# geo.Add(model)

# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
65/2:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)



# cube = cube1-cube2#*cyl1#-cube2

# model1 = corner1*cyl1#*cyl1
# # model = model#*model1

# model = cyl1-cube

# geo = csg.CSGeometry()
# geo.Add(model)

# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
65/3:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))

# cube = cube1-cube2#*cyl1#-cube2

# model1 = corner1*cyl1#*cyl1
# # model = model#*model1

# model = cyl1-cube

# geo = csg.CSGeometry()
# geo.Add(model)

# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
65/4:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))

# cube = cube1-cube2#*cyl1#-cube2

# model1 = corner1*cyl1#*cyl1
# # model = model#*model1

# model = cyl1-cube

geo = occ.OCCGeometry()
geo.Add(box)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/5:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))

# cube = cube1-cube2#*cyl1#-cube2

# model1 = corner1*cyl1#*cyl1
# # model = model#*model1

# model = cyl1-cube

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/6:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/7:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box = box1-box2

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/8:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

cyl1 = occ.Cylinder(occ.Pnt(1,0.5,0.5), occ.X, r=0.3, h=0.5)

box = box1-box2

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/9:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

cyl1 = occ.Cylinder(occ.Pnt(75,75,50), occ.X, r=0.3, h=0.5)

box = box1-box2

geo = occ.OCCGeometry(box*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/10:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

cyl1 = occ.Cylinder(occ.Pnt(75,75,50), occ.Z, r=0.3, h=0.5)

box = box1-box2

geo = occ.OCCGeometry(box*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/11:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

cyl1 = occ.Cylinder(occ.Pnt(75,75,50), occ.Y, r=0.3, h=0.5)

box = box1-box2

geo = occ.OCCGeometry(box*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/12:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

cyl1 = occ.Cylinder(occ.Pnt(90,90,50), occ.Y, r=5)

box = box1-box2

geo = occ.OCCGeometry(box*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/13:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

cyl1 = occ.Cylinder(occ.Pnt(90,90,50), occ.Y, r=5, h=0.5)

box = box1-box2

geo = occ.OCCGeometry(box*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/14:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

cyl1 = occ.Cylinder(occ.Pnt(90,90,50), occ.Z, r=5, h=0.5)

box = box1-box2

geo = occ.OCCGeometry(box*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/15:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

cyl1 = occ.Cylinder(occ.Pnt(90,90,0), occ.Z, r=5, h=0.5)

box = box1-box2

geo = occ.OCCGeometry(box*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/16:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

cyl1 = occ.Cylinder(occ.Pnt(90,90,0), occ.Z, r=5, h=800)

box = box1-box2

geo = occ.OCCGeometry(box*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/17:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

cyl1 = occ.Cylinder(occ.Pnt(90,90,0), occ.Z, r=5, h=200)

box = box1-box2

geo = occ.OCCGeometry(box*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/18:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

cyl1 = occ.Cylinder(occ.Pnt(75,75,0), occ.Z, r=5, h=200)

box = box1-box2

geo = occ.OCCGeometry(box*cyl1)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/19:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


corner1 = occ.Box(occ.Pnt(75,75,50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,0), occ.Z, r=25, h=200)

box = box1-box2
box = corner1*cyl1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/20:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


corner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,0), occ.Z, r=25, h=200)

box = box1-box2
box = corner1*cyl1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
65/21:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


corner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,0), occ.Z, r=25, h=200)

box = box1-box2
box = corner1*cyl1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=7)
ng.Redraw()
65/22:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


corner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,0), occ.Z, r=25, h=200)

box = box1-box2
box = corner1*cyl1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=6)
ng.Redraw()
65/23:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,0), occ.Z, r=25, h=200)
corner1 = bcorner1*cyl1

box = (box1-box2)*cyl1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=6)
ng.Redraw()
65/24:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,0), occ.Z, r=25, h=200)
corner1 = bcorner1*cyl1

box = (box1-box2)

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=6)
ng.Redraw()
65/25:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,0), occ.Z, r=25, h=200)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=6)
ng.Redraw()
65/26:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-20), occ.Z, r=25, h=200)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=6)
ng.Redraw()
65/27:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=50)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=6)
ng.Redraw()
65/28:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=6)
ng.Redraw()
65/29:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=4)
ng.Redraw()
65/30:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,25))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1 = bcorner1-cyl1+bicorner1

box = (box1-box2)-corner1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=4)
ng.Redraw()
65/31:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,25))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1+bicorner1

geo = occ.OCCGeometry(box)

mesh = geo.GenerateMesh(maxh=4)
ng.Redraw()
65/32:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,25))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1+bicorner1

geo = occ.OCCGeometry(box)

# mesh = geo.GenerateMesh(maxh=4)
# ng.Redraw()
65/33:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,25))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1+bicorner1

geo = occ.OCCGeometry(box)

# mesh = geo.GenerateMesh(maxh=4)
# ng.Redraw()
66/1:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,25))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1+bicorner1

geo = occ.OCCGeometry(box)

# mesh = geo.GenerateMesh(maxh=4)
# ng.Redraw()
66/2: geo
66/3: mesh = geo.GenerateMesh(maxh=10)
66/4:
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/5:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,25))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1+bicorner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/6:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,25))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1+bicorner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/7:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1+bicorner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/8:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))


bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)

bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl2 = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner2 = bicorner1-cyl2
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1+corner2

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/9:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# def corner(x1,x2):
    
    
    

bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)

bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl2 = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner2 = bicorner1-cyl2
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1+corner2

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/10:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

def corner(x1,x2):
    
    
    

bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)

bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl2 = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner2 = bicorner1-cyl2
corner1 = bcorner1-cyl1

box = 0*(box1-box2)-corner1+corner2

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/11:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

def corner(x1,x2):
    
    
    

bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)

bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl2 = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner2 = bicorner1-cyl2
corner1 = bcorner1-cyl1

# box = (box1-box2)-corner1+corner2
box = corner2-corner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/12:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

    

bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)

bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl2 = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner2 = bicorner1-cyl2
corner1 = bcorner1-cyl1

# box = (box1-box2)-corner1+corner2
box = corner2-corner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/13:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

    

bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)

bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl2 = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner2 = bicorner1-cyl2
corner1 = bcorner1-cyl1

# box = (box1-box2)-corner1+corner2
box = corner2#-corner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/14:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

    

bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)

bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl2 = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner2 = bicorner1-cyl2
corner1 = bcorner1-cyl1

# box = (box1-box2)-corner1+corner2
box = corner2-corner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/15:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

    

bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)

bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl2 = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner2 = bicorner1-cyl2
corner1 = bcorner1-cyl1

box = (box1-box2)-corner1+corner2
# box = corner2-corner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/16:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    

bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)

bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl2 = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner2 = bicorner1-cyl2
corner1 = bcorner1-cyl1

box = (box1-box2+box3)-corner1+corner2
# box = corner2-corner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/17:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    

bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)

bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl2 = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner2 = bicorner1-cyl2
corner1 = bcorner1-cyl1

box = (box1-box2+box3)-0*corner1+corner2
# box = corner2-corner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/18:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    

bcorner1 = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1 = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)

bicorner1 = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl2 = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner2 = bicorner1-cyl2
corner1 = bcorner1-cyl1

box = (box1-box2+box3)-corner1+corner2
box = corner2+corner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/19:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)


corner1_int = corner1_int-cyl1_int
corner1_ext = corner1_ext-cyl1_ext

box = (box1-box2+box3)+corner1_int-corner1_ext
# box = corner2+corner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/20:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(0,0,-50), occ.Pnt(25,25,50))
cyl2_ext = occ.Cylinder(occ.Pnt(0,0,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(25,25,-50), occ.Pnt(50,50,50))
cyl2_int = occ.Cylinder(occ.Pnt(25,25,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
# box = corner2+corner1

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/21:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(0,0,-50), occ.Pnt(25,25,50))
cyl2_ext = occ.Cylinder(occ.Pnt(0,0,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(25,25,-50), occ.Pnt(50,50,50))
cyl2_int = occ.Cylinder(occ.Pnt(25,25,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
box = box3+corner2_int-corner2_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/22:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(0,0,-50), occ.Pnt(25,25,50))
cyl2_ext = occ.Cylinder(occ.Pnt(25,25,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(25,25,-50), occ.Pnt(50,50,50))
cyl2_int = occ.Cylinder(occ.Pnt(25,25,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
box = box3+corner2_int-corner2_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/23:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(25,25,-50), occ.Pnt(50,50,50))
cyl2_int = occ.Cylinder(occ.Pnt(25,25,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
box = box3+corner2_int-corner2_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/24:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(25,25,-50), occ.Pnt(50,50,50))
cyl2_int = occ.Cylinder(occ.Pnt(25,25,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
box = box3+corner2_int-corner2_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/25:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(25,25,-50), occ.Pnt(50,50,50))
cyl2_int = occ.Cylinder(occ.Pnt(25,25,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
box = box3+corner2_int+corner2_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/26:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
box = box3+corner2_int+corner2_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/27:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
# box = box3+corner2_int+corner2_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/28:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

# box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
box = box3+corner3_int+corner3_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/29:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

# box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
box = box3+corner3_int+corner3_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/30:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

# box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
box = box3+corner3_int+corner3_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/31:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

# box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
box = box3+corner3_int+corner3_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/32:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

# box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext
box = box3+corner3_int+corner3_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/33:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

# corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
# cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
# corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
# cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
# corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext
##########################################################################

box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext
# box = box3+corner3_int+corner3_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/34:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

# box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext
box = box3+corner4_int+corner4_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/35:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

# box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext
box = box3+corner4_int+corner4_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/36:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

# box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext
box = box3+corner4_int+corner4_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/37:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

box = (box1-box2+box3)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/38:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

box = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/39:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

geo = occ.OCCGeometry(box)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/40:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

geo = occ.OCCGeometry(coil)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/41:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

steel = occ.Box(occ.Pnt(0.5,15,50-3.2),occ.Pnt(120.5,65,50))

geom = coil + steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/42:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

steel = occ.Box(occ.Pnt(0.5,15+10,50-3.2),occ.Pnt(120.5,65+10,50))

geom = coil + steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/43:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

steel = occ.Box(occ.Pnt(0.5+10,15,50-3.2),occ.Pnt(120.5+10,65,50))

geom = coil + steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/44:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

steel = occ.Box(occ.Pnt(0.5,15,50-3.2+10),occ.Pnt(120.5,65,50+10))

geom = coil + steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/45:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

steel = occ.Box(occ.Pnt(0.5,15,50-3.2+10),occ.Pnt(120.5,65,50+10))

geom = coil + steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/46:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))
steel = occ.Box(occ.Pnt(0.5,15,50+10-3.2),occ.Pnt(120.5,65,50+10))

geom = coil + mid_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/47:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))
steel = occ.Box(occ.Pnt(0.5,15,50+10-3.2),occ.Pnt(120.5,65,50+10))

geom = coil + mid_steel + steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/48:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))
steel = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))

geom = coil + mid_steel + steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/49:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))
steel = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))

geom = coil + mid_steel + steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/50:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 #+ r_steel3

geom = coil + mid_steel + r_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/51:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel2 = occ.Box(occ.Pnt(),occ.Pnt())
r_steel = r_steel1 + r_steel2 #+ r_steel3

geom = coil + mid_steel + r_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/52:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
# r_steel2 = occ.Box(occ.Pnt(),occ.Pnt())
r_steel = r_steel1 + r_steel2 #+ r_steel3

geom = coil + mid_steel + r_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/53:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel2 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10))
r_steel = r_steel1 + r_steel2 #+ r_steel3

geom = coil + mid_steel + r_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/54:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10))
r_steel = r_steel1 + r_steel2 #+ r_steel3

geom = coil + mid_steel + r_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/55:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 #+ r_steel3

geom = coil + mid_steel + r_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/56:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

geom = coil + mid_steel + r_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/57:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

geom = coil + mid_steel + r_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/58:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
# l_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
# l_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
l_steel = l_steel1 #+ l_steel2 + l_steel3


geom = coil + mid_steel + r_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/59:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
# l_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
# l_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
l_steel = l_steel1 #+ l_steel2 + l_steel3


geom = coil + mid_steel + r_steel + l_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/60:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
# l_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
l_steel = l_steel1 + l_steel2 + #l_steel3


geom = coil + mid_steel + r_steel + l_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/61:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
# l_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
l_steel = l_steel1 + l_steel2 #+ l_steel3


geom = coil + mid_steel + r_steel + l_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/62:
import ngsolve as ng
# import netgen.csg as csg
import netgen.occ as occ
import netgen.gui

# cube1 = csg.OrthoBrick(csg.Pnt(-100,-100,-50),csg.Pnt(100,100,50))
# cube2 = csg.OrthoBrick(csg.Pnt(-75,-75,-50),csg.Pnt(75,75,50))

# corner1 = csg.OrthoBrick(csg.Pnt(75,75,-50),csg.Pnt(100,100,50))
# cyl1 = csg.Cylinder(csg.Pnt(0,0,-50),csg.Pnt(0,0,50),90)

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

# box3 = occ.Box(occ.Pnt(-10,-10,-50), occ.Pnt(10,10,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3


geom = coil + mid_steel + r_steel + l_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/63:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
geom = coil + mid_steel + r_steel + l_steel

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/64:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
geom = coil + mid_steel + r_steel + l_steel + ambient

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/65:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100)) - geom

full = geom + ambient 

geo = occ.OCCGeometry(full)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/66:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100)) - geom

full = geom + ambient 

geo = occ.OCCGeometry(geom)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
66/67:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100)) - geom

full = geom + ambient 

geo = occ.OCCGeometry(geom)
# mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/68:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
# ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100)) - geom

# full = geom + ambient 

geo = occ.OCCGeometry(geom)
# mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
66/69:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
# ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100)) - geom

# full = geom + ambient 

geo = occ.OCCGeometry(geom)
# mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
67/1:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
# ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100)) - geom

# full = geom + ambient 

geo = occ.OCCGeometry(geom)
# mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
67/2:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
# ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100)) - geom

# full = geom + ambient 

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
68/1:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
# ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100)) - geom

# full = geom + ambient 

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
68/2:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100)) - geom

# full = geom + ambient 

geo = occ.OCCGeometry(geom)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
68/3:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100)) - geom

# full = geom + ambient 

geo = occ.OCCGeometry(ambient)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
68/4:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100)) - geom

full = geom + ambient 

geo = occ.OCCGeometry(full)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
68/5:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound( [geom, ambient])

geo = occ.OCCGeometry(full)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
69/1:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound( [geom, ambient])

geo = occ.OCCGeometry(full)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
69/2:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])

geo = occ.OCCGeometry(full)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
70/1:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])

geo = occ.OCCGeometry(full)
mesh = geo.GenerateMesh(maxh=10)
ng.Redraw()
70/2:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()

DrawGeo(full)
70/3: !pip3 install webgui_jupyter_widgets
70/4:
jupyter nbextension install --user --py webgui_jupyter_widgets
jupyter nbextension enable --user --py webgui_jupyter_widgets
70/5:
!jupyter nbextension install --user --py webgui_jupyter_widgets
!jupyter nbextension enable --user --py webgui_jupyter_widgets
71/1: #!pip3 install webgui_jupyter_widgets
71/2:
!jupyter nbextension install --user --py webgui_jupyter_widgets
!jupyter nbextension enable --user --py webgui_jupyter_widgets
71/3:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()

DrawGeo(full)
72/1: import webgui_jupyter_widgets
71/4:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()

DrawGeo(full)
71/5:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext
# box = box3+corner4_int+corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3


l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()

DrawGeo(full)
74/1:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()

DrawGeo(full)
75/1:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()

DrawGeo(full)
75/2:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full)

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/3:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping=1)

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/4:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping=1, dist=64)

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/5:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, draw_vol=False, clipping={"y":1, "z":0, "dist":0.012});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/6:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, draw_vol=False, clipping={"z":1, "z":0, "dist":0.012});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/7:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, draw_vol=False, clipping={"z":1, "z":0, "dist":64});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/8:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, draw_vol=False, clipping={"z":1, "dist":64});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/9:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, draw_vol=False, clipping={"z":1, "dist":-64});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/10:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, draw_vol=False, clipping={"z":1, "dist":64});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/11:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, draw_vol=False, clipping={"z":0, "dist":64});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/12:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, draw_vol=False, clipping={"z":1, "dist":64});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/13:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, draw_vol=False, clipping={"z":-1, "dist":64});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/14:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, draw_vol=False, clipping={"z":-1, "dist":64});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/15:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, draw_vol=True, clipping={"z":-1, "dist":64});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/16:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, clipping={"z":-1, "dist":64});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/17:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, clipping={"z":-1, "dist":64});

# geo = occ.OCCGeometry(full)
# mesh = geo.GenerateMesh(maxh=10)
# ng.Redraw()
75/18:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, clipping={"z":-1, "dist":64});
75/19:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, clipping={"z":-1, "dist":64});
75/20:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, clipping={"z":-1, "dist":64});
75/21:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, clipping={"z":-1, "dist":64}, misc={"line_thickness"=1});
75/22:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, clipping={"z":-1, "dist":64}, misc={"line_thickness":1});
75/23:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
DrawGeo(full, misc={"line_thickness":1});
# DrawGeo(full, clipping={"z":-1, "dist":64}, misc={"line_thickness":1});
75/24:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
# DrawGeo(full, misc={"line_thickness":1});
DrawGeo(full, clipping={"z":-1, "dist":64}, misc={"line_thickness":1});
75/25:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
# DrawGeo(full, misc={"line_thickness":1});
DrawGeo(full, clipping={"z":-1, "dist":64}, Misc={"line_thickness":1});
75/26:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
# DrawGeo(full, misc={"line_thickness":1});
DrawGeo(full, clipping={"z":-1, "dist":64}, misc={"line_thickness":1});
75/27:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
# DrawGeo(full, clipping=1, dist=64)
# DrawGeo(full, misc={"line_thickness":1});
DrawGeo(full, clipping={"z":-1, "dist":64}, misc={"line_thickness":1}, objects={"Edges":0});
75/28:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64}, misc={"line_thickness":1});
75/29:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64}, misc={"line_thickness":1});
75/30:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64}, Misc={"line_thickness":1});
75/31:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64}, Misc={"line_thickness":0});
75/32:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64}, Misc={"line_thickness":0.1});
75/33:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64}, Misc={"line_thickness":1});
75/34:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64}, Misc={"line_thickness":1});
72/2: import webgui_jupyter_widgets as wg
72/3: wg.html
72/4: from netgen.webgui import Draw
72/5: import netgen.webgui as ng
72/6: ng
75/35:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64}, Misc={"line_thickness":1});
75/36:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
75/37:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64}, Misc={"line_thickness":1});
75/38:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64});
75/39:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Identifications
##########################################################################



geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64});
75/40: coil.edges
75/41: coil.edges[0]
75/42: coil.edges[12]
75/43: coil.edges[456]
75/44: coil.edges[56]
75/45:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Identifications
##########################################################################

coil.edges[0]='first'

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64});
75/46:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Identifications
##########################################################################

coil.face[0].name='first'

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64});
75/47:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Identifications
##########################################################################

coil.faces[0].name='first'

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64});
75/48: coil.faces[0].name
75/49: coil.faces[1].name
75/50: coil.faces[0].name
75/51: coil.faces
75/52: coil.faces.size
75/53: coil.faces
75/54: coil.faces.wires
75/55: coil.faces.wires.faces
75/56: coil.faces[20]
75/57: coil.faces[13]
75/58: coil.faces[14]
75/59: coil.faces[15]
75/60: coil.faces[16]
75/61: coil.faces[18]
75/62: coil.faces[17]
75/63: coil.faces
75/64: coil.faces[-1]
75/65: coil.Properties
75/66: coil.Properties[0]
75/67: coil
75/68: coil.faces.Max(Z)
75/69: coil.faces.Max(occ.Z)
75/70: coil.faces.Size()
75/71: coil.faces
73/1: netgen.libngpy._NgOCC.ListOfShapes
75/72: for face in coil.faces:
75/73:
for face in coil.faces:
    face.name = 'kekw'
75/74:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Identifications
##########################################################################

for face in coil.faces:
    face.name = 'kekw'

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64});
75/75: list(coil.faces)
75/76: list(coil.faces).size()
75/77: len(list(coil.faces))
75/78: len(list(coil.faces))
75/79: len(list(steel.faces))
75/80: len(list(r_steel.faces))
75/81: len(list(l_steel.faces))
75/82: len(list(mid_steel.faces))
75/83:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
    
for face in coil.faces: face.name = 'coil_face'

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64});
75/84:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Compound([geom, ambient])
DrawGeo(full, clipping={"z":-1, "dist":64});
75/85:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'


DrawGeo(full, clipping={"z":-1, "dist":64});
75/86:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'


DrawGeo(full, clipping={"z":-1, "dist":64});
75/87: coil.mass
75/88: coil.col = (1,0,0)
75/89:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'


DrawGeo(full, clipping={"z":-1, "dist":64});
75/90:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.col = (1,0,0)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/91:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0,0)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/92:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0,0)
coil.l_steel.col=(1,1,0)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/93:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0,0)
coil.l_steel.col=(0,1,0)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/94:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0,0)
l_steel.col=(0,1,0)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/95:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0,0)
l_steel.col=(1,1,0)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/96:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0,0)
l_steel.faces.col=(1,1,0)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/97:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0,0)
l_steel.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/98:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0,0)
l_steel.faces.col=(1,01,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/99:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0,0)
l_steel.faces.col=(1,0,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/100:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/101:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/102:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/103:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,0.5,0.5)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/104:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(0.5,0.5,0.5)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/105:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(0,0,0)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/106:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/107:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
##########################################################################
# "Fancy" coloring cuz why not im bored
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/108:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
##########################################################################
# "Fancy" coloring cuz why not im bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/109:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/110:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat = 'kek'
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/111:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/112:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/113:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
75/114: Drawnow()
75/115: ng.Redraw()
75/116: mesh = ng.OCCGeometry(full)
75/117: mesh = OCCGeometry(full)
75/118: mesh = occ.OCCGeometry(full)
75/119:
mesh = occ.OCCGeometry(full)
Draw(mesh)
75/120:
mesh = occ.OCCGeometry(full)
ng.Draw(mesh)
75/121:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
77/1:
import ngsolve as ng
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
77/2:
import netgen.gui
mesh = occ.OCCGeometry(full)
ng.Draw(mesh)
77/3:
import ngsolve as ng
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

fullGeo = occ.OCCGeometry(full)
DrawGeo(fullGeo, clipping={"z":-1, "dist":64});
77/4:
import netgen.gui
fullGeo = occ.OCCGeometry(full)
ng.Draw(mesh)
77/5:
import ngsolve as ng
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
77/6:
import pde
MESH = pde.mesh.netgen(geoOCCmesh)
MESH.pdemesh2()
73/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/meshes/untitled2.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/meshes')
73/3: import pde
73/4: runcell(0, 'C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py')
73/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
73/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
73/7: %gui tk
73/8: %gui tk
81/1: %gui tk
81/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
81/3: runcell(0, 'C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py')
81/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
82/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
80/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
80/2: occ.OCCGeometry(full)
80/3: ng.Draw(occ.OCCGeometry(full))
80/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
84/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
84/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
84/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
84/4: import netgen.gui
84/5:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui
# from netgen.webgui import Draw a
84/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
83/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
83/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
83/3:
fullocc = occ.OCCGeometry(full)
ng.Draw(fullocc)
83/4:

fullocc = occ.OCCGeometry(full)
ng.Draw(fullocc)
83/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
83/6: runcell(0, 'C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py')
83/7: pde.mesh.from_netgen
83/8: pde.mesh.from_netgen
83/9: pde.mesh.from_netgen(geoOCCmesh)
83/10: geoOCCmesh = ng.Mesh(fullocc)
83/11: geoOCCmesh = geoOCC.GenerateMesh()
83/12:
geoOCC = occ.OCCGeometry(full)
ng.Draw(geoOCC)
83/13: geoOCCmesh = geoOCC.GenerateMesh()
83/14: npoints = geoOCCmesh.Elements2D().NumPy()['np'].max()
83/15: npoints
83/16: geoOCCmesh
83/17: geoOCCmesh.Elements3D().NumPy()
83/18: geoOCCmesh.Elements3D().NumPy()['np']
83/19: geoOCCmesh.Elements3D().NumPy()['np'].max()
83/20: geoOCCmesh.Coordinates()
83/21:
t = npy.c_[geoOCCmesh.Elements2D().NumPy()['nodes'].astype(npy.uint64)[:,:npoints],
           geoOCCmesh.Elements2D().NumPy()['index'].astype(npy.uint64)]-1
83/22:
t = np.c_[geoOCCmesh.Elements2D().NumPy()['nodes'].astype(npy.uint64)[:,:npoints],
          geoOCCmesh.Elements2D().NumPy()['index'].astype(npy.uint64)]-1
83/23: npoints = geoOCCmesh.Elements2D().NumPy()['np'].max()
83/24: npoints
83/25: geoOCCmesh.Elements2D()
83/26: geoOCCmesh.Elements2D().NumPy()
83/27: geoOCCmesh.Elements2D().NumPy()['nodes']
83/28: geoOCCmesh.Elements2D().NumPy()['nodes'].astype(npy.uint64)[:,:npoints]
83/29:
t = np.c_[geoOCCmesh.Elements2D().NumPy()['nodes'].astype(np.uint64)[:,:npoints],
          geoOCCmesh.Elements2D().NumPy()['index'].astype(np.uint64)]-1
83/30:
t = np.c_[geoOCCmesh.Elements2D().NumPy()['nodes'].astype(np.uint64)[:,:npoints],
          geoOCCmesh.Elements2D().NumPy()['index'].astype(np.uint64)]-1
83/31: import numpy as np
83/32:
t = np.c_[geoOCCmesh.Elements2D().NumPy()['nodes'].astype(np.uint64)[:,:npoints],
          geoOCCmesh.Elements2D().NumPy()['index'].astype(np.uint64)]-1
83/33: t
83/34:
e = np.c_[geoOCCmesh.Elements1D().NumPy()['nodes'].astype(np.uint64)[:,:((npoints+1)//2)],
          geoOCCmesh.Elements1D().NumPy()['index'].astype(np.uint64)]-1
83/35: e
83/36: npoints = geoOCCmesh.Elements3D().NumPy()['np'].max()
83/37: npoints
83/38: geoOCCmesh.Elements1D().NumPy()['np'].max()
83/39: geoOCCmesh.Elements1D().NumPy()
83/40: geoOCCmesh.Elements1D().NumPy()['np']
83/41: :((npoints+1)//2)
83/42: ((npoints+1)//2)
83/43:
max_bc_index = geoOCCmesh.Elements1D().NumPy()['index'].astype(np.uint64).max()
max_rg_index = geoOCCmesh.Elements2D().NumPy()['index'].astype(np.uint64).max()
83/44: max_bc_index
83/45: max_rg_index
83/46:
t = np.c_[geoOCCmesh.Elements3D().NumPy()['nodes'].astype(np.uint64)[:,:npoints3D],
          geoOCCmesh.Elements3D().NumPy()['index'].astype(np.uint64)]-1
83/47:
npoints2D = geoOCCmesh.Elements2D().NumPy()['np'].max()
npoints3D = geoOCCmesh.Elements2D().NumPy()['np'].max()

p = geoOCCmesh.Coordinates()

t = np.c_[geoOCCmesh.Elements3D().NumPy()['nodes'].astype(np.uint64)[:,:npoints3D],
          geoOCCmesh.Elements3D().NumPy()['index'].astype(np.uint64)]-1

f = np.c_[geoOCCmesh.Elements2D().NumPy()['nodes'].astype(np.uint64)[:,:npoints2D],
          geoOCCmesh.Elements2D().NumPy()['index'].astype(np.uint64)]-1

e = np.c_[geoOCCmesh.Elements1D().NumPy()['nodes'].astype(np.uint64)[:,:((npoints2D+1)//2)],
          geoOCCmesh.Elements1D().NumPy()['index'].astype(np.uint64)]-1
83/48: t
83/49: npoints3D
83/50:
npoints2D = geoOCCmesh.Elements2D().NumPy()['np'].max()
npoints3D = geoOCCmesh.Elements3D().NumPy()['np'].max()

p = geoOCCmesh.Coordinates()

t = np.c_[geoOCCmesh.Elements3D().NumPy()['nodes'].astype(np.uint64)[:,:npoints3D],
          geoOCCmesh.Elements3D().NumPy()['index'].astype(np.uint64)]-1

f = np.c_[geoOCCmesh.Elements2D().NumPy()['nodes'].astype(np.uint64)[:,:npoints2D],
          geoOCCmesh.Elements2D().NumPy()['index'].astype(np.uint64)]-1

e = np.c_[geoOCCmesh.Elements1D().NumPy()['nodes'].astype(np.uint64)[:,:((npoints2D+1)//2)],
          geoOCCmesh.Elements1D().NumPy()['index'].astype(np.uint64)]-1
83/51: t
83/52: geoOCCmesh.GetIdentifications()
83/53:
regions_1d_np = []
for i in range(max_bc_index):
    regions_1d_np += [geoOCCmesh.GetBCName(i)]

regions_2d_np = []
for i in range(max_rg_index):
    regions_2d_np += [geoOCCmesh.GetMaterial(i+1)]
83/54: max_bc_index
83/55:
max_bc_index = geoOCCmesh.Elements2D().NumPy()['index'].astype(np.uint64).max()
max_rg_index = geoOCCmesh.Elements3D().NumPy()['index'].astype(np.uint64).max()
83/56:
regions_1d_np = []
for i in range(max_bc_index):
    regions_1d_np += [geoOCCmesh.GetBCName(i)]

regions_2d_np = []
for i in range(max_rg_index):
    regions_2d_np += [geoOCCmesh.GetMaterial(i+1)]
83/57: regions_2d_np
83/58: regions_1d_np
83/59: identifications
83/60: np.array(geoOCCmesh.GetIdentifications())
83/61: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
83/62: t
83/63: f
83/64: e
85/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/3: regions_2d_np
85/4: regions_2d_np
85/5: regions_3d_np
85/6: t
85/7: e
85/8: f
77/7:
import ngsolve as ng
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
85/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/10:
fig = go.Figure()

xx_trig = np.c_[p[t[:,0],0],p[t[:,1],0],p[t[:,2],0]]
yy_trig = np.c_[p[t[:,0],1],p[t[:,1],1],p[t[:,2],1]]

xxx_trig = np.c_[xx_trig,xx_trig[:,0],np.nan*xx_trig[:,0]]
yyy_trig = np.c_[yy_trig,yy_trig[:,0],np.nan*yy_trig[:,0]]


fig.add_trace(go.Scatter(mode='lines', 
                           name='TrigTraces',
                           # x=x,
                           # y=y,
                           x=xxx_trig.flatten(),
                           y=yyy_trig.flatten(),
                           line=dict(color='blue', 
                                     width=2)))


fig.show()
85/11: fig
85/12: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/13: fig
85/14: fig.html()
85/15: fig.to_html()
85/16: pio.renderers
85/17:
import plotly.io as pio
pio.renderers
85/18:
import plotly.graph_objects as go
import plotly.io as pio
pio.renderers.default = "browser"

fig = go.Figure()

xx_trig = np.c_[p[t[:,0],0],p[t[:,1],0],p[t[:,2],0]]
yy_trig = np.c_[p[t[:,0],1],p[t[:,1],1],p[t[:,2],1]]

xxx_trig = np.c_[xx_trig,xx_trig[:,0],np.nan*xx_trig[:,0]]
yyy_trig = np.c_[yy_trig,yy_trig[:,0],np.nan*yy_trig[:,0]]


fig.add_trace(go.Scatter(mode = 'lines', 
                         name = 'TrigTraces',
                         # x=x,
                         # y=y,
                         x = xxx_trig.flatten(),
                         y = yyy_trig.flatten(),
                         line = dict(color = 'blue', width = 2)))


fig.show()
85/19: t
85/20: t.shape
85/21: t.shape[0]
85/22:

fig = go.Figure()


xx_trig = np.c_[p[t[:,0],0],p[t[:,1],0],p[t[:,2],0]]
yy_trig = np.c_[p[t[:,0],1],p[t[:,1],1],p[t[:,2],1]]

nt = t.shape[0]

# if DATAT == 'P1d':
#     zz = u[:3*nt].reshape(nt,3)
# if DATAT == 'P0':
#     zz = npy.tile(u[:nt],(3,1)).T
# if DATAT == 'P1':
#     zz = u[t]

ii, jj, kk = np.r_[:3*nt].reshape((nt, 3)).T
fig.add_trace(go.Mesh3d(
    name = 'Trig values',
    x = xx_trig.flatten(), y = yy_trig.flatten(), z = 0*xx_trig.flatten(),
    i = ii, j = jj, k = kk, intensity = xx_trig.flatten(), 
    colorscale = 'Rainbow',
    intensitymode = 'vertex',
    lighting = dict(ambient = 1),
    contour_width = 1, contour_color = "#000000", contour_show = True,
    # xaxis = dict(range())
))


fig.show()
85/23:
fig = go.Figure()


xx_trig = np.c_[p[t[:,0],0],p[t[:,1],0],p[t[:,2],0]]
yy_trig = np.c_[p[t[:,0],1],p[t[:,1],1],p[t[:,2],1]]
zz_trig = np.c_[p[t[:,0],2],p[t[:,1],2],p[t[:,2],2]]

nt = t.shape[0]

# if DATAT == 'P1d':
#     zz = u[:3*nt].reshape(nt,3)
# if DATAT == 'P0':
#     zz = npy.tile(u[:nt],(3,1)).T
# if DATAT == 'P1':
#     zz = u[t]

ii, jj, kk = np.r_[:3*nt].reshape((nt, 3)).T
fig.add_trace(go.Mesh3d(
    name = 'Trig values',
    x = xx_trig.flatten(), y = yy_trig.flatten(), z = zz_trig.flatten(),
    i = ii, j = jj, k = kk, intensity = zz_trig.flatten(), 
    colorscale = 'Rainbow',
    intensitymode = 'vertex',
    lighting = dict(ambient = 1),
    contour_width = 1, contour_color = "#000000", contour_show = True,
    # xaxis = dict(range())
))


fig.show()
85/24: zz_trig = np.c_[p[t[:,0],2],p[t[:,1],2],p[t[:,2],2]]
85/25: zz_trig
85/26: yy_trig
85/27: xx_trig
85/28:

ii, jj, kk = np.r_[:3*nt].reshape((nt, 3)).T
fig.add_trace(go.Mesh3d(
    name = 'Trig values',
    x = xx_trig.flatten(), 
    y = yy_trig.flatten(), 
    z = zz_trig.flatten(),
    i = ii, j = jj, k = kk, intensity = 0*zz_trig.flatten(), 
    colorscale = 'Rainbow',
    intensitymode = 'vertex',
    lighting = dict(ambient = 1),
    contour_width = 1, contour_color = "#000000", contour_show = True,
    # xaxis = dict(range())
))


fig.show()
85/29:
xx_trig = np.c_[p[t[:,0],0],p[t[:,1],0],p[t[:,2],0]]
yy_trig = np.c_[p[t[:,0],1],p[t[:,1],1],p[t[:,2],1]]
zz_trig = np.c_[p[t[:,0],2],p[t[:,1],2],p[t[:,2],2]]

nt = t.shape[0]

# if DATAT == 'P1d':
#     zz = u[:3*nt].reshape(nt,3)
# if DATAT == 'P0':
#     zz = npy.tile(u[:nt],(3,1)).T
# if DATAT == 'P1':
#     zz = u[t]

ii, jj, kk = np.r_[:3*nt].reshape((nt, 3)).T
fig.add_trace(go.Mesh3d(
    name = 'Trig values',
    x = xx_trig.flatten(), 
    y = yy_trig.flatten(), 
    z = zz_trig.flatten(),
    i = ii, j = jj, k = kk, intensity = 0*zz_trig.flatten(), 
    colorscale = 'Rainbow',
    intensitymode = 'vertex',
    lighting = dict(ambient = 1),
    contour_width = 1, contour_color = "#000000", contour_show = True,
    # xaxis = dict(range())
))


fig.show()
85/30:
xxx_trig = np.c_[xx_trig,xx_trig[:,0],np.nan*xx_trig[:,0]]
yyy_trig = np.c_[yy_trig,yy_trig[:,0],np.nan*yy_trig[:,0]]
zzz_trig = np.c_[zz_trig,zz_trig[:,0],np.nan*zz_trig[:,0]]

fig.add_trace(go.Scatter3d(name = 'Trig traces',
                            mode = 'lines',
                            x = xxx_trig.flatten(),
                            y = yyy_trig.flatten(),
                            z = zzz_trig.flatten(),
                            line = go.scatter3d.Line(color = 'black', 
                                                    width = 1.5),
                            showlegend = False))


fig.show()
85/31: xx_trig
85/32:
xxx_trig = np.c_[xx_trig,xx_trig[:,0],np.nan*xx_trig[:,0]]
yyy_trig = np.c_[yy_trig,yy_trig[:,0],np.nan*yy_trig[:,0]]
zzz_trig = np.c_[zz_trig,zz_trig[:,0],np.nan*zz_trig[:,0]]

fig.add_trace(go.Scatter3d(name = 'Trig traces',
                            mode = 'lines',
                            x = xxx_trig.flatten(),
                            y = yyy_trig.flatten(),
                            z = zzz_trig.flatten(),
                            line = go.scatter3d.Line(color = 'black', 
                                                    width = 1.5),
                            showlegend = False))


fig.show()
85/33: xxx_trig = np.c_[xx_trig,xx_trig[:,0],np.nan*xx_trig[:,0]]
85/34: xxx_trig
85/35: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/36: f
85/37: np.where(f[:,3]~=0)
85/38: np.where(f[:,3]!=0)
85/39: np.where(f[:,3]!=0)[0]
85/40: f[:,np.where(f[:,3]!=0)[0]]
85/41: f[np.where(f[:,3]!=0)[0],:]
85/42: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/43: regions_2d_np
85/44: regions_2d_np=='ambient_face'
85/45: 'ambient_face' in regions_2d_np
85/46: regions_2d_np.index('ambient_face')
85/47: [i for i in regions_2d_np.index('ambient_face')]
85/48: [int i for i in regions_2d_np.index('ambient_face')]
85/49: [i for elem in regions_2d_np.index('ambient_face')]
85/50: [i for i,elem in regions_2d_np.index('ambient_face')]
85/51: [i for i, x in regions_2d_np if x == "ambient_face"]
85/52: [x in regions_2d_np if x == "ambient_face"]
85/53: [i for i, x in enumerate(regions_2d_np) if x == "ambient_face"]
85/54: [x in enumerate(regions_2d_np) if x == "ambient_face"]
85/55: x in enumerate(regions_2d_np) if x == "ambient_face"
85/56: [i for i, x in enumerate(regions_2d_np) if x == "ambient_face"]
85/57: [i for i, x in enumerate(regions_2d_np) if x != "ambient_face"]
85/58: f
85/59: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/60: f
85/61: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/62: f
85/63: f[all_but_ambient,:]
85/64: [i for i, x in enumerate(regions_2d_np) if x == "ambient_face"]
85/65: all_but_ambient
85/66: enumerate(regions_2d_np)
85/67: all_but_ambient
85/68: f[-100,:]
85/69: f[:-100,:]
85/70: f[:-200,:]
85/71: f[:-300,:]
85/72: f[:-400,:]
85/73: f[:-500,:]
85/74: f[:,3]
85/75: np.where(f[:,3]==all_but_ambient)
85/76: np.where(f[:,3])
85/77: f
85/78: MESH.getIndices2d(MESH.regions_2d,regions)
85/79:
def getIndices2d(liste, name):
    regions = npy.char.split(name,',').tolist()
    ind = npy.empty(shape=(0,),dtype=npy.int64)
    for k in regions:
        if k[0] == '*':
            n = npy.flatnonzero(npy.char.find(liste,k[1:])!=-1)
        else:
            n = npy.flatnonzero(npy.char.equal(liste,k))
        ind = npy.append(ind,n,axis=0)
    return npy.unique(ind)
85/80: getIndices2d(regions_2d_np,'ambient_face')
85/81: import numpy as npy
85/82: getIndices2d(regions_2d_np,'ambient_face')
85/83: getIndices2d(regions_2d_np,'ambient_face')
85/84: getIndices2d(regions_2d_np,'~ambient_face')
85/85: getIndices2d(regions_2d_np,'!ambient_face')
85/86: getIndices2d(regions_2d_np,'ambient_face|l_steel_face')
85/87: getIndices2d(regions_2d_np,'ambient_face,l_steel_face')
85/88: getIndices2d(regions_2d_np,'l_steel_face')
85/89: ind_regions = getIndices2d(regions_3d_np, 'ambient_face')
85/90: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/91: ind_regions
85/92: indices
85/93: regions_3d_np
85/94: ind_regions = getIndices2d(regions_2d_np, 'ambient_face')
85/95: indices = npy.in1d(MESH.t[:,-1],ind_regions)
85/96: indices = npy.in1d(t[:,-1],ind_regions)
85/97: indices
85/98: indices = npy.in1d(f[:,-1],ind_regions)
85/99: indices
85/100: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/101: f
85/102: indices
85/103: f = f[indices,:]
85/104: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/105: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/106: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/107: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/108: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/109: geoOCCmesh.RefineMesh()
85/110:
import ngsolve as ng
import netgen.occ as occ
import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))

##########################################################################
# Rounding corners ...
##########################################################################
corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")

##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});

##########################################################################
# Generating mesh...
##########################################################################

geoOCC = occ.OCCGeometry(full)
ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
geoOCCmesh.Refinemesh()

##########################################################################
# Extracting info from the mesh
##########################################################################

import numpy as np
import numpy as npy

npoints2D = geoOCCmesh.Elements2D().NumPy()['np'].max()
npoints3D = geoOCCmesh.Elements3D().NumPy()['np'].max()

p = geoOCCmesh.Coordinates()

t = np.c_[geoOCCmesh.Elements3D().NumPy()['nodes'].astype(np.uint64)[:,:npoints3D],
          geoOCCmesh.Elements3D().NumPy()['index'].astype(np.uint64)]-1

f = np.c_[geoOCCmesh.Elements2D().NumPy()['nodes'].astype(np.uint64)[:,:npoints2D],
          geoOCCmesh.Elements2D().NumPy()['index'].astype(np.uint64)]-1

e = np.c_[geoOCCmesh.Elements1D().NumPy()['nodes'].astype(np.uint64)[:,:((npoints2D+1)//2)],
          geoOCCmesh.Elements1D().NumPy()['index'].astype(np.uint64)]-1

max_bc_index = geoOCCmesh.Elements2D().NumPy()['index'].astype(np.uint64).max()
max_rg_index = geoOCCmesh.Elements3D().NumPy()['index'].astype(np.uint64).max()

regions_2d_np = []
for i in range(max_bc_index):
    regions_2d_np += [geoOCCmesh.GetBCName(i)]

regions_3d_np = []
for i in range(max_rg_index):
    regions_3d_np += [geoOCCmesh.GetMaterial(i+1)]

identifications = np.array(geoOCCmesh.GetIdentifications())


all_but_ambient = [i for i, x in enumerate(regions_2d_np) if x != "ambient_face"]


def getIndices2d(liste, name):
    regions = npy.char.split(name,',').tolist()
    ind = npy.empty(shape=(0,),dtype=npy.int64)
    for k in regions:
85/111: geoOCCmesh.Refinemesh()
85/112: geoOCCmesh.refinemesh()
85/113: geoOCCmesh.Refine()
85/114: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
85/115: MESH = mesh3(p,e,t)
85/116: MESH = mesh3(p,e,t)
86/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/2: 1/20*(5-np.sqrt(5))
87/3: 1/20*(5+3*np.sqrt(5))
87/4:
v1 = 1/20*(5+3*np.sqrt(5))
v2 = 1/20*(5-np.sqrt(5))
87/5: v1
87/6: v2
87/7: -4/50
87/8: -4/5
87/9: 1/6
87/10:
v1 = 0.568430584196844
v2 = 0.143856471934385
w1 = 0.217765069880405
w2 = 0.021489953413063
qp = np.array([[v1,v2,v2,v2,  0,1/2,1/2,1/2,  0,  0],
               [v2,v2,v2,v1,1/2,  0,1/2,  0,1/2,  0],
               [v2,v2,v1,v2,1/2,1/2,  0,  0,  0,1/2]])
we = np.r_[w1,w1,w1,w1,w2,w2,w2,w2,w2,w2]
87/11: qp
87/12: we
87/13: edges_trigs
87/14: t
87/15: t
87/16: t[:3,:]
87/17: t[:,:3]
87/18: np.sort(t[:,:3])
87/19: np.sort(t[:,:3])-t[:,:3]
87/20: (np.sort(t[:,:3])-t[:,:3]).flatten()
87/21: plt.plot((np.sort(t[:,:3])-t[:,:3]).flatten())
87/22: import matplotlib.pyplot as plt
87/23: plt.plot((np.sort(t[:,:3])-t[:,:3]).flatten())
87/24:
t = npy.c_[npy.sort(t[:,:4]),t[:,4]]


edges_tets = npy.r_[npy.c_[t[:,0],t[:,1]],
                    npy.c_[t[:,0],t[:,2]],
                    npy.c_[t[:,0],t[:,3]],
                    npy.c_[t[:,1],t[:,2]],
                    npy.c_[t[:,1],t[:,3]],
                    npy.c_[t[:,2],t[:,3]]]

face_tets = npy.r_[npy.c_[t[:,1],t[:,2],t[:,3]],
                   npy.c_[t[:,0],t[:,2],t[:,3]],
                   npy.c_[t[:,0],t[:,1],t[:,3]],
                   npy.c_[t[:,0],t[:,1],t[:,2]]]

mp_tet = 1/3*(p[t[:,0],:] + p[t[:,1],:] + p[t[:,2],:] + p[t[:,3],:])

e_new = npy.sort(e[:,:2])

nt = t.shape[0]

#############################################################################################################
edges = npy.sort(edges_tets).astype(int)
EdgesToVertices, je = npy.unique(edges, axis = 0, return_inverse = True)
# EdgesToVertices, je = unique_rows(edges, return_inverse = True)
87/25: EdgesToVertices
87/26: TetsToEdges
87/27:

NoEdges = EdgesToVertices.shape[0]
TetsToEdges = je[0:4*nt].reshape(nt,4, order = 'F').astype(npy.int64)
BoundaryEdges = intersect2d(EdgesToVertices,e_new)
# InteriorEdges = npy.setdiff1d(npy.arange(NoEdges),BoundaryEdges)
87/28:
t = npy.c_[npy.sort(t[:,:4]),t[:,4]]


edges_tets = npy.r_[npy.c_[t[:,0],t[:,1]],
                    npy.c_[t[:,0],t[:,2]],
                    npy.c_[t[:,0],t[:,3]],
                    npy.c_[t[:,1],t[:,2]],
                    npy.c_[t[:,1],t[:,3]],
                    npy.c_[t[:,2],t[:,3]]]

face_tets = npy.r_[npy.c_[t[:,1],t[:,2],t[:,3]],
                   npy.c_[t[:,0],t[:,2],t[:,3]],
                   npy.c_[t[:,0],t[:,1],t[:,3]],
                   npy.c_[t[:,0],t[:,1],t[:,2]]]

mp_tet = 1/3*(p[t[:,0],:] + p[t[:,1],:] + p[t[:,2],:] + p[t[:,3],:])

f_new = npy.sort(f[:,:2])

nt = t.shape[0]

#############################################################################################################
edges = npy.sort(edges_tets).astype(int)
EdgesToVertices, je = npy.unique(edges, axis = 0, return_inverse = True)
# EdgesToVertices, je = unique_rows(edges, return_inverse = True)

NoEdges = EdgesToVertices.shape[0]
TetsToEdges = je[0:4*nt].reshape(nt,4, order = 'F').astype(npy.int64)
BoundaryEdges = intersect2d(EdgesToVertices,f_new)
# InteriorEdges = npy.setdiff1d(npy.arange(NoEdges),BoundaryEdges)

EdgesToVertices = npy.c_[EdgesToVertices,npy.zeros(EdgesToVertices.shape[0],dtype = npy.int64)-1]
EdgesToVertices[BoundaryEdges,2] = f[:,-1]
#############################################################################################################
87/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/mesh3stuff.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/30: t
87/31: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/32: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/33: EdgesToVertices
87/34: NoEdges
87/35: EdgesToVertices
87/36: TetsToEdges
87/37: BoundaryEdges
87/38: EdgesToVertices
77/8:
import ngsolve as ng
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Compounding ...
##########################################################################

geom = coil + mid_steel + r_steel + l_steel
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

DrawGeo(full, clipping={"z":-1, "dist":64});
77/9: coil
87/39: BoundaryEdges
87/40: EdgesToVertices
87/41: EdgesToVertices
87/42: f_new
87/43: f_new
87/44: f
87/45: f_new
87/46: BoundaryEdges
87/47: f
87/48: e
87/49: p
87/50: e
87/51: p
87/52: e
87/53: t
87/54: e[:,:1]
87/55: f[:,:2]
87/56: f
87/57: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/58:

t = npy.c_[npy.sort(t[:,:4]),t[:,4]]


edges_tets = npy.r_[npy.c_[t[:,0],t[:,1]],
                    npy.c_[t[:,0],t[:,2]],
                    npy.c_[t[:,0],t[:,3]],
                    npy.c_[t[:,1],t[:,2]],
                    npy.c_[t[:,1],t[:,3]],
                    npy.c_[t[:,2],t[:,3]]]

face_tets = npy.r_[npy.c_[t[:,1],t[:,2],t[:,3]],
                   npy.c_[t[:,0],t[:,2],t[:,3]],
                   npy.c_[t[:,0],t[:,1],t[:,3]],
                   npy.c_[t[:,0],t[:,1],t[:,2]]]

mp_tet = 1/3*(p[t[:,0],:] + p[t[:,1],:] + p[t[:,2],:] + p[t[:,3],:])

e_new = npy.sort(e[:,:2])
f_new = npy.sort(f[:,:3])

nt = t.shape[0]

#############################################################################################################
edges = npy.sort(edges_tets).astype(int)
EdgesToVertices, je = npy.unique(edges, axis = 0, return_inverse = True)
# EdgesToVertices, je = unique_rows(edges, return_inverse = True)

NoEdges = EdgesToVertices.shape[0]
TetsToEdges = je[0:4*nt].reshape(nt,4, order = 'F').astype(npy.int64)
BoundaryEdges = intersect2d(EdgesToVertices,e_new)
# InteriorEdges = npy.setdiff1d(npy.arange(NoEdges),BoundaryEdges)

EdgesToVertices = npy.c_[EdgesToVertices,npy.zeros(EdgesToVertices.shape[0],dtype = npy.int64)-1]
EdgesToVertices[BoundaryEdges,2] = e[:,-1]
#############################################################################################################
87/59: EdgesToVertices
87/60: EdgesToVertices
87/61: npy.zeros(EdgesToVertices.shape[0],dtype = npy.int64)-1
87/62: edges_tets
87/63: edges
87/64: edges_tets
87/65: edges-edges_tets
87/66: (edges-edges_tets).flatten()
87/67: plt.plot()edges-edges_tets).flatten()
87/68: plt.plot(edges-edges_tets).flatten())
87/69: plt.plot((edges-edges_tets).flatten())
87/70:

t = npy.c_[npy.sort(t[:,:4]),t[:,4]]


edges_tets = npy.r_[npy.c_[t[:,0],t[:,1]],
                    npy.c_[t[:,0],t[:,2]],
                    npy.c_[t[:,0],t[:,3]],
                    npy.c_[t[:,1],t[:,2]],
                    npy.c_[t[:,1],t[:,3]],
                    npy.c_[t[:,2],t[:,3]]]

face_tets = npy.r_[npy.c_[t[:,1],t[:,2],t[:,3]],
                   npy.c_[t[:,0],t[:,2],t[:,3]],
                   npy.c_[t[:,0],t[:,1],t[:,3]],
                   npy.c_[t[:,0],t[:,1],t[:,2]]]

mp_tet = 1/3*(p[t[:,0],:] + p[t[:,1],:] + p[t[:,2],:] + p[t[:,3],:])

e_new = npy.sort(e[:,:2])
f_new = npy.sort(f[:,:3])

nt = t.shape[0]

#############################################################################################################
edges = npy.sort(edges_tets).astype(int)
EdgesToVertices, je = npy.unique(edges, axis = 0, return_inverse = True)

NoEdges = EdgesToVertices.shape[0]
TetsToEdges = je[:4*nt].reshape(nt,4, order = 'F').astype(npy.int64)
BoundaryEdges = intersect2d(EdgesToVertices,e_new)
# InteriorEdges = npy.setdiff1d(npy.arange(NoEdges),BoundaryEdges)

EdgesToVertices = npy.c_[EdgesToVertices,npy.zeros(EdgesToVertices.shape[0],dtype = npy.int64)-1]
EdgesToVertices[BoundaryEdges,2] = e[:,-1]
#############################################################################################################
87/71: edges_tets
87/72: EdgesToVertices
87/73: BoundaryEdges
87/74: EdgesToVertices
87/75: e_new
87/76: e
87/77:

edges = npy.sort(edges_tets).astype(int)
EdgesToVertices, je = npy.unique(edges, axis = 0, return_inverse = True)

NoEdges = EdgesToVertices.shape[0]
TetsToEdges = je[:4*nt].reshape(nt,4, order = 'F').astype(npy.int64)
BoundaryEdges = intersect2d(EdgesToVertices,e_new)
# InteriorEdges = npy.setdiff1d(npy.arange(NoEdges),BoundaryEdges)

EdgesToVertices = npy.c_[EdgesToVertices,npy.zeros(EdgesToVertices.shape[0],dtype = npy.int64)-1]
EdgesToVertices[BoundaryEdges,2] = e[:,-1]
#############################################################################################################



#############################################################################################################
faces = npy.sort(faces_tets).astype(int)
FacesToVertices, je = npy.unique(faces, axis = 0, return_inverse = True)

NoFaces = FacesToVertices.shape[0]
TetsToFaces = je[:4*nt].reshape(nt,4, order = 'F').astype(npy.int64)
BoundaryFaces = intersect2d(FacesToVertices,f_new)
# InteriorFaces = npy.setdiff1d(npy.arange(NoFaces),BoundaryFaces)

FacesToVertices = npy.c_[FacesToVertices,npy.zeros(FacesToVertices.shape[0],dtype = npy.int64)-1]
FacesToVertices[BoundaryFaces,3] = f[:,-1]
#############################################################################################################
87/78:
faces_tets = npy.r_[npy.c_[t[:,1],t[:,2],t[:,3]],
                    npy.c_[t[:,0],t[:,2],t[:,3]],
                    npy.c_[t[:,0],t[:,1],t[:,3]],
                    npy.c_[t[:,0],t[:,1],t[:,2]]]
87/79:

faces = npy.sort(faces_tets).astype(int)
FacesToVertices, je = npy.unique(faces, axis = 0, return_inverse = True)

NoFaces = FacesToVertices.shape[0]
TetsToFaces = je[:4*nt].reshape(nt,4, order = 'F').astype(npy.int64)
BoundaryFaces = intersect2d(FacesToVertices,f_new)
# InteriorFaces = npy.setdiff1d(npy.arange(NoFaces),BoundaryFaces)

FacesToVertices = npy.c_[FacesToVertices,npy.zeros(FacesToVertices.shape[0],dtype = npy.int64)-1]
FacesToVertices[BoundaryFaces,3] = f[:,-1]
#############################################################################################################
87/80: FacesToVertices
87/81: TetsToFaces
87/82: NoFaces
87/83: TetsToEdges
87/84:

edges = npy.sort(edges_tets).astype(int)
EdgesToVertices, je = npy.unique(edges, axis = 0, return_inverse = True)

NoEdges = EdgesToVertices.shape[0]
TetsToEdges = je[:6*nt].reshape(nt,6, order = 'F').astype(npy.int64)
BoundaryEdges = intersect2d(EdgesToVertices,e_new)
# InteriorEdges = npy.setdiff1d(npy.arange(NoEdges),BoundaryEdges)

EdgesToVertices = npy.c_[EdgesToVertices,npy.zeros(EdgesToVertices.shape[0],dtype = npy.int64)-1]
EdgesToVertices[BoundaryEdges,2] = e[:,-1]
#############################################################################################################



#############################################################################################################
faces = npy.sort(faces_tets).astype(int)
FacesToVertices, je = npy.unique(faces, axis = 0, return_inverse = True)

NoFaces = FacesToVertices.shape[0]
TetsToFaces = je[:4*nt].reshape(nt,4, order = 'F').astype(npy.int64)
BoundaryFaces = intersect2d(FacesToVertices,f_new)
# InteriorFaces = npy.setdiff1d(npy.arange(NoFaces),BoundaryFaces)

FacesToVertices = npy.c_[FacesToVertices,npy.zeros(FacesToVertices.shape[0],dtype = npy.int64)-1]
FacesToVertices[BoundaryFaces,3] = f[:,-1]
#############################################################################################################
87/85: TetsToEdges
87/86: NoEdges
87/87: TetsToEdges.shape
87/88: nt
87/89: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/90: nt
87/91: BoundaryFaces
87/92: EdgesToVertices
87/93: FacesToVertices
87/94: TetsToFaces
87/95: TetsToEdges
87/96: InteriorEdges = npy.setdiff1d(npy.arange(NoEdges),BoundaryEdges)
87/97: InteriorEdges
87/98: IntEdgesToTriangles
87/99: t
87/100: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/101: 30000*(1.03)**10
87/102: 30000*(1.035)**10
87/103: 300000*(1.035)**10
87/104: 30000*(1.035)**10
87/105: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/106: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/107:

from mst import *

newListOfEdges = MESH.EdgesToVertices[:,:2]
g = Graph(MESH.np) 

for i in range(MESH.NoEdges):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]
87/108: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/109: MESH.pdesurf(u_H1, faces = 'l_steel_face,r_steel_face,mid_steel_face,coil_face')
87/110: ind_faces = MESH.getIndices2d(MESH.regions_2d,faces)
87/111: MESH.getIndices
87/112: MESH.regions_2d
87/113: getIndices(MESH.regions_2d,'ambient_face')
87/114: pde.tools.getIndices(MESH.regions_2d,'ambient_face')
87/115: MESH.f
87/116: MESH.f
87/117: pde.tools.getIndices(MESH.regions_2d,'ambient_face')
87/118: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/119:

pde.tools.getIndices(MESH.regions_2d,'ambient_face')
87/120: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/121: a = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
87/122: a
87/123: MESH.f
87/124: MESH.Boundary_Faces
87/125: MESH.f[:,-1]
87/126: pde.tools.getIndices(MESH.f[:,-1],a)
87/127: MESH.f[:,-1]
87/128: a
87/129: np.in1d(MESH.f[:,-1],a)
87/130: np.argwhere(np.in1d(MESH.f[:,-1],a))
87/131: np.argwhere(np.in1d(MESH.f[:,-1],a))[0]
87/132: np.argwhere(np.in1d(MESH.f[:,-1],a))[:,0]
87/133: MESH.f[np.argwhere(np.in1d(MESH.f[:,-1],a))[:,0],:]
87/134: a
87/135: MESH.f[np.argwhere(np.in1d(MESH.f[:,-1],a))[:,0],:].shape
87/136: MESH.f[np.argwhere(np.in1d(MESH.f[:,-1],a))[:,0],2].shape
87/137: MESH.f[np.argwhere(np.in1d(MESH.f[:,-1],a))[:,0],2]
87/138: MESH.f[np.argwhere(np.in1d(MESH.f[:,-1],a))[:,0],3]
87/139: MESH.f[np.argwhere(np.in1d(MESH.f[:,-1],a))[:,0],:]
87/140:

a = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
corresponding_faces = MESH.f[np.argwhere(np.in1d(MESH.f[:,-1],a))[:,0],:]
87/141: corresponding_faces
87/142: MESH.FacesToVertices
87/143:
edges_trigs = npy.r_[npy.c_[t[:,1],t[:,2]],
                     npy.c_[t[:,2],t[:,0]],
                     npy.c_[t[:,0],t[:,1]]]
87/144: edges_trigs
87/145:
trigs = MESH.FacesToVertices

edges_trigs = npy.r_[npy.c_[trigs[:,0],trigs[:,1]],
                     npy.c_[trigs[:,0],trigs[:,2]],
                     npy.c_[trigs[:,1],trigs[:,2]]]
87/146: edges_trigs
87/147:
edges_trigs = npy.r_[npy.c_[trigs[:,0],trigs[:,1]],
                     npy.c_[trigs[:,0],trigs[:,2]],
                     npy.c_[trigs[:,1],trigs[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)
87/148: edges_trigs_unique
87/149: edges_trigs_unique.shape
87/150: MESH
87/151: corresponding_faces
87/152:
a = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
faces = MESH.f[np.argwhere(np.in1d(MESH.f[:,-1],a))[:,0],:]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)
87/153: edges_trigs_unique
87/154: edges_trigs_unique.shape
87/155: faces
87/156: np.argwhere(np.in1d(MESH.f[:,-1],a))[:,0]
87/157:

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.argwhere(np.in1d(MESH.f[:,-1],regions_indices))[:,0]
87/158:

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.argwhere(np.in1d(MESH.f[:,-1],regions_indices))[:,0]


faces = MESH.f[np.argwhere(np.in1d(MESH.f[:,-1],face_indices))[:,0],:]
87/159: faces
87/160:
regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.argwhere(np.in1d(MESH.f[:,-1],regions_indices))[:,0]
faces = MESH.f[face_indices,:]
87/161: faces
87/162:

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.argwhere(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices,:]
87/163: faces
87/164: np.argwhere(np.in1d(MESH.f[:,-1],regions_indices))
87/165: np.where(np.in1d(MESH.f[:,-1],regions_indices))
87/166:


regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices,:]
87/167: faces
87/168: faces = MESH.f[face_indices,:]
87/169: faces.shape
87/170:

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))[:,0]
faces = MESH.f[face_indices,:]
87/171:

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))[0]
faces = MESH.f[face_indices,:]
87/172: faces
87/173:
regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]
87/174: faces
87/175: face_indices
87/176: np.in1d(MESH.f[:,-1]
87/177: MESH.f[:,-1]
87/178: regions_indices
87/179: in1d
87/180: regions_indices
87/181: face_indices
87/182: faces
87/183:
edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]
87/184: edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)
87/185: je
87/186: edges_trigs_unique
87/187: MESH.EdgesToVertices
87/188: pde.intersect2d
87/189: pde.intersect2d(MESH.EdgesToVertices,edges_trigs_unique)
87/190: pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
87/191: MESH.EdgesToVertices[808,:]
87/192: MESH.EdgesToVertices[edges_indices,:]
87/193: edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
87/194: MESH.EdgesToVertices[edges_indices,:]
87/195: MESH.EdgesToVertices[edges_indices]
87/196: MESH.EdgesToVertices[edge_indices]
87/197: edges_trigs_unique
87/198:



regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)

print(edge_indices.shape)
87/199:



regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)

print(edge_indices.shape)
87/200: MESH.regions_2d
87/201:




regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face,r_steel_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)

print(edge_indices.shape)
87/202:


regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face,r_steel_face,l_steel_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)

print(edge_indices.shape)
87/203:


regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face,r_steel_face,l_steesl_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)

print(edge_indices.shape)
87/204: edge_indices
87/205: MESH.NoEdges
87/206: MESH.FEMLISTS['N0']['B']['LIST_DOF']
87/207: K_Hcurl
87/208: MESH
87/209:
regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face,r_steel_face,l_steel_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)

print(edge_indices.shape)


# LIST_DOF  = np.unique(MESH.FEMLISTS['N0']['B']['LIST_DOF'][indices])
LIST_DOF2 = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

D = sp.eye(sizeM, format = 'csc')

# if listDOF.size > 0:
#     LIST_DOF = listDOF

# R1 = D[:,LIST_DOF]
R2 = D[:,LIST_DOF2]

# return R1.T.tocsc(),R2.T.tocsc()
87/210:


from scipy import sparse as sp

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face,r_steel_face,l_steel_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)

print(edge_indices.shape)


# LIST_DOF  = np.unique(MESH.FEMLISTS['N0']['B']['LIST_DOF'][indices])
LIST_DOF2 = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

D = sp.eye(sizeM, format = 'csc')

# if listDOF.size > 0:
#     LIST_DOF = listDOF

# R1 = D[:,LIST_DOF]
R2 = D[:,LIST_DOF2]

# return R1.T.tocsc(),R2.T.tocsc()
87/211:

from mst import *

newListOfEdges = MESH.EdgesToVertices[:,:2]
g = Graph(MESH.np) 

for i in range(MESH.NoEdges):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]


from scipy import sparse as sp

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face,r_steel_face,l_steel_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)

print(edge_indices.shape)


# LIST_DOF  = np.unique(MESH.FEMLISTS['N0']['B']['LIST_DOF'][indices])
LIST_DOF2 = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

D = sp.eye(MESH.NoEdges, format = 'csc')

# if listDOF.size > 0:
#     LIST_DOF = listDOF

# R1 = D[:,LIST_DOF]
R2 = D[:,LIST_DOF2]

# return R1.T.tocsc(),R2.T.tocsc()
87/212: R2
87/213: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/214: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/215: R2
87/216: K_Hcurl
87/217: R2@K_Hcurl
87/218: R2.T@K_Hcurl
87/219: R2.T@K_Hcurl@R2
87/220: np.linalg.matrix_rank(R2.T@K_Hcurl@R2)
87/221: np.linalg.matrix_rank((R2.T@K_Hcurl@R2).A)
87/222: MESH
87/223: KR = (R2.T@K_Hcurl@R2)
87/224: KR
87/225: indices
87/226: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/227: indices
87/228: KR = (R2.T@K_Hcurl@R2)
87/229: KR
87/230: np.linalg.matrix_rank(KR.A)
87/231: np.linalg.matrix_rank(K_Hcurl)
87/232: np.linalg.matrix_rank(K_Hcurl.A)
87/233: K_Hcurl
87/234: MESH.EdgesToVertices[:,:2]
87/235: edges_trigs_unique
87/236: MESH.EdgesToVertices[:,:2]
87/237: MESH.EdgesToVertices[:,:2]
87/238: MESH.EdgesToVertices[:,:2]
87/239: MESH.EdgesToVertices[:,:2].shape
87/240: edges_trigs_unique.shape
87/241: edge_indices
87/242: edges_trigs_unique
87/243: edges_trigs_unique.shape
87/244: edge_indices
87/245: edge_indices.shape
87/246: np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)
87/247: np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices).shape
87/248:



from scipy import sparse as sp

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face,r_steel_face,l_steel_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
other_edge_indices = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)
87/249: other_edge_indices
87/250:
from scipy import sparse as sp

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face,r_steel_face,l_steel_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
other_edge_indices = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

print(edge_indices.shape)



from mst import *

newListOfEdges = MESH.EdgesToVertices[other_edge_indices,:2]
g = Graph(MESH.np) 

for i in range(MESH.NoEdges):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]
87/251: other_edge_indices
87/252:


from scipy import sparse as sp

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face,r_steel_face,l_steel_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
other_edge_indices = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

print(edge_indices.shape)
87/253: edge_indices
87/254: other_edge_indices
87/255:


from scipy import sparse as sp

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
other_edge_indices = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

print(edge_indices.shape)
87/256: edge_indices
87/257: other_edge_indices
87/258: print(edge_indices.shape)
87/259: other_edge_indices.shape
87/260: MESH.regions_2d
87/261:
regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
other_edge_indices = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

print(edge_indices.shape)
87/262: other_edge_indices
87/263: MESH.EdgesToVertices[other_edge_indices,:2]
87/264: np.unique(MESH.EdgesToVertices[other_edge_indices,:2])
87/265: np.unique(MESH.EdgesToVertices[other_edge_indices,:2]).shape
87/266: np.unique(MESH.EdgesToVertices[other_edge_indices,:2]).size
87/267:


from scipy import sparse as sp

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
other_edge_indices = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

noPoints_interior = np.unique(MESH.EdgesToVertices[other_edge_indices,:2]).size

print(edge_indices.shape)



from mst import *

newListOfEdges = MESH.EdgesToVertices[other_edge_indices,:2]
g = Graph(noPoints_interior) 

for i in range(MESH.NoEdges):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]
87/268: MESH.EdgesToVertices[other_edge_indices,:2]
87/269: newListOfEdges
87/270: newListOfEdges.shape
87/271: newListOfEdges.shape[0]
87/272:


from scipy import sparse as sp

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
other_edge_indices = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

noPoints_interior = np.unique(MESH.EdgesToVertices[other_edge_indices,:2]).size

print(edge_indices.shape)



from mst import *

newListOfEdges = MESH.EdgesToVertices[other_edge_indices,:2]
g = Graph(noPoints_interior) 

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]


# LIST_DOF  = np.unique(MESH.FEMLISTS['N0']['B']['LIST_DOF'][indices])
LIST_DOF2 = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

D = sp.eye(MESH.NoEdges, format = 'csc')
87/273:

from scipy import sparse as sp

regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
other_edge_indices = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

noPoints_interior = np.unique(MESH.EdgesToVertices[other_edge_indices,:2]).size

print(edge_indices.shape)



from mst import *

newListOfEdges = MESH.EdgesToVertices[other_edge_indices,:2]
g = Graph(noPoints_interior) 

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]
87/274: newListOfEdges
87/275: Graph(noPoints_interior)
87/276:
from mst import *

newListOfEdges = MESH.EdgesToVertices[other_edge_indices,:2]
g = Graph(noPoints_interior)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)
87/277:
from mst import *

newListOfEdges = MESH.EdgesToVertices[other_edge_indices,:2]
g = Graph(noPoints_interior)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
87/278: newListOfEdges
87/279:
from mst import *

newListOfEdges = MESH.EdgesToVertices[other_edge_indices,:2]
g = Graph(noPoints_interior)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]


# LIST_DOF  = np.unique(MESH.FEMLISTS['N0']['B']['LIST_DOF'][indices])
LIST_DOF2 = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

D = sp.eye(MESH.NoEdges, format = 'csc')
87/280:
for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)
87/281:
for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)
87/282:
for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)
87/283:
    ListOfEdges[i,1],i)

g.KruskalMST()
87/284:

g.KruskalMST()
87/285:


from mst import *

newListOfEdges = MESH.EdgesToVertices[other_edge_indices,:2]
g = Graph(noPoints_interior)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)
87/286: noPoints_interior
87/287: MESH.EdgesToVertices[other_edge_indices,:2]
87/288: MESH.EdgesToVertices[other_edge_indices,:2].ravel()
87/289: np.sort(MESH.EdgesToVertices[other_edge_indices,:2].ravel())
87/290: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/291: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/292: K_Hcurl
87/293:

from mst import *

newListOfEdges = MESH.EdgesToVertices[:,:2]
g = Graph(MESH.np) 

for i in range(MESH.NoEdges):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]
87/294: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/295: noPoints_interior
87/296: K_Hcurl
87/297: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/298: indices
87/299: edge_indices
87/300: indices
87/301: np.union1d(edge_indices,indices)
87/302: np.union1d(edge_indices,indices).shape
87/303: K_Hcurl
87/304: 1700-771
87/305: np.linalg.matrix_rank(K_Hcurl.A)
87/306: 1700-1289
87/307: 1700-1298
87/308: edge_indices.shape
87/309: indices.shape
87/310:

from mst import *

newListOfEdges = MESH.EdgesToVertices[:,:2]
g = Graph(MESH.np) 

for i in range(MESH.NoEdges):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]  


# LIST_DOF  = np.unique(MESH.FEMLISTS['N0']['B']['LIST_DOF'][indices])
LIST_DOF2 = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

D = sp.eye(MESH.NoEdges, format = 'csc')

# if listDOF.size > 0:
#     LIST_DOF = listDOF

# R1 = D[:,LIST_DOF]
R2 = D[:,LIST_DOF2]
87/311: R2
87/312: R2.T@K_Hcurl@R2
87/313: KR = R2.T@K_Hcurl@R2
87/314: np.linalg.matrix_rank(KR.A)
87/315: 1376-1298
87/316: MESH
87/317: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/318: KR = R2.T@K_Hcurl@R2
87/319: KR
87/320: np.linalg.matrix_rank(KR.A)
87/321: 10112-9812
87/322: MESH
87/323: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/324: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/325: R
87/326: KR = R2.T@K_Hcurl@R2
87/327: KR
87/328: plt.spy(KR,markersize=1)
87/329: edge_indices
87/330: indices
87/331: np.union
87/332: np.union1d(indices,edge_indices)
87/333: np.union1d(edge_indices)
87/334: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/335: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/336: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/337: KR
87/338: np.linalg.matrix_rank(KR.A)
87/339: MESH.EdgesToVertices[:,:2]
87/340: MESH.Boundary_Edges
87/341: edge_indices
87/342: MESH.EdgesToVertices[edge_indices,:2]
87/343:
newListOfEdges = np.r_[MESH.EdgesToVertices[edge_indices,:2],
                       MESH.EdgesToVertices[np.setdiff1d(np.r_[:MESH.NoEdges], edge_indices),:2]]
87/344: newListOfEdges.shape
87/345: newListOfEdges = MESH.EdgesToVertices[:,:2]
87/346: newListOfEdges.shape
87/347: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/348: KR
87/349: KR.shape
87/350: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/351: KR
87/352: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/353: K_Hcurl
87/354: K_Hcurl.shape
87/355: np.linalg.matrix_rank(K_Hcurl.A)
87/356: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/357: KR
87/358: np.linalg.matrix_rank(K_Hcurl.A)
87/359: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/360: KR
87/361: MESH
87/362: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/363: KR
87/364: np.linalg.matrix_rank(K_Hcurl.A)
87/365: np.linalg.matrix_rank(KR.A)
87/366: np.linalg.matrix_rank(KR.A,tol=1e-16)
87/367: np.linalg.matrix_rank(KR.A)
87/368: np.linalg.matrix_rank(KR.A,tol=1e-213)
87/369: np.linalg.matrix_rank(KR.A,tol=1e-312312312312)
87/370: np.linalg.matrix_rank(KR.A,tol=0)
87/371: np.linalg.matrix_rank(KR.A,tol=1)
87/372: np.linalg.matrix_rank(KR.A)
87/373: np.linalg.matrix_rank(KR.A,tol=1e-2)
87/374: np.linalg.matrix_rank(KR.A,tol=1e-3)
87/375: np.linalg.matrix_rank(KR.A,tol=1e-4)
87/376: np.linalg.matrix_rank(KR.A,tol=1e-5)
87/377: np.linalg.matrix_rank(KR.A,tol=1e-8)
87/378: np.linalg.matrix_rank(KR.A,tol=1e-12)
87/379: np.linalg.matrix_rank(KR.A,tol=1e-15)
87/380: np.linalg.matrix_rank(KR.A,tol=1e-16)
87/381: np.linalg.matrix_rank(KR.A,tol=1e-18)
87/382: np.linalg.matrix_rank(KR.A,tol=1e-19)
87/383: np.linalg.matrix_rank(KR.A,tol=1e-123123)
87/384: np.linalg.matrix_rank(KR.A,tol=1e-123123312312)
87/385: np.linalg.matrix_rank(KR.A,tol=0)
87/386: np.linalg.matrix_rank(KR.A,tol=0)
87/387: KR
87/388: np.linalg.matrix_rank(K_Hcurl.A,tol=0)
87/389: K_Hcurl
87/390: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-16)
87/391: KR
87/392: chol(KR)
87/393: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-16)
87/394: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-14)
87/395: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-13)
87/396: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-12)
87/397: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-12)
87/398: np.linalg.matrix_rank(KR.A,tol=1e-12)
87/399: print(np.linalg.matrix_rank(KR.A,tol=1e-15))
87/400: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/401: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/402: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/403: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/404: 1289-1256
87/405: MESH
87/406: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/407: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/408: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/409: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/410: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/411: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/412: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/413: MESH
87/414: 1700-324
87/415: 1376-1256
87/416: 1700-324-80
87/417: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/418:
from mst import *

# newListOfEdges = MESH.EdgesToVertices[:,:2]
# newListOfEdges = np.r_[MESH.EdgesToVertices[edge_indices,:2],
#                        MESH.EdgesToVertices[np.setdiff1d(np.r_[:MESH.NoEdges], edge_indices),:2]]
# newListOfEdges = np.r_[MESH.EdgesToVertices[np.setdiff1d(np.r_[:MESH.NoEdges], edge_indices),:2],
#                        MESH.EdgesToVertices[edge_indices,:2]]

newListOfEdges = MESH.EdgesToVertices[edge_indices,:2]

g = Graph(MESH.np) 

for i in range(MESH.NoEdges):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]
87/419: newListOfEdges.shape
87/420: newListOfEdges.shape[0]
87/421: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/422: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/423: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/424: MESH
87/425: edge_indices
87/426: edge_indices.shape
87/427:

print(edge_indices.shape)

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)
D = sp.eye(MESH.NoEdges, format = 'csc')
R = D[:,LIST_DOF]

K_noEdges = R.T@K_Hcurl@R
87/428: K_noEdges
87/429: np.linalg.matrix_rank(K_noEdges.A,tol=1e-12)
87/430: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/431: 1028-929
87/432: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/433: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/434:






fes = ng.HCurl(mesh, order=2, nograds=True)
print ("HCurl dofs:", fes.ndof)
u,v = fes.TnT()
87/435:
fes = ng.HCurl(geoOCCmesh, order=2, nograds=True)
print ("HCurl dofs:", fes.ndof)
u,v = fes.TnT()
87/436: geoOCCmesh
87/437:





geoOCC = occ.OCCGeometry(full)
ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
geoOCCmesh.Refine()
geoOCCmesh.Refine()
# geoOCCmesh.Refine()

mesh = ng.Mesh(geoOCCmesh)


##########################################################################
# NGSOVLE STUFF...
##########################################################################

fes = ng.HCurl(mesh, order=2, nograds=True)
print ("HCurl dofs:", fes.ndof)
u,v = fes.TnT()
87/438: M_Hcurl
87/439: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/440: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/441: MESH
87/442: 2009/2
87/443: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/444: u
87/445: v
87/446: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/447: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/448: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/449: MESH
87/450: 262+144
87/451: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/452: geoOCCmesh
87/453: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/454: MESH
87/455: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/456: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/457: MESH
87/458: MESH.EdgesToVertices.shape
87/459: runfile('C:/Users/Radu/Documents/GitHub/fem/pde/mesh_class.py', wdir='C:/Users/Radu/Documents/GitHub/fem/pde')
87/460: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/461: runfile('C:/Users/Radu/Documents/GitHub/fem/pde/mesh_class.py', wdir='C:/Users/Radu/Documents/GitHub/fem/pde')
87/462: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/463: MESH.EdgesToVertices
87/464: MESH.EdgesToVertices.shape
87/465: MESH
87/466: 262+40
87/467: runfile('C:/Users/Radu/Documents/GitHub/fem/pde/mesh_class.py', wdir='C:/Users/Radu/Documents/GitHub/fem/pde')
87/468: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/469: t
87/470: MESH,.t
87/471: MESH.t
87/472: 262+40+40
87/473: runfile('C:/Users/Radu/Documents/GitHub/fem/pde/mesh_class.py', wdir='C:/Users/Radu/Documents/GitHub/fem/pde')
87/474: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/475: t
87/476: runfile('C:/Users/Radu/Documents/GitHub/fem/pde/mesh_class.py', wdir='C:/Users/Radu/Documents/GitHub/fem/pde')
87/477: t
87/478: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/479: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/480: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/481: print((edges_tets-edges).norm())
87/482: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/483: print((edges_tets-edges).norm())
87/484: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/485: MESH
87/486: 262-344
87/487: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/488: MESH
87/489: 344*2+144
87/490: 344*2+144*2
87/491: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/492: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/493: MESH
87/494: 309-262
87/495: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/496: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/497: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/498: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/499: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/500: MESH
87/501: 344*2+144*2
87/502: 344*2+144*3
87/503: 344*3+144*3
87/504: 344*3+144*2
87/505: 344*3
87/506: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/507: 344*3
87/508: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/509: MESH
87/510: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/511: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/512: 50*3
87/513: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/514: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/515: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/516: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/517: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/518: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/519: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
87/520: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
88/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/7: bfa = ng.BilinearForm(ng.curl(phi)*ng.curl(psi)*dx).Assemble()
89/8: bfa = ng.BilinearForm(ng.curl(u)*ng.curl(v)*dx).Assemble()
89/9: bfa = ng.BilinearForm(ng.curl(u)*ng.curl(v)*ng.dx).Assemble()
89/10: bfa
89/11: bfa.NumPy()
89/12: bfa.mat.COO()
89/13: bfa.mat.COO().shape
89/14: bfa.mat.COO()
89/15: bfa.mat.NumPy()
89/16: bfa.mat
89/17: bfa.mat.__dict__
89/18: __dict__(bfa.mat)
89/19: dict(bfa.mat)
89/20: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/21: A
89/22: K_Hcurl
89/23: A-K_Hcurl
89/24: (A-K_Hcurl).max()
89/25: (A-K_Hcurl).min()
89/26: K_Hcurl
89/27: np.linalg.matrix_rank(A.A,tol=1e-12)
89/28: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-12)
89/29: MESH
89/30: 2512-463
89/31: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-15)
89/32: np.linalg.matrix_rank(A.A,tol=1e-15)
89/33: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/34: np.linalg.matrix_rank(A.A,tol=1e-15)
89/35: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-15)
89/36: plt.
89/37: plt.spy
89/38: import matplotlib.pyplot as plt
89/39: plt.spy(A,markersize=1)
89/40: plt.spy(K_Hcurl,markersize=1)
89/41: plt.spy(A,markersize=1)
89/42: plt.figure()
89/43: plt.spy(K_Hcurl,markersize=1)
89/44: A[0,0]
89/45: K_Hcurl[0,0]
89/46: K_Hcurl[1,0]
89/47: K_Hcurl[1,1]
89/48: K_Hcurl[10,10]
89/49: K_Hcurl[1312,1312]
89/50: A[1312,1312]
89/51: MESH
89/52: K_Hcurl[1,1]
89/53: A
89/54: K_Hcurl
89/55: 2512-462
89/56: 2512-463
89/57: 2512-462
89/58: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/59: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-15)
89/60: K_Hcurl
89/61: R
89/62: R2
89/63: R2@K_Hcurl@R2.T
89/64: R2.T@K_Hcurl@R2
89/65: chol(KR)
89/66: K_Hcurl
89/67: R2
89/68: R2.T@K_Hcurl@R2
89/69: curl(gfu)
89/70: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/71: K_Hcurl
89/72: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-15)
89/73: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/74: KR
89/75: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
89/76: KR
89/77: chol(KR)
89/78: np.r_[:MESH.NoEdges]
89/79: MESH.EdgesToVertices
89/80: MESH.FacesToVertices
90/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/2: MESH.FacesToVertices
90/3: A
90/4: normu
90/5: normu.shape
90/6: MESH
90/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/8: MESH
90/9: phix_Hcurl_P0
90/10: normu
90/11: normu.shape
90/12: MESH.nt*3
90/13: MESH.nt*4
90/14: MESH.nt
90/15: ux.shape
90/16: ux
90/17: ux.shape
90/18: J
90/19: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/20: scatter
90/21: import matplotlib.pyplot as plt
90/22: plt.quiver
90/23: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/24: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/25: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/26: x
90/27: y
90/28: u
90/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/30: J1(x,y,z)
90/31: (x<75)*(x>-75)*(y>-95)*(y<-75)
90/32: (x<75)*(x>-75)*(y>-95)*(y<-75)*J1(x,y,z)
90/33: J = lambda x,y,z : (x<75)*(x>-75)*(y>-95)*(y<-75)*J1(x,y,z)
90/34: J(x,y,z)
90/35: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/36: J1(x,y,z)
90/37:
x, y, z = np.meshgrid(np.arange(-150, 150, 10),
                      np.arange(-150, 150, 10),
                      np.arange( -70,  70, 10))
90/38: J1(x,y,z)
90/39: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/40: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/41: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/42: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/43: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/44: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/45: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/46: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/47: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/48: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/49: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/50: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/51: x
90/52: x<75
90/53: x
90/54: J1(x,y,z)
90/55: J(x,y,z)[0]
90/56: J(x,y,z)[1]
90/57: J(x,y,z)[2]
90/58: J
90/59: x
90/60: y
90/61: z
90/62: J1(x,y,z)
90/63: J(x,y,z)
90/64: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/65:
u = J(x,y,z)[0]
v = J(x,y,z)[1]
w = J(x,y,z)[2]
90/66: u
90/67: v
90/68: w
90/69: x
90/70: y
90/71: z
90/72: J(x,y,z)
90/73: x.shape
90/74: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/75: J1(x,y,z)
90/76: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/77: J1(x,y,z)
90/78: (x<75)*(x>-75)*(y>-95)*(y<-75)*J1(x,y,z)
90/79: (x<75)*(x>-75)*(y>-95)*(y<-75)
90/80: x
90/81: y
90/82: x
90/83: y
90/84: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/85: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/86: x
90/87: y
90/88: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/89: x
90/90: y
90/91: z
90/92: x.shape
90/93: y
90/94: y.shape
90/95: z.shape
90/96: x.flatten()
90/97: y.flatten()
90/98: z.flatten()
90/99: (x<75)*(x>-75)
90/100: (y>-95)*(y<-75)
90/101: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/102: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/103: u
90/104: v
90/105: w
90/106: J(x,y,z)
90/107: x
90/108: y
90/109: u
90/110: z
90/111: J(x,y,z)
90/112: x.flatten()
90/113: y.flatten()
90/114: z.flatten()
90/115: J(x.flatten(),y.flatten(),z.flatten())
90/116: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
90/117: J(x.flatten(),y.flatten(),z.flatten())
90/118: x.ravel()
90/119: x.ravel().shape
90/120: y.ravel().shape
90/121: z.ravel().shape
91/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/2: J(x.ravel(),y.ravel(),z.ravel())
91/3: J1(x.ravel(),y.ravel(),z.ravel())
91/4: J1(x.ravel(),y.ravel(),z.ravel()).shape
91/5:

J1 = lambda x,y,z : np.c_[ 1+0*x, 0*y, 0*z]
91/6: J1(x.ravel(),y.ravel(),z.ravel()).shape
91/7: np.c_[ 1+0*x, 0*y, 0*z]
91/8: J1(x.ravel(),y.ravel(),z.ravel()).shape
91/9: J1(x.ravel(),y.ravel(),z.ravel())[:,0]
91/10: J1(x.ravel(),y.ravel(),z.ravel())[:,1]
91/11: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/12: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/13: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/14: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/15: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/16: x.ravel()
91/17: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/18: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/19: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/20: x
91/21: x<75
91/22: (x<75)*(x>-75)
91/23: (y>-95)*(x>-75)
91/24: (y>-95)*(y>-75)
91/25: (y>-95)*(y<-75)
91/26: y
91/27: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/28: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/31: np.r_[(x<75)*(x>-75),(y>-95)*(y<-75),1]
91/32: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/33: np.c_[(x<75)*(x>-75),(y>-95)*(y<-75),1]
91/34: np.c_[(x<75)*(x>-75),(y>-95)*(y<-75),1+z*0]
91/35: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/36: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/37: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/38: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/39: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/40: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/41: y
91/42: (y> 75)*(y< 95)
91/43: (y> 75)*(y< 95).all()
91/44: (y> 75)*(y< 95).any()
91/45: y
91/46: print(y)
91/47: plt
91/48: plt.plot((y> 75)*(y< 95))
91/49: (x<75)*(x>-75)
91/50: (x<75)*(x>-75)x
91/51: x
91/52: y
91/53: (x<75)*(x>-75)*(y>-95)*(y<-75)
91/54: plt.plot((x<75)*(x>-75)*(y>-95)*(y<-75))
91/55: plt.plot((x<75)*(x>-75)*(y>-95)*(y<-75))
91/56: plt.plot((x<75)*(x>-75),(y> 75)*(y< 95))
91/57: plt.plot((x<75)*(x>-75),(y> 75)*(y< 95))
91/58: plt.plot((x<75)*(x>-75)*(y> 75)*(y< 95))
91/59: plt.plot((x<75)*(x>-75)*(y>-95)*(y<-75))
91/60: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/61: J1(x,y,z)
91/62: (x<75)*(x>-75)*(y>-95)*(y<-75)*J1(x,y,z)
91/63: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/64: J(x,y,z)
91/65: J(x,y,z)[:,0]
91/66: (x<75)*(x>-75)*(y>-95)*(y<-75)
91/67: J1(x,y,z)
91/68: J1(x,y,z).shape
91/69: ((x<75)*(x>-75)*(y>-95)*(y<-75)).shape
91/70: np.tile(((x<75)*(x>-75)*(y>-95)*(y<-75)),3,1)
91/71: np.tile(((x<75)*(x>-75)*(y>-95)*(y<-75)),(3,1))
91/72: np.tile(((x<75)*(x>-75)*(y>-95)*(y<-75)),(1,3))
91/73: np.tile(((x<75)*(x>-75)*(y>-95)*(y<-75)),(3,1)).T
91/74: np.tile(((x<75)*(x>-75)*(y>-95)*(y<-75)),(3,1))
91/75: np.tile(((x<75)*(x>-75)*(y>-95)*(y<-75)),(3,1)).T
91/76: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/77: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/78: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/79: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/80: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/81: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/82: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/83: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/84: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/85: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/J.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/86: import vtk
91/87: vtk
91/88: import vtk
91/89: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/vtk_stuff.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/90: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/vtk_stuff.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/91: VTKGrid
91/92: MESH
91/93: vtk.vtkPoints()
91/94: vtk
91/95: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/vtk_stuff.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/96: vtk
91/97: a = vtk()
91/98: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
91/99:

import vtk


points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()
91/100: points
91/101: grid
91/102: p
91/103: MESH.p
91/104: MESH.p
91/105: MESH.p[i,0]
91/106: MESH.p[0,0]
91/107:
import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))
91/108: MESH.t
91/109: MESH.t[0,:]
91/110: MESH.t[i,0]
91/111:
def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in MESH.np]
91/112: MESH.np
91/113:
def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.np)]
91/114: elems
91/115: grid.Allocate(MESH.nt, 1)
91/116:
import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.np)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())
91/117:

import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.np)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vku")
writer.SetInput(grid)
writer.Write()
91/118:

import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.np)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())
91/119: grid
91/120:
import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.np)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vku")
writer.SetInputData(grid)
writer.Write()
91/121:
import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.np)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
92/1:
import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.np)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
92/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/5: grid.SetFieldData
92/6: MESH.t[:,-1]
92/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/9:
import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

# GetPointData()->SetVectors(myvectors)
# grid.GetPointData.SetVectors(MESH.t[:,-1])
grid.GetCellData().AddArray(MESH.t[:,-1])

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
92/10:

import vtk
from vtk.util import numpy_support as nps

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

# GetPointData()->SetVectors(myvectors)
# grid.GetPointData.SetVectors(MESH.t[:,-1])
arr = nps.numpy_to_vtk(MESH.t[:,-1])
arr.SetName('foo')
grid.GetCellData().AddArray(arr)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
92/11: from vtk.util import numpy_support as nps
92/12: nps.numpy_to_vtk(MESH.t[:,-1])
92/13: numpy.int8
92/14: import numpy
92/15: numpy.bool
92/16: numpy.bool_
92/17: numpy.bool
92/18: MESH.t[:,-1]
92/19:

import vtk
from vtk.util import numpy_support as nps

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

# GetPointData()->SetVectors(myvectors)
# grid.GetPointData.SetVectors(MESH.t[:,-1])
arr = nps.numpy_to_vtk(MESH.t[:,-1])
arr.SetName('foo')
grid.GetCellData().AddArray(arr)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
92/20:
import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

# GetPointData()->SetVectors(myvectors)
# grid.GetPointData.SetVectors(MESH.t[:,-1])
grid.GetCellData().AddArray(MESH.t[:,-1])

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
92/21:

import vtk
from vtk.util import numpy_support as nps

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

# GetPointData()->SetVectors(myvectors)
# grid.GetPointData.SetVectors(MESH.t[:,-1])
arr = nps.numpy_to_vtk(MESH.t[:,-1])
arr.SetName('foo')
grid.GetCellData().AddArray(arr)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
92/22:
import vtk
from vtk.util import numpy_support as nps

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))


# for i in range(MESH.nt):

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)


# GetPointData()->SetVectors(myvectors)
# grid.GetPointData.SetVectors(MESH.t[:,-1])
# arr = nps.numpy_to_vtk(MESH.t[:,-1])
# arr.SetName('foo')
# grid.GetCellData().AddArray(arr)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
92/23: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/24: pdata
92/25: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/26: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/27:
interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(renderer_window)
interactor.Initialize()
interactor.Start()
92/28: grid
92/29: vtk.vtkVector3
92/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/31: np.sqrt(3)
92/32: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/33: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/34: J
92/35:

J1 = lambda x,y,z : np.c_[ 1+0*x, 0*y, 0*z]
J2 = lambda x,y,z : np.c_[ 0*x, 1+0*y, 0*z]
J3 = lambda x,y,z : np.c_[-1+0*x, 0*y, 0*z]
J4 = lambda x,y,z : np.c_[ 0*x,-1+0*y, 0*z]


J = lambda x,y,z : np.tile(((x<75)*(x>-75)*(y>-95)*(y<-75)),(3,1)).T*J1(x,y,z) +\
                   np.tile(((x<75)*(x>-75)*(y> 75)*(y< 95)),(3,1)).T*J3(x,y,z) +\
                   np.tile(((x<-75)*(x>-95)*(y<75)*(y>-75)),(3,1)).T*J4(x,y,z) +\
                   np.tile(((x> 75)*(x< 95)*(y<75)*(y>-75)),(3,1)).T*J2(x,y,z)
92/36: J
92/37: J(MESH.p[i,0],MESH.p[i,0],MESH.p[i,0])
92/38: J
92/39: MESH.p[i,0]
92/40: J(MESH.t[i,0],MESH.t[i,0],MESH.t[i,0])
92/41: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/42: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/43: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
92/44: Je[0]
92/45: J(MESH.t[i,0],MESH.t[i,0],MESH.t[i,0])
92/46: J(MESH.t[i,0],MESH.t[i,0],MESH.t[i,0])[0]
92/47:

import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())



scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)

vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)

for i in range(MESH.nt):
    Je = J(MESH.t[i,0],MESH.t[i,0],MESH.t[i,0])[0]
    print(Je)
    vec.InsertNextTuple([Je[0],Je[1],Je[2]])
pdata.SetVectors(vec)




writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
92/48: J
92/49: MESH.t[i,0]
92/50: MESH.t[:,0]
92/51: MESH.t[0,:]
92/52: MESH.mp
93/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/2: MESH.mp_tet
93/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/4: MESH.mp_tet
93/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/7: vec.SetName
93/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/10:

MESH.pdesurf(u_H1, faces = 'l_steel_face,r_steel_face,mid_steel_face,coil_face')
93/11:


J = lambda x,y,z : np.tile(((x<75)*(x>-75)*(y=>-100)*(y<-75)),(3,1)).T*J1(x,y,z) +\
                   np.tile(((x<75)*(x>-75)*(y> 75)*(y< 95)),(3,1)).T*J3(x,y,z) +\
                   np.tile(((x<-75)*(x>-95)*(y<75)*(y>-75)),(3,1)).T*J4(x,y,z) +\
                   np.tile(((x> 75)*(x< 95)*(y<75)*(y>-75)),(3,1)).T*J2(x,y,z)
93/12:


J = lambda x,y,z : np.tile(((x<75)*(x>-75)*(y>=-100)*(y<-75)),(3,1)).T*J1(x,y,z) +\
                   np.tile(((x<75)*(x>-75)*(y> 75)*(y< 95)),(3,1)).T*J3(x,y,z) +\
                   np.tile(((x<-75)*(x>-95)*(y<75)*(y>-75)),(3,1)).T*J4(x,y,z) +\
                   np.tile(((x> 75)*(x< 95)*(y<75)*(y>-75)),(3,1)).T*J2(x,y,z)
93/13: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/14: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/15: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/16: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/17: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/18: MESH.p.max()
93/19: MESH.p.min()
93/20: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/21: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
93/22: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/3: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/10: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/11: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/12: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/13: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/14: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/15: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/16: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/17: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/18: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/19: J
94/20: J(1,2,3)
94/21: J(1,2,3)[0]
94/22: J(1,2,3)[0,0]
94/23: J(1,2,3)[1,0]
94/24: J(1,2,3)[0,1]
94/25: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/26: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/27: J(x,y,z)
94/28: J(np.r_[0,2],np.r_[0,2],np.r_[0,2])
94/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
94/31: eJx
94/32: plt.plot(eJx)
94/33: import matplotlib.pyplot as plt
94/34: plt.plot(eJx)
95/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/2: MESH
95/3: eJx.shape
95/4:

eJx = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : J(x,y,z)[0,0], regions = 'coil').diagonal()
eJy = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : J(x,y,z)[0,1], regions = 'coil').diagonal()
eJz = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : J(x,y,z)[0,2], regions = 'coil').diagonal()
95/5: eJx.shape
95/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/8: J(x,y,z)
95/9: J(1,2,3)
95/10: J(1,2,3)[0]
95/11: J(np.r_[0,2],np.r_[0,2],np.r_[0,2])
95/12: J(np.r_[0,2],np.r_[0,2],np.r_[0,2])[0]
95/13: J(np.r_[0,2],np.r_[0,2],np.r_[0,2])[:0]
95/14: J(np.r_[0,2],np.r_[0,2],np.r_[0,2])[:]
95/15: J(np.r_[0,2],np.r_[0,2],np.r_[0,2])[:,0]
95/16: J(np.r_[0,2],np.r_[0,2],np.r_[0,2]).shape
95/17: J(np.r_[0,2],np.r_[0,2],np.r_[10,2]).
95/18: J(np.r_[0,2],np.r_[0,2],np.r_[10,2])
95/19: J(np.r_[0,2],np.r_[0,2],np.r_[10,2])[:,0]
95/20: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/21: KR
95/22: KR
95/23: chol(KR)
95/24: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/25: MESH
95/26: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/27: 2148*2
95/28: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/30: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/31: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/32: K_Hcurl
95/33: np.linalg.matrix_rank(K_Hcurl.A,tol=1e-15)
95/34: MESH
95/35: 2148-388
95/36: R
95/37:

r = Jx @ D @ phix_Hcurl.T +\
    Jy @ D @ phiy_Hcurl.T +\
    Jz @ D @ phiz_Hcurl.T
95/38:
eJx = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : J(x,y,z)[:,0], regions = 'coil').diagonal()
eJy = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : J(x,y,z)[:,1], regions = 'coil').diagonal()
eJz = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : J(x,y,z)[:,2], regions = 'coil').diagonal()


r = eJx @ D @ phix_Hcurl.T +\
    eJy @ D @ phiy_Hcurl.T +\
    eJz @ D @ phiz_Hcurl.T
95/39: eJx.shape
95/40: D.shape
95/41: order
95/42: eJx.shape
95/43: MESH
95/44: 6144/1536
95/45: D.shape
95/46: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/47: r.shape
95/48: K_Hcurl
95/49: R
95/50: R.T@r
95/51:

cholKR = chol(KR)
x = cholKR.solve_A(R.T@r)
x = R@x
95/52: x
95/53: x.shape
95/54: MESH
95/55:
ux = phix_Hcurl_P0.T @ x
uy = phiy_Hcurl_P0.T @ x
uz = phiz_Hcurl_P0.T @ x
95/56: ux
95/57: ux.shape
95/58: MESH
95/59: 93900/23475
95/60: phix_Hcurl_P0
95/61: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/62:


import time

tm = time.monotonic()

import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())



scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)




vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vec.InsertNextTuple([eJx[i],eJy[i],eJz[i]])
vec.SetName('omg')
pdata.SetVectors(vec)




vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    vec.InsertNextTuple([ux[i],uy[i],uz[i]])
vec.SetName('lel')
pdata.SetVectors(vec)


print('Time needed ... ',time.monotonic()-tm)

tm = time.monotonic()

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()

print('Time needed to write to file ... ',time.monotonic()-tm)
95/63: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/64: ux.max()
95/65: uy.max()
95/66: uz.max()
95/67: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/68: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/69: MESH
95/70: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/71: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/72:


import time

tm = time.monotonic()

import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())



scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)




vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    veJc.InsertNextTuple([eJx[i],eJy[i],eJz[i]])
vecJ.SetName('omg')
# pdata.SetVectors(vec)




vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    vec.InsertNextTuple([ux[i],uy[i],uz[i]])
vec.SetName('lel')
pdata.SetVectors(vec,vecJ)


print('Time needed ... ',time.monotonic()-tm)

tm = time.monotonic()

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()

print('Time needed to write to file ... ',time.monotonic()-tm)
95/73:


import time

tm = time.monotonic()

import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())



scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)




vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx[i],eJy[i],eJz[i]])
vecJ.SetName('omg')
# pdata.SetVectors(vec)




vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    vec.InsertNextTuple([ux[i],uy[i],uz[i]])
vec.SetName('lel')
pdata.SetVectors(vec,vecJ)


print('Time needed ... ',time.monotonic()-tm)

tm = time.monotonic()

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()

print('Time needed to write to file ... ',time.monotonic()-tm)
95/74: pdata.SetVectors([vec,vecJ])
95/75: pdata.AddArray
95/76: pdata.AddArray(vecJ)
95/77:


import time

tm = time.monotonic()

import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())



scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)




vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx[i],eJy[i],eJz[i]])
vecJ.SetName('omg')
# pdata.SetVectors(vec)
pdata.AddArray(vec)



vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    vec.InsertNextTuple([ux[i],uy[i],uz[i]])
vec.SetName('lel')
# pdata.SetVectors([vec,vecJ])
pdata.AddArray(vecJ)

print('Time needed ... ',time.monotonic()-tm)

tm = time.monotonic()

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()

print('Time needed to write to file ... ',time.monotonic()-tm)
95/78:



import time

tm = time.monotonic()

import vtk

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())



scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)




eJx0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : J(x,y,z)[:,0], regions = 'coil').diagonal()
eJy0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : J(x,y,z)[:,1], regions = 'coil').diagonal()
eJz0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : J(x,y,z)[:,2], regions = 'coil').diagonal()

vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx[i],eJy[i],eJz[i]])
vecJ.SetName('omg')
# pdata.SetVectors(vec)
pdata.AddArray(vec)



vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    vec.InsertNextTuple([ux[i],uy[i],uz[i]])
vec.SetName('lel')
# pdata.SetVectors([vec,vecJ])
pdata.AddArray(vecJ)

print('Time needed ... ',time.monotonic()-tm)

tm = time.monotonic()

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()

print('Time needed to write to file ... ',time.monotonic()-tm)
95/79:
C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T +\
             phiy_Hcurl @ D @ dphiy_H1.T
             phiz_Hcurl @ D @ dphiz_H1.T
95/80:

C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T +\
             phiy_Hcurl @ D @ dphiy_H1.T +\
             phiz_Hcurl @ D @ dphiz_H1.T
95/81: C_Hcurl_H1
95/82: bmat
95/83:
AA = bmat([[K_Hcurl, C_Hcurl_H1], 
           [C_Hcurl_H1.T, None]])
95/84:
M_Hcurl = phix_Hcurl @ D @ phix_Hcurl.T +\
          phiy_Hcurl @ D @ phiy_Hcurl.T +\
          phiz_Hcurl @ D @ phiz_Hcurl.T


K_Hcurl = curlphix_Hcurl @ D @ curlphix_Hcurl.T +\
          curlphiy_Hcurl @ D @ curlphiy_Hcurl.T +\
          curlphiz_Hcurl @ D @ curlphiz_Hcurl.T

C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T +\
             phiy_Hcurl @ D @ dphiy_H1.T +\
             phiz_Hcurl @ D @ dphiz_H1.T

from scipy.sparse import bmat

AA = bmat([[K_Hcurl, C_Hcurl_H1], 
           [C_Hcurl_H1.T, None]])
95/85: AA.shape
95/86: AA
95/87: plt.spy(AA,markersize=1)
95/88: import matplotlib.pyplot as plt
95/89: plt.spy(AA,markersize=1)
95/90: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
95/91: AA
95/92: np.linalg.matrix_rank(AA.A,tol=1e-15)
95/93: np.linalg.matrix_rank(AA.A,tol=1e-12)
98/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/3:
C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T +\
             phiy_Hcurl @ D @ dphiy_H1.T +\
             phiz_Hcurl @ D @ dphiz_H1.T
97/4: C_Hcurl_H1
97/5:
AA = bmat([[K_Hcurl, C_Hcurl_H1], 
           [C_Hcurl_H1.T, None]])
97/6: AA
97/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/8: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/10: C_Hcurl_H1
97/11: C_Hcurl_H1.shape
97/12: C_Hcurl_H1.shape
97/13: MESH
97/14: C_Hcurl_H1_eich[:,:-1]
97/15: C_Hcurl_H1[:,:-1]
97/16: C_Hcurl_H1_eich
97/17: C_Hcurl_H1_eich = C_Hcurl_H1[:,:-1]
97/18:
AA = bmat([[K_Hcurl, C_Hcurl_H1_eich], 
           [C_Hcurl_H1_eich.T, None]])
97/19: np.zeros(MESH.np-1)
97/20: bb = np.r_[r,np.zeros(MESH.np-1)]
97/21: bb.shape
97/22: AA.shape
97/23: xx = sp.linalg.solve(AA,bb)
97/24: xx = sp.solve(AA,bb)
97/25: xx = sp.linalg.solve(AA,bb)
97/26: xx = sp.linalg.spsolve(AA,bb)
97/27: xx
97/28: xx = np.r_[xx,0]
97/29: xx.shape
97/30: MESH
97/31: xx[:-MESH.nt].shape
97/32: MESH
97/33: xx[MESH.nt:-1]
97/34: xx[MESH.nt:-1]-shape
97/35: xx[MESH.nt:-1].shape
97/36: xx[-MESH.nt:].shape
97/37: MESH.nt
97/38: MESH.np
97/39: xx[-MESH.np:].shape
97/40: xx
97/41: xx[-MESH.np:]
97/42: xx[-MESH.np:].shape
97/43: xx[-MESH.np+1:].shape
97/44: dx_xx = phix_Hcurl.T@xx
97/45: dx_xx = dphix_H1_P0.T@xx
97/46: dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
97/47: dx_xx = dphix_H1_P0.T@xx
97/48: xx.shape
97/49: xx = xx[-MESH.np:]
97/50: xx.shape
97/51: dx_xx = dphix_H1_P0.T@xx
97/52: dx_xx.shape
97/53: eJx.shape
97/54: eJx0.shape
97/55: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/56: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/57: MESH
97/58:


tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

print('Time needed ... ',time.monotonic()-tm)



tm = time.monotonic()
scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)
print('Time needed ... ',time.monotonic()-tm)



tm = time.monotonic()
vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0[i],eJy0[i],eJz0[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)
print('Time needed ... ',time.monotonic()-tm)


tm = time.monotonic()
vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0_new[i],eJy0_new[i],eJz0_new[i]])
vecJ.SetName('omg2')
pdata.AddArray(vecJ)
print('Time needed ... ',time.monotonic()-tm)



tm = time.monotonic()
vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    vec.InsertNextTuple([ux[i],uy[i],uz[i]])
vec.SetName('lel')
# pdata.SetVectors([vec,vecJ])
pdata.AddArray(vecJ)
print('Time needed ... ',time.monotonic()-tm)



tm = time.monotonic()
writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
97/59:

tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

print('Time needed 1... ',time.monotonic()-tm)



tm = time.monotonic()
scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)
print('Time needed 2... ',time.monotonic()-tm)



tm = time.monotonic()
vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0[i],eJy0[i],eJz0[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)
print('Time needed ... ',time.monotonic()-tm)


tm = time.monotonic()
vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0_new[i],eJy0_new[i],eJz0_new[i]])
vecJ.SetName('omg2')
pdata.AddArray(vecJ)
print('Time needed 3... ',time.monotonic()-tm)



tm = time.monotonic()
vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    vec.InsertNextTuple([ux[i],uy[i],uz[i]])
vec.SetName('lel')
# pdata.SetVectors([vec,vecJ])
pdata.AddArray(vecJ)
print('Time needed 4... ',time.monotonic()-tm)



tm = time.monotonic()
writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
97/60:


tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np):
    points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems:
    grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

print('Time needed 1... ',time.monotonic()-tm)



tm = time.monotonic()
scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)
print('Time needed 2... ',time.monotonic()-tm)



tm = time.monotonic()
vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0[i],eJy0[i],eJz0[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)
print('Time needed 3... ',time.monotonic()-tm)


tm = time.monotonic()
vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0_new[i],eJy0_new[i],eJz0_new[i]])
vecJ.SetName('omg2')
pdata.AddArray(vecJ)
print('Time needed 4... ',time.monotonic()-tm)



tm = time.monotonic()
vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    vec.InsertNextTuple([ux[i],uy[i],uz[i]])
vec.SetName('lel')
# pdata.SetVectors([vec,vecJ])
pdata.AddArray(vecJ)
print('Time needed 5... ',time.monotonic()-tm)



tm = time.monotonic()
writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
97/61:

tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())
print('Time needed 1... ',time.monotonic()-tm)



tm = time.monotonic()
scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)
print('Time needed 2... ',time.monotonic()-tm)



tm = time.monotonic()
vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    # Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0[i],eJy0[i],eJz0[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)
print('Time needed 3... ',time.monotonic()-tm)


tm = time.monotonic()
vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    # Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0_new[i],eJy0_new[i],eJz0_new[i]])
vecJ.SetName('omg2')
pdata.AddArray(vecJ)
print('Time needed 4... ',time.monotonic()-tm)



tm = time.monotonic()
vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    vec.InsertNextTuple([ux[i],uy[i],uz[i]])
vec.SetName('lel')
# pdata.SetVectors([vec,vecJ])
pdata.AddArray(vecJ)
print('Time needed 5... ',time.monotonic()-tm)



tm = time.monotonic()
writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
97/62:

tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())



scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)



vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    # Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0[i],eJy0[i],eJz0[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    # Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0_new[i],eJy0_new[i],eJz0_new[i]])
vecJ.SetName('omg2')
pdata.AddArray(vecJ)



vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    vec.InsertNextTuple([ux[i],uy[i],uz[i]])
vec.SetName('lel')
# pdata.SetVectors([vec,vecJ])
pdata.AddArray(vecJ)


writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
97/63:

tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())



scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)



vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    # Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0[i],eJy0[i],eJz0[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(3)
for i in range(MESH.nt):
    # Je = J(MESH.mp_tet[i,0],MESH.mp_tet[i,1],MESH.mp_tet[i,2])[0]
    vecJ.InsertNextTuple([eJx0_new[i],eJy0_new[i],eJz0_new[i]])
vecJ.SetName('omg2')
pdata.AddArray(vecJ)



vec = vtk.vtkFloatArray()
vec.SetNumberOfComponents(3)
for i in range(MESH.nt):
    vec.InsertNextTuple([ux[i],uy[i],uz[i]])
vec.SetName('lel')
# pdata.SetVectors([vec,vecJ])
pdata.AddArray(vecJ)
print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vkt")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
97/64: unit_coil.shape
97/65: unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil').diagonal()
97/66: unit_coil.shape
97/67:

unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil').diagonal()

K_Hcurl_coil = curlphix_Hcurl @ D @ unit_coil @ curlphix_Hcurl.T +\
               curlphiy_Hcurl @ D @ unit_coil @ curlphiy_Hcurl.T +\
               curlphiz_Hcurl @ D @ unit_coil @ curlphiz_Hcurl.T
97/68: D
97/69: unit_coil
97/70:

unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

K_Hcurl_coil = curlphix_Hcurl @ D @ unit_coil @ curlphix_Hcurl.T +\
               curlphiy_Hcurl @ D @ unit_coil @ curlphiy_Hcurl.T +\
               curlphiz_Hcurl @ D @ unit_coil @ curlphiz_Hcurl.T
97/71: K_Hcurl_coil
97/72: plt
97/73: import matplotlib.pyplot as plt
97/74: plt.spy(K_Hcurl_coil)
97/75: K_Hcurl_coil.indptr
97/76: np.diff(K_Hcurl_coil.indptr) != 0
97/77: plt.plot(np.diff(K_Hcurl_coil.indptr) != 0)
97/78: K_Hcurl_coil.indptr
97/79: np.where(K_Hcurl_coil.indptr)
97/80: np.where(K_Hcurl_coil.indptr).shape
97/81: np.where(K_Hcurl_coil.indptr)[0].shape
97/82: K_Hcurl_coil
97/83: np.where(K_Hcurl_coil.indptr!=0)[0].shape
97/84: np.where(K_Hcurl_coil.indptr!=0).shape
97/85: np.where(K_Hcurl_coil.indptr==0)[0].shape
97/86: K_Hcurl_coil
97/87: np.diff
97/88: non_zero_rows = np.where((np.diff(K_Hcurl_coil.indptr) != 0))
97/89: non_zero_rows
97/90: non_zero_rows.shape
97/91: non_zero_rows[0].shape
97/92: MESH
97/93: K_Hcurl_coil = K_Hcurl_coil_full[non_zero_rows,non_zero_rows]
97/94:
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

K_Hcurl_coil_full = curlphix_Hcurl @ D @ unit_coil @ curlphix_Hcurl.T +\
                    curlphiy_Hcurl @ D @ unit_coil @ curlphiy_Hcurl.T +\
                    curlphiz_Hcurl @ D @ unit_coil @ curlphiz_Hcurl.T

non_zero_rows = np.where((np.diff(K_Hcurl_coil.indptr) != 0))

K_Hcurl_coil = K_Hcurl_coil_full[non_zero_rows,non_zero_rows]
97/95: K_Hcurl_coil
97/96: non_zero_rows
97/97:
K_Hcurl_coil_full = curlphix_Hcurl @ D @ unit_coil @ curlphix_Hcurl.T +\
                    curlphiy_Hcurl @ D @ unit_coil @ curlphiy_Hcurl.T +\
                    curlphiz_Hcurl @ D @ unit_coil @ curlphiz_Hcurl.T

non_zero_rows = np.where((np.diff(K_Hcurl_coil.indptr) != 0))[0]

K_Hcurl_coil = K_Hcurl_coil_full[non_zero_rows,non_zero_rows]
97/98: K_Hcurl_coil
97/99: K_Hcurl_coil_full
97/100: K_Hcurl_coil_full[non_zero_rows,non_zero_rows]
97/101:
K_Hcurl_coil_full = curlphix_Hcurl @ D @ unit_coil @ curlphix_Hcurl.T +\
                    curlphiy_Hcurl @ D @ unit_coil @ curlphiy_Hcurl.T +\
                    curlphiz_Hcurl @ D @ unit_coil @ curlphiz_Hcurl.T

non_zero_rows = np.where((np.diff(K_Hcurl_coil.indptr) != 0))[0]

K_Hcurl_coil = K_Hcurl_coil_full[:,non_zero_rows]
K_Hcurl_coil = K_Hcurl_coil[non_zero_rows,:]
97/102: K_Hcurl_coil
97/103: K_Hcurl_coil_full
97/104: non_zero_rows
97/105: K_Hcurl_coil_full
97/106: K_Hcurl_coil = K_Hcurl_coil_full[:,non_zero_rows]
97/107: K_Hcurl_coil
97/108: K_Hcurl_coil[non_zero_rows,:]
97/109: K_Hcurl_coil = K_Hcurl_coil[non_zero_rows,:]
97/110: K_Hcurl_coil
97/111:
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

K_Hcurl_coil_full = curlphix_Hcurl @ D @ unit_coil @ curlphix_Hcurl.T +\
                    curlphiy_Hcurl @ D @ unit_coil @ curlphiy_Hcurl.T +\
                    curlphiz_Hcurl @ D @ unit_coil @ curlphiz_Hcurl.T

non_zero_rows = np.where((np.diff(K_Hcurl_coil.indptr) != 0))[0]

K_Hcurl_coil = K_Hcurl_coil_full[:,non_zero_rows]
K_Hcurl_coil = K_Hcurl_coil[non_zero_rows,:]
97/112: K_Hcurl_coil
97/113: K_Hcurl_coil_full
97/114: non_zero_rows.shape
97/115: unit_coil
97/116: unit_coil.shape
97/117: K_Hcurl_coil
97/118: K_Hcurl_coil_full
97/119:

unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

K_Hcurl_coil_full = curlphix_Hcurl @ D @ unit_coil @ curlphix_Hcurl.T +\
                    curlphiy_Hcurl @ D @ unit_coil @ curlphiy_Hcurl.T +\
                    curlphiz_Hcurl @ D @ unit_coil @ curlphiz_Hcurl.T

non_zero_rows = np.where((np.diff(K_Hcurl_coil_full.indptr) != 0))[0]

K_Hcurl_coil = K_Hcurl_coil_full[:,non_zero_rows]
K_Hcurl_coil = K_Hcurl_coil[non_zero_rows,:]
97/120: K_Hcurl_coil
97/121: K_Hcurl_coil_full
97/122: plt.spy(K_Hcurl_coil_full,markersize=1)
97/123: plt.spy(K_Hcurl_coil,markersize=1)
97/124: np.linalg.matrix_rank(K_Hcurl_coil.A,tol=1e-12)
97/125: K_Hcurl_coil
97/126:
C_Hcurl_H1 = phix_Hcurl @ D @ unit_coil @ dphix_H1.T +\
             phiy_Hcurl @ D @ unit_coil @ dphiy_H1.T +\
             phiz_Hcurl @ D @ unit_coil @ dphiz_H1.T
97/127: C_Hcurl_H1
97/128: plt.spy(unit_coil @,markersize=1)
97/129: plt.spy(C_Hcurl_H1,markersize=1)
97/130: C_Hcurl_H1_coil = C_Hcurl_H1_coil_full[:,non_zero_rows]
97/131:
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

K_Hcurl_coil_full = curlphix_Hcurl @ D @ unit_coil @ curlphix_Hcurl.T +\
                    curlphiy_Hcurl @ D @ unit_coil @ curlphiy_Hcurl.T +\
                    curlphiz_Hcurl @ D @ unit_coil @ curlphiz_Hcurl.T

C_Hcurl_H1_coil_full = phix_Hcurl @ D @ unit_coil @ dphix_H1.T +\
                       phiy_Hcurl @ D @ unit_coil @ dphiy_H1.T +\
                       phiz_Hcurl @ D @ unit_coil @ dphiz_H1.T

non_zero_rows = np.where((np.diff(K_Hcurl_coil_full.indptr) != 0))[0]

K_Hcurl_coil = K_Hcurl_coil_full[:,non_zero_rows]
K_Hcurl_coil = K_Hcurl_coil[non_zero_rows,:]

C_Hcurl_H1_coil = C_Hcurl_H1_coil_full[:,non_zero_rows]
97/132:


unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

K_Hcurl_coil_full = curlphix_Hcurl @ D @ unit_coil @ curlphix_Hcurl.T +\
                    curlphiy_Hcurl @ D @ unit_coil @ curlphiy_Hcurl.T +\
                    curlphiz_Hcurl @ D @ unit_coil @ curlphiz_Hcurl.T

C_Hcurl_H1_coil_full = phix_Hcurl @ D @ unit_coil @ dphix_H1.T +\
                       phiy_Hcurl @ D @ unit_coil @ dphiy_H1.T +\
                       phiz_Hcurl @ D @ unit_coil @ dphiz_H1.T

non_zero_rows = np.where((np.diff(K_Hcurl_coil_full.indptr) != 0))[0]

K_Hcurl_coil = K_Hcurl_coil_full[:,non_zero_rows]
K_Hcurl_coil = K_Hcurl_coil[non_zero_rows,:]

C_Hcurl_H1_coil = C_Hcurl_H1_coil_full[non_zero_rows,:]
97/133: C_Hcurl_H1_coil
97/134: plt.spy(C_Hcurl_H1,markersize=1)
97/135: plt.spy(C_Hcurl_H1_coil,markersize=1)
97/136:
non_zero_rows_K = np.where((np.diff(K_Hcurl_coil_full.indptr) != 0))[0]
non_zero_rows_C = np.where((np.diff(C_Hcurl_H1_coil_full.indptr) != 0))[0]
97/137: non_zero_rows_K
97/138: non_zero_rows_C
97/139: non_zero_rows_C.shape
97/140:


unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

K_Hcurl_coil_full = curlphix_Hcurl @ D @ unit_coil @ curlphix_Hcurl.T +\
                    curlphiy_Hcurl @ D @ unit_coil @ curlphiy_Hcurl.T +\
                    curlphiz_Hcurl @ D @ unit_coil @ curlphiz_Hcurl.T

C_Hcurl_H1_coil_full = phix_Hcurl @ D @ unit_coil @ dphix_H1.T +\
                       phiy_Hcurl @ D @ unit_coil @ dphiy_H1.T +\
                       phiz_Hcurl @ D @ unit_coil @ dphiz_H1.T

non_zero_rows_K = np.where((np.diff(K_Hcurl_coil_full.indptr) != 0))[0]
non_zero_rows_C = np.where((np.diff(C_Hcurl_H1_coil_full.indptr) != 0))[0]

K_Hcurl_coil = K_Hcurl_coil_full[:,non_zero_rows_K]
K_Hcurl_coil = K_Hcurl_coil[non_zero_rows_K,:]

C_Hcurl_H1_coil = C_Hcurl_H1_coil_full[non_zero_rows_K,:]
C_Hcurl_H1_coil = C_Hcurl_H1_coil[:,non_zero_rows_C]
97/141: C_Hcurl_H1_coil
97/142: plt.spy(C_Hcurl_H1_coil)
97/143: plt.spy(C_Hcurl_H1_coil,markersize=1)
97/144:
AA = bmat([[K_Hcurl_coil, C_Hcurl_H1_coil], 
           [C_Hcurl_H1_coil.T, None]]).tocsc()
97/145: AA
97/146: AA.shape
97/147: C_Hcurl_H1_coil
97/148: C_Hcurl_H1_coil_full
97/149: AA
97/150: np.linalg.matrix_rank(AA.A,tol=1e-12)
97/151: np.linalg.matrix_rank(AA.A,tol=1e-14)
97/152: pde.hdiv.assemble3
97/153: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/154: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/155: MESH
97/156: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/157: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/158: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/159: 54*3
97/160: 54*3+62*2
97/161: 54*3+62*3
97/162: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/163: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/164: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/165: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/166: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/167: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/168: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/169: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/170: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/171: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/172: A = sp.csr_matrix((vals,(rows,cols)))
97/173: A
97/174: np.linalg.matrix_rank(A.A,tol=1e-14)
97/175: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/176: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/177: A
97/178: np.linalg.matrix_rank(A.A,tol=1e-14)
97/179: 1760+389-1
97/180: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/181: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/182: geoOCC
97/183: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/184: A
97/185: K_Hcurl
97/186: import matplotlib.pyplot as plt
97/187: plt.spy(A,markersize=1)
97/188: bfa
97/189: bfa.space
97/190: bfa.mat
97/191: bfa.mat.Vec()
97/192: bfa.mat.FV
97/193: bfa.mat.FV()
97/194: bfa.mat.NumPy()
97/195: bfa.mat
97/196: __dict(bfa.mat)
97/197: __dict__(bfa.mat)
97/198: bfa.mat.__dict__
97/199: bfa.mat.COO()
97/200: plt.spy(K_Hcurl,markersize=1)
97/201: plt.spy(K_Hcurl,markersize=1)
97/202: plt.figure()
97/203: plt.spy(A,markersize=1)
97/204: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/205: A
97/206: K_Hcurl
97/207: A.shape
97/208: A-K_Hcurl
97/209: (A-K_Hcurl).max()
97/210: (A-K_Hcurl).min()
97/211: A
97/212: K_Hcurl
97/213:

lam[0] = lambda x,y,z : 1-x-y-z
lam[1] = lambda x,y,z : x
lam[2] = lambda x,y,z : y
lam[3] = lambda x,y,z : z
97/214: lam
97/215:

lam = []
lam[0] = lambda x,y,z : 1-x-y-z
lam[1] = lambda x,y,z : x
lam[2] = lambda x,y,z : y
lam[3] = lambda x,y,z : z
97/216: lam = []
97/217: lam
97/218: lam[0] = lambda x,y,z : 1-x-y-z
97/219:
lam = {}
lam[0] = lambda x,y,z : 1-x-y-z
lam[1] = lambda x,y,z : x
lam[2] = lambda x,y,z : y
lam[3] = lambda x,y,z : z
97/220: lam
97/221: np.choose
97/222: MESH.t
97/223: MESH.FacesToVertices
97/224:
lam = {}
lam[0] = lambda x,y,z : 1-x-y-z
lam[1] = lambda x,y,z : x
lam[2] = lambda x,y,z : y
lam[3] = lambda x,y,z : z

Dlam = {}
Dlam[0] = lambda x,y,z : np.r_[-1,-1,-1]
Dlam[1] = lambda x,y,z : np.r_[ 1, 0, 0]
Dlam[2] = lambda x,y,z : np.r_[ 0, 1, 0]
Dlam[3] = lambda x,y,z : np.r_[ 0, 0, 1]

W2 = lambda i,j,k,x,y,z : lam[i]*np.cross(Dlam[j](x,y,z),Dlam[k](x,y,z))+\
                          lam[j]*np.cross(Dlam[k](x,y,z),Dlam[i](x,y,z))+\
                          lam[k]*np.cross(Dlam[i](x,y,z),Dlam[j](x,y,z))
97/225: W2(0,1,2,1,1,1)
97/226:
lam = {}
lam[0] = lambda x,y,z : 1-x-y-z
lam[1] = lambda x,y,z : x
lam[2] = lambda x,y,z : y
lam[3] = lambda x,y,z : z

Dlam = {}
Dlam[0] = lambda x,y,z : np.r_[-1,-1,-1]
Dlam[1] = lambda x,y,z : np.r_[ 1, 0, 0]
Dlam[2] = lambda x,y,z : np.r_[ 0, 1, 0]
Dlam[3] = lambda x,y,z : np.r_[ 0, 0, 1]

W2 = lambda i,j,k,x,y,z : lam[i](x,y,z)*np.cross(Dlam[j](x,y,z),Dlam[k](x,y,z))+\
                          lam[j](x,y,z)*np.cross(Dlam[k](x,y,z),Dlam[i](x,y,z))+\
                          lam[k](x,y,z)*np.cross(Dlam[i](x,y,z),Dlam[j](x,y,z))
97/227: W2(0,1,2,1,1,1)
97/228: W2(1,2,3,1,1,1)
97/229: W2(1,2,3,2,2,2)
97/230: W2(1,2,3,1,1,1)
97/231: W2(0,2,3,1,1,1)
97/232: W2(0,2,3,0,1,1)
97/233: W2(0,2,3,1,1,1)
97/234: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/235: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/236: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
97/237:
fespot = H1(mesh, order=3, definedon="coil", dirichlet="out")
phi,psi = fespot.TnT()
sigma = 58.7e6
bfa = BilinearForm(sigma*grad(phi)*grad(psi)*dx).Assemble()
inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
gfphi = GridFunction(fespot)
gfphi.vec.data = inv * lff.vec
99/1: gfphi
99/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
99/3: gfphi
99/4: gfphi.vec
99/5: gfphi.vec.data
99/6: gfphi.vec.NumPy()
99/7: gfphi.vec
99/8: gfphi.vec.data
99/9: gfphi.vec.data.vec
99/10: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
99/11:



MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################
99/12: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
99/13: MESH = pde.mesh3.netgen(geoOCCmesh)
99/14: MESH = pde.mesh3.netgen(mesh)
99/15:

geo = OCCGeometry(Glue([coil,air]))
with TaskManager():
    geoOCCmesh = geo.GenerateMesh(meshsize.coarse, maxh=0.01)
    mesh = Mesh(geoOCCmesh)#.Curve(3)
99/16: MESH = pde.mesh3.netgen(geoOCCmesh)
99/17: MESH
99/18:

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')

M = phi_H1 @ D @ phi_H1.T

K = dphix_H1 @ D @ dphix_H1.T +\
    dphiy_H1 @ D @ dphiy_H1.T +\
    dphiz_H1 @ D @ dphiz_H1.T
99/19:

order = 2

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')

M = phi_H1 @ D @ phi_H1.T

K = dphix_H1 @ D @ dphix_H1.T +\
    dphiy_H1 @ D @ dphiy_H1.T +\
    dphiz_H1 @ D @ dphiz_H1.T
99/20: M
99/21: K
99/22: unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
99/23: unit_coil
99/24: unit_coil
99/25: unit_coil.max()
99/26: unit_coil.min()
99/27:


M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T
99/28: plt
99/29: import matplotlib.pyplot as plt
99/30: plt.spy(M,markersize=1)
99/31: unit_coil
99/32: unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil').diagonal()
99/33: unit_coil
99/34: getIndices(MESH.regions_3d,regions)
99/35: getIndices(MESH.regions_3d,'coil')
99/36: pde.tools.getIndices(MESH.regions_3d,'coil')
99/37:
aa = pde.tools.getIndices(MESH.regions_3d,'coil')
indices = npy.in1d(MESH.t[:,-1],aa)
99/38:
aa = pde.tools.getIndices(MESH.regions_3d,'coil')
indices = np.in1d(MESH.t[:,-1],aa)
99/39: import numpy as np
99/40:
aa = pde.tools.getIndices(MESH.regions_3d,'coil')
indices = np.in1d(MESH.t[:,-1],aa)
99/41: indices
99/42:
aa = pde.tools.getIndices(MESH.regions_3d,'coil')
indices = np.in1d(MESH.t[:,-1],aa)
D = sp.eye(sizeM, format = 'csc')
R1 = D[:,indices]
99/43: import scipy.sparse as sp
99/44:
aa = pde.tools.getIndices(MESH.regions_3d,'coil')
indices = np.in1d(MESH.t[:,-1],aa)
D = sp.eye(sizeM, format = 'csc')
R1 = D[:,indices]
99/45:
aa = pde.tools.getIndices(MESH.regions_3d,'coil')
indices = np.in1d(MESH.t[:,-1],aa)
D = sp.eye(MESH.np, format = 'csc')
R1 = D[:,indices]
99/46: indices
99/47: indices.shape
99/48: MESH.np
99/49:
order = 2

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')


unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil').diagonal()
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')


M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

M,nz_indices = removeZeros(M)
K, = removeZeros(K)


# Draw (mesh, clipping={"y":1, "z":0, "dist":0.012});


# fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
# phi,psi = fespot.TnT()
# sigma = 58.7e6
# bfa = BilinearForm(sigma*grad(phi)*grad(psi)*dx).Assemble()
# inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
# lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
# gfphi = GridFunction(fespot)
# gfphi.vec.data = inv * lff.vec


# Draw (gfphi, draw_vol=False, clipping={"y":1, "z":0, "dist":0.012});



def removeZeros(A):
    indices = np.where((np.diff(A.indptr) != 0))[0]
    Anz = A[:,indices]
    Anz = Anz[indices,:]
    return Anz,indices
99/50:


unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')


M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

M,nz_indices = removeZeros(M)
K, = removeZeros(K)


# Draw (mesh, clipping={"y":1, "z":0, "dist":0.012});


# fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
# phi,psi = fespot.TnT()
# sigma = 58.7e6
# bfa = BilinearForm(sigma*grad(phi)*grad(psi)*dx).Assemble()
# inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
# lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
# gfphi = GridFunction(fespot)
# gfphi.vec.data = inv * lff.vec


# Draw (gfphi, draw_vol=False, clipping={"y":1, "z":0, "dist":0.012});



def removeZeros(A):
    indices = np.where((np.diff(A.indptr) != 0))[0]
    Anz = A[:,indices]
    Anz = Anz[indices,:]
    return Anz,indices
99/51:
def removeZeros(A):
    indices = np.where((np.diff(A.indptr) != 0))[0]
    Anz = A[:,indices]
    Anz = Anz[indices,:]
    return Anz,indices
99/52:

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

M,nz_indices = removeZeros(M)
K, = removeZeros(K)
99/53: K = removeZeros(K)
99/54: K
99/55: K.shape
99/56: M
99/57: K = removeZeros(K)[0]
99/58:

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

M,nz_indices = removeZeros(M)
K = removeZeros(K)[0]
99/59: K
99/60: M
99/61: plt.spy(M,markersize=1)
99/62: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
99/63:



def removeZeros(A):
    indices = np.where((np.diff(A.indptr) != 0))[0]
    Anz = A[:,indices]
    Anz = Anz[indices,:]
    return Anz,indices

###########################################################################
MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################

order = 2

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')


unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')


M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

M,nz_indices = removeZeros(M)
K = removeZeros(K)[0]


# Draw (mesh, clipping={"y":1, "z":0, "dist":0.012});


# fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
# phi,psi = fespot.TnT()
# sigma = 58.7e6
# bfa = BilinearForm(sigma*grad(phi)*grad(psi)*dx).Assemble()
# inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
# lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
# gfphi = GridFunction(fespot)
# gfphi.vec.data = inv * lff.vec


# Draw (gfphi, draw_vol=False, clipping={"y":1, "z":0, "dist":0.012});
99/64: M
99/65: K
99/66: np.linalg.matrix_rank(M.A,tol=1e-14)
99/67: chol(K)
99/68: from sksparse.cholmod import cholesky as chol
99/69: chol(K)
99/70: chol(M)
99/71:

MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################

order = 2
phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')


unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

M,nz_indices = removeZeros(M)
K = removeZeros(K)[0]

###########################################################################


# Draw (mesh, clipping={"y":1, "z":0, "dist":0.012});


fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
phi,psi = fespot.TnT()
# sigma = 58.7e6
bfa = BilinearForm(sigma*grad(phi)*grad(psi)*dx).Assemble()
# inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
# lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
# gfphi = GridFunction(fespot)
# gfphi.vec.data = inv * lff.vec
rows,cols,vals = bfa.mat.COO()
A = sp.csr_matrix((vals,(rows,cols)))

# Draw (gfphi, draw_vol=False, clipping={"y":1, "z":0, "dist":0.012});
99/72: K
99/73: A
99/74: MESH
99/75:
fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
phi,psi = fespot.TnT()
# sigma = 58.7e6
bfa = BilinearForm(grad(phi)*grad(psi)*dx).Assemble()
# inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
# lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
# gfphi = GridFunction(fespot)
# gfphi.vec.data = inv * lff.vec
rows,cols,vals = bfa.mat.COO()
A = sp.csr_matrix((vals,(rows,cols)))
99/76: A
99/77: MESH
99/78: plt.spy(A,markersize=1)
99/79: plt.spy(K,markersize=1)
99/80:

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T
99/81: plt.spy(K,markersize=1)
99/82: K = removeZeros(K)[0]
99/83: plt.spy(K,markersize=1)
99/84: bfa.FreeDofs()
99/85:


MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################

order = 2
phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')


unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

M,nz_indices = removeZeros(M)
# K = removeZeros(K)[0]

###########################################################################


# Draw (mesh, clipping={"y":1, "z":0, "dist":0.012});


fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
phi,psi = fespot.TnT()
# sigma = 58.7e6
bfa = BilinearForm(grad(phi)*grad(psi)*dx).Assemble()
# inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
# lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
# gfphi = GridFunction(fespot)
# gfphi.vec.data = inv * lff.vec
rows,cols,vals = bfa.mat.COO()
A = sp.csr_matrix((vals,(rows,cols)))

# Draw (gfphi, draw_vol=False, clipping={"y":1, "z":0, "dist":0.012});
99/86: A-K
99/87: (A-K).max()
99/88: (A-K).min()
99/89: sigma = 58.7e6
99/90: fespot.FreeDofs()
99/91: fespot.FreeDofs().index
99/92: fespot.FreeDofs()
99/93: indices
99/94: indices.shape
99/95:
M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T
99/96: M.shape
99/97: crosssection
99/98: MESH.f
99/99: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
99/100: MESH.Bx
99/101: MESH.JB00(1,1)
99/102: MESH.JB00
99/103: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
99/104:

phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)
99/105: phiB_H1
99/106: phiB_H1.shape
99/107: DB = pde.int.assemble3(MESH, order = order)
99/108: DB
99/109: DB.shape
99/110: das = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in')
99/111: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
100/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
100/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
101/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
101/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
101/3: das = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in')
101/4: das = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in')
101/5: MESH.Bx(qp[0,i],qp[1,i])
101/6: qp, we = pde.quadrature.dunavant(2)
101/7: MESH.Bx(qp[0,i],qp[1,i])
101/8: MESH.Bx(qp[0,2],qp[1,2])
101/9: MESH.Bx(qp[0,2],qp[1,2]).shape
101/10: indices
101/11: das = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in')
101/12: MESH.Bx(qp[0,i],qp[1,i])
101/13: MESH.Bx(qp[0,2],qp[1,2]).shape
101/14: das = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in')
101/15: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
101/16: das = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in')
101/17: das = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in')
101/18: das = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in')
101/19: debugfile('C:/Users/Radu/Documents/GitHub/fem/pde/int/assemble3.py', wdir='C:/Users/Radu/Documents/GitHub/fem/pde/int')
101/20: debugfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
101/21: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
101/22: das
101/23: r = unit_face_in @ DB @ phiB_H1.T
101/24:
unit_face_in = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in')

r = unit_face_in @ DB @ phiB_H1.T
101/25: unit_face_in
101/26:
unit_face_in = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in').diagonal()

r = unit_face_in @ DB @ phiB_H1.T
101/27: eJz = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : J(x,y,z)[:,2], regions = 'coil').diagonal()
101/28: unit_face_in.shape()
101/29: unit_face_in.shape
101/30: DB.shape
101/31: phiB_H1.shape
101/32: DB = pde.int.assembleB3(MESH, order = order)
101/33: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
101/34: unit_face_in
101/35: unit_face_in.shape
101/36: DB.shape
101/37: phiB_H1.T.shape
101/38: r
101/39: r.shape
101/40: MESH
101/41:

face_in  = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in').diagonal()
face_out = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 2+0*x, faces = 'in').diagonal()

r = (face_in + face_out) @ DB @ phiB_H1.T
101/42:
face_in  = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in').diagonal()
face_out = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 2+0*x, faces = 'in').diagonal()

r = (face_in + face_out) @ DB @ phiB_H1.T
101/43: r
101/44: r = r[nz_indices]
101/45: r.shape
101/46: x = chol(K).solve_A(r)
101/47:

xx = np.zeros(MESH.np)
xx[nz_indices] = x
101/48: xx
101/49:






tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)




vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    vecJ.InsertNextTuple([xx[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
101/50:





import time
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)




vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    vecJ.InsertNextTuple([xx[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
101/51:






import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)




vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    vecJ.InsertNextTuple([xx[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
101/52:





import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)


pdata = grid.GetPointData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.np)
for i,p in enumerate(scalars): data.SetValue(i,xx[i])
pdata.SetScalars(data)


# vecJ = vtk.vtkFloatArray()
# vecJ.SetNumberOfComponents(1)
# for i in range(MESH.np):
#     vecJ.InsertNextTuple([xx[i]])
# vecJ.SetName('omg')
# pdata.AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
101/53: xx.shape
101/54: MESH
101/55:






import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)


pdata = grid.GetPointData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.np)
for i,p in enumerate(xx): data.SetValue(i,xx[i])
pdata.SetScalars(data)


# vecJ = vtk.vtkFloatArray()
# vecJ.SetNumberOfComponents(1)
# for i in range(MESH.np):
#     vecJ.InsertNextTuple([xx[i]])
# vecJ.SetName('omg')
# pdata.AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
101/56: xx
101/57: xx.shape
101/58: xx.max()
101/59: xx.min()
101/60: crosssection
101/61: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
101/62:

vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    vecJ.InsertNextTuple([xx[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)
101/63:






import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)


# pdata = grid.GetPointData()
# data = vtk.vtkDoubleArray()
# data.SetNumberOfValues(MESH.np)
# for i,p in enumerate(xx): data.SetValue(i,xx[i])
# pdata.SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    vecJ.InsertNextTuple([xx[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
101/64: vecJ
101/65: xx
101/66: xx.shape
101/67: xx.min()
101/68: xx.max()
101/69: x = chol(K).solve_A(r)
101/70: xx
101/71: x
101/72: plt.plot(x)
101/73: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
101/74: x
101/75: plt.plot(x)
101/76: r
101/77: plt.plot(r)
101/78: crosssection
101/79: plt.plot(face_in)
101/80: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
101/81: plt.plot(x)
101/82: x
101/83: lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
101/84: lff.mat
101/85: lff.vec
101/86: lff.vec.NumPy()
101/87: lff
101/88: lff.FV()
101/89: lff.vec.FV()
101/90: lff.vec.FV().NumPy()
101/91: plt.plot(r)
101/92:
M,nz_indices = removeZeros(M)
K = removeZeros(K)[0]

r = r[nz_indices]


x = chol(K).solve_A(r)

xx = np.zeros(MESH.np)
xx[nz_indices] = x

###########################################################################


# Draw (mesh, clipping={"y":1, "z":0, "dist":0.012});


fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
phi,psi = fespot.TnT()
# sigma = 58.7e6
bfa = BilinearForm(grad(phi)*grad(psi)*dx).Assemble()
# inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
# gfphi = GridFunction(fespot)
# gfphi.vec.data = inv * lff.vec
rows,cols,vals = bfa.mat.COO()
A = sp.csr_matrix((vals,(rows,cols)))

r2 = lff.vec.FV().NumPy()
101/93: plt.plot(r)
101/94: plt.plot(r2)
101/95: r-r2
101/96:


MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################

order = 2
phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)


phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)
DB = pde.int.assembleB3(MESH, order = order)

face_in  = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1/crosssection+0*x, faces = 'in').diagonal()
face_out = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 0+0*x, faces = 'out').diagonal()

r = (face_in + face_out) @ DB @ phiB_H1.T


unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

M,nz_indices = removeZeros(M)
K = removeZeros(K)[0]

r1 = r.copy()
r = r[nz_indices]


x = chol(K).solve_A(r)

xx = np.zeros(MESH.np)
xx[nz_indices] = x

###########################################################################


# Draw (mesh, clipping={"y":1, "z":0, "dist":0.012});


fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
phi,psi = fespot.TnT()
# sigma = 58.7e6
bfa = BilinearForm(grad(phi)*grad(psi)*dx).Assemble()
# inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
# gfphi = GridFunction(fespot)
# gfphi.vec.data = inv * lff.vec
rows,cols,vals = bfa.mat.COO()
A = sp.csr_matrix((vals,(rows,cols)))

r2 = lff.vec.FV().NumPy()


# Draw (gfphi, draw_vol=False, clipping={"y":1, "z":0, "dist":0.012});

###########################################################################
101/97: r
101/98: r.shape
101/99: r1.shape
101/100: r2.shape
101/101: r1
101/102: r2
101/103: r1-r2
101/104: plt.plot(r1-r2)
101/105:


fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
phi,psi = fespot.TnT()
# sigma = 58.7e6
bfa = BilinearForm(grad(phi)*grad(psi)*dx).Assemble()
# inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
gfphi = GridFunction(fespot)
gfphi.vec.data = inv * lff.vec
rows,cols,vals = bfa.mat.COO()
A = sp.csr_matrix((vals,(rows,cols)))

r2 = lff.vec.FV().NumPy()
gfphi = gfphi.vec.FV().NumPy()
101/106:





fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
phi,psi = fespot.TnT()
# sigma = 58.7e6
bfa = BilinearForm(grad(phi)*grad(psi)*dx).Assemble()
inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
gfphi = GridFunction(fespot)
gfphi.vec.data = inv * lff.vec
rows,cols,vals = bfa.mat.COO()
A = sp.csr_matrix((vals,(rows,cols)))

r2 = lff.vec.FV().NumPy()
gfphi = gfphi.vec.FV().NumPy()
101/107: gfphi
101/108: xx
101/109: x
101/110: A
101/111: A
101/112: K
101/113: r1
101/114: r2
101/115: r1-r2
101/116: (r1-r2).shape
101/117: x
101/118: x.shape
101/119: x.max()
101/120: x.min()
101/121: K
101/122: K
101/123: np.linalg.matrix_rank(K.A,tol=1e-14)
102/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/3: K
102/4: K.shape
102/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/6: K
102/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/8: K
102/9: nz_indices
102/10: nz_indices.shape
102/11: R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'out')
102/12: R0
102/13: RSS
102/14: K = RSS @ K @ RSS.T
102/15: K = RSS.T @ K @ RSS
102/16: R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'out')
102/17: K = RSS.T @ K @ RSS
102/18: K = RSS @ K @ RSS.T
102/19: RSS
102/20: K
102/21:

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

K = RSS @ K @ RSS.T
102/22: K
102/23: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/24: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/25: RSS@r
102/26: (RSS@r).shape
102/27: K
102/28: nz_indices
102/29: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/30: xx
102/31: gphi
102/32: gphii
102/33: gfphi
102/34: plt.plot(gfphi)
102/35: plt.plot(xx)
102/36: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/37: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/38: xx
102/39: gphi
102/40: gfphi
102/41: xx
102/42: plot(xx)
102/43: plt.plot(xx)
102/44: plt.plot(gfphi)
102/45:
M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

K = RSS @ K @ RSS.T
M = RSS @ M @ RSS.T

M,nz_indices = removeZeros(M)
K = removeZeros(K)[0]

r1 = r.copy()
r = (RSS@r)[nz_indices]


x = chol(sigma*K).solve_A(r)
x = RSS.T@r

xx = np.zeros(MESH.np)
xx[nz_indices] = x
102/46:
r = face_in @ DB @ phiB_H1.T


unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

K = RSS @ K @ RSS.T
M = RSS @ M @ RSS.T

M,nz_indices = removeZeros(M)
K = removeZeros(K)[0]

r1 = r.copy()
r = (RSS@r)[nz_indices]


x = chol(sigma*K).solve_A(r)
x = RSS.T@r

xx = np.zeros(MESH.np)
xx[nz_indices] = x
102/47: r.shape
102/48: RSS
102/49:

face_in  = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1/crosssection, faces = 'in').diagonal()
102/50: indices
102/51: indices = np.where((np.diff(K.indptr) != 0))[0]
102/52: indices
102/53:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T
102/54: K
102/55: indices = np.where((np.diff(K.indptr) != 0))[0]
102/56: indices
102/57: indices.shape
102/58: D = sp.eye(A.shape, format = 'csc')
102/59: A
102/60: D = sp.eye(A.shape, format = 'csc')
102/61: D = sp.eye(A.size, format = 'csc')
102/62: D
102/63: A
102/64: A.size
102/65: A
102/66: A.shape
102/67:


MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################

order = 0
phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'out')

sigma = 58.7e6
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)
DB = pde.int.assembleB3(MESH, order = order)

face_in  = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1/crosssection+0*x, faces = 'in').diagonal()

r = face_in @ DB @ phiB_H1.T

unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

RZ = removeZeros2(A)

K = RSS @ K @ RSS.T
M = RSS @ M @ RSS.T

M,nz_indices = removeZeros(M)
K = removeZeros(K)[0]

r1 = r.copy()
r = (RSS@r)[nz_indices]


x = chol(sigma*K).solve_A(r)
x = RSS.T@r

xx = np.zeros(MESH.np)
xx[nz_indices] = x

###########################################################################
102/68:
def removeZeros2(A):
    indices = np.where((np.diff(A.indptr) != 0))[0]
    D = sp.eye(A.shape[0], format = 'csc')
    R = D[:,indices]
    return R
102/69: RZ = removeZeros2(A)
102/70: RZ
102/71:

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

RZ = removeZeros(A)

K = RZ @ RSS @ K @ RSS.T @ RZ.T
102/72: RZ
102/73:

def removeZeros_old(A):
    # create stuff...
    indices = np.where((np.diff(A.indptr) != 0))[0]
    Anz = A[:,indices]
    Anz = Anz[indices,:]
    return Anz,indices

def removeZeros(A):
    indices = np.where((np.diff(A.indptr) != 0))[0]
    D = sp.eye(A.shape[0], format = 'csc')
    R = D[:,indices]
    return R
102/74:
M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

RZ = removeZeros(A)

K = RZ @ RSS @ K @ RSS.T @ RZ.T
M = RSS @ M @ RSS.T
102/75: K
102/76: RZ
102/77: RSS
102/78:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T


K = RSS @ K @ RSS.T
RZ = removeZeros(A)
K = RZ @ K @ RZ.T
102/79: RZ
102/80: K
102/81: RZ
102/82:

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T


K = RSS @ K @ RSS.T
RZ = removeZeros(K)
K = RZ @ K @ RZ.T
102/83: RZ
102/84: K
102/85: K = RZ.T @ K @ RZ
102/86:
def removeZeros(A):
    indices = np.where((np.diff(A.indptr) != 0))[0]
    D = sp.eye(A.shape[0], format = 'csc')
    R = D[indices,:]
    return R
102/87:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T


K = RSS @ K @ RSS.T
RZ = removeZeros(K)
K = RZ @ K @ RZ
102/88:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T


K = RSS @ K @ RSS.T
RZ = removeZeros(K)
K = RZ @ K @ RZ.T
102/89:

r = RZ@RSS@r
102/90:
K = RSS @ K @ RSS.T
RZ = removeZeros(K)
K = RZ @ K @ RZ.T

M = RSS @ M @ RSS.T
M = RZ @ M @ RZ.T

r = RZ@RSS@r


x = chol(sigma*K).solve_A(r)
x = RZ.T@RSS.T@r
102/91:


MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################

order = 0
phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'out')

sigma = 58.7e6
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)
DB = pde.int.assembleB3(MESH, order = order)

face_in  = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1/crosssection+0*x, faces = 'in').diagonal()

r = face_in @ DB @ phiB_H1.T

unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T


K = RSS @ K @ RSS.T
RZ = removeZeros(K)
K = RZ @ K @ RZ.T

M = RSS @ M @ RSS.T
M = RZ @ M @ RZ.T

r = RZ@RSS@r


x = chol(sigma*K).solve_A(r)
x = RZ.T@RSS.T@r
102/92: x = RSS.T@RZ.T@x
102/93: x
102/94:
fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
phi,psi = fespot.TnT()
sigma = 58.7e6
bfa = BilinearForm(sigma*grad(phi)*grad(psi)*dx).Assemble()
inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
gfphi = GridFunction(fespot)
gfphi.vec.data = inv * lff.vec
rows,cols,vals = bfa.mat.COO()
A = sp.csr_matrix((vals,(rows,cols)))

r2 = lff.vec.FV().NumPy()
gfphi = gfphi.vec.FV().NumPy()
102/95: gfphi
102/96: x
102/97: gfphi-x
102/98: (gfphi-x).max()
102/99: (gfphi-x).min()
102/100:





import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)


# pdata = grid.GetPointData()
# data = vtk.vtkDoubleArray()
# data.SetNumberOfValues(MESH.np)
# for i,p in enumerate(xx): data.SetValue(i,xx[i])
# pdata.SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    vecJ.InsertNextTuple([xx[i]])
vecJ.SetName('omg')
pdata.AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/101: pdata.GetPointData().AddArray
102/102:






import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
pdata = grid.GetCellData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
pdata.SetScalars(data)


# pdata = grid.GetPointData()
# data = vtk.vtkDoubleArray()
# data.SetNumberOfValues(MESH.np)
# for i,p in enumerate(xx): data.SetValue(i,xx[i])
# pdata.SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    vecJ.InsertNextTuple([xx[i]])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/103: xx
102/104: xx.shape
102/105: xx.max()
102/106: xx.min()
102/107:

vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    # vecJ.InsertNextTuple([xx[i]])
    vecJ.SetValue(i,xx[i])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)
102/108:






import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


# pdata = grid.GetPointData()
# data = vtk.vtkDoubleArray()
# data.SetNumberOfValues(MESH.np)
# for i,p in enumerate(xx): data.SetValue(i,xx[i])
# pdata.SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    # vecJ.InsertNextTuple([xx[i]])
    vecJ.SetValue(i,xx[i])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/109: xx.max()
102/110: vecJ
102/111: vecJ[0]
102/112: vecJ
102/113: vecJ.get
102/114: vecJ.getValue
102/115:





import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


# pdata = grid.GetPointData()
# data = vtk.vtkDoubleArray()
# data.SetNumberOfValues(MESH.np)
# for i,p in enumerate(xx): data.SetValue(i,xx[i])
# pdata.SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    vecJ.InsertNextValue([xx[i]])
    # vecJ.SetValue(i,xx[i])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/116:







import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


# pdata = grid.GetPointData()
# data = vtk.vtkDoubleArray()
# data.SetNumberOfValues(MESH.np)
# for i,p in enumerate(xx): data.SetValue(i,xx[i])
# pdata.SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    vecJ.InsertNextValue(xx[i])
    # vecJ.SetValue(i,xx[i])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/117:







import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

# scalars = MESH.t[:,-1]
# data = vtk.vtkDoubleArray()
# data.SetNumberOfValues(MESH.nt)
# for i,p in enumerate(scalars): data.SetValue(i,p)
# grid.GetCellData().SetScalars(data)


# pdata = grid.GetPointData()
# data = vtk.vtkDoubleArray()
# data.SetNumberOfValues(MESH.np)
# for i,p in enumerate(xx): data.SetValue(i,xx[i])
# pdata.SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    vecJ.InsertNextValue(xx[i])
    # vecJ.SetValue(i,xx[i])
vecJ.SetName('omg')
grid.GetPointData().SetScalars(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/118:






import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


# pdata = grid.GetPointData()
# data = vtk.vtkDoubleArray()
# data.SetNumberOfValues(MESH.np)
# for i,p in enumerate(xx): data.SetValue(i,xx[i])
# pdata.SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    vecJ.InsertNextValue(xx[i])
    # vecJ.SetValue(i,xx[i])
vecJ.SetName('omg')
grid.GetPointData().SetScalars(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/119: xx
102/120:









import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


pdata = grid.GetPointData()
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.np)
for i,p in enumerate(xx): data.SetValue(i,xx[i])
pdata.SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    vecJ.InsertNextValue(xx[i])
    # vecJ.SetValue(i,xx[i])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/121:








import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    vecJ.InsertNextValue(xx[i])
    # vecJ.SetValue(i,xx[i])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/122:






import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    # vecJ.InsertNextValue(xx[i])
    vecJ.SetValue(i,xx[i])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/123: xx
102/124: xx.max()
102/125: xx.min()
102/126:






import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
for i in range(MESH.np):
    # vecJ.InsertNextValue(xx[i])
    # vecJ.SetValue(i,xx[i])
    vecJ.InsertPoint(i,x[i])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/127:







import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1);
for i in range(MESH.np):
    vecJ.InsertNextValue(xx[i])
    # vecJ.SetValue(i,xx[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/128:







import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1);
for i in range(MESH.np):
    # vecJ.InsertNextValue(xx[i])
    vecJ.SetValue(i,xx[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/129: xx[i]
102/130: xx[312]
102/131:





import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1);
for i in range(MESH.np):
    # vecJ.InsertNextValue(xx[i])
    # vecJ.SetValue(i,xx[i])
    vecJ.InsertPoint(i,x[i])
vecJ.SetName('omg')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/132:






import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    vecJ.InsertNextValue(xx[i])
    # vecJ.SetValue(i,xx[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('wtf')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/133: xx
102/134: r
102/135: x
102/136:






import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    vecJ.InsertNextValue(x[i])
    # vecJ.SetValue(i,xx[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('wtf')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/137: x
102/138: r
102/139: gfphi
102/140: x
102/141: x-gfphi
102/142: (gfphi-x).min()
102/143: (gfphi-x).max()
102/144: x
102/145: gphi
102/146:







import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    vecJ.InsertNextValue(x[i])
    # vecJ.SetValue(i,x[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('lel')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/147:






import time
import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    # vecJ.InsertNextValue(x[i])
    vecJ.SetValue(i,x[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('lel')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/148: MESH.np
102/149: MESH
102/150: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/151: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/152:


tm = time.monotonic()
###########################################################################
MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################

order = 0
phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'out')

sigma = 58.7e6
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)
DB = pde.int.assembleB3(MESH, order = order)

face_in  = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1/crosssection+0*x, faces = 'in').diagonal()

r = face_in @ DB @ phiB_H1.T

unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T


K = RSS @ K @ RSS.T
RZ = removeZeros(K)
K = RZ @ K @ RZ.T

M = RSS @ M @ RSS.T
M = RZ @ M @ RZ.T

r = RZ @ RSS @ r

x = chol(sigma*K).solve_A(r)
x = RSS.T @ RZ.T @ x
print('My code took ... ',time.monotonic()-tm)

###########################################################################


# Draw (mesh, clipping={"y":1, "z":0, "dist":0.012});
tm = time.monotonic()
mesh = Mesh(geoOCCmesh)
fespot = H1(mesh, order=1, definedon="coil", dirichlet="out")
phi,psi = fespot.TnT()
sigma = 58.7e6
bfa = BilinearForm(sigma*grad(phi)*grad(psi)*dx).Assemble()
inv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse="sparsecholesky")
lff = LinearForm(1/crosssection*psi*ds("in")).Assemble()
gfphi = GridFunction(fespot)
gfphi.vec.data = inv * lff.vec
rows,cols,vals = bfa.mat.COO()
A = sp.csr_matrix((vals,(rows,cols)))

r2 = lff.vec.FV().NumPy()
gfphi = gfphi.vec.FV().NumPy()
print('ngsolve took ... ',time.monotonic()-tm)

# Draw (gfphi, draw_vol=False, clipping={"y":1, "z":0, "dist":0.012});

###########################################################################
102/153: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/154:

tm = time.monotonic()
###########################################################################
MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################

order = 0
sigma = 58.7e6
phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'out')

phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)
DB = pde.int.assembleB3(MESH, order = order)
face_in  = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1/crosssection+0*x, faces = 'in').diagonal()

print('pde.stuff ... ',time.monotonic()-tm)

r = face_in @ DB @ phiB_H1.T

unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T


K = RSS @ K @ RSS.T
RZ = removeZeros(K)
K = RZ @ K @ RZ.T

M = RSS @ M @ RSS.T
M = RZ @ M @ RZ.T

r = RZ @ RSS @ r

x = chol(sigma*K).solve_A(r)
x = RSS.T @ RZ.T @ x
print('My code took ... ',time.monotonic()-tm)
102/155:
tm = time.monotonic()
###########################################################################
MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################

order = 0
sigma = 58.7e6
phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'out')
print('pde.stuff ... ',time.monotonic()-tm)

phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)
DB = pde.int.assembleB3(MESH, order = order)
face_in  = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1/crosssection+0*x, faces = 'in').diagonal()

print('pde.stuff ... ',time.monotonic()-tm)
102/156: phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
102/157: dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
102/158: D = pde.int.assemble3(MESH, order = order)
102/159: R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'out')
102/160: dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
102/161:

tm = time.monotonic()
###########################################################################
MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################
print('MESH.stuff ... ',time.monotonic()-tm)


order = 0
sigma = 58.7e6
phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'out')
print('pde.stuff ... ',time.monotonic()-tm)

phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)
DB = pde.int.assembleB3(MESH, order = order)
face_in  = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1/crosssection+0*x, faces = 'in').diagonal()

print('pde.stuff ... ',time.monotonic()-tm)

r = face_in @ DB @ phiB_H1.T

unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T


K = RSS @ K @ RSS.T
RZ = removeZeros(K)
K = RZ @ K @ RZ.T

M = RSS @ M @ RSS.T
M = RZ @ M @ RZ.T

r = RZ @ RSS @ r

x = chol(sigma*K).solve_A(r)
x = RSS.T @ RZ.T @ x
print('My code took ... ',time.monotonic()-tm)
102/162:
###########################################################################
MESH = pde.mesh3.netgen(geoOCCmesh)
###########################################################################
102/163: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/164: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/165: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
102/166: MESH
102/167: grid
102/168: grid.GetAttributes
102/169: grid.GetAttributes()
102/170: grid.GetAttributes(POINTS)
102/171: grid.GetPoints()
102/172: grid.GetPoints().GetNumberOfPoints()
102/173: grid.GetCells().GetNumberOfCells()
102/174: MESH
102/175:

import vtklib

grid = vtklib.createVTK(MESH)
102/176:

import vtklib

grid = vtklib.createVTK(MESH)
vtklib.add_H1_Scalar(grid, x, 'lel')
vtklib.writeVTK(grid, 'whatever.vtu')
102/177: x
102/178:
import vtklib

grid = vtklib.createVTK(MESH)
vtklib.add_H1_Scalar(grid, x, 'lel')
vtklib.writeVTK(grid, 'das.vtu')
102/179:
port vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    vecJ.InsertNextValue(x[i])
vecJ.SetName('lel')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/180:

import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    vecJ.InsertNextValue(x[i])
vecJ.SetName('lel')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/181: x
102/182:
import vtklib

grid = vtklib.createVTK(MESH)
vtklib.add_H1_Scalar(grid, x, 'lel')
vtklib.writeVTK(grid, 'das.vtu')
102/183:

import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    # vecJ.InsertNextValue(x[i])
    vecJ.SetValue(i,x[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('lel')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
102/184: x
102/185: x.max()
102/186: x.min()
102/187:

vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    # vecJ.InsertNextValue(x[i])
    # vecJ.SetValue(i,x[i])
    vecJ.InsertPoint(i,x[i])
vecJ.SetName('lel')
grid.GetPointData().AddArray(vecJ)
103/1: # vecJ.SetValue(i,x[i])
103/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
103/3: x
103/4: x.max()
103/5: x.min()
103/6:

import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    vecJ.InsertNextValue(x[i])
    # vecJ.SetValue(i,x[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('lel')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
103/7:

import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    # vecJ.InsertNextValue(x[i])
    vecJ.SetValue(i,x[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('lel')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
103/8:
vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    # vecJ.InsertNextValue(x[i])
    # vecJ.SetValue(i,x[i])
    vecJ.InsertPoint(i,x[i])
vecJ.SetName('lel')
grid.GetPointData().AddArray(vecJ)
103/9:




import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    vecJ.InsertNextValue(x[i])
    # vecJ.SetValue(i,x[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('lel')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
103/10:





import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    vecJ.InsertNextValue(x[i])
    # vecJ.SetValue(i,x[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('ledasl')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
103/11:






import vtk
tm = time.monotonic()

points = vtk.vtkPoints()
grid = vtk.vtkUnstructuredGrid()

for i in range(MESH.np): points.InsertPoint(i, (MESH.p[i,0], MESH.p[i,1], MESH.p[i,2]))

def create_cell(i):
    tetra = vtk.vtkTetra()
    ids = tetra.GetPointIds()
    ids.SetId(0, MESH.t[i,0])
    ids.SetId(1, MESH.t[i,1])
    ids.SetId(2, MESH.t[i,2])
    ids.SetId(3, MESH.t[i,3])
    return tetra

elems = [create_cell(i) for i in range(MESH.nt)]
grid.Allocate(MESH.nt, 1)
grid.SetPoints(points)

for elem in elems: grid.InsertNextCell(elem.GetCellType(), elem.GetPointIds())

scalars = MESH.t[:,-1]
data = vtk.vtkDoubleArray()
data.SetNumberOfValues(MESH.nt)
for i,p in enumerate(scalars): data.SetValue(i,p)
grid.GetCellData().SetScalars(data)


vecJ = vtk.vtkFloatArray()
vecJ.SetNumberOfValues(MESH.np)
vecJ.SetNumberOfComponents(1)
for i in range(MESH.np):
    # vecJ.InsertNextValue(x[i])
    vecJ.SetValue(i,x[i])
    # vecJ.InsertPoint(i,x[i])
vecJ.SetName('ledasl')
grid.GetPointData().AddArray(vecJ)

print('Time needed to prepare file ... ',time.monotonic()-tm)

writer = vtk.vtkXMLUnstructuredGridWriter()
writer.SetFileName("whatever.vtu")
writer.SetInputData(grid)
writer.Write()
print('Time needed to write to file ... ',time.monotonic()-tm)
103/12: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
103/13: K-shape
103/14: K.shape
103/15: r.shape
103/16: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
103/17: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
103/18: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
103/19: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
106/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
106/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
106/3:
import importlib
importlib.reload(pde)
106/4: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
106/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
106/6:

phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)
106/7:

phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)
phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

M_Hdiv = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T +\
         phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T +\
         phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T


C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
106/8: M_Hdiv
106/9: C_Hdiv_L2
106/10: MESH
106/11: MESH.FacesToVertices
106/12: Boundary_EdgeOrientation
106/13: MESH.FacesToVertices
106/14: MESH.DirectionFaces
106/15: MESH.FacesToVertices
106/16: MESH.TetsToFaces
106/17: MESH.Boundary_Faces
106/18: MESH.Boundary_Faces
106/19: MESH.TetsToFaces.shape
106/20: MESH
106/21: MESH.FacesToVertices
106/22: MESH.FacesToVertices[]
106/23: MESH.BoundaryFaces_Region
106/24: MESH.BoundaryFaces
106/25: MESH.Boundary_Faces
106/26: MESH.FacesToVertices[MESH.Boundary_Faces,:]
106/27: geoOCCmesh
106/28: geoOCCmesh.face
106/29: geoOCCmesh.face[0]
106/30:
for i in range(geoOCCmesh.GetNFaceDescriptors()):
    fd = ngmesh.FaceDescriptor(i+1)
    print (fd)
    print (fd.domin, fd.domout)
106/31: geoOCCmesh.GetNFaceDescriptors()
106/32:
for i in range(geoOCCmesh.GetNFaceDescriptors()):
    fd = geoOCCmesh.FaceDescriptor(i+1)
    print (fd)
    print (fd.domin, fd.domout)
106/33: geo = OCCGeometry(Glue([coil,air]))
106/34: geo
106/35: geo
106/36: geo.faces
106/37: Glue([coil,air]]
106/38: Glue([coil,air])
106/39: a = Glue([coil,air])
106/40: a.faces.max(Z)
106/41: a.faces.max(Z).Norm
106/42: a.faces.max(Z).Norm()
106/43: a.faces.max(Z).
106/44: a.faces.max(Z)
106/45: a.faces.max(Z).Direction()
106/46: a.faces.max(Z)
106/47: geo
106/48: geo.GetFace(0).GetBoundary().
106/49: geo.GetFace(0).GetBoundary()
106/50: coil.faces[0]
106/51: indices = npy.unique(MESH.TetsToFaces, return_index=True)[1]
106/52: indices = np.unique(MESH.TetsToFaces, return_index=True)[1]
106/53: indices
106/54: MESH.TetsToFaces
106/55: MESH.TetsToFaces.ravel()
106/56: MESH.TetsToFaces
106/57: gem_list = MESH.TetsToFaces.ravel()
106/58: _,j,i = npy.intersect1d(gem_list,MESH.Boundary_Faces, return_indices = True)
106/59: _,j,i = np.intersect1d(gem_list,MESH.Boundary_Faces, return_indices = True)
106/60: Boundary_EdgeOrientation = npy.zeros(shape = i.shape)
106/61: Boundary_FaceOrientation = np.zeros(shape = i.shape)
106/62: Boundary_EdgeOrientation[i] = gem_dir_list[j]
106/63: gem_dir_list = MESH.DirectionFaces.ravel()
106/64: Boundary_EdgeOrientation[i] = gem_dir_list[j]
106/65: Boundary_FacesOrientation[i] = gem_dir_list[j]
106/66: Boundary_FaceOrientation[i] = gem_dir_list[j]
106/67: Boundary_FaceOrientation
106/68: Boundary_FaceOrientation.max()
106/69: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
106/70: gem_list = MESH.TetsToFaces.ravel()
106/71: _,j,i = np.intersect1d(gem_list,MESH.Boundary_Faces, return_indices = True)
106/72: gem_dir_list = MESH.DirectionFaces.ravel()
106/73: Boundary_FaceOrientation[i] = gem_dir_list[j]
106/74: Boundary_FaceOrientation.max()
106/75: Boundary_FaceOrientation.min()
106/76: runcell(0, 'C:/Users/Radu/Documents/GitHub/fem/pde/hdiv/assemble3.py')
106/77: assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order, faces = 'in')
106/78: pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order, faces = 'in')
106/79: pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order, faces = 'in')
106/80: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order)
106/81: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order)
106/82: import pde
106/83: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order)
106/84: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order)
106/85: debugfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
106/86: debugfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
106/87: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order)
106/88: MESH.detB(0,0)
106/89: MESH.detB(0,0).min()
106/90: MESH.detB(0,1).min()
106/91: MESH.detB(0,0.12312).min()
106/92: MESH.detB(0.332,0.12312).min()
106/93: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order)
106/94:

dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = 1)
106/95: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order)
106/96: 15636*3
106/97: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order)
106/98: phi_H1.shape
106/99: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = order)
106/100: das
106/101: dsa
106/102: dsa.min()
106/103: dsa.max()
106/104: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = 3)
106/105: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = 1)
106/106: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = 0)
106/107: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = 1)
106/108: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = 1)
106/109: debugfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
106/110: dsa = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'M', shape = phix_Hdiv.shape, order = 1)
106/111: MESH.f
106/112: p
106/113: das = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in')
106/114: das
106/115: das = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y : 1+0*x, faces = 'in').diagonal()
106/116: das
106/117: das.max()
106/118: das.min()
106/119: A = np.array([[1,1],[4,1/2]])
106/120: A
106/121: np.linalg.inv(A)
106/122: A\s
106/123: np.linalg.inv(A)*7
106/124: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
106/125: MESH.FacesToVertices
106/126: MESH.FacesToVertices.shape[0]
106/127: MESH.NoFaces
106/128: FaceNormals = np.zeros(MESH.NoFaces,2)
106/129: FaceNormals = np.zeros((MESH.NoFaces,2))
106/130: FaceNormals
106/131: MESH.FacesToVertices
106/132: MESH.f
106/133:

f = MESH.f; p = MESH.p;
f0 = f[:,0]; f1 = f[:,1]; f2 = f[:,2]
B00 = p[f0,0]; B01 = p[f1,0]; B02 = p[f2,0];
B10 = p[f0,1]; B11 = p[f1,1]; B12 = p[f2,1];
B20 = p[f0,2]; B21 = p[f1,2]; B22 = p[f2,2];
106/134: np.cross
106/135: np.cross(np.c_[B02-B00,B12-B10,B22-B20].T,np.c_[B01-B00,B11-B10,B21-B20].T)
106/136: np.c_[B02-B00,B12-B10,B22-B20].T
106/137: np.c_[B02-B00,B12-B10,B22-B20].T.shape
106/138: np.cross(np.c_[B02-B00,B12-B10,B22-B20],np.c_[B01-B00,B11-B10,B21-B20])
106/139: normals = np.cross(np.c_[B02-B00,B12-B10,B22-B20],np.c_[B01-B00,B11-B10,B21-B20])
106/140:

n = np.cross(np.c_[B02-B00,B12-B10,B22-B20],np.c_[B01-B00,B11-B10,B21-B20])
normals = n/np.sqrt(n[:,0]**2 + n[:,1]**2 + n[:,2]**2)
106/141: normals = n/np.sqrt(n[:,0]**2 + n[:,1]**2 + n[:,2]**2)[None]
106/142: np.sqrt(n[:,0]**2 + n[:,1]**2 + n[:,2]**2)
106/143: np.cross(np.c_[B02-B00,B12-B10,B22-B20],np.c_[B01-B00,B11-B10,B21-B20])
106/144: normals = n/np.tile(np.sqrt(n[:,0]**2 + n[:,1]**2 + n[:,2]**2),(1,3))
106/145: normals = n/np.tile(np.sqrt(n[:,0]**2 + n[:,1]**2 + n[:,2]**2),(3,1))
106/146: normals = n/np.tile(np.sqrt(n[:,0]**2 + n[:,1]**2 + n[:,2]**2),(3,1)).T
106/147: normals
106/148:
n = npy.cross(npy.c_[npy.c_[B01-B00,B11-B10,B21-B20],B02-B00,B12-B10,B22-B20])
normals = n/npy.tile(npy.sqrt(n[:,0]**2 + n[:,1]**2 + n[:,2]**2),(3,1)).T
self.normals = normals
105/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
105/2: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/unit_cube.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
105/3: MESH
105/4: MESH.normals
105/5: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
108/1:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

wp = occ.WorkPlane(occ.Axes((0,0,0), n=occ.X, h=occ.Y)).MoveTo(-100,-50).Rectangle(25,100).Face()

geom = occ.Compound([coil + mid_steel + r_steel + l_steel, wp]) #+ wp
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)


DrawGeo(full, clipping={"z":-1, "dist":64});
108/2:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

wp = occ.WorkPlane(occ.Axes((0,0,0), n=occ.X, h=occ.Y)).MoveTo(-100,-50).Rectangle(25,100).Face()

geom = occ.Compound([coil + mid_steel + r_steel + l_steel, wp]) #+ wp
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

Draw(geoOCCmesh)
108/3:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

wp = occ.WorkPlane(occ.Axes((0,0,0), n=occ.X, h=occ.Y)).MoveTo(-100,-50).Rectangle(25,100).Face()

geom = occ.Compound([coil + mid_steel + r_steel + l_steel, wp]) #+ wp
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/4:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box = occ.Box(occ.Pnt(0,0,-50), occ.Pnt(100,-100,50))

geom = (coil + mid_steel + r_steel + l_steel)*wp #+ wp
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/5:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))

geom = (coil + mid_steel + r_steel + l_steel)*wp #+ wp
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/6:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))

geom = (coil + mid_steel + r_steel + l_steel)#*wp #+ wp
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/7:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))

geom = (coil + mid_steel + r_steel + l_steel)+wp #+ wp
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/8:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))

geom = (coil + mid_steel + r_steel + l_steel + wp) #+ wp
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/9:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))

geom = (coil + mid_steel + r_steel + l_steel + half_box) #+ wp
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/10:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))

geom = (coil + mid_steel + r_steel + l_steel)*half_box #+ wp
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/11:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel)*half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/12:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(-100,0,50))

geom = (coil + mid_steel + r_steel + l_steel)*half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/13:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel)*half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/14:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,0,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel)*half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/15:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,0,50))
half_box_2 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,0,50))

geom = (coil + mid_steel + r_steel + l_steel)*half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/16:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,0,50))
half_box_2 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,0,50))

geom = (coil*half_box_1+coil*half_box_2 + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/17:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,0,50))
half_box_2 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,0,50))

geom = (coil*half_box_1 + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/18:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,0,50))
half_box_2 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,0,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_1
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/19:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,100,50))
half_box_2 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,0,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_1
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/20:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,1,50))
half_box_2 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,0,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_1
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/21:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,100,-50), occ.Pnt(100,0,50))
half_box_2 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,0,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_1
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/22:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,100,-50), occ.Pnt(100,0,50))
half_box_2 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,0,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/23:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel)*half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/24:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/25:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(100,-100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(-100,-100,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/26:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(100,-100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(-100,0,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/27:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(100,-100,50))
# half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(-100,0,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_1
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/28:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel)*half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/29:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(100,-100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/30:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_1
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/31:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/32:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/33:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

# half_box_1 = occ.Box(occ.Pnt(0,100,-50), occ.Pnt(-100,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/34:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_2
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/35:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil + mid_steel + r_steel + l_steel) + half_box_1
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/36:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

geom = (coil*half_box_1 + coil*half_box_2 + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/37:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Glue(coil*half_box_1,coil*half_box_2)

geom = ( + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/38:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Glue([coil*half_box_1,coil*half_box_2])

geom = ( + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/39:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Glue([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/40:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/41:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
108/42:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.face[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/43:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

# coil.face[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/44: coil.faces
108/45: coil.faces[0]
108/46: coil.faces[32]
108/47: coil.faces[2]
108/48: coil.faces[2].name
108/49:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
full = geom
# full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

full.face[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/50:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = occ.Glue([geom,wp])
# full = geom
full = occ.Compound([occ.Glue([geom, ambient]),wp])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

full.face[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/51:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = geom
full = occ.Glue([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

full.face[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/52:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))




# full = geom
full = occ.Glue([geom, ambient])

##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

# full.face[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/53:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([geom, ambient])


# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

# full.face[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/54:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

# full.face[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")

full = occ.Glue([geom, ambient])
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/55:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([geom, ambient])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

# full.face[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")

    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/56:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([geom, ambient])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

# full.face[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")

    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/57:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil_full*half_box_1,coil_full*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([geom, ambient])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

# full.face[32].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")

    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/58:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil_full*half_box_1,coil_full*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/59:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil_full*half_box_1,coil_full*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])



full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/60:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil_full*half_box_1,coil_full*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Compound([geom, ambient])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/61:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil_full*half_box_1,coil_full*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([geom, ambient])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

# geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

# geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

# DrawGeo(geoOCCmesh)
108/62:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil_full*half_box_1,coil_full*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([geom, ambient])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
109/1:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([geom, ambient])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
109/2:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([ambient, geom])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/1:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([ambient, geom])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/2:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([geom, ambient])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/3:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = occ.Glue([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([geom, ambient])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/4:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = coil*half_box_1 + coil*half_box_2
# coil = occ.Glue([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([geom, ambient])



# full = geom


##########################################################################
# Identifications
##########################################################################

for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/5:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
# coil = coil*half_box_1 + coil*half_box_2
coil = occ.Glue([coil*half_box_1,coil*half_box_2])
for face in coil.faces: face.name = 'coil_face'

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
full = occ.Glue([geom, ambient])



# full = geom


##########################################################################
# Identifications
##########################################################################


for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/6:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
# coil = coil*half_box_1 + coil*half_box_2
coil = occ.Glue([coil*half_box_1,coil*half_box_2])
for face in coil.faces: face.name = 'coil_face'

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom


##########################################################################
# Identifications
##########################################################################


for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/7:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
# coil = coil*half_box_1 + coil*half_box_2
coil = occ.Glue([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom
for face in coil.faces: face.name = 'coil_face'


##########################################################################
# Identifications
##########################################################################


for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/8:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
coil = coil*half_box_1 + coil*half_box_2
# coil = occ.Glue([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom
for face in coil.faces: face.name = 'coil_face'


##########################################################################
# Identifications
##########################################################################


for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/9:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
# coil = coil*half_box_1 + coil*half_box_2
# coil = occ.Glue([coil*half_box_1,coil*half_box_2])
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom
for face in coil.faces: face.name = 'coil_face'


##########################################################################
# Identifications
##########################################################################


for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/10:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
# coil = coil*half_box_1 + coil*half_box_2
coil = occ.Glue([coil*half_box_1,coil*half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom
for face in coil.faces: face.name = 'coil_face'


##########################################################################
# Identifications
##########################################################################


for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/11:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
# coil = coil*half_box_1 + coil*half_box_2
# coil = occ.Glue([coil*half_box_1,coil*half_box_2])
coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom
for face in coil.faces: face.name = 'coil_face'


##########################################################################
# Identifications
##########################################################################


for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/12:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
# coil = coil*half_box_1 + coil*half_box_2
coil = occ.Glue([coil*half_box_1,coil*half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom
for face in coil.faces: face.name = 'coil_face'


##########################################################################
# Identifications
##########################################################################


for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/13:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))
# coil = coil*half_box_1 + coil*half_box_2
coil = occ.Glue([coil_full*half_box_1,coil_full*half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom
for face in coil.faces: face.name = 'coil_face'


##########################################################################
# Identifications
##########################################################################


for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/14:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))


# coil = coil*half_box_1 + coil*half_box_2
coil = occ.Glue([coil_full*half_box_1,coil_full*half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/15:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))


coil = coil*half_box_1 + coil*half_box_2
# coil = occ.Glue([coil_full*half_box_1,coil_full*half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/16:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))


coil = coil*half_box_1 + coil*half_box_2
# coil = occ.Glue([coil_full*half_box_1,coil_full*half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/17:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil*half_box_1
coil_half_box_2 = coil*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/18:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil*half_box_1
coil_half_box_2 = coil*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/19:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil*half_box_1
coil_half_box_2 = coil*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/20:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil*half_box_1
coil_half_box_2 = coil*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])



full = geom


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/21:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil*half_box_1
coil_half_box_2 = coil*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])


full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])
# full = geom


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/22:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil*half_box_1
coil_half_box_2 = coil*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
# coil = occ.Compound([coil*half_box_1,coil*half_box_2])

# geom = (coil + mid_steel + r_steel + l_steel)
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))
# full = occ.Glue([geom, ambient])


full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])
# full = geom


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/23:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil*half_box_1
coil_half_box_2 = coil*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
110/24:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil*half_box_1
coil_half_box_2 = coil*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
105/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/t13geo.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
111/1:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil*half_box_1
coil_half_box_2 = coil*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
111/2:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
111/3: coil.faces[2].name
111/4: coil.faces
105/7: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
105/8: MESH
105/9: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/magnetostatics_ngs.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
105/10: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
112/1: %run -t "c:\Users\Radu\Documents\GitHub\fem\PROJECTS\TEAM\magnetostatics_ngs.py"
113/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
113/2: # Mass matrix
113/3:

from scipy import sparse as sp
import numpy as npy
from .spaces3 import spaceInfo
from ..tools import getIndices
from .. import basis
from .. import quadrature


def assemble3(MESH,space,matrix,order=-1):

    if not space in MESH.FEMLISTS.keys():
        spaceInfo(MESH,space)

    p = MESH.p;
    t = MESH.t; nt = t.shape[0]

    sizeM = MESH.FEMLISTS[space]['TET']['sizeM']
    phi = MESH.FEMLISTS[space]['TET']['phi']; lphi = len(phi)
    dphi = MESH.FEMLISTS[space]['TET']['dphi']; ldphi = len(dphi)

    LIST_DOF = MESH.FEMLISTS[space]['TET']['LIST_DOF']

    if order != -1:
        qp,we = quadrature.keast(order); nqp = len(we)

    #####################################################################################
    # Mass matrix
    #####################################################################################

    if matrix == 'M':
        if order == -1:
            qp = MESH.FEMLISTS[space]['TET']['qp_we_M'][0];
            we = MESH.FEMLISTS[space]['TET']['qp_we_M'][1]; nqp = len(we)

        ellmatsB = npy.zeros((nqp*nt,lphi))

        im = npy.tile(LIST_DOF,(nqp,1))
        jm = npy.tile(npy.c_[:nt*nqp].reshape(nt,nqp).T.flatten(),(lphi,1)).T

        for j in range(lphi):
            for i in range(nqp):
                ellmatsB[i*nt:(i+1)*nt,j] = phi[j](qp[0,i],qp[1,i],qp[2,i])

        B = sparse(im,jm,ellmatsB,sizeM,nqp*nt)
        return B

    #####################################################################################
    # Stiffness matrices
    #####################################################################################

    if matrix == 'K':
        if order == -1:
            qp =  MESH.FEMLISTS[space]['TET']['qp_we_K'][0];
            we =  MESH.FEMLISTS[space]['TET']['qp_we_K'][1]; nqp = len(we)

        ellmatsBKx = npy.zeros((nqp*nt,ldphi))
        ellmatsBKy = npy.zeros((nqp*nt,ldphi))
        ellmatsBKz = npy.zeros((nqp*nt,ldphi))

        im = npy.tile(LIST_DOF,(nqp,1))
        jm = npy.tile(npy.c_[:nt*nqp].reshape(nt,nqp).T.flatten(),(ldphi,1)).T

        for j in range(ldphi):
            for i in range(nqp):
                dphii = dphi[j](qp[0,i],qp[1,i],qp[2,i])
                detA = MESH.detA(qp[0,i],qp[1,i],qp[2,i])
                iJF00 = MESH.iJF00(qp[0,i],qp[1,i],qp[2,i]); iJF01 = MESH.iJF01(qp[0,i],qp[1,i],qp[2,i]); iJF02 = MESH.iJF02(qp[0,i],qp[1,i],qp[2,i]);
                iJF10 = MESH.iJF10(qp[0,i],qp[1,i],qp[2,i]); iJF11 = MESH.iJF11(qp[0,i],qp[1,i],qp[2,i]); iJF12 = MESH.iJF12(qp[0,i],qp[1,i],qp[2,i]);
                iJF20 = MESH.iJF20(qp[0,i],qp[1,i],qp[2,i]); iJF21 = MESH.iJF21(qp[0,i],qp[1,i],qp[2,i]); iJF22 = MESH.iJF22(qp[0,i],qp[1,i],qp[2,i]);

                ellmatsBKx[i*nt:(i+1)*nt,j] = iJF00*dphii[0]+iJF10*dphii[1]+iJF20*dphii[2]
                ellmatsBKy[i*nt:(i+1)*nt,j] = iJF01*dphii[0]+iJF11*dphii[1]+iJF21*dphii[2]
                ellmatsBKz[i*nt:(i+1)*nt,j] = iJF02*dphii[0]+iJF12*dphii[1]+iJF22*dphii[2]

        BKx = sparse(im,jm,ellmatsBKx,sizeM,nqp*nt)
        BKy = sparse(im,jm,ellmatsBKy,sizeM,nqp*nt)
        BKz = sparse(im,jm,ellmatsBKz,sizeM,nqp*nt)
        return BKx, BKy, BKz


# # @nb.jit(cache=True)
def assembleB3(MESH, space, matrix, shape, order=-1):

    if not space in MESH.FEMLISTS.keys():
        spaceInfo(MESH,space)

    p = MESH.p;
    f = MESH.f; nf = f.shape[0]

    phi =  MESH.FEMLISTS[space]['B']['phi']; lphi = len(phi)
    LIST_DOF = MESH.FEMLISTS[space]['B']['LIST_DOF']

    if order != -1:
        qp,we = quadrature.dunavant(order); nqp = len(we)

    #####################################################################################
    # Mass matrix (over the edge)
    #####################################################################################

    if matrix == 'M':
        if order == -1:
            qp = MESH.FEMLISTS[space]['B']['qp_we_B'][0];
            we = MESH.FEMLISTS[space]['B']['qp_we_B'][1]; nqp = len(we)

        ellmatsB = npy.zeros((nqp*nf,lphi))

        im = npy.tile(LIST_DOF,(nqp,1))
        jm = npy.tile(npy.c_[0:nf*nqp].reshape(nf,nqp).T.flatten(),(lphi,1)).T

        for j in range(lphi):
            for i in range(nqp):
                ellmatsB[i*nf:(i+1)*nf,j] = phi[j](qp[0,i],qp[1,i])

        B = sparse(im,jm,ellmatsB,shape[0],nqp*nf)
        return B

# def assembleE(MESH,space,matrix,order=1):

#     if not space in MESH.FEMLISTS.keys():
#         spaceInfo(MESH,space)

#     p = MESH.p; 
#     t = MESH.t; nt = MESH.nt

#     phi =  MESH.FEMLISTS[space]['TRIG']['phi']; lphi = len(phi)
#     sizeM = MESH.FEMLISTS[space]['TRIG']['sizeM']

#     LIST_DOF = MESH.FEMLISTS[space]['TRIG']['LIST_DOF']
#     # DIRECTION_DOF = MESH.FEMLISTS[space]['TRIG']['DIRECTION_DOF']

#     qp,we = quadrature.one_d(order); nqp = len(we)

#     # on edge2: (0,0) -> (1,0)
#     qp2 = npy.c_[1-qp,0*qp].T
#     # on edge1: (0,0) -> (0,1)
#     qp1 = npy.c_[0*qp,qp].T
#     # on edge0: (0,1) -> (1,0)
#     qp0 = npy.c_[qp,1-qp].T

#     #####################################################################################
#     # Mappings
#     #####################################################################################

#     t0 = t[:,0]; t1 = t[:,1]; t2 = t[:,2]
#     A00 = p[t1,0]-p[t0,0]; A01 = p[t2,0]-p[t0,0];
#     A10 = p[t1,1]-p[t0,1]; A11 = p[t2,1]-p[t0,1];
#     detA = A00*A11-A01*A10

#     #####################################################################################
#     # Mass matrix (over the edge)
#     #####################################################################################

#     if matrix == 'M':

#         ellmatsB0 = npy.zeros((nqp*nt,lphi))
#         ellmatsB1 = npy.zeros((nqp*nt,lphi))
#         ellmatsB2 = npy.zeros((nqp*nt,lphi))

#         im = npy.tile(LIST_DOF,(nqp,1))

#         ind0 = npy.argwhere(MESH.EdgeDirectionTrig[:,0]==-1)
#         ind1 = npy.argwhere(MESH.EdgeDirectionTrig[:,1]==-1)
#         ind2 = npy.argwhere(MESH.EdgeDirectionTrig[:,2]==-1)

#         indices = npy.tile(npy.arange(nqp),(nt,1))

#         indices0 = indices.copy(); indices1 = indices.copy(); indices2 = indices.copy()

#         indices0[ind0,:] = indices0[ind0,::-1]; 
#         indices1[ind1,:] = indices1[ind1,::-1]; 
#         indices2[ind2,:] = indices2[ind2,::-1];

#         jm0 = npy.tile(npy.tile(MESH.TriangleToEdges[:,0]*nqp,nqp) + indices0.T.flatten(),(lphi,1)).T
#         jm1 = npy.tile(npy.tile(MESH.TriangleToEdges[:,1]*nqp,nqp) + indices1.T.flatten(),(lphi,1)).T
#         jm2 = npy.tile(npy.tile(MESH.TriangleToEdges[:,2]*nqp,nqp) + indices2.T.flatten(),(lphi,1)).T

#         for j in range(lphi):
#             for i in range(nqp):
#                 phii0 = phi[j](qp0[0,i],qp0[1,i])
#                 phii1 = phi[j](qp1[0,i],qp1[1,i])
#                 phii2 = phi[j](qp2[0,i],qp2[1,i])

#                 ellmatsB0[i*nt:(i+1)*nt,j] = phii0*MESH.EdgeDirectionTrig[:,0]
#                 ellmatsB1[i*nt:(i+1)*nt,j] = phii1*MESH.EdgeDirectionTrig[:,1]
#                 ellmatsB2[i*nt:(i+1)*nt,j] = phii2*MESH.EdgeDirectionTrig[:,2]

#         ellmatsB0 = ellmatsB0*(npy.abs(ellmatsB0)>1e-12)
#         ellmatsB1 = ellmatsB1*(npy.abs(ellmatsB1)>1e-12)
#         ellmatsB2 = ellmatsB2*(npy.abs(ellmatsB2)>1e-12)

#         B0 = sparse(im,jm0,ellmatsB0,sizeM,nqp*MESH.NoEdges)
#         B1 = sparse(im,jm1,ellmatsB1,sizeM,nqp*MESH.NoEdges)
#         B2 = sparse(im,jm2,ellmatsB2,sizeM,nqp*MESH.NoEdges)

#         B0.eliminate_zeros()
#         B1.eliminate_zeros()
#         B2.eliminate_zeros()

#         return B0,B1,B2

def assembleR3(MESH, space, faces = '', listDOF = npy.empty(0)):

    if not space in MESH.FEMLISTS.keys():
        spaceInfo(MESH,space)

    if type(faces) == str:
        if faces == '':
            ind_faces = MESH.MESH.BoundaryFaces_Region
        else:
            ind_faces = getIndices(MESH.regions_2d,faces)
    else:
        if MESH.regions_2d == []:
            ind_faces = faces
        else:
            ind_faces = getIndices(MESH.regions_2d,faces)


    indices = npy.in1d(MESH.BoundaryFaces_Region,ind_faces)

    sizeM = MESH.FEMLISTS[space]['TET']['sizeM']
    LIST_DOF  = npy.unique(MESH.FEMLISTS[space]['B']['LIST_DOF'][indices,:])
    LIST_DOF2 = npy.setdiff1d(npy.arange(sizeM),LIST_DOF)

    if listDOF.size > 0:
        LIST_DOF = listDOF

    D = sp.eye(sizeM, format = 'csc')
    R1 = D[:,LIST_DOF]
    R2 = D[:,LIST_DOF2]

    return R1.T.tocsc(),R2.T.tocsc()


def sparse(i, j, v, m, n):
    return sp.csc_matrix((v.flatten(), (i.flatten(), j.flatten())), shape=(m, n))
113/4:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo
import numpy as np
import numpy as npy

from scipy import sparse as sp

full = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))

##########################################################################
# Identifications
##########################################################################

for face in full.faces: face.name = 'ambient_face'
for edge in full.edges: edge.name = 'ambient_edges'

full.mat("full")

##########################################################################
# Generating mesh...
##########################################################################

geoOCC = occ.OCCGeometry(full)
ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh(maxh = 30)
# geoOCCmesh.Refine()

mesh = ng.Mesh(geoOCCmesh)
# mesh.Refine()


##########################################################################
# NGSOVLE STUFF...
##########################################################################

# fes = ng.H1(mesh, order = 0)
# fes = ng.HCurl(mesh, order = 0)
fes = ng.HDiv(mesh, order = 0)
print ("Hx dofs:", fes.ndof)
u,v = fes.TnT()

# bfa = ng.BilinearForm(ng.grad(u)*ng.grad(v)*ng.dx).Assemble()
bfa = ng.BilinearForm(u*v*ng.dx).Assemble()
# bfa = ng.BilinearForm(ng.curl(u)*ng.curl(v)*ng.dx).Assemble()
# bfa = ng.BilinearForm(ng.div(u)*ng.div(v)*ng.dx).Assemble()

rows,cols,vals = bfa.mat.COO()
A = sp.csr_matrix((vals,(rows,cols)))

##########################################################################


import sys
sys.path.insert(0,'../../') # adds parent directory
import pde
from sksparse.cholmod import cholesky as chol

order = 3

MESH = pde.mesh3.netgen(geoOCCmesh)
print(MESH)

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)

M = phi_H1 @ D @ phi_H1.T

K = dphix_H1 @ D @ dphix_H1.T + \
    dphiy_H1 @ D @ dphiy_H1.T + \
    dphiz_H1 @ D @ dphiz_H1.T

R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')

Kn = RSS @ K @ RSS.T


phix_Hcurl, phiy_Hcurl, phiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = order)
curlphix_Hcurl, curlphiy_Hcurl, curlphiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = order)
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

M_Hcurl = phix_Hcurl @ D @ phix_Hcurl.T + \
          phiy_Hcurl @ D @ phiy_Hcurl.T + \
          phiz_Hcurl @ D @ phiz_Hcurl.T

K_Hcurl = curlphix_Hcurl @ D @ curlphix_Hcurl.T + \
          curlphiy_Hcurl @ D @ curlphiy_Hcurl.T + \
          curlphiz_Hcurl @ D @ curlphiz_Hcurl.T

M_Hdiv = phix_Hdiv @ D @ phix_Hdiv.T + \
         phiy_Hdiv @ D @ phiy_Hdiv.T + \
         phiz_Hdiv @ D @ phiz_Hdiv.T

K_Hdiv = divphi_Hdiv @ D @ divphi_Hdiv.T

C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T + \
             phiy_Hcurl @ D @ dphiy_H1.T + \
             phiz_Hcurl @ D @ dphiz_H1.T

from scipy.sparse import bmat

AA = bmat([[K_Hcurl, C_Hcurl_H1],
           [C_Hcurl_H1.T, None]])

##########################################################################
# Tree/Cotree gauging
##########################################################################

from mst import *

newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

D = sp.eye(MESH.NoEdges, format = 'csc')

R = D[:,LIST_DOF]

KR = R.T@K_Hcurl@R
##########################################################################


MESH = pde.mesh3.netgen(geoOCCmesh)


##########################################################################








curlphix_Hcurl, curlphiy_Hcurl, curlphiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = order)



regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
npy.c_[faces[:,0],faces[:,2]],
npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
other_edge_indices = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

noPoints_interior = np.unique(MESH.EdgesToVertices[other_edge_indices,:2]).size

print(edge_indices.shape)




# LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)
# D = sp.eye(MESH.NoEdges, format = 'csc')
# R = D[:,LIST_DOF]

# K_noEdges = R.T@K_Hcurl@R
# print(K_noEdges.shape,np.linalg.matrix_rank(K_noEdges.A,tol=1e-12))





# LIST_DOF  = np.unique(MESH.FEMLISTS['N0']['B']['LIST_DOF'][indices])
# LIST_DOF2 = np.setdiff1d(np.r_[:MESH.NoEdges],indices)




# print(KR.shape,np.linalg.matrix_rank(KR.A, tol=1e-10))
# print(K_Hcurl.shape,np.linalg.matrix_rank(K_Hcurl.A, tol=1e-10))
# return R1.T.tocsc(),R2.T.tocsc()


FaceNormals = np.zeros((MESH.NoFaces,2))
# for i in range(MESH.NoFaces):
#     p1 = 
# n = 

f = MESH.f; p = MESH.p;
f0 = f[:,0]; f1 = f[:,1]; f2 = f[:,2]
B00 = p[f0,0]; B01 = p[f1,0]; B02 = p[f2,0];
B10 = p[f0,1]; B11 = p[f1,1]; B12 = p[f2,1];
B20 = p[f0,2]; B21 = p[f1,2]; B22 = p[f2,2];
113/5: a
113/6: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
113/7: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
113/8: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
113/9: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
113/10: and
113/11: A
113/12: A.shape
113/13: A.shape
113/14: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\magnGeo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
113/15: A
113/16: A
114/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
115/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
116/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
116/2:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo
import numpy as np
import numpy as npy

from scipy import sparse as sp

full = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))

##########################################################################
# Identifications
##########################################################################

for face in full.faces: face.name = 'ambient_face'
for edge in full.edges: edge.name = 'ambient_edges'

full.mat("full")

##########################################################################
# Generating mesh...
##########################################################################

geoOCC = occ.OCCGeometry(full)
ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh(maxh = 30)
# geoOCCmesh.Refine()

mesh = ng.Mesh(geoOCCmesh)
# mesh.Refine()


##########################################################################
# NGSOVLE STUFF...
##########################################################################

# fes = ng.H1(mesh, order = 0)
# fes = ng.HCurl(mesh, order = 0)
fes = ng.HDiv(mesh, order = 0)
print ("Hx dofs:", fes.ndof)
u,v = fes.TnT()

# bfa = ng.BilinearForm(ng.grad(u)*ng.grad(v)*ng.dx).Assemble()
bfa = ng.BilinearForm(u*v*ng.dx).Assemble()
# bfa = ng.BilinearForm(ng.curl(u)*ng.curl(v)*ng.dx).Assemble()
# bfa = ng.BilinearForm(ng.div(u)*ng.div(v)*ng.dx).Assemble()

rows,cols,vals = bfa.mat.COO()
A = sp.csr_matrix((vals,(rows,cols)))

##########################################################################


import sys
sys.path.insert(0,'../../') # adds parent directory
import pde
from sksparse.cholmod import cholesky as chol

order = 3

MESH = pde.mesh3.netgen(geoOCCmesh)
print(MESH)

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)

M = phi_H1 @ D @ phi_H1.T

K = dphix_H1 @ D @ dphix_H1.T +\
    dphiy_H1 @ D @ dphiy_H1.T +\
    dphiz_H1 @ D @ dphiz_H1.T

R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')

Kn = RSS @ K @ RSS.T


phix_Hcurl, phiy_Hcurl, phiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = order)
curlphix_Hcurl, curlphiy_Hcurl, curlphiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = order)
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

M_Hcurl = phix_Hcurl @ D @ phix_Hcurl.T +\
          phiy_Hcurl @ D @ phiy_Hcurl.T +\
          phiz_Hcurl @ D @ phiz_Hcurl.T

K_Hcurl = curlphix_Hcurl @ D @ curlphix_Hcurl.T +\
          curlphiy_Hcurl @ D @ curlphiy_Hcurl.T +\
          curlphiz_Hcurl @ D @ curlphiz_Hcurl.T
          
M_Hdiv = phix_Hdiv @ D @ phix_Hdiv.T +\
         phiy_Hdiv @ D @ phiy_Hdiv.T +\
         phiz_Hdiv @ D @ phiz_Hdiv.T
          
K_Hdiv = divphi_Hdiv @ D @ divphi_Hdiv.T
          
C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T +\
             phiy_Hcurl @ D @ dphiy_H1.T +\
             phiz_Hcurl @ D @ dphiz_H1.T

from scipy.sparse import bmat

AA = bmat([[K_Hcurl, C_Hcurl_H1],
           [C_Hcurl_H1.T, None]])

##########################################################################
# Tree/Cotree gauging
##########################################################################

from mst import *

newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)
    
g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

D = sp.eye(MESH.NoEdges, format = 'csc')

R = D[:,LIST_DOF]

KR = R.T@K_Hcurl@R
##########################################################################


MESH = pde.mesh3.netgen(geoOCCmesh)


##########################################################################








curlphix_Hcurl, curlphiy_Hcurl, curlphiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = order)



regions_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
face_indices = np.where(np.in1d(MESH.f[:,-1],regions_indices))
faces = MESH.f[face_indices]

edges_trigs = npy.r_[npy.c_[faces[:,0],faces[:,1]],
                     npy.c_[faces[:,0],faces[:,2]],
                     npy.c_[faces[:,1],faces[:,2]]]

edges_trigs_unique, je = npy.unique(edges_trigs, axis = 0, return_inverse = True)

edge_indices = pde.intersect2d(MESH.EdgesToVertices[:,:2],edges_trigs_unique)
other_edge_indices = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)

noPoints_interior = np.unique(MESH.EdgesToVertices[other_edge_indices,:2]).size

print(edge_indices.shape)




# LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],edge_indices)
# D = sp.eye(MESH.NoEdges, format = 'csc')
# R = D[:,LIST_DOF]

# K_noEdges = R.T@K_Hcurl@R
# print(K_noEdges.shape,np.linalg.matrix_rank(K_noEdges.A,tol=1e-12))





# LIST_DOF  = np.unique(MESH.FEMLISTS['N0']['B']['LIST_DOF'][indices])
# LIST_DOF2 = np.setdiff1d(np.r_[:MESH.NoEdges],indices)




# print(KR.shape,np.linalg.matrix_rank(KR.A, tol=1e-10))
# print(K_Hcurl.shape,np.linalg.matrix_rank(K_Hcurl.A, tol=1e-10))
# return R1.T.tocsc(),R2.T.tocsc()


FaceNormals = np.zeros((MESH.NoFaces,2))
# for i in range(MESH.NoFaces):
#     p1 = 
    # n = 
    
f = MESH.f; p = MESH.p;
f0 = f[:,0]; f1 = f[:,1]; f2 = f[:,2]
B00 = p[f0,0]; B01 = p[f1,0]; B02 = p[f2,0];
B10 = p[f0,1]; B11 = p[f1,1]; B12 = p[f2,1];
B20 = p[f0,2]; B21 = p[f1,2]; B22 = p[f2,2];
116/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
116/4: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
117/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
118/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
118/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/3: A
118/4: A
118/5: A
118/6: A
118/7: A
118/8: A
118/9: B
118/10: C
118/11: A
118/12: A
118/13: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/14: geoOCC
118/15: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/16: np
118/17: np.linalg
105/11: np.linalg.norm
118/18: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/19: import numpy as np
118/20: sp
118/21: np
118/22: sp.spa
118/23: sp
118/24: np.shape(a)
118/25: ads
118/26: A
118/27: B
118/28: A.A
105/12: A
105/13: A.A
118/29: r
118/30: phi
118/31: phix_Hdiv
118/32: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/33: Kn = RSS @ K @ RSS.T
118/34: R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')
118/35: Kn = RSS @ K @ RSS.T
118/36: Kn
118/37: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/38: phiz_Hcurl
118/39: phiz_Hcurl.shape
118/40: phiz_Hcurl
118/41: phix_Hcurl
118/42: phix_Hcurl
118/43: dphiy_H1_P0
118/44: das
118/45: phiz_Hcurl
105/14: phi_H1
118/46: phiy_Hcurl
118/47: phi_H1
118/48: phiy_Hdiv
118/49: ng.BlockVector
118/50: ng.H1LumpingFESpace
118/51: ng.H1LumpingFESpace()
119/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
118/52: occ.gp_Vec
118/53: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/54: name
118/55: full
118/56: mesh
118/57: geoOCCmesh
118/58: geoOCCmesh
118/59: geoOCCmesh
118/60: geoOCCmesh
118/61: geoOCCmesh
118/62: geoOCCmesh
118/63: geoOCCmesh
118/64: pde.hdiv
118/65: np
118/66: np.linalg
118/67: A
118/68: A.A
118/69: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/70: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/71: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/72: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/73: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/74: MESH
118/75: from t13geo import *
118/76: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
118/77: MESH
119/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
119/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
120/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
120/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
120/3: MESH
120/4: A.shape
120/5: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
120/6: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
120/7: geoOCCmesh
120/8: geoOCCmesh.nodof
120/9: geoOCCmesh.ne
120/10: geoOCCmesh.nt
120/11: geoOCCmesh.ne
120/12: MESH
120/13: geoOCCmesh = geoOCC.GenerateMesh()
120/14: geoOCCmesh.ne
120/15: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
120/16: geoOCCmesh.ne
120/17: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
120/18: geoOCCmesh.ne
120/19: geoOCCmesh
120/20: geoOCCmesh.ne
120/21: geoOCCmesh.Refine()
120/22: geoOCCmesh.ne
120/23: from t13geo import *
120/24: geoOCCmesh.ne
120/25: from t13geo import *
120/26: geoOCCmesh.ne
120/27:
%load_ext autoreload
%autoreload 2
120/28: from t13geo import *
120/29: geoOCCmesh.ne
120/30: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
120/31: geoOCCmesh.ne
120/32: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
120/33: geoOCCmesh.ne
120/34: geoOCCmesh.ne
120/35: geoOCCmesh.ne
120/36: from t13geo import *
120/37: geoOCCmesh.ne
120/38: from t13geo import *
120/39: geoOCCmesh.ne
120/40: from t13geo import *
120/41: geoOCCmesh.ne
121/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
121/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
121/3: from t13geo import *
121/4: geoOCCmesh.ne
121/5: from t13geo import *
121/6: geoOCCmesh.ne
121/7: from t13geo import *
121/8: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
121/9: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
121/10: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\magnetostatics_ngs.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
122/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
122/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\magnetostatics_ngs.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
122/3: A
122/4: A.shape
122/5: A.A
122/6: A
122/7: A.A
122/8: A.shape
122/9: A
122/10: A
122/11: A
122/12: A@A
122/13: (A@A).nnz
122/14: face_in
122/15: A
122/16: A.A
123/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
123/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
123/3: MESH
123/4: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
123/5: MESH
123/6: geoOCCmesh
123/7: geoOCCmesh.ne
124/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
124/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/4: MESH
124/5: geoOCCmesh
124/6: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/7: MESH
124/8:
from t13geo import *

import sys
sys.path.insert(0,'../../') # adds parent directory
import pde
from sksparse.cholmod import cholesky as chol
from scipy import sparse as sp
import numpy as np
import time
import vtk
from scipy.sparse import bmat


MESH = pde.mesh3.netgen(geoOCCmesh)
124/9: MESH
124/10: MESH.f
124/11: MESH.regions_2d
124/12: pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
124/13: MESH.__getattribute__
124/14: MESH.DirectionFaces
124/15: MESH.Boundary_Faces
124/16: MESH.BoundaryFaces_Region
124/17: MESH.BoundaryFaces_Region==6
124/18: MESH.n
124/19: MESH.normals
124/20: MESH.normals(MESH.BoundaryFaces_Region==6)
124/21: MESH.normals(MESH.BoundaryFaces_Region==6,:)
124/22: MESH.normals[MESH.BoundaryFaces_Region==6,:]
124/23: MESH.normals[MESH.BoundaryFaces_Region==2,:]
124/24: MESH.normals[MESH.BoundaryFaces_Region==1,:]
124/25: MESH.normals[MESH.BoundaryFaces_Region==6,:]
124/26: MESH.normals[MESH.BoundaryFaces_Region==pde.tools.getIndices(MESH.regions_2d,'coil_cut_1'),:]
124/27: MESH.normals[MESH.BoundaryFaces_Region==pde.tools.getIndices(MESH.regions_2d,'coil_cut_2'),:]
124/28: MESH.normals[MESH.BoundaryFaces_Region==pde.tools.getIndices(MESH.regions_2d,'coil_face'),:]
124/29: MESH.normals[MESH.BoundaryFaces_Region==pde.tools.getIndices(MESH.regions_2d,'coil_face')[0],:]
124/30: MESH.normals[MESH.BoundaryFaces_Region==pde.tools.getIndices(MESH.regions_2d,'coil_face')[1],:]
124/31: MESH.normals[MESH.BoundaryFaces_Region==pde.tools.getIndices(MESH.regions_2d,'coil_face')[2],:]
124/32: MESH.normals[MESH.BoundaryFaces_Region==pde.tools.getIndices(MESH.regions_2d,'coil_face')[3],:]
124/33: MESH.normals[MESH.BoundaryFaces_Region==pde.tools.getIndices(MESH.regions_2d,'coil_face')[4],:]
124/34: MESH.normals[MESH.BoundaryFaces_Region==pde.tools.getIndices(MESH.regions_2d,'coil_face')[5],:]
124/35: MESH.normals[MESH.BoundaryFaces_Region==pde.tools.getIndices(MESH.regions_2d,'coil_face')[6],:]
124/36: MESH.normals[MESH.BoundaryFaces_Region==0,:]
124/37: MESH.normals[MESH.BoundaryFaces_Region==17,:]
124/38: MESH.normals[MESH.BoundaryFaces_Region==5,:]
124/39: MESH.normals[MESH.BoundaryFaces_Region==15,:]
124/40: MESH.normals[MESH.BoundaryFaces_Region==13,:]
124/41: MESH.normals[MESH.BoundaryFaces_Region==13,:]
124/42: MESH.normals[MESH.BoundaryFaces_Region==19,:]
124/43: MESH.normals[MESH.BoundaryFaces_Region==4,:]
124/44: MESH.normals[MESH.BoundaryFaces_Region==12,:]
124/45:

RZ = pde.tools.removeZeros(M_Hdiv_coil_full)
M_Hdiv_coil = RZ @ M_Hdiv_coil_full @ RZ.T
124/46:

M_Hcurl_coil_full = phix_Hcurl @ D @ unit_coil @ phix_Hcurl.T + \
                    phiy_Hcurl @ D @ unit_coil @ phiy_Hcurl.T + \
                    phiz_Hcurl @ D @ unit_coil @ phiz_Hcurl.T

RZ = pde.tools.removeZeros(M_Hdiv_coil_full)
M_Hdiv_coil = RZ @ M_Hdiv_coil_full @ RZ.T
124/47: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/48: M_Hdiv_coil_full
124/49: RZ
124/50: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/51: r_hdiv
124/52: RZdiv @ r_hdiv
124/53: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/54: MESH.regions_2d
124/55: MESH.regions_3d
124/56: unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
124/57: unit_coil
124/58: unit_coil.nnz
124/59: MESH.regions_2d
124/60: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/61: x
124/62: K
124/63: np.linalg.matrix_rank(K.A)
124/64: RZ
124/65: RSS
124/66: RSS[:-1,:]
124/67: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/68: x
124/69: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/70: x
124/71: x.shape
124/72: MESH
124/73: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/74: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/75: x.max()
124/76: x.min()
124/77: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/78: x.min()
124/79: x.max()
124/80: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/81: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/82: x.max()
124/83: x.min()
124/84: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/85: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/86: R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')
124/87: RSS
124/88: R0
124/89: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/90: x.min()
124/91: x.max()
124/92: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/93: x.max()
124/94: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/95: R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')
124/96: RSS
124/97: RSS.indices
124/98: RSS.indices.shape
124/99: RSS.indices.max()
124/100: RSS.indptr
124/101: RSS.indptr.max()
124/102: RSS.indptr.shape
124/103: R0.indices.shape
124/104: R0.indices
124/105: R0
124/106: R0.A
124/107: RSS
124/108: bmat
124/109: bmat([RSS,R0[1:,:]])
124/110: [RSS,R0[1:,:]]
124/111: bmat([RSS,R0[1:,:]])
124/112: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/113: hstack([RSS,R0[1:,:]])
124/114: hstack((RSS,R0[1:,:]))
124/115: hstack((RSS,R0[:,1:]))
124/116: R0[:,1:]
124/117: RSS
124/118: vstack((RSS,R0[1:,:]))
124/119: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/120: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/121: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/122: A
124/123: R0
124/124: RS
124/125: RSS
124/126: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/127: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/128: phi_H1
124/129: MESH
124/130: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/131: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/132: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/133: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/134: geoOCCcoilmesh.ne
124/135: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
124/136: MESH
124/137: M_Hcurl_coil
124/138: K
124/139: unit_coil
124/140: (RZ.T @ x).shape
124/141: (RZ.T @ x)
124/142: RS
124/143: RS
124/144: R0
124/145: unit_coil
124/146: unit_coil.shape
124/147: np.where(unit_coil)
124/148: np.where(unit_coil.any())
124/149: np.argwhere(unit_coil.any())
124/150: np.argwhere(unit_coil)
124/151: np.argwhere(unit_coil).shape
124/152: 10080/4
124/153: geoOCCcoilmesh.ne
124/154: RZ
124/155: pde.mesh.ngmesh(geoOCCcoilmesh)
124/156: pde.mesh.netgen(geoOCCcoilmesh)
124/157: A = pde.mesh.netgen(geoOCCcoilmesh)
124/158: MESH = pde.mesh.netgen(geoOCCcoilmesh)
124/159: MESH = pde.mesh.netgen(geoOCCcoilmesh)
124/160: MESH = pde.mesh3.netgen(geoOCCmesh)
124/161: geoOCCcoilmesh = geoOCCcoil.GenerateMesh()
124/162: MESH = pde.mesh3.netgen(geoOCCcoilmesh)
124/163: MESH
124/164: MESH = pde.mesh.netgen(geoOCCcoilmesh)
124/165: MESH = pde.mesh3.netgen(geoOCCcoilmesh)
124/166: MESH = pde.mesh3.netgen(geoOCCcoilmesh)
124/167: MESH
124/168: K
124/169: RS
124/170: RZ
124/171: unit_coil
124/172: unit_coil.diagonal()
124/173: unit_coil = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
124/174: unit_coil.diagonal()
124/175: unit_coil.diagonal()==0
124/176: np.sum(unit_coil.diagonal()==0)
124/177: MESH = pde.mesh3.netgen(geoOCCmesh)
124/178: unit_coil = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
124/179: np.sum(unit_coil.diagonal()==0)
124/180: np.sum(unit_coil.diagonal()==1)
124/181: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\magnetostatics_ngs.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
125/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/4: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/5: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/6: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/7: coil_cut
125/8: coil_cut==1
125/9: np.sum(coil_cut==1)
125/10: np.sum(coil_cut~=0)
125/11: np.sum(coil_cut!=0)
125/12: R = phiB_H1 @ DB @ phiB_H1.T
125/13: R
125/14: K
125/15: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/16: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/17: plt
125/18: import matplotlib.pyplot as plt
125/19: plt.spy(R)
125/20: plt.spy(R)
125/21: plt.show()
125/22: plt.show()
125/23: plt.spy(R)
125/24: plt.spy(R,markersize=1)
125/25: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/26: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/27: MESH.normals
125/28: MESH.detB(1,2)
125/29: MESH.detB(0,1)
125/30: phiB_H1
125/31: plt.spy(phiB_H1)
125/32: MESH.NoFaces
125/33: MESH.nf
125/34: MESH.detB
125/35: MESH.normals
125/36: MESH.normals.shape
125/37: MESH
125/38: dnu_phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'dnu', shape = phi_H1.shape, order = order)
125/39: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/40: dnu_phiB_H1
125/41: dnu_phiB_H1
125/42: phiB_H1
125/43: dnu_phiB_H1.max()
125/44: phiB_H1.max()
125/45: R = dnu_phiB_H1 @ DB @ phiB_H1.T
125/46: R-R.T
125/47: (R-R.T).maX()
125/48: (R-R.T).max()
125/49: R+R.T
125/50: (R+R.T).max()
125/51: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/52: (R+R.T).max()
125/53: (R-R.T).max()
125/54: R
125/55: plt.spy(R)
125/56: R+R:T
125/57: R+R.T
125/58: (R+R.T).max()
125/59: (R+R.T).min()
125/60: R
125/61: R = dnu_phiB_H1 @ DB @ phiB_H1.T
125/62: (R+R.T).min()
125/63: (R+R.T).max()
125/64: (R-R.T).max()
125/65: (R-R.T).min()
125/66: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/67: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/68: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/69: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/70: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/71: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/72: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/73: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/74: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/75: (R + 2*R.T + 10*MB)
125/76: (R + 2*R.T + 10*MB).max()
125/77: (R + 2*R.T + 10*MB).min()
125/78: R.max()
125/79: R.min()
125/80: MB.min()
125/81: MB.max()
125/82: M.max()
125/83: M.min()
125/84: DB.max()
125/85: D.max()
125/86: MESH.detB
125/87: MESH.detB(0,0)
125/88: MESH.detB(0,0).max()
125/89: MESH.detA(0,0,0).max()
125/90: np.sqrt(142652154)
125/91: np.sqrt(11943)
125/92: 354527^(1/3)
125/93: 354527**(1/3)
125/94: pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
125/95: face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
125/96: MESH.f
125/97: MESH
125/98: MESH.f
125/99: MESH.Boundary_Faces
125/100: MESH.BoundaryFaces_Region
125/101: MESH.BoundaryFaces_Region==6
125/102: MESH.f
125/103: MESH.f[MESH.BoundaryFaces_Region==6,:]
125/104: MESH.f[MESH.BoundaryFaces_Region==6,1:2]
125/105: MESH.f[MESH.BoundaryFaces_Region==6,1:3]
125/106: MESH.f[MESH.BoundaryFaces_Region==6,1:4]
125/107: MESH.f[MESH.BoundaryFaces_Region==6,:3]
125/108: MESH.f[MESH.BoundaryFaces_Region==6,:3].ravel()
125/109: np.unique(MESH.f[MESH.BoundaryFaces_Region==6,:3].ravel())
125/110:
face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
points_to_duplicate = np.unique(MESH.f[MESH.BoundaryFaces_Region==face_index,:3].ravel())
125/111: points_to_duplicate
125/112: MESH.p[points_to_duplicate,:]
125/113: MESH.t
125/114: MESH.mp
125/115: MESH.mp_tet
125/116: actual_points
125/117:
face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
points_to_duplicate = np.unique(MESH.f[MESH.BoundaryFaces_Region==face_index,:3].ravel())
actual_points = MESH.p[points_to_duplicate,:]
125/118: actual_points
125/119: MESH.f
125/120: MESH.t
125/121: pde.tools.ismember(MESH.t[:,:3],points_to_duplicate)
125/122: a,b = pde.tools.ismember(MESH.t[:,:3],points_to_duplicate)
125/123: a
125/124: b
125/125: points_to_duplicate
125/126: MESH.t
125/127: MESH.t[:,:3]
125/128: MESH.t[:,:4]
125/129: a,b = pde.tools.ismember(MESH.t[:,:4],points_to_duplicate)
125/130: a
125/131: b
125/132: points_to_duplicate
125/133: MESH.t
125/134: a
125/135: MESH.t
125/136: a
125/137: MESH.t
125/138: b
125/139: MESH.t
125/140: a
125/141: b
125/142: MESH.t
125/143: MESH.t[:,:4]
125/144: MESH.t[:,:4]==1
125/145: np.where(MESH.t[:,:4]==1)
125/146: np.argwhere(MESH.t[:,:4]==1)
125/147: MESH[702,:]
125/148: np.where(MESH.t[:,:4]==1)
125/149: np.where(MESH.t[:,:4]==3)
125/150: MESH.t[:,:4]
125/151: MESH.t[:,:4]==3
125/152: np.argwhere(MESH.t[:,:4]==3)
125/153: np.argwhere(MESH.t[:,:4]==3).shape
125/154: np.argwhere(MESH.t[:,:4]==1).shape
125/155: np.argwhere(MESH.t[:,:4]==2).shape
125/156: np.argwhere(MESH.t[:,:4]==3).shape
125/157: np.argwhere(MESH.t[:,:4]==4).shape
125/158: np.argwhere(MESH.t[:,:4]==5).shape
125/159: np.argwhere(MESH.t[:,:4]==6).shape
125/160: np.argwhere(MESH.t[:,:4]==6))
125/161: np.argwhere(MESH.t[:,:4]==6)
125/162: np.argwhere(MESH.t[:,:4].ravel()==6)
125/163: np.argwhere(MESH.t[:,:4].ravel()==6)[0]
125/164: np.argwhere(MESH.t[:,:4].ravel()==6)[:0]
125/165: np.argwhere(MESH.t[:,:4].ravel()==6)[:,0]
125/166: np.argwhere(MESH.t[:,:4].ravel()==6)[:,0].shape
125/167: np.argwhere(MESH.t[:,:4].ravel()==1)[:,0].shape
125/168: np.argwhere(MESH.t[:,:4].ravel()==1)[:,0]
125/169: np.argwhere(MESH.t[:,:4].ravel()==points_to_duplicate[9])[:,0]
125/170: np.argwhere(MESH.t[:,:4].ravel()==points_to_duplicate[i])[:,0]
125/171: np.argwhere(MESH.t[:,:4].ravel()==points_to_duplicate[0])[:,0]
125/172: np.argwhere(MESH.t[:,:4]==points_to_duplicate[0])[:,0]
125/173: MESH.t[297,:]
125/174: points_to_duplicate[0]
125/175: MESH.t[641,:]
125/176: MESH.mp_tet[297,:]
125/177: MESH.mp_tet[297,0]
125/178: points_to_duplicate
125/179: MESh.p
125/180: MESH.p
125/181: MESH.p.append(1)
125/182: MESH.p
125/183: kek = np.r_[MESH.p,MESH.p[0]]
125/184: kek = np.r_[MESH.p,MESH.p[0,:]]
125/185: MESH.p[0,:]
125/186: kek = np.r_[MESH.p,MESH.p[0,:]]
125/187: kek = np.vstack[MESH.p,MESH.p[0,:]]
125/188: kek = np.vstack(MESH.p,MESH.p[0,:])
125/189: kek = np.vstack([MESH.p,MESH.p[0,:]])
125/190: kek
125/191: MESH.shape
125/192: MESH.p.shape
125/193: MESH.p.shape[4132,:]
125/194: MESH.p.shape[4131,:]
125/195: MESH.p.shape[4132,:]
125/196: MESH.p[4132,:]
125/197: MESH.p[4131,:]
125/198: MESH.p[-1,:]
125/199: MESH
125/200: MESH.t[297,:]
125/201: MESH.t[297,:]==5
125/202: MESH.t[297,:]
125/203: MESH.t[297,:3]
125/204: MESH.t[297,:4]
125/205: MESH.t[297,:4]==5
125/206: MESH.t[297,:MESH.t[297,:4]==5]
125/207: MESH.t[297,MESH.t[297,:4]==5]
125/208: MESH.t[297,:]
125/209: MESH.t[297,:4]==5
125/210: MESH.t[297,MESH.t[297,:4]==5]
125/211: MESH.t[297,MESH.t[297,:]==5]
125/212: MESH.t[297,MESH.t[297,:]==5] = 6
125/213: MESH.t[297,MESH.t[297,:]==5] = 6
125/214: MESH.t[297,MESH.t[297,:]==5]
125/215: MESH.t[297,:4]
125/216: MESH.t[297,MESH.t[297,:4]==5]
125/217: MESH.t[297,MESH.t[297,:]==5]
125/218: MESH.p
125/219: MESH.p.shape
125/220: MESH.np
125/221: MESH.p.max()
125/222: MESH.nt.max()
125/223: MESH.t.max()
125/224: MESH.np
125/225: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/226: points_to_duplicate
125/227: range(points_to_duplicate)
125/228: enumerate(points_to_duplicate)
125/229: a,b = enumerate(points_to_duplicate)[0]
125/230: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/231: pnt
125/232: i
125/233: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/234: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/235: tets_containing_points
125/236: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/237: MESH
125/238: MESH.p.shape
125/239: points_to_duplicate.shape
125/240: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/241: t
125/242: t.max()
125/243: MESH
125/244: MESH.np + i
125/245: points_to_duplicate
125/246: pnt
125/247: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/248: t.max()
125/249: t
125/250: t.max()
125/251: MESH
125/252: points_to_duplicate.shape
125/253: MESH.t.max()
125/254: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/255: MESH.t.max()
125/256: t.max()
125/257: MESH.np
125/258: i
125/259: 4132+16
125/260: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/261: t.max()
125/262: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/263: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/264: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/265: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/266: tets_containing_points
125/267: MESH.t[tets_containing_points,:]
125/268: points_to_duplicate
125/269: pnt
125/270: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/271: t.max()
125/272: MESH.t
125/273: t
125/274: MESH.t.max()
125/275: t.max()
125/276: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
126/1:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
126/2:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Comound([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
126/3:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Compound([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
126/4:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Compound([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


# for face in coil.faces: face.name = 'coil_face'
for face in coil_half_box_1.faces: face.name = 'coil_face'
for face in coil_half_box_2.faces: face.name = 'coil_face'

for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
126/5:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Compound([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


# for face in coil.faces: face.name = 'coil_face'
for face in coil_half_box_1.faces: face.name = 'coil_face_1'
for face in coil_half_box_2.faces: face.name = 'coil_face_2'

for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
126/6:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


# for face in coil.faces: face.name = 'coil_face'
for face in coil_half_box_1.faces: face.name = 'coil_face_1'
for face in coil_half_box_2.faces: face.name = 'coil_face_2'

for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
126/7:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


# for face in coil.faces: face.name = 'coil_face'
for face in coil_half_box_1.faces: face.name = 'coil_face_1'
for face in coil_half_box_2.faces: face.name = 'coil_face_2'

for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
126/8:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
# for face in coil_half_box_1.faces: face.name = 'coil_face_1'
# for face in coil_half_box_2.faces: face.name = 'coil_face_2'

for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
126/9:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
# for face in coil_half_box_1.faces: face.name = 'coil_face_1'
# for face in coil_half_box_2.faces: face.name = 'coil_face_2'

for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
125/277: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/278: face_index
125/279: face_index
125/280: points_to_duplicate
125/281: actual_points
125/282: pnt
125/283: i
125/284:
face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
points_to_duplicate = np.unique(MESH.f[MESH.BoundaryFaces_Region == face_index,:3].ravel())
actual_points = MESH.p[points_to_duplicate,:]

t = MESH.t[:,:4].copy()
p = MESH.p.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p = np.vstack([p,p[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            print(i,j,MESH.np+i,pnt,t[j,:])
            t[j,t[j,:]==pnt] = MESH.np + i
125/285: t
125/286: t.amx()
125/287: t.max()
125/288: MESH.t.max()
125/289: face_index
125/290: MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
125/291: points_to_duplicate
125/292: MESH.np
125/293: np.arange(MESH.np,MESH.np+10)
125/294: points_to_duplicate
125/295: points_to_duplicate.size
125/296:
points_to_duplicate = np.unique(MESH.f[MESH.BoundaryFaces_Region == face_index,:3].ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)
125/297: points_to_duplicate
125/298: new_points
125/299: points_to_duplicate.shape
125/300: new_points.shape
125/301: MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
125/302: faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
125/303: faces
125/304:
face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t = MESH.t[:,:4].copy()
p = MESH.p.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p = np.vstack([p,p[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            print(i,j,MESH.np+i,pnt,t[j,:])
            t[j,t[j,:]==pnt] = MESH.np + i
125/305: t.max()
125/306: faces.ravel()
125/307: faces.ravel()
125/308: points_to_duplicate
125/309: new_points
125/310: points_to_duplicate==6
125/311: new_points[points_to_duplicate==6]
125/312: new_points[points_to_duplicate==15]
125/313:

for i,j in enumerate(faces.ravel()):
    new_faces[i] = new_points[points_to_duplicate==j]
125/314:
face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t = MESH.t[:,:4].copy()
p = MESH.p.copy()
f = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p = np.vstack([p,p[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            print(i,j,MESH.np+i,pnt,t[j,:])
            t[j,t[j,:]==pnt] = MESH.np + i

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]
125/315: new_faces
125/316: faces
125/317: f
125/318: f[:,4]
125/319: f[:,3]
125/320: f[:,3].max()
125/321: f[:,3].max()+1
125/322: new_faces
125/323: np.c_[new_faces,f[:,3].max()+1]
125/324: np.c_[new_faces,np.tile(f[:,3].max()+1,(1,17))]
125/325: np.c_[new_faces,np.tile(f[:,3].max()+1,(17,1))]
125/326: points_to_duplicate.size
125/327:

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t = MESH.t[:,:4].copy()
p = MESH.p.copy()
f = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p = np.vstack([p,p[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            print(i,j,MESH.np+i,pnt,t[j,:])
            t[j,t[j,:]==pnt] = MESH.np + i

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f[:,3].max()+1,(points_to_duplicate.size,1))]
125/328: f
125/329: new_faces
125/330: f = np.r_[f,new_faces]
125/331: f
125/332: f.max()
125/333: t.max()
125/334: MESH.region_2d
125/335: MESH.regions_2d
125/336: MESH.regions_2d
125/337: MESH.regions_2d.type()
125/338: MESH.regions_2d.type
125/339: aa = MESH.regions_2d
125/340: regions_2d_new = [MESH.regions_2d,'new']
125/341: regions_2d_new
125/342: regions_2d_new = MESH.regions_2d.append('new')
125/343: regions_2d_new
125/344: regions_2d_new
125/345: MESH.regions_2d
125/346: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/347: regions_2d_new
125/348: MESH_coil = pde.mesh3()
125/349:

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(points_to_duplicate.size,1))]
f_new = np.r_[f_new,new_faces]

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')
125/350: t_new.max()
125/351: p_new.max()
125/352: p_new.shape
125/353: MESH.p.shape
125/354: MESH.f.shape
125/355: f_new.shape
125/356: MESH_coil = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d)
125/357: t_new
125/358: MESH.t
125/359: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/360: t_new
125/361: MESH.t[:,4]
125/362: t_new.shape
125/363: MESH.t[:,4].shape
125/364: np.r_[t_new,MESH.t[:,4]]
125/365: np.c_[t_new,MESH.t[:,4]]
125/366: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/367: t_new
125/368: MESH_coil = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d)
125/369: f_new[:,:3]
125/370: f_new
125/371: MESH.f
125/372: t_new
125/373:
new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(points_to_duplicate.size,1))]
f_new = np.r_[f_new,new_faces].astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

MESH_coil = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d)
125/374: f_new
125/375: np.r_[f_new,new_faces].astype(int)
125/376: f_new = np.r_[f_new,new_faces].astype(uint64)
125/377: np.r_[f_new,new_faces].astype(int)
125/378: np.r_[f_new,new_faces]
125/379: f_new
125/380: f_new = f_new.astype(int)
125/381: f_new
125/382: MESH_coil = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d)
125/383: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/384: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/385: identifications = np.c_[points_to_duplicate,new_points]
125/386: identifications
125/387: identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
125/388: identifications
125/389: MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
125/390: MESH.identifications
125/391: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/392: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/393: dphix_H1.T@x
125/394: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/395: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/396: dx_x
125/397: dx_x.shape
125/398: MESH
125/399: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/400: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/401: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/402: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/403: faces
125/404: new_faces
125/405: MESH.normals
125/406: MESH.f
125/407: MESH.BoundaryFaces_Region
125/408: MESH.BoundaryFaces_Region==6
125/409: MESH.normals[MESH.BoundaryFaces_Region==6,:]
125/410: MESH.normals[MESH.BoundaryFaces_Region==58,:]
125/411: MESH.normals[MESH.BoundaryFaces_Region==1,:]
125/412: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/413: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/414: MESH.normals[MESH.BoundaryFaces_Region==1,:]
125/415: MESH.normals[MESH.BoundaryFaces_Region==6,:]
125/416: t_new
125/417: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/418: MESH.normals.shape
125/419: MESH.f.shape
125/420: np.linalg.norm(MESH.normals)
125/421: np.linalg.norm(MESH.normals,1)
125/422: np.linalg.norm(MESH.normals,2)
125/423: np.linalg.norm(MESH.normals)
125/424: MESH.normals
125/425: np.apply_along_axis(np.linalg.norm, 1, MESH.normals)
125/426: np.apply_along_axis(np.linalg.norm, 1, MESH.normals).max()
125/427: np.apply_along_axis(np.linalg.norm, 1, MESH.normals).min()
125/428: np.apply_along_axis(np.linalg.norm, 1, MESH.normals).shape
125/429: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
125/430: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
127/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
127/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
127/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
127/4: *npy.apply_along_axis(npy.linalg.norm, 1, MESH.normals)
127/5: np.apply_along_axis(np.linalg.norm, 1, MESH.normals)
127/6: np.apply_along_axis(np.linalg.norm, 1, MESH.normals).shape
127/7: face_in.shape
127/8: 9228*3
127/9: 9228/3
127/10: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
127/11: npy.apply_along_axis(npy.linalg.norm, 1, MESH.normals)
127/12: npy.apply_along_axis(npy.linalg.norm, 1, MESH.normals)
127/13: import numpy as npy
127/14: npy.apply_along_axis(npy.linalg.norm, 1, MESH.normals)
127/15: npy.apply_along_axis(npy.linalg.norm, 1, MESH.normals).max()
127/16: npy.apply_along_axis(npy.linalg.norm, 1, MESH.normals).min()
127/17: MESH.normals
127/18: phiB_H1.shape
127/19: phiB_H1
127/20: MESH.normals
127/21: MESH.normals[0,:]
127/22: MESH.normals[:,0]
127/23: MESH.normals[:,0].shape
127/24: phiB_H1
127/25: DB.shape
127/26: DB.diagonal()
127/27: face_in_1
127/28:

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
127/29: face_in_1
127/30: face_in_1.shape
127/31: MESH.normals
127/32: MESH.normals[:,0]
127/33: N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
127/34: N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
128/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
128/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
128/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
128/4: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
129/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
129/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
129/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
129/4: face_in_1
129/5: face_in_1.shape
129/6: N1.shape
129/7: pde.int.assembleN3(MESH, order = order).diagonal()
129/8: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
129/9: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
129/10: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
129/11: N1
129/12: DB
129/13: plt.plot(DB)
129/14: import matplotlib.pyplot as plt
129/15: plt.plot(DB)
129/16: plt.spy(DB)
129/17: plt.show()
130/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
130/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/3: plt.plot(face_in_1)
130/4: import matplotlib.pyplot as plt
130/5: plt.plot(face_in_1)
130/6: plt.show(/)
130/7: plt.show()
130/8: face_in_2*N2 + face_in_3*N3
130/9: (face_in_2*N2 + face_in_3*N3).max()
130/10: (face_in_2*N2 + face_in_3*N3).min()
130/11: face_in_1
130/12: face_in_1.maX()
130/13: face_in_1.max()
130/14: (face_in_1*N1-face_in_1)
130/15: (face_in_1*N1-face_in_1).max()
130/16: (face_in_1*N1-face_in_1).min()
130/17: n1
130/18: N1
130/19: N1[-20]
130/20: N1[-20:]
130/21: face_in_1
130/22: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/23: R0
130/24: R1
130/25: R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')
130/26: R1
130/27: R0
130/28: RS0
130/29: RS1
130/30: R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
130/31: R0
130/32: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/33: R1
130/34: r = RZ @ RS0 @ K @ R1.T @ r
130/35: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/36: r.shape
130/37: R1.T
130/38: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/39: (1+np.zeros(17))
130/40: R1.T @ (1+np.zeros(17))
130/41: K @ R1.T @ (1+np.zeros(17))
130/42: R1.T @ (1+np.zeros(17)).shape
130/43: (R1.T @ (1+np.zeros(17))).shape
130/44: K.shape
130/45: R1
130/46:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T
130/47: K
130/48: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/49: R1.T @ (1+np.zeros(17))
130/50: (R1.T @ (1+np.zeros(17))).shape
130/51: K.shape
130/52: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/53: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/54: dx_x
130/55: dx_y
130/56: dx_x
130/57: dy_x
130/58: dz_x
130/59: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/60: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/61: x.shape
130/62: MESH
130/63: RS1
130/64: RS1.T
130/65: R1.shape
130/66: RS0
130/67: RZ
130/68: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/69: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/70: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/71: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/72: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/73: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/74: dx_x
130/75: dx_x.shape
130/76: MESH
130/77: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/78: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/79: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
130/80: eJx.shape
130/81: D.shape
130/82: phix_Hcurl
130/83: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
131/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/3: eJx.shape
131/4: MESHG
131/5: MESH
131/6: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/7: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/8: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/9: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/10: dx_x_P0
131/11: dy_x_P0
131/12: dz_x_P0
131/13: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/14: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/15: KR
131/16: KR.shape
131/17: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/18: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/19: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/20: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
131/21: K_Hcurl
131/22: np.linalg.matrix_rank(K_Hcurl)
131/23: np.linalg.matrix_rank(K_Hcurl.A)
132/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
132/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
132/3: KR
132/4: R
132/5: MESH
132/6: 27806-4148
132/7: MESH = pde.mesh3.netgen(geoOCCmesh)
132/8: MESH
132/9: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
132/10: R
132/11: MESH
132/12: R
132/13: plt
132/14: import matplotlib.pyplot as plt
132/15: plt.show()
132/16: plt.plot(eJx)
132/17: plt.show()
132/18: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
132/19: plt
132/20: plt.plot(x)
132/21: unit_coil
132/22: unit_coil.shape
132/23: unit_coil.diagonal()
132/24: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
132/25: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
132/26: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
132/27: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
132/28: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
132/29: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
132/30: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
132/31: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
132/32: x
132/33: x.shape
133/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
133/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
133/3: MESH
133/4: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
133/5: MESH
133/6: points_to_duplicate
133/7: points_to_duplicate.shape
133/8: new_faces
133/9: np.c_[new_faces,np.tile(f_new[:,3].max()+1,(points_to_duplicate.size,1))]
133/10: new_faces.shape
133/11: np.tile(f_new[:,3].max()+1,(points_to_duplicate.size,1)).shape
133/12: new_faces
133/13: points_to_duplicate
133/14: f_new[:,3].max()+1
133/15: new_faces.shape
133/16: new_faces.shape[0]
133/17: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
133/18: new_faces.shape[0]
133/19: R1
133/20: R1.shape
133/21: R1.shape[0]
133/22: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
133/23: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
133/24: KR
133/25: MESH
133/26: KR.nnz
133/27: pde.pcg()
133/28: pde.pcg(KR,r)
133/29: KR.shape
133/30: r.shape
133/31:
r = eJx @ D @ phix_Hcurl.T + \
    eJy @ D @ phiy_Hcurl.T + \
    eJz @ D @ phiz_Hcurl.T
133/32: r.shape
133/33: pde.pcg(KR,R.T@r)
133/34: x = cholKR.solve_A(R.T@r)
133/35:
import vtklib

grid = vtklib.createVTK(MESH)
vtklib.add_H1_Scalar(grid, phi_j, 'lel')
vtklib.add_L2_Vector(grid,evJx,evJy,evJz,'kek')
vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'kek2')
vtklib.add_L2_Vector(grid,ux,uy,uz,'kek3')

vtklib.add_L2_Scalar(grid,dx_x_P0**2+dy_x_P0**2+dz_x_P0**2,'kek2magn')
vtklib.add_L2_Scalar(grid,ux**2+uy**2+uz**2,'kek3norm')
vtklib.writeVTK(grid, 'das2.vtu')
133/36:
from mst import *

newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
133/37: MESH = pde.mesh3.netgen(geoOCCmesh)
133/38: from solve_t13_strom import *
133/39: MESH
133/40:
order = 1

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')
133/41:
M = phi_H1 @ D @ phi_H1.T

K = dphix_H1 @ D @ dphix_H1.T + \
    dphiy_H1 @ D @ dphiy_H1.T + \
    dphiz_H1 @ D @ dphiz_H1.T
133/42:

Kn = RSS @ K @ RSS.T

phix_Hcurl, phiy_Hcurl, phiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = order)
curlphix_Hcurl, curlphiy_Hcurl, curlphiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = order)
133/43:

M_Hcurl = phix_Hcurl @ D @ phix_Hcurl.T + \
          phiy_Hcurl @ D @ phiy_Hcurl.T + \
          phiz_Hcurl @ D @ phiz_Hcurl.T

K_Hcurl = curlphix_Hcurl @ D @ curlphix_Hcurl.T + \
          curlphiy_Hcurl @ D @ curlphiy_Hcurl.T + \
          curlphiz_Hcurl @ D @ curlphiz_Hcurl.T

C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T + \
             phiy_Hcurl @ D @ dphiy_H1.T + \
             phiz_Hcurl @ D @ dphiz_H1.T

curlphix_Hcurl_P0, curlphiy_Hcurl_P0, curlphiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = 0)
phix_Hcurl_P0, phiy_Hcurl_P0, phiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = 0)
dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
133/44: cholKR = chol(KR)
134/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
134/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
135/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
135/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
135/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
136/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
136/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
136/3: x
136/4: KR@x-R.T@r
136/5: KR@R@x-R.T@r
136/6: KR@R@x
136/7: KR@R.T@x
136/8: KR@R.T@x-R.T@r
136/9: pde.pcg(KR,R.T@r,output=True)
136/10: pde.pcg(KR,R.T@r,output=True)
136/11: pde.pcg(KR,R.T@r,maxit = 200, output=True)
136/12: KR.shape
136/13: KR.nnz
136/14: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
137/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
137/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
137/3: pde.pcg(KR,R.T@r,maxit = 200, output=True)
137/4: pde.pcg(KR,R.T@r,maxit = 300, output=True)
137/5: pde.pcg(KR,R.T@r,maxit = 3000, output=True)
137/6: pde.pcg(KR,R.T@r,maxit = 10_000, output=True)
137/7: KR
137/8: pde.pcg(KR,R.T@r,maxit = 20_000, output=True)
137/9: pde.pcg(KR,R.T@r,maxit = 40_000, output=True)
137/10: KR
137/11: pde.pcg(KR,R.T@r,maxit = 40_000, output=True, pfun = lambda x: 1/x)
137/12: pde.pcg(KR,R.T@r,maxit = 40_000, output=True, pfuns = lambda x: 1/x)
138/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
138/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/3: M
138/4: K
138/5: MR = R.T@M_Hcurl@R
138/6: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/7: MR
138/8: KR
138/9: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/10: (1/MR.diagonal())
138/11: (1/MR.diagonal()).shape
138/12: sp.spdiags((1/MR.diagonal()))
138/13: sp.sparse((1/MR.diagonal()))
138/14: sp.csc((1/MR.diagonal()))
138/15: ((1/MR.diagonal()))
138/16: spdiags(1/MR.diagonal(), 0)
138/17: sp.spdiags(1/MR.diagonal(), 0)
138/18: sp.spdiags(1/MR.diagonal(), 0,MESH.np,MESH.np)
138/19: 1/MR.diagonal().shape
138/20: (1/MR.diagonal()).shape
138/21: MESH
138/22: MR
138/23: MR.shape
138/24: sp.spdiags(1/MR.diagonal(), 0,MR.shape)
138/25: x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(1/MR.diagonal(), 0,MR.shape)@x)
138/26:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(1/MR.diagonal(), 0,MR.shape)@x)
x = pde.pcg(KR,R.T@r,output=True)
138/27:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(1e6+0*1/MR.diagonal(), 0,MR.shape)@x)
x = pde.pcg(KR,R.T@r,output=True)
138/28:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(1e10+0*1/MR.diagonal(), 0,MR.shape)@x)
x = pde.pcg(KR,R.T@r,output=True)
138/29:

x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(1e4+0*1/MR.diagonal(), 0,MR.shape)@x,maxit=1000)
x = pde.pcg(KR,R.T@r,output=True,maxit=1000)
138/30: KR
138/31: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/32:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(1/MR.diagonal(), 0,MR.shape)@x,maxit=10000)
x = pde.pcg(KR,R.T@r,output=True,maxit=10000)
138/33:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(MR.diagonal(), 0,MR.shape)@x,maxit=10000)
x = pde.pcg(KR,R.T@r,output=True,maxit=10000)
138/34: np.arange(1000)
138/35: np.arange(1000)+1
138/36: 1/(np.arange(1000)+1)
138/37: 1/(np.arange(MR.shape[0])+1)
138/38:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(MR.diagonal(), 0,MR.shape)@x,maxit=1000)
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : 10**4*1/(np.arange(MR.shape[0])+1)@x,maxit=1000)
x = pde.pcg(KR,R.T@r,output=True,maxit=1000)
138/39:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(MR.diagonal(), 0,MR.shape)@x,maxit=1000)
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(10**4*1/(np.arange(MR.shape[0])+1), 0,MR.shape)@x,maxit=1000)
x = pde.pcg(KR,R.T@r,output=True,maxit=1000)
138/40:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(MR.diagonal(), 0,MR.shape)@x,maxit=1000)
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(10**4*(np.arange(MR.shape[0])+1), 0,MR.shape)@x,maxit=1000)
x = pde.pcg(KR,R.T@r,output=True,maxit=1000)
138/41:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(MR.diagonal(), 0,MR.shape)@x,maxit=1000)
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(10**5*(np.arange(MR.shape[0])+1), 0,MR.shape)@x,maxit=1000)
x = pde.pcg(KR,R.T@r,output=True,maxit=1000)
138/42:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(MR.diagonal(), 0,MR.shape)@x,maxit=1000)
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(1*(np.arange(MR.shape[0])+1), 0,MR.shape)@x,maxit=1000)
x = pde.pcg(KR,R.T@r,output=True,maxit=1000)
138/43:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(MR.diagonal(), 0,MR.shape)@x,maxit=10000)
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(1*(np.arange(MR.shape[0])+1), 0,MR.shape)@x,maxit=10000)
x = pde.pcg(KR,R.T@r,output=True,maxit=10000)
138/44:
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(MR.diagonal(), 0,MR.shape)@x,maxit=10000)
x = pde.pcg(KR,R.T@r,output=True,pfuns = lambda x : sp.spdiags(10**(-6)*(np.arange(MR.shape[0])+1), 0,MR.shape)@x,maxit=10000)
x = pde.pcg(KR,R.T@r,output=True,maxit=10000)
138/45: x = pde.pcg(KR,R.T@r,output=True,maxit=1e14,tol=1e-5)
138/46: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/47: LIST_DOF
138/48: newListOfEdges
138/49: MESH.EdgesToVertices[:,:2]
138/50: random.permutation(10)
138/51: np.random.permutation(10)
138/52: MESH.EdgesToVertices[:,:2].shape
138/53: MESH.EdgesToVertices[:,:2].shape[0]
138/54: MESH.EdgesToVertices[:,:2].shape[0]
138/55: np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
138/56: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/57: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/58: LIST_DOF
138/59: random
138/60: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/61: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/62: runfile('\\solve_t13_strom.py')
138/63: random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
138/64: random.shape
138/65: random.max()
138/66: R
138/67: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/68: R
138/69: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/70: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/71: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/72: LIST_DOF
138/73: newListOfEdges
138/74: R
138/75: MESH
138/76: 27728-4131
138/77: KR
138/78: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/79: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/80: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/81: R
138/82: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/83: runfile('\\solve_t13_strom.py')
138/84: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/85: runfile('\\solve_t13_strom.py')
138/86: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/87: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/88: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/89: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/90: R
138/91: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/92: R
138/93: MESH
138/94: 27728-4132+1
138/95: LIST_DOF
138/96: plt
138/97: import matplotlib.pyplot as plt
138/98: np.unique(LIST_DOF).shape
138/99: LIST_DOF.shape
138/100: indices
138/101:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
138/102: indices
138/103:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/104:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/105:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/106:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/107:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/108:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/109:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/110:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/111:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/112:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/113:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/114:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/115:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/116:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/117:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/118:
from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]

# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)

g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
print(indices)
138/119: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/120: runfile('\\solve_t13_strom.py')
138/121: runfile('\\solve_t13_strom.py')
138/122: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/123: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/124: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
138/125: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
139/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
139/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
140/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
140/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
140/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
140/4: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
140/5: RSS
140/6: R
140/7: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
140/8: KR
140/9: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
140/10: KR
140/11: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
140/12: R.T@K_Hcurl@R
140/13: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
141/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/3: R.T@K_Hcurl@R
141/4: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/5: KR
141/6: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/7: KR
141/8: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/9: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/10: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/11: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/12: runfile('\\solve_t13.py')
141/13: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/14: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/15: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/16: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/17: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/18: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/19: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/20: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/21: newListOfEdges
141/22: MESH.EdgesToVertices[:,:2]
141/23:
random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]
141/24: newListOfEdges
141/25: LIST_DOF
141/26: indices
141/27: random
141/28: random.shape
141/29: indices.shape
141/30: newListOfEdges
141/31: random
141/32: newListOfEdges
141/33: random
141/34: random[indices]
141/35: random[indices].shape
141/36: indices.shape
141/37: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/38: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/39: runfile('\\solve_t13.py')
141/40: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/41: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/42: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/43: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/44: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/45: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/46: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/47: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\unit_cube.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/48: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/49: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/50: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/51: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/52: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/53: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/54: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
142/1:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
142/2:
import ngsolve as ng
import netgen.occ as occ
# import netgen.gui
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
# for face in coil_half_box_1.faces: face.name = 'coil_face_1'
# for face in coil_half_box_2.faces: face.name = 'coil_face_2'

for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
142/3:
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
# for face in coil_half_box_1.faces: face.name = 'coil_face_1'
# for face in coil_half_box_2.faces: face.name = 'coil_face_2'

for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});
# DrawGeo(coil, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()

DrawGeo(geoOCCmesh)
142/4:
import ngsolve as ng
import netgen.occ as occ

# import netgen.gui
# from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")

##########################################################################
# Generating mesh...
##########################################################################

geoOCC = occ.OCCGeometry(full)
# ng.Draw(geoOCC)

geoOCCmesh = geoOCC.GenerateMesh()
# geoOCCmesh.Refine()
# geoOCCmesh.Refine()
142/5:
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'

for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
geoOCCmesh = geoOCC.GenerateMesh()

DrawGeo(geoOCCmesh)
142/6:
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'

for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
geoOCCmesh = geoOCC.GenerateMesh()

DrawGeo(geoOCCmesh, clipping={"z":-1, "dist":64})
142/7:
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

    
half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'

for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")
    
##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################

DrawGeo(full, clipping={"z":-1, "dist":64});

geoOCC = occ.OCCGeometry(full)
geoOCCmesh = geoOCC.GenerateMesh()

DrawGeo(geoOCCmesh, clipping={"z":-1, "dist":64})
142/8:
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])


##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")


geoOCC = occ.OCCGeometry(full)
geoOCCmesh = geoOCC.GenerateMesh()

DrawGeo(full, clipping={"z":-1, "dist":64});
DrawGeo(geoOCCmesh, clipping={"z":-1, "dist":64})
142/9:
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])

##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")


geoOCC = occ.OCCGeometry(full)
geoOCCmesh = geoOCC.GenerateMesh()

DrawGeo(full, clipping={"z":-1, "dist":64});
DrawGeo(geoOCCmesh, clipping={"z":-1, "dist":64})
142/10:
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])

##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")


geoOCC = occ.OCCGeometry(full)
geoOCCmesh = geoOCC.GenerateMesh()

DrawGeo(full, clipping={"z":-1, "dist":64});
DrawGeo(geoOCCmesh, clipping={"z":-1, "dist":64})
142/11:
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])

##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")


geoOCC = occ.OCCGeometry(full)
geoOCCmesh = geoOCC.GenerateMesh()

DrawGeo(full, clipping={"z":-1, "dist":64});
DrawGeo(geoOCCmesh, clipping={"z":-1, "dist":64})
144/1: %run TEAM_13_geometry.ipynb
145/1: %run TEAM_13_geometry.ipynb
145/2:
%%capture
%run TEAM_13_geometry.ipynb
145/3: geoOCCmesh
145/4:
%%capture
%run TEAM_13_geometry.ipynb
145/5: geoOCCmesh
145/6: $\newcommand{\vect}[1]{{\mathbf{\boldsymbol{{#1}}}}}$
145/7: $\newcommand{\vect}[1]{{\mathbf{\boldsymbol{{#1}}}}$
145/8:
$\newcommand{\vect}[1]{{\mathbf{\boldsymbol{{#1}}}}}$
This is the vector $\vect{x}$.
145/9: $\vect{x}$
146/1:
%%capture
%run TEAM_13_geometry.ipynb
146/2: geoOCCmesh
146/3:
%%capture
%run TEAM_13_geometry.ipynb
146/4:
%%capture
%run TEAM_13_geometry.ipynb
146/5:
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
146/6:
import sys
sys.path.insert(0,'../../../') # adds parent directory
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
146/7:
import sys
sys.path.insert(0,'../../../../') # adds parent directory
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
146/8:
import sys
sys.path.insert(0,'../../../') # adds parent directory
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
146/9: sys.path
146/10:
%%capture
%run TEAM_13_geometry.ipynb
146/11:
import sys
sys.path.insert(0,'../../../') # adds parent directory
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
146/12:
import sys
sys.path.insert(0,'../../../') # adds parent directory
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
146/13: sys.path
146/14: pde
147/1:

#####################################################################################################################
Mperp_mag1 = np.array([-0.507223091788922, 0.861814791678634])
Mperp_mag2 = np.array([-0.250741225095427, 0.968054150364350])
Mperp_mag3 = (-1)*np.array([-0.968055971101187, 0.250734195544481])
Mperp_mag4 = (-1)*np.array([-0.861818474866413, 0.507216833690415])
Mperp_mag5 = np.array([-0.861814791678634, -0.507223091788922])
Mperp_mag6 = np.array([-0.968054150364350, -0.250741225095427])
Mperp_mag7 = (-1)*np.array([-0.250734195544481, -0.968055971101187])
Mperp_mag8 = (-1)*np.array([-0.507216833690415, -0.861818474866413])
Mperp_mag9 = np.array([0.507223091788922, -0.861814791678634])
Mperp_mag10 = np.array([0.250741225095427, -0.968054150364350])
Mperp_mag11 = (-1)*np.array([0.968055971101187, -0.250734195544481])
Mperp_mag12 = (-1)*np.array([0.861818474866413, -0.507216833690415])
Mperp_mag13 = np.array([0.861814791678634, 0.507223091788922])
Mperp_mag14 = np.array([0.968054150364350, 0.250741225095427])
Mperp_mag15 = (-1)*np.array([0.250734195544481, 0.968055971101187])
Mperp_mag16 = (-1)*np.array([0.507216833690415, 0.861818474866413])

Mperp_mag = np.c_[Mperp_mag1,Mperp_mag2, Mperp_mag3, Mperp_mag4, Mperp_mag5, Mperp_mag6, Mperp_mag7, Mperp_mag8,
                  Mperp_mag9,Mperp_mag10,Mperp_mag11,Mperp_mag12,Mperp_mag13,Mperp_mag14,Mperp_mag15,Mperp_mag16]

m = np.c_[Mperp_mag[1,:],-Mperp_mag[0,:]].T
nu0 = 10**7/(4*np.pi)
m = m*nu0*1.158095238095238
#####################################################################################################################




#####################################################################################################################
offset = 0
polepairs  = 4
gamma_correction_model = -30.0
gamma = 40.0
gamma_correction_timestep = -1
phi0 = (gamma + gamma_correction_model + gamma_correction_timestep * polepairs) * np.pi/180.0



def f48(s):
    return (s-1)%48
    
area_coils_UPlus  = np.r_[f48(offset+1) , f48(offset+2)]
area_coils_VMinus = np.r_[f48(offset+3) , f48(offset+4)]
area_coils_WPlus  = np.r_[f48(offset+5) , f48(offset+6)]
area_coils_UMinus = np.r_[f48(offset+7) , f48(offset+8)]
area_coils_VPlus  = np.r_[f48(offset+9) , f48(offset+10)]
area_coils_WMinus = np.r_[f48(offset+11), f48(offset+12)]

for k in range(1,4):
    area_coils_UPlus = np.r_[area_coils_UPlus, f48(k*12+offset+1)]
    area_coils_UPlus = np.r_[area_coils_UPlus, f48(k*12+offset+2)]
    
    area_coils_VMinus = np.r_[area_coils_VMinus, f48(k*12+offset+3)]
    area_coils_VMinus = np.r_[area_coils_VMinus, f48(k*12+offset+4)]
    
    area_coils_WPlus = np.r_[area_coils_WPlus, f48(k*12+offset+5)]
    area_coils_WPlus = np.r_[area_coils_WPlus, f48(k*12+offset+6)]
    
    area_coils_UMinus = np.r_[area_coils_UMinus, f48(k*12+offset+7)]
    area_coils_UMinus = np.r_[area_coils_UMinus, f48(k*12+offset+8)]
    
    area_coils_VPlus = np.r_[area_coils_VPlus, f48(k*12+offset+9)]
    area_coils_VPlus = np.r_[area_coils_VPlus, f48(k*12+offset+10)]
    
    area_coils_WMinus = np.r_[area_coils_WMinus, f48(k*12+offset+11)]
    area_coils_WMinus = np.r_[area_coils_WMinus, f48(k*12+offset+12)]
    
    
I0peak = 1555.63491861 ### *1.5
phase_shift_I1 = 0.0
phase_shift_I2 = 2/3*np.pi#4/3*pi
phase_shift_I3 = 4/3*np.pi#2/3*pi

I1c = I0peak * np.sin(phi0 + phase_shift_I1)
I2c = (-1)* I0peak * np.sin(phi0 + phase_shift_I2)
I3c = I0peak * np.sin(phi0 + phase_shift_I3)

areaOfOneCoil = 0.00018053718538758062

UPlus  =  I1c* 2.75 / areaOfOneCoil
VMinus =  I2c* 2.75 / areaOfOneCoil

WPlus  =  I3c* 2.75 / areaOfOneCoil
UMinus = -I1c* 2.75 / areaOfOneCoil

VPlus  = -I2c* 2.75 / areaOfOneCoil
WMinus = -I3c* 2.75 / areaOfOneCoil
    
j3 = np.zeros(48)
j3[area_coils_UPlus]  = UPlus
j3[area_coils_VMinus] = VMinus
j3[area_coils_WPlus]  = WPlus
j3[area_coils_UMinus] = UMinus
j3[area_coils_VPlus]  = VPlus
j3[area_coils_WMinus] = WMinus
#####################################################################################################################

import sys
sys.path.insert(0,'../../../') # adds parent directory

import pde
import plotly.io as pio
pio.renderers.default = "notebook"


MESH = pde.mesh.netgen(geoOCCmesh)

ind_air_all = np.flatnonzero(np.core.defchararray.find(MESH.regions_2d,'air')!=-1)
ind_stator_rotor = np.flatnonzero(np.core.defchararray.find(MESH.regions_2d,'iron')!=-1)
ind_magnet = np.flatnonzero(np.core.defchararray.find(MESH.regions_2d,'magnet')!=-1)
ind_coil = np.flatnonzero(np.core.defchararray.find(MESH.regions_2d,'coil')!=-1)
ind_shaft = np.flatnonzero(np.core.defchararray.find(MESH.regions_2d,'shaft')!=-1)

trig_air_all = np.where(np.isin(MESH.t[:,-1],ind_air_all))
trig_stator_rotor = np.where(np.isin(MESH.t[:,-1],ind_stator_rotor))
trig_magnet = np.where(np.isin(MESH.t[:,-1],ind_magnet))
trig_coil = np.where(np.isin(MESH.t[:,-1],ind_coil))
trig_shaft = np.where(np.isin(MESH.t[:,-1],ind_shaft))

vek = np.zeros(MESH.nt)
vek[trig_air_all] = 1
vek[trig_magnet] = 2
vek[trig_coil] = 3
vek[trig_stator_rotor] = 4
vek[trig_shaft] = 3.6

# fig = MESH.pdemesh()
# fig = MESH.pdesurf(vek)
# fig.show()

print(np.where(MESH.e[:,2]==23)[0].shape)
print(np.where(MESH.e[:,2]==25)[0].shape)
147/2:
origin = (0,0)
# inner radius rotor
r1 = 26.5*10**(-3)
# outer radius rotor
r2 = 78.63225*10**(-3)
# sliding mesh rotor
r4 = 78.8354999*10**(-3)
# sliding mesh stator
r6 = 79.03874999*10**(-3)
# inner radius stator
r7 = 79.242*10**(-3)
# outer radius stator
r8 = 116*10**(-3)

# Points for magnet1 and air around magnet1
m1 = (69.23112999*10**(-3),7.535512*10**(-3))
m2 = (74.828958945*10**(-3),10.830092744*10**(-3))
m3 = (66.13621099700001*10**(-3),25.599935335*10**(-3))
m4 = (60.53713*10**(-3),22.30748*10**(-3))
a5 = (69.75636*10**(-3),5.749913*10**(-3))
a6 = (75.06735*10**(-3),3.810523*10**(-3))
a7 = (65.6868747*10**(-3),26.3184618*10**(-3))
# a7 = (65.3506200*10**(-3),26.51379*10**(-3))
a8 = (59.942145092*10**(-3),24.083661604*10**(-3))

# Points for magnet2 and air around magnet2
m5 = (58.579985516*10**(-3), 27.032444757*10**(-3))
m6 = (64.867251151*10**(-3),28.663475405*10**(-3))
m7 = (60.570096319*10**(-3),45.254032279*10**(-3))
m8 = (54.282213127*10**(-3),43.625389857*10**(-3))
a1 = (53.39099766*10**(-3),45.259392713*10**(-3))
a2 = (55.775078884*10**(-3),50.386185578*10**(-3))
a3 = (59.41521771*10**(-3),25.355776837*10**(-3))
a4 = (65.12210917100001*10**(-3),27.707477175*10**(-3))

# Points for Stator Nut and air in the stator
s1 = (79.04329892000*10**(-3),3.9538335974*10**(-3))
s2 = (80.143057128*10**(-3),4.0037794254*10**(-3))
s3 = (80.387321219*10**(-3),2.965459706*10**(-3))
s4 = (98.78501315600001*10**(-3),3.9007973292*10**(-3))
s5 = (98.44904989600001*10**(-3),9.026606148400001*10**(-3))
s6 = (80.086666706*10**(-3),7.5525611543*10**(-3))
s7 = (79.980020247*10**(-3),6.4912415424*10**(-3))
s8 = (78.88229587*10**(-3),6.4102654448*10**(-3))
147/3:
import numpy as np
import netgen.occ as occ
from numpy import sin, cos, pi

def rotate(m,k,p):
    a = np.pi/p
    mx = m[0]*np.cos(k*a) -m[1]*np.sin(k*a)
    my = m[0]*np.sin(k*a) +m[1]*np.cos(k*a)
    return (mx, my, 0)

def drawMagnet1(k):
    m1new = rotate(m1,k,4); m2new = rotate(m2,k,4)
    m3new = rotate(m3,k,4); m4new = rotate(m4,k,4)

    a5new = rotate(a5,k,4); a6new = rotate(a6,k,4)
    a7new = rotate(a7,k,4); a8new = rotate(a8,k,4)

    #Draw magnet
    seg1 = occ.Segment(m1new,m2new); seg2 = occ.Segment(m2new,m3new)
    seg3 = occ.Segment(m3new,m4new); seg4 = occ.Segment(m4new,m1new)
    magnet1 = occ.Face(occ.Wire([seg1,seg2,seg3,seg4]))
    
    #Draw air around magnet
    air_seg1 = occ.Segment(m1new,a5new); air_seg2 = occ.Segment(a5new,a6new)
    air_seg3 = occ.Segment(a6new,m2new); air_seg4 = occ.Segment(m2new,m1new)
    air_magnet1_1 = occ.Face(occ.Wire([air_seg1,air_seg2,air_seg3,air_seg4]))
    
    air_seg5 = occ.Segment(m4new,m3new); air_seg6 = occ.Segment(m3new,a7new)
    air_seg7 = occ.Segment(a7new,a8new); air_seg8 = occ.Segment(a8new,m4new)
    air_magnet1_2 = occ.Face(occ.Wire([air_seg5,air_seg6,air_seg7,air_seg8]))

    return (magnet1,air_magnet1_1,air_magnet1_2)

def drawMagnet2(k):
    m5new = rotate(m5,k,4); m6new = rotate(m6,k,4)
    m7new = rotate(m7,k,4); m8new = rotate(m8,k,4)

    a1new = rotate(a1,k,4); a2new = rotate(a2,k,4)
    a3new = rotate(a3,k,4); a4new = rotate(a4,k,4)

    #Draw magnet
    seg1 = occ.Segment(m5new,m6new); seg2 = occ.Segment(m6new,m7new)
    seg3 = occ.Segment(m7new,m8new); seg4 = occ.Segment(m8new,m5new)
    magnet2 = occ.Face(occ.Wire([seg1,seg2,seg3,seg4]))

    #Draw air around magnet
    air_seg1 = occ.Segment(m5new,a3new); air_seg2 = occ.Segment(a3new,a4new)
    air_seg3 = occ.Segment(a4new,m6new); air_seg4 = occ.Segment(m6new,m5new)
    air_magnet2_1 = occ.Face(occ.Wire([air_seg1,air_seg2,air_seg3,air_seg4]))
    
    air_seg5 = occ.Segment(m8new,m7new); air_seg6 = occ.Segment(m7new,a2new)
    air_seg7 = occ.Segment(a2new,a1new); air_seg8 = occ.Segment(a1new,m8new)
    air_magnet2_2 = occ.Face(occ.Wire([air_seg5,air_seg6,air_seg7,air_seg8]))

    return (magnet2,air_magnet2_1,air_magnet2_2)

def drawStatorNut(k):

    s1new = rotate(s1,k,24); s2new = rotate(s2,k,24)
    s3new = rotate(s3,k,24); s4new = rotate(s4,k,24)
    s5new = rotate(s5,k,24); s6new = rotate(s6,k,24)
    s7new = rotate(s7,k,24); s8new = rotate(s8,k,24)

    #Draw stator coil
    seg1 = occ.Segment(s2new,s3new); seg2 = occ.Segment(s3new,s4new)
    seg3 = occ.Segment(s4new,s5new); seg4 = occ.Segment(s5new,s6new)
    seg5 = occ.Segment(s6new,s7new); seg6 = occ.Segment(s7new,s2new)
    stator_coil = occ.Face(occ.Wire([seg1,seg2,seg3,seg4,seg5,seg6]))
    
    #Draw air nut in the stator
    air_seg1 = occ.Segment(s1new,s2new); air_seg2 = occ.Segment(s2new,s7new)
    air_seg3 = occ.Segment(s7new,s8new); air_seg4 = occ.Segment(s8new,s1new)
    stator_air = occ.Face(occ.Wire([air_seg1,air_seg2,air_seg3,air_seg4]))

    stator_air = stator_air-(stator_air*air_gap_stator)
    return (stator_coil,stator_air)
147/4:
domains = []

h_max = 1

h_air_gap = r6-r4 #0.05*h_max
h_air_magnets = h_max
h_coils = h_max
h_stator_air = h_max
h_magnets = h_max
h_stator_iron = h_max
h_rotor_iron = h_max
h_shaft_iron = h_max

rotor_inner  = occ.Circle(origin,r=r1).Face()
rotor_outer  = occ.Circle(origin,r=r2).Face()
sliding_inner  = occ.Circle(origin,r=r4).Face()
sliding_outer  = occ.Circle(origin,r=r6).Face()
stator_inner = occ.Circle(origin,r=r7).Face()
stator_outer = occ.Circle(origin,r=r8).Face()

rotor_inner.edges[0].name = "rotor_inner"
rotor_outer.edges[0].name = "rotor_outer"
stator_inner.edges[0].name = "stator_inner"
stator_outer.edges[0].name = "stator_outer"

rotor_iron = rotor_outer - rotor_inner

air_gap_stator = stator_inner - sliding_outer
# air_gap = sliding_outer - sliding_inner
air_gap_rotor = sliding_inner - rotor_outer

stator_iron = stator_outer - stator_inner

for k in range(48):
    (stator_coil,stator_air) = drawStatorNut(k)

    stator_coil.faces.name = "coil" + str(k)
    stator_air.faces.name = "air"

    stator_iron -= stator_coil
    stator_iron -= stator_air

    domains.append(stator_coil)
    domains.append(stator_air)

for k in range(8):
    (magnet1,air_magnet1_1,air_magnet1_2) = drawMagnet1(k)
    (magnet2,air_magnet2_1,air_magnet2_2) = drawMagnet2(k)

    magnet1.faces.name = "magnet" + str(2*k+1)
    magnet1.faces.maxh = h_magnets
    magnet1.edges[0].name = "magnets_interface"
    magnet1.edges[1].name = "magnets_interface"
    magnet1.edges[2].name = "magnets_interface"
    magnet1.edges[3].name = "magnets_interface"

    magnet2.faces.name = "magnet" + str(2*k+2)
    magnet2.faces.maxh = h_magnets
    magnet2.edges[0].name = "magnets_interface"
    magnet2.edges[1].name = "magnets_interface"
    magnet2.edges[2].name = "magnets_interface"
    magnet2.edges[3].name = "magnets_interface"

    air_magnet1_1.faces.name = "rotor_air"
    air_magnet1_2.faces.name = "rotor_air"
    air_magnet2_1.faces.name = "rotor_air"
    air_magnet2_2.faces.name = "rotor_air"

    air_magnet1_1.faces.maxh = h_air_magnets
    air_magnet1_2.faces.maxh = h_air_magnets
    air_magnet2_1.faces.maxh = h_air_magnets
    air_magnet2_2.faces.maxh = h_air_magnets

    rotor_iron -= magnet1
    rotor_iron -= air_magnet1_1
    rotor_iron -= air_magnet1_2
    rotor_iron -= magnet2
    rotor_iron -= air_magnet2_1
    rotor_iron -= air_magnet2_2

    domains.append(magnet1)
    domains.append(magnet2)
    domains.append(air_magnet1_1)
    domains.append(air_magnet1_2)
    domains.append(air_magnet2_1)
    domains.append(air_magnet2_2)

stator_iron.faces.name = "stator_iron"
stator_iron.faces.maxh = h_stator_iron

air_gap_stator.faces.name = "air_gap_stator"
air_gap_stator.faces.maxh = h_air_gap

# air_gap.faces.name = "air_gap"
# air_gap.faces.maxh = h_air_gap

air_gap_rotor.faces.name = "air_gap_rotor"
air_gap_rotor.faces.maxh = 0.998*h_air_gap

rotor_iron.faces.name = "rotor_iron"
rotor_iron.faces.maxh = h_rotor_iron

shaft_iron = rotor_inner
shaft_iron.faces.name = "shaft_iron"
shaft_iron.faces.maxh = h_shaft_iron

domains.append(shaft_iron)
domains.append(rotor_iron)
domains.append(air_gap_stator)
# domains.append(air_gap)
domains.append(air_gap_rotor)
domains.append(stator_iron)

geo = occ.Glue(domains)

if pizza_slice:
    pizza = occ.MoveTo(*origin).Line(1).Rotate(90).Line(1).Close().Face()

    geo = pizza*occ.Glue(domains)

    geo.edges[0].name = "left"
    geo.edges[4].name = "left"
    geo.edges[24].name = "left"
#     geo.edges[28].name = "left"
    geo.edges[28].name = "left"
    geo.edges[92].name = "left"

    geo.edges[2].name = "right"
    geo.edges[6].name = "right"
    geo.edges[26].name = "right"
#     geo.edges[30].name = "right"
    geo.edges[42].name = "right"
    geo.edges[94].name = "right"
    
    geo.edges[25].name = "airL"
    geo.edges[27].name = "airR"

    rot = occ.Rotation(occ.Axis((0,0,0), occ.Z), 45)
    geo.edges[2].Identify(geo.edges[0], "per", 0, rot)
    geo.edges[6].Identify(geo.edges[4], "per", 0, rot)
    geo.edges[26].Identify(geo.edges[24], "per", 0, rot)
#     geo.edges[30].Identify(geo.edges[28], "per", 0, rot)
    geo.edges[42].Identify(geo.edges[28], "per", 0, rot)
    geo.edges[94].Identify(geo.edges[92], "per", 0, rot)
    
    transX = occ.Translation(occ.Vec(1,1,0))
#     transY = occ.Translation(0.00028744*occ.Y)
    geo.edges[25].Identify(geo.edges[27], "rotstat",0,transX)

# transX = occ.Translation(20*occ.X)
# geo = transX(geo)
    
geoOCC = occ.OCCGeometry(geo, dim=2)
geoOCCmesh = geoOCC.GenerateMesh()

import ngsolve as ng
ngsolvemesh = ng.Mesh(geoOCCmesh)
# ngsolvemesh.Refine()
# ngsolvemesh.Refine()
# geoOCCmesh.SecondOrder()

# len(mesh.ngmesh.GetIdentifications())
147/5:
#####################################################################################################################
#import scipy.io
#scipy.io.savemat('motor.mat', {"m" : m,
#                               "j3" : j3,
#                               "geoOCC" : geoOCC,
#                 do_compression=True)
#####################################################################################################################


if pizza_slice:
    #####################################################################################################################
    np.savez_compressed('motor_pizza_gap.npz', m=m, j3=j3, geoOCC = geoOCC, 
                        geoOCCmesh = geoOCCmesh, ident_points = ident_points, ident_edges = ident_edges)
    #####################################################################################################################
else:
    #####################################################################################################################
    np.savez_compressed('motor_gap.npz', m=m, j3=j3, geoOCC = geoOCC,
                        geoOCCmesh = geoOCCmesh)
    #####################################################################################################################
147/6: ident_points
147/7: geoOCCmesh.Points()
147/8: MESH.Boundary_Edges
147/9: np.where(MESH.e[:,2]==25)[0].shape
147/10: np.where(MESH.e[:,2]==23)[0].shape
147/11: MESH.pdemesh(info=1)
146/15:
import sys
sys.path.insert(0,'../../../') # adds parent directory
sys.path.insert(0,'../../../../') # adds parent directory
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
146/16:
import sys
sys.path.insert(0,'../../../') # adds parent directory
sys.path.insert(0,'../../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
148/1:
%%capture
%run TEAM_13_geometry.ipynb
148/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
148/3:
##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
148/4:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
148/5:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
148/6:
%%capture
%run TEAM_13_geometry.ipynb
148/7:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
148/8:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
148/9:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
148/10:
%%capture
%run TEAM_13_geometry.ipynb
148/11:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
148/12:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH2 = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH2
141/55: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
141/56: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
148/13:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

tm = time.monotonic()

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))
print('My code took ... ',time.monotonic()-tm)

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()

phi_j = x
148/14:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))
print('My code took ... ',time.monotonic()-tm)

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()

phi_j = x
148/15:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))
print('My code took ... ',time.monotonic()-tm)

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()

phi_j = x
148/16:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()

phi_j = x
148/17: phi_j
148/18: MESH.pdesurf2(x)
148/19: MESH.pdesurf(x)
141/57: MESH.pdesurf(x)
148/20: MESH.pdesurf(x, faces = 'l_steel_face,r_steel_face,mid_steel_face,coil_face')
141/58: x
148/21:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
148/22:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
148/23: MESH.pdesurf(x, faces = 'l_steel_face,r_steel_face,mid_steel_face,coil_face')
148/24:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
148/25:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
148/26: MESH.pdesurf(x, faces = 'l_steel_face,r_steel_face,mid_steel_face,coil_face')
148/27: MESH.pdesurf(x, faces = 'l_steel_face,r_steel_face,mid_steel_face,coil_face,coil_cut_1,coil_cut_1')
148/28: MESH.pdesurf(x, faces = 'l_steel_face,r_steel_face,mid_steel_face,coil_face,new,coil_cut_1')
148/29: x.shape
148/30: MESH.pdesurf(x, faces = 'l_steel_face,r_steel_face,mid_steel_face,coil_face')
148/31: MESH.pdesurf(x, faces = 'coil_face')
148/32:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
MESH.pdesurf(x, faces = 'coil_face')
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
148/33:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
148/34:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + 0*R1.T @ (1+np.zeros(R1.shape[0]))

MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
148/35:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x - R1.T @ (1+np.zeros(R1.shape[0]))

MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
148/36:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
148/37:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + 0*R1.T @ (1+np.zeros(R1.shape[0]))

MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
148/38:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
148/39:
import vtklib

grid = vtklib.createVTK(MESH)
vtklib.add_H1_Scalar(grid, x, 'J')
vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
vtklib.writeVTK(grid, 'current_density.vtu')
149/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
149/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
149/3: grid = pde.tools.createVTK(MESH)
148/40:
grid = pde.tools.vtklib.createVTK(MESH)
vtklib.add_H1_Scalar(grid, x, 'J')
vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
vtklib.writeVTK(grid, 'current_density.vtu')
148/41:
grid = pde.tools.createVTK(MESH)
vtklib.add_H1_Scalar(grid, x, 'J')
vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
vtklib.writeVTK(grid, 'current_density.vtu')
150/1:
%%capture
%run TEAM_13_geometry.ipynb
150/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
150/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
150/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
150/5:
grid = pde.tools.createVTK(MESH)
vtklib.add_H1_Scalar(grid, x, 'J')
vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
vtklib.writeVTK(grid, 'current_density.vtu')
150/6:
grid = pde.tools.vtklib.createVTK(MESH)
vtklib.add_H1_Scalar(grid, x, 'J')
vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
vtklib.writeVTK(grid, 'current_density.vtu')
150/7:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
150/8: import pyvista as pyv
150/9: pyv
150/10:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh.plot(cpos='xz')
150/11:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
150/12:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
150/13: mesh.active_normals
150/14: pv.plot(mesh)
150/15: pv.plot(mesh)
151/1:
%%capture
%run TEAM_13_geometry.ipynb
151/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
151/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
151/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
151/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
151/6: x.shape
151/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
151/8: pv.plot(mesh)
151/9: pv.plot(mesh)
151/10: pv.plot(mesh)
152/1:
%%capture
%run TEAM_13_geometry.ipynb
152/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
152/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
152/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
152/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
152/6: x.shape
152/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
152/8: pv.plot(mesh)
154/1:
%%capture
%run TEAM_13_geometry.ipynb
154/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
154/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
154/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
154/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
154/6: x.shape
154/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
154/8: pv.plot(mesh)
155/1: mesh.plot()
155/2:
%%capture
%run TEAM_13_geometry.ipynb
155/3:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
155/4:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
155/5:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
155/6:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
155/7: x.shape
155/8:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
155/9: mesh.plot()
157/1:
%%capture
%run TEAM_13_geometry.ipynb
157/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
157/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
157/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
157/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
157/6: x.shape
157/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
157/8: mesh.connectivity
157/9: mesh.view()
157/10: mesh.plot()
157/11: mesh.plot()
157/12: x.shape
157/13:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
157/14: mesh.plot()
157/15: mesh.plot()
158/1:
%%capture
%run TEAM_13_geometry.ipynb
158/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
158/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
158/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
158/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
158/6: x.shape
158/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
158/8: mesh.plot()
158/9: mesh.plot()
159/1:
%%capture
%run TEAM_13_geometry.ipynb
159/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
159/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
159/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
159/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
159/6: x.shape
159/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
159/8: mesh.plot()
160/1: mesh.plot()
160/2:
%%capture
%run TEAM_13_geometry.ipynb
160/3:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
160/4:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
160/5:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
160/6:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
160/7: x.shape
160/8:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
160/9: mesh.plot()
161/1:
%%capture
%run TEAM_13_geometry.ipynb
161/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
161/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
161/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
161/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
161/6: x.shape
161/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
161/8: mesh.plot()
161/9: mesh.plot()
161/10:
mesh.plot()
vtk
161/11:
mesh.plot()
import vtk
vtk
163/1:
%%capture
%run TEAM_13_geometry.ipynb
163/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
163/3:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
163/4:
import sys
sys.path.insert(0,'../../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
163/5:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
164/1:
import netgen.occ as occ
from netgen.webgui import Draw as DrawGeo

box1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(100,100,50))
box2 = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(75,75,50))
    
##########################################################################
# Rounding corners ...
##########################################################################

corner1_ext = occ.Box(occ.Pnt(75,75,-50), occ.Pnt(100,100,50))
cyl1_ext = occ.Cylinder(occ.Pnt(75,75,-50), occ.Z, r=25, h=100)
corner1_int = occ.Box(occ.Pnt(50,50,-50), occ.Pnt(75,75,50))
cyl1_int = occ.Cylinder(occ.Pnt(50,50,-50), occ.Z, r=25, h=100)
corner1_int = corner1_int-cyl1_int; corner1_ext = corner1_ext-cyl1_ext

corner2_ext = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(-75,-75,50))
cyl2_ext = occ.Cylinder(occ.Pnt(-75,-75,-50), occ.Z, r=25, h=100)
corner2_int = occ.Box(occ.Pnt(-75,-75,-50), occ.Pnt(-50,-50,50))
cyl2_int = occ.Cylinder(occ.Pnt(-50,-50,-50), occ.Z, r=25, h=100)
corner2_int = corner2_int-cyl2_int; corner2_ext = corner2_ext-cyl2_ext

corner3_ext = occ.Box(occ.Pnt(75,-75,-50), occ.Pnt(100,-100,50))
cyl3_ext = occ.Cylinder(occ.Pnt(75,-75,-50), occ.Z, r=25, h=100)
corner3_int = occ.Box(occ.Pnt(50,-50,-50), occ.Pnt(75,-75,50))
cyl3_int = occ.Cylinder(occ.Pnt(50,-50,-50), occ.Z, r=25, h=100)
corner3_int = corner3_int-cyl3_int; corner3_ext = corner3_ext-cyl3_ext

corner4_ext = occ.Box(occ.Pnt(-75,75,-50), occ.Pnt(-100,100,50))
cyl4_ext = occ.Cylinder(occ.Pnt(-75,75,-50), occ.Z, r=25, h=100)
corner4_int = occ.Box(occ.Pnt(-50,50,-50), occ.Pnt(-75,75,50))
cyl4_int = occ.Cylinder(occ.Pnt(-50,50,-50), occ.Z, r=25, h=100)
corner4_int = corner4_int-cyl4_int; corner4_ext = corner4_ext-cyl4_ext

##########################################################################
# Adding the steel parts
##########################################################################

coil_full = (box1-box2)+corner1_int-corner1_ext+corner2_int-corner2_ext+corner3_int-corner3_ext+corner4_int-corner4_ext

mid_steel = occ.Box(occ.Pnt(-1.6,-25,-64.2),occ.Pnt(1.6,25,64.2))

r_steel1 = occ.Box(occ.Pnt(1.6+0.5,15,50+10-3.2),occ.Pnt(1.6+120.5,65,50+10))
r_steel2 = occ.Box(occ.Pnt(1.6+0.5,15,-(50+10-3.2)),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel3 = occ.Box(occ.Pnt(1.6+120.5-3.2,15,50+10-3.2),occ.Pnt(1.6+120.5,65,-(50+10)))
r_steel = r_steel1 + r_steel2 + r_steel3

l_steel1 = occ.Box(occ.Pnt(-1.6-0.5,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,50+10))
l_steel2 = occ.Box(occ.Pnt(-1.6-0.5,-15,-(50+10-3.2)),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel3 = occ.Box(occ.Pnt(-1.6-120.5+3.2,-15,50+10-3.2),occ.Pnt(-1.6-120.5,-65,-(50+10)))
l_steel = l_steel1 + l_steel2 + l_steel3

##########################################################################
# Glueing ...
##########################################################################

half_box_1 = occ.Box(occ.Pnt(-100,-100,-50), occ.Pnt(0,100,50))
half_box_2 = occ.Box(occ.Pnt(100,-100,-50), occ.Pnt(0,100,50))

coil_half_box_1 = coil_full*half_box_1
coil_half_box_2 = coil_full*half_box_2

coil = occ.Glue([coil_half_box_1,coil_half_box_2])
ambient =  occ.Box(occ.Pnt(-200,-200,-100), occ.Pnt(200,200,100))

full = occ.Glue([coil, mid_steel, r_steel, l_steel, ambient])

##########################################################################
# "Fancy" coloring cuz why not I got a bit bored :)
##########################################################################

coil.faces.col=(1,0.5,0)
l_steel.faces.col=(1,0.5,1)
r_steel.faces.col=(1,0.5,1)
mid_steel.faces.col=(1,0.5,1)
ambient.faces.col=(1,1,1)

##########################################################################
# Identifications
##########################################################################


for face in coil.faces: face.name = 'coil_face'
for face in r_steel.faces: face.name = 'r_steel_face'
for face in l_steel.faces: face.name = 'l_steel_face'
for face in mid_steel.faces: face.name = 'mid_steel_face'
for face in ambient.faces: face.name = 'ambient_face'

coil.faces[6].name = 'coil_cut_1'
coil.faces[12].name = 'coil_cut_2'

coil.mat("coil")
r_steel.mat("r_steel")
l_steel.mat("l_steel")
mid_steel.mat("mid_steel")


geoOCC = occ.OCCGeometry(full)
geoOCCmesh = geoOCC.GenerateMesh()

DrawGeo(full, clipping={"z":-1, "dist":64});
DrawGeo(geoOCCmesh, clipping={"z":-1, "dist":64})
163/6: pwd
165/1:
%%capture
%run TEAM_13_geometry.ipynb
165/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
165/3:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
149/4: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
166/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
166/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
166/3: from sksparse.cholmod import cholesky
166/4: from sksparse.cholmod import cholesky
166/5: from sksparse.cholmod import cholesky
167/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
167/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
167/3: from sksparse.cholmod import cholesky
167/4: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
167/5: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
168/1:
print('PyDev console: using IPython 8.4.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
168/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
169/1:
print('PyDev console: using IPython 8.4.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
169/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
169/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
169/4: from sksparse.cholmod import cholesky as chol
169/5: chol
169/6: chol.__getattribute__
169/7: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
169/8: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
169/9: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
169/10: new_points[points_to_duplicate==j]
169/11: new_points[points_to_duplicate==j]
169/12: new_points[points_to_duplicate==j]
169/13: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
169/14: new_faces.ravel()[i]
169/15: new_points[points_to_duplicate==j]
169/16: new_points
169/17: new_points[points_to_duplicate==j]
169/18: new_faces.ravel()
169/19: new_faces.ravel()[i]
169/20: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
169/21: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
169/22: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
165/4:
%%capture
%run TEAM_13_geometry.ipynb
165/5:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
165/6:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
165/7:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
165/8:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
165/9: x.shape
165/10:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
165/11:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
165/12:
mesh.plot()
import vtk
vtk
169/23:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
169/24:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
169/25: pwd
169/26:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
165/13:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
170/1:
%%capture
%run TEAM_13_geometry.ipynb
170/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
170/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
170/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
170/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
170/6: x.shape
170/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
170/8:
mesh.plot()
import vtk
vtk
169/27: mesh.plot()
169/28: mesh.plot()
170/9:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
170/10:
mesh.plot()
import vtk
vtk
171/1:
%%capture
%run TEAM_13_geometry.ipynb
171/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
171/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
171/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
171/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
171/6: x.shape
171/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
171/8:
mesh.plot()
import vtk
vtk
171/9: pwd
171/10:
mesh.plot()
import vtk
171/11:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
171/12:
mesh.plot()
import vtk
171/13:
mesh.plot()
import vtk
171/14:
mesh.plot()
import vtk
171/15:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
171/16:
mesh.plot()
import vtk
169/29: mesh.plot()
169/30: mesh.plot()
171/17:
mesh.plot()
import vtk
171/18:
mesh.plot()
import vtk
171/19:
mesh.plot(jupyter_backend='trame')
import vtk
171/20:
mesh.plot(jupyter_backend='trame')
import vtk
171/21:
%%capture
%run TEAM_13_geometry.ipynb
171/22:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
171/23:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
171/24:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
171/25:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
171/26: x.shape
171/27:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
171/28:
mesh.plot(jupyter_backend='trame')
import vtk
172/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
172/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
172/3: mesh
172/4:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
172/5: mesh.plot()
172/6:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
172/7: mesh.plot()
172/8: mesh.plot(notebook=True)
172/9: debugfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
172/10: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
174/1: debugfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
172/11: debugfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
172/12: debugfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
172/13: A
172/14: P
172/15: B
172/16: mesh
172/17: mesh.plot()
172/18: mesh.plot(notebook=True)
172/19: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
172/20: debugfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
175/1: A
175/2: self
175/3: activate_module_for(self._helper, self.server, view)
175/4: A = activate_module_for(self._helper, self.server, view)
175/5: A
175/6: A.shape
175/7: type(A)
172/21: from trame_vtk.modules import paraview
172/22: runfile('C:\\Users\\Radu\\anaconda\\envs\\fem39\\Lib\\site-packages\\trame_vtk\\widgets\\vtk\\common.py', wdir='C:\\Users\\Radu\\anaconda\\envs\\fem39\\Lib\\site-packages\\trame_vtk\\widgets\\vtk')
172/23: from trame_vtk.modules import paraview
172/24: from trame_vtk.modules import paraview
172/25: from trame_vtk.modules import vtk
172/26: server.enable_module(paraview)
176/1: from trame_vtk import vtk
176/2: import trame_vtk as vtk
176/3: vtk
171/29:
%%capture
%run TEAM_13_geometry.ipynb
171/30:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
171/31:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
171/32:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
171/33:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
171/34: x.shape
171/35:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
171/36:
mesh.plot(jupyter_backend='trame')
import vtk
176/4: import trame_vtk as vtk
176/5: vtk.VtkRemoteLocalView
176/6: a = vtk()
176/7: a = vtk.widgets.vtk()
176/8: a = vtk.widgets.vtk
176/9: a
176/10: vtk
176/11: a = vtk.widgets.vtk.VtkRemoteView
176/12: a = vtk.widgets.vtk.VtkRemoteView()
176/13: a = vtk.widgets.vtk.VtkRemoteView(paraview)
176/14: a = vtk.widgets.vtk.VtkRemoteView()
176/15: import vtk.web
171/37:
import pyvista as pv
sphere = pv.Sphere()

# short example
sphere.plot(jupyter_backend='trame')

# long example
plotter = pv.Plotter(notebook=True)
plotter.add_mesh(sphere)
plotter.show(jupyter_backend='trame')
171/38:
import pyvista as pv
sphere = pv.Sphere()

# short example
sphere.plot(jupyter_backend='trame')

# long example
plotter = pv.Plotter(notebook=True)
plotter.add_mesh(sphere)
plotter.show()
171/39:
import pyvista as pv
sphere = pv.Sphere()

# short example
sphere.plot()

# long example
plotter = pv.Plotter(notebook=True)
plotter.add_mesh(sphere)
plotter.show()
171/40:
import pyvista as pv
sphere = pv.Sphere()

# short example
sphere.plot()

# long example
plotter = pv.Plotter(notebook=True)
plotter.add_mesh(sphere)
plotter.show()
177/1:
%%capture
%run TEAM_13_geometry.ipynb
177/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
177/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
177/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
177/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
177/6: x.shape
177/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
177/8:
mesh.plot(jupyter_backend='trame')
import vtk
172/27: mesh.plot(notebook=True)
172/28: mesh.plot(notebook=True)
172/29: mesh.plot(notebook=True)
178/1:
mesh.plot(jupyter_backend='trame')
import vtk
178/2:
%%capture
%run TEAM_13_geometry.ipynb
178/3:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
178/4:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
178/5:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
178/6:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
178/7: x.shape
178/8:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
178/9:
mesh.plot(jupyter_backend='trame')
import vtk
180/1:
%%capture
%run TEAM_13_geometry.ipynb
180/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
180/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
180/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
180/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
180/6: x.shape
180/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
180/8:
mesh.plot(jupyter_backend='trame')
import vtk
172/30: mesh.plot(notebook=True)
172/31: mesh.plot(notebook=True)
181/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
181/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
181/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
181/4: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
182/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
182/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
183/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
183/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
184/1:
%%capture
%run TEAM_13_geometry.ipynb
184/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
184/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
184/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
184/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
184/6: x.shape
184/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
184/8:
mesh.plot(jupyter_backend='trame')
import vtk
185/1:
%%capture
%run TEAM_13_geometry.ipynb
185/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
185/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
185/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
185/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
185/6: x.shape
185/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
185/8:
mesh.plot(jupyter_backend='trame')
import vtk
185/9: pwd
185/10:
import pyvista as pv
sphere = pv.Sphere()

# short example
sphere.plot()

# long example
plotter = pv.Plotter(notebook=True)
plotter.add_mesh(sphere)
plotter.show()
186/1:
%%capture
%run TEAM_13_geometry.ipynb
186/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
186/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
186/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
186/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
186/6: x.shape
186/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
186/8:
mesh.plot(jupyter_backend='trame')
import vtk
187/1:
%%capture
%run TEAM_13_geometry.ipynb
187/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
187/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
187/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
187/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
187/6: x.shape
187/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
187/8:
mesh.plot(jupyter_backend='trame')
import vtk
189/1:
%%capture
%run TEAM_13_geometry.ipynb
189/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
189/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
189/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
189/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
189/6: x.shape
189/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
189/8:
mesh.plot(jupyter_backend='trame')
import vtk
190/1:
import pyvista as pv
sphere = pv.Sphere()

# short example
sphere.plot()

# long example
plotter = pv.Plotter(notebook=True)
plotter.add_mesh(sphere)
plotter.show()
173/1: import trame_vtk as vtk
173/2: import trame_vtk.widgets.vtk as vtk
173/3: vtk.VtkView
173/4: vtk.VtkView()
173/5: vtk.webv
173/6: vtk.web
173/7: import trame_vtk.widgets.vtk
173/8: import trame_vtk.widgets.vtk as vtk
173/9: vtk.VtkCellData
173/10: vtk.VtkCellData.html
173/11: vtk.VtkCellData.html()
173/12:
import pyvista as pv
sphere = pv.Sphere()

# short example
sphere.plot()

# long example
plotter = pv.Plotter(notebook=True)
plotter.add_mesh(sphere)
plotter.show()
173/13: runfile('C:/Users/Radu/Documents/tesdt.py', wdir='C:/Users/Radu/Documents')
191/1: runfile('C:/Users/Radu/Documents/tesdt.py', wdir='C:/Users/Radu/Documents')
191/2: runfile('C:/Users/Radu/Documents/tesdt.py', wdir='C:/Users/Radu/Documents')
191/3: runfile('C:/Users/Radu/Documents/tesdt.py', wdir='C:/Users/Radu/Documents')
191/4: debugfile('C:/Users/Radu/Documents/tesdt.py', wdir='C:/Users/Radu/Documents')
192/1: runfile('C:/Users/Radu/Documents/tesdt.py', wdir='C:/Users/Radu/Documents')
192/2: debugfile('C:/Users/Radu/Documents/tesdt.py', wdir='C:/Users/Radu/Documents')
192/3: debugfile('C:/Users/Radu/Documents/tesdt.py', wdir='C:/Users/Radu/Documents')
192/4: debugfile('C:/Users/Radu/Documents/tesdt.py', wdir='C:/Users/Radu/Documents')
192/5: runfile('C:/Users/Radu/Documents/tesdt.py', wdir='C:/Users/Radu/Documents')
192/6:
import pyvista as pv
pv.set_jupyter_backend('client')
192/7: pv.plot(mesh)
192/8:
sphere = pv.Sphere()
sphere.plot()
193/1:
import pyvista as pv
pv.set_jupyter_backend('web')
193/2:
import pyvista as pv
pv.set_jupyter_backend('trame')
193/3:
sphere = pv.Sphere()
sphere.plot()
195/1:
import pyvista as pv
pv.set_jupyter_backend('trame')
195/2:
import pyvista as pv
pv.set_jupyter_backend('trame')
195/3:
sphere = pv.Sphere()
sphere.plot()
196/1:
import pyvista as pv
pv.set_jupyter_backend('trame')
197/1:
%%capture
%run TEAM_13_geometry.ipynb
197/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
197/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
197/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
197/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
197/6: x.shape
197/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
197/8:
mesh.plot(jupyter_backend='server')
import vtk
197/9: pwd
197/10:
import pyvista as pv
pv.set_jupyter_backend('trame')
197/11:
mesh.plot(jupyter_backend='server')
import vtk
198/1:
%%capture
%run TEAM_13_geometry.ipynb
198/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
198/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
198/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
198/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
198/6: x.shape
198/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
198/8:
mesh.plot(jupyter_backend='server')
import vtk
198/9: pwd
198/10:
import pyvista as pv
pv.set_jupyter_backend('trame')
198/11:
mesh.plot(jupyter_backend='trame')
import vtk
198/12: mesh.plot(jupyter_backend='trame')
199/1:
%%capture
%run TEAM_13_geometry.ipynb
199/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
199/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
199/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
199/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
199/6: x.shape
199/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
199/8: mesh.plot(jupyter_backend='trame')
199/9: pwd
199/10:
import pyvista as pv
pv.set_jupyter_backend('trame')
200/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
200/2:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
200/3:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
200/4:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
200/5: mesh.plot(jupyter_backend='trame')
201/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
201/2: mesh.plot(jupyter_backend='trame')
202/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
202/2: mesh.plot(jupyter_backend='client')
203/1: mesh.plot(jupyter_backend='static')
203/2:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
203/3: mesh.plot(jupyter_backend='static')
205/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
205/2: mesh.plot(jupyter_backend='static')
205/3: mesh.plot(jupyter_backend='trame')
205/4: mesh.plot(jupyter_backend='html')
206/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
206/2: mesh.plot(jupyter_backend='html')
206/3: mesh.plot(jupyter_backend='trame')
206/4:
import pyvista as pv
pv.set_jupyter_backend('trame')
207/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
207/2: mesh.plot(jupyter_backend='trame')
209/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
209/2: mesh.plot(jupyter_backend='html')
209/3: mesh.plot(jupyter_backend='trame')
210/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
210/2: mesh.plot(jupyter_backend='trame')
211/1:
%%capture
%run TEAM_13_geometry.ipynb
211/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
211/3:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
211/4: mesh.plot(jupyter_backend='trame')
212/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
212/2:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
213/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
213/2: mesh.plot(jupyter_backend='trame')
214/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
214/2: mesh.plot(jupyter_backend='trame')
215/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
215/2: mesh.plot(jupyter_backend='trame')
215/3:
%%capture
%run TEAM_13_geometry.ipynb
215/4:
import pyvista as pv
reader = pv.get_reader('das.pvd')


mesh = reader.read('current_density.vtu')
mesh
215/5:
import pyvista as pv
reader = pv.get_reader('das.pvd')
mesh = reader.read('current_density.vtu')
mesh
215/6:
import pyvista as pv
mesh = pv.read('das.pvd')
mesh
215/7:
import pyvista as pv
mesh = pv.read('das.pvsm')
mesh
215/8:
import pyvista as pv
mesh = pv.read('dass.pvsm')
mesh
216/1:
import pyvista as pv
mesh = pv.read('dass.pvsm')
mesh
216/2:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
216/3: mesh.plot(jupyter_backend='trame')
216/4:
# mesh.plot(jupyter_backend='trame')
p = pv.Plotter()
p.add_mesh(dataset, style='wireframe', color='blue', label='Input')
p.add_mesh(clipped, label='Clipped')
p.add_legend()
p.show()
216/5:
# mesh.plot(jupyter_backend='trame')
p = pv.Plotter()
p.add_mesh(mesh, style='wireframe', color='blue', label='Input')
p.add_mesh(mesh, label='Clipped')
p.add_legend()
p.show()
216/6:
# mesh.plot(jupyter_backend='trame')
p = pv.Plotter()
p.add_mesh(mesh, style='wireframe', color='blue', label='Input')
# p.add_mesh(mesh, label='Clipped')
p.add_legend()
p.show()
216/7:
# mesh.plot(jupyter_backend='trame')
p = pv.Plotter()
p.add_mesh(mesh, style='wireframe', color='blue')
# p.add_mesh(mesh, label='Clipped')
p.add_legend()
p.show()
216/8:
# mesh.plot(jupyter_backend='trame')
p = pv.Plotter()
p.add_mesh(mesh, style='wireframe', color='blue', label='')
# p.add_mesh(mesh, label='Clipped')
p.add_legend()
p.show()
216/9:
# mesh.plot(jupyter_backend='trame')
p = pv.Plotter()
p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
p.add_legend()
p.show()
216/10:
# mesh.plot(jupyter_backend='trame')
p = pv.Plotter()
p.add_mesh(mesh, style='wireframe')
# p.add_mesh(mesh, label='Clipped')
p.add_legend()
p.show()
216/11:
# mesh.plot(jupyter_backend='trame')
p = pv.Plotter()
p.add_mesh(mesh)
# p.add_mesh(mesh, label='Clipped')
p.add_legend()
p.show()
216/12:
mesh.plot(jupyter_backend='trame')
# p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# # p.add_mesh(mesh, label='Clipped')
# p.add_legend()
# p.show()
216/13:
mesh.plot(jupyter_backend='client')
# p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# # p.add_mesh(mesh, label='Clipped')
# p.add_legend()
# p.show()
217/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
217/2:
mesh.plot(jupyter_backend='client')
# p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# # p.add_mesh(mesh, label='Clipped')
# p.add_legend()
# p.show()
217/3:
mesh.plot(jupyter_backend='client')
mesh.export_html('kek.html')
# p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# # p.add_mesh(mesh, label='Clipped')
# p.add_legend()
# p.show()
217/4:
mesh.plot(jupyter_backend='client')
mesh.export_html('kek.html')
# p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# # p.add_mesh(mesh, label='Clipped')
# p.add_legend()
# p.show()
217/5:
mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# # p.add_mesh(mesh, label='Clipped')
# p.add_legend()
# p.show()
217/6:
mesh.plot(jupyter_backend='trame')
# mesh.export_html('kek.html')
# p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# # p.add_mesh(mesh, label='Clipped')
# p.add_legend()
# p.show()
217/7:
mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# # p.add_mesh(mesh, label='Clipped')
# p.add_legend()
# p.show()
218/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
218/2:
mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# # p.add_mesh(mesh, label='Clipped')
# p.add_legend()
# p.show()
218/3:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
p = pv.Plotter()
p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# # p.add_mesh(mesh, label='Clipped')
# p.add_legend()
p.show()
218/4:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
p = pv.Plotter()
p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# # p.add_mesh(mesh, label='Clipped')
# p.add_legend()
p.show(jupyter_backend='html')
218/5:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
p.add_mesh(mesh, label='Clipped')
# p.add_legend()
p.show(jupyter_backend='html')
218/6:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1.2, invert=True)
# p.add_legend()
clipped.show(jupyter_backend='html')
218/7:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1.2, invert=True)
# p.add_legend()
clipped.plot(jupyter_backend='html')
218/8:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
p = pv.Plotter()
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1.2, invert=True)
# p.add_legend()
clipped.plot()
218/9:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="J", value=1.2, invert=True)
# p.add_legend()
clipped.plot()
218/10:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1.2, invert=True)
# p.add_legend()
clipped.plot()
218/11:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1.2, invert=False)
# p.add_legend()
clipped.plot()
218/12:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1.2)
# p.add_legend()
clipped.plot()
218/13:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=2)
# p.add_legend()
clipped.plot()
218/14:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=0)
# p.add_legend()
clipped.plot()
218/15:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=0)
# p.add_legend()
clipped.plot()
218/16:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=0.1)
# p.add_legend()
clipped.plot()
218/17:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="J", value=0.1)
# p.add_legend()
clipped.plot()
218/18:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="J", value=0.2)
# p.add_legend()
clipped.plot()
218/19:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Das", value=0.2)
# p.add_legend()
clipped.plot()
218/20:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=0.2)
# p.add_legend()
clipped.plot()
218/21:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=10)
# p.add_legend()
clipped.plot()
218/22:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1)
# p.add_legend()
clipped.plot()
218/23:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1)
# p.add_legend()
mesh.plot()
218/24:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1)
# p.add_legend()
clipped.plot()
218/25:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
clipped.plot()
218/26:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
clipped.plot(jupyter_backend='html')
218/27:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
clipped.plot(jupyter_backend='html')


plotter = pv.Plotter()
plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=1, invert=True), color='red', opacity=0.1)
plotter.show_axes()
plotter.show()
218/28:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
# clipped.plot(jupyter_backend='html')


plotter = pv.Plotter()
plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=1, invert=True), color='red', opacity=0.1)
plotter.show_axes()
plotter.show()
218/29:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
# clipped.plot(jupyter_backend='html')


plotter = pv.Plotter()
plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=1, invert=True), color='red', opacity=0.8)
plotter.show_axes()
plotter.show()
218/30:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
# clipped.plot(jupyter_backend='html')


plotter = pv.Plotter()
plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=1, invert=True), color='red', opacity=0.8)
plotter.show_axes()
plotter.show(jupyter_backend='html')
218/31:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
# clipped.plot(jupyter_backend='html')


plotter = pv.Plotter()
plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=1, invert=True), color='red', opacity=0.8)
# plotter.show_axes()
plotter.show(jupyter_backend='html')
218/32:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
# clipped.plot(jupyter_backend='html')


plotter = pv.Plotter()
plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=1, invert=True), opacity=0.8)
# plotter.show_axes()
plotter.show(jupyter_backend='html')
218/33:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
# clipped.plot(jupyter_backend='html')


plotter = pv.Plotter()
plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=1, invert=True), opacity=0.8)
# plotter.show_axes()
plotter.show(jupyter_backend='html')
218/34:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
# clipped.plot(jupyter_backend='html')


plotter = pv.Plotter()
plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=2, invert=True), opacity=0.8)
# plotter.show_axes()
plotter.show(jupyter_backend='html')
218/35:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
# clipped.plot(jupyter_backend='html')


plotter = pv.Plotter()
plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=-100, invert=True), opacity=0.8)
# plotter.show_axes()
plotter.show(jupyter_backend='html')
218/36:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
# clipped.plot(jupyter_backend='html')


plotter = pv.Plotter()
plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# plotter.show_axes()
plotter.show(jupyter_backend='html')
218/37:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
# p.add_legend()
# clipped.plot(jupyter_backend='html')


plotter = pv.Plotter()
plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8).threshold(value=0.02)
# plotter.show_axes()
plotter.show(jupyter_backend='html')
218/38:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
clipped = mesh.threshold(value=0.02)
p.add_legend()
clipped.plot(jupyter_backend='html')


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
218/39:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
clipped = mesh.threshold(value=0.02)
# p.add_legend()
clipped.plot(jupyter_backend='html')


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
218/40:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
clipped = mesh.threshold(value=1)
# p.add_legend()
clipped.plot(jupyter_backend='html')


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
218/41:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)
clipped = mesh.threshold(value=1)
# p.add_legend()
clipped.plot(jupyter_backend='html',show_edges=True)


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
218/42:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = dataset.threshold([0,1.2])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True)


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
218/43:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1.2])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True)


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
218/44:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,3])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True)


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
218/45:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True)


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
218/46:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="k")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
218/47:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
218/48:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
218/49:
%%capture
%run TEAM_13_geometry.ipynb
218/50:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
219/1:
%%capture
%run TEAM_13_geometry.ipynb
219/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
219/3:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
220/1:
%%capture
%run TEAM_13_geometry.ipynb
220/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
222/1:
%%capture
%run TEAM_13_geometry.ipynb
222/2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
222/3:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
222/4:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
222/5:
%%capture
%run TEAM_13_geometry.ipynb
222/6:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
222/7:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
222/8:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
222/9:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
214/3:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
214/4:
%%capture
%run TEAM_13_geometry.ipynb
214/5:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
214/6:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
214/7:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
214/8:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
214/9: x.shape
214/10:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
214/11:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
214/12: pwd
214/13:
import pyvista as pv
pv.set_jupyter_backend('trame')
214/14:
sphere = pv.Sphere()
sphere.plot()
222/10:
%%capture
%run TEAM_13_geometry.ipynb
222/11:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
222/12:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
223/1:
%%capture
%run TEAM_13_geometry.ipynb
223/2:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
223/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
223/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
223/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
223/6: x.shape
223/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
223/8:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
223/9: pwd
223/10:
import pyvista as pv
pv.set_jupyter_backend('trame')
223/11:
sphere = pv.Sphere()
sphere.plot()
214/15:
%%capture
%run TEAM_13_geometry.ipynb
214/16:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
214/17:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
214/18:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
214/19:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
214/20: x.shape
214/21:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
214/22:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
214/23: pwd
226/1:
%%capture
%run TEAM_13_geometry.ipynb
226/2:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
226/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
226/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
226/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
226/6: x.shape
226/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
226/8:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
226/9: pwd
226/10:
import pyvista as pv
pv.set_jupyter_backend('trame')
227/1:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='trame',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
227/2:
%%capture
%run TEAM_13_geometry.ipynb
227/3:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
227/4:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
227/5:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
227/6:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
227/7: x.shape
227/8:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
227/9:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='trame',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
229/1:
%%capture
%run TEAM_13_geometry.ipynb
229/2:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
229/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
229/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
229/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
229/6: x.shape
229/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
229/8:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
229/9: pwd
231/1:
%%capture
%run TEAM_13_geometry.ipynb
231/2:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
231/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
231/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
231/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
231/6: x.shape
231/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
231/8:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html', show_edges=True, color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
214/24:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
214/25: x.shape
214/26:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
214/27:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
214/28:
%%capture
%run TEAM_13_geometry.ipynb
214/29:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
214/30:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
214/31:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
214/32:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
214/33: x.shape
214/34:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
214/35:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
224/1:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
224/2:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
224/3:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
233/1:
%%capture
%run TEAM_13_geometry.ipynb
233/2:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
233/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
233/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
233/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
233/6: x.shape
233/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
233/8:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
235/1:
%%capture
%run TEAM_13_geometry.ipynb
235/2:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
235/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
235/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
235/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
235/6: x.shape
235/7:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
235/8:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
236/1:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
236/2:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()
threshed.plot(jupyter_backend='html',show_edges=True,color="w")


# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')
236/3:
%%capture
%run TEAM_13_geometry.ipynb
236/4:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
236/5:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
236/6:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
236/7:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
236/8:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
# mesh.set_active_scalars("Scalars_")
# threshed = mesh.threshold([0,1])

p = pv.Plotter()
p.add_mesh(threshed, style='wireframe', color='blue', label=None)
p.show(jupyter_backend='html',show_edges=True)
236/9:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
# mesh.set_active_scalars("Scalars_")
# threshed = mesh.threshold([0,1])

p = pv.Plotter()
p.add_mesh(threshed, style='wireframe', color='blue', label=None)
p.show(jupyter_backend='html')
236/10:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
# mesh.set_active_scalars("Scalars_")
# threshed = mesh.threshold([0,1])

p = pv.Plotter()
p.add_mesh(threshed, style='solid', color='blue', label=None)
p.show(jupyter_backend='html')
236/11:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
# mesh.set_active_scalars("Scalars_")
# threshed = mesh.threshold([0,1])

p = pv.Plotter()
p.add_mesh(threshed, style='surface', color='blue', label=None)
p.show(jupyter_backend='html')
236/12:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("J")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
p.add_mesh(threshed, style='surface', color='blue', label=None)
p.show(jupyter_backend='html')
236/13:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("J")
threshed = mesh.threshold([0,0.1])

p = pv.Plotter()
p.add_mesh(threshed, style='surface', color='blue', label=None)
p.show(jupyter_backend='html')
236/14:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("J")
threshed = mesh.threshold([0,0.1])

p = pv.Plotter()
p.add_mesh(threshed, style='wireframe', color='blue', label=None)
p.show(jupyter_backend='html')
236/15:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("J")
threshed = mesh.threshold([0,0.8])

p = pv.Plotter()
p.add_mesh(threshed, style='wireframe', color='blue', label=None)
p.show(jupyter_backend='html')
236/16:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("J")
threshed = mesh.threshold([0.1,0.8])

p = pv.Plotter()
p.add_mesh(threshed, style='wireframe', color='blue', label=None)
p.show(jupyter_backend='html')
236/17:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("J")
threshed = mesh.threshold([0.1,1])

p = pv.Plotter()
p.add_mesh(threshed, style='wireframe', color='blue', label=None)
p.show(jupyter_backend='html')
236/18:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("J")
threshed = mesh.threshold([0.1,1])

p = pv.Plotter()
p.add_mesh(threshed, style='solid', color='blue', label=None)
p.show(jupyter_backend='html')
236/19:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("J")
threshed = mesh.threshold([0.1,1])

p = pv.Plotter()
p.add_mesh(threshed, style='surface', color='blue', label=None)
p.show(jupyter_backend='html')
236/20:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("J")
threshed = mesh.threshold([0.1,1])

p = pv.Plotter()
p.add_mesh(threshed, style='surface', label=None)
p.show(jupyter_backend='html')
236/21:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0.1,1])

p = pv.Plotter()
p.add_mesh(threshed, style='surface', label=None)
p.show(jupyter_backend='html')
236/22:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
p.add_mesh(threshed, style='surface', label=None)
p.show(jupyter_backend='html')
236/23:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', label=None)
p.show(jupyter_backend='html')
236/24:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.5, label=None)
p.show(jupyter_backend='html')
236/25:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.5, label=None)
p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]
p.show(jupyter_backend='html')
236/26:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.5, label=None)
p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]
p.show(jupyter_backend='trame')
236/27: pl.camera.position
236/28: p.camera.position
236/29: p.camera.position
236/30: p.camera
236/31: p.camera.position
236/32:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)
p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]
p.show(jupyter_backend='trame')
236/33:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)
p.camera_position = [(-36, 35, 600)]
p.show(jupyter_backend='trame')
236/34:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)
p.camera_position = [-36, 35, 600]
p.show(jupyter_backend='trame')
236/35: p.camera.position
236/36: p.camera.position
236/37:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)
p.camera_position = [-23, 8, 600]
p.show(jupyter_backend='trame')
236/38: p.camera.position
236/39: p.camera.position
236/40: p.camera.position
236/41: p.camera_position
236/42: p.camera_position
236/43:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)
p.camera_position = [(13.201289622663401, 24.030481241112547, -578.9065853873345),(0.0, 0.0, 0.0),(0.0, 0.0, 0.0)]
p.show(jupyter_backend='trame')
236/44:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)
p.camera_position = [(20, 20, 500),(0.0, 0.0, 0.0),(0.0, 0.0, 0.0)]
p.show(jupyter_backend='trame')
236/45: p.camera_position
236/46:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)
p.camera_position = [(20, 20, 500),(0.0, 0.0, 0.0),(0.0, 0.0, 0.0)]
p.show(jupyter_backend='trame')
236/47: p.camera_position
236/48:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)
p.camera_position = [(20, 20, 500),(0.0, 0.0, 0.0),(0.0, 0.0, 0.0)]
p.show(jupyter_backend='trame')
236/49: p.camera_position
236/50:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)
p.camera_position = [(0, 0, 500),(0.0, 0.0, 0.0),(0.0, 0.0, 0.0)]
p.show(jupyter_backend='trame')
236/51:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)
p.camera_position = [(0, 0, 600),(0.0, 0.0, 0.0),(0.0, 0.0, 0.0)]
p.show(jupyter_backend='trame')
236/52:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

threshed.set_active_scalars("J")

p = pv.Plotter()
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)
p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/53: p.camera_position
236/54:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
p.add_mesh(threshed.arrows, style='surface', opacity = 0.8, label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/55:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
# p.add_mesh(threshed.arrows, style='surface', opacity = 0.8, label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/56: threshed.arrows
236/57:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
# p.add_mesh(threshed.arrows, style='surface', opacity = 0.8, label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/58: K.shape
236/59: threshed.set_active_vectors("grad_J")
236/60:
threshed.set_active_vectors("grad_J")
threshed.arrows
236/61:
threshed.set_active_vectors("grad_J")
threshed.arrow
236/62:
threshed.set_active_vectors("grad_J")
threshed.arrows
236/63: mesh['J']
236/64: mesh['J'].shape
236/65: mesh['grad_J'].shape
236/66:
threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="Normals", orient="Normals", tolerance=0.05)
arrows
236/67:
threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
arrows
236/68:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, style='surface', opacity = 0.8, label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/69:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
# p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, style='surface', opacity = 1, label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/70:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, style='surface', opacity = 1, label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/71:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black", opacity = 1, label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/72:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black", label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/73:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

# threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black", label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/74:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
# threshed.set_active_scalars("J")
# p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black", label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/75:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
# threshed.set_active_scalars("J")
# p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0)
p.add_mesh(arrows, color="black", label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/76:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
# threshed.set_active_scalars("J")
# p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=1)
p.add_mesh(arrows, color="black", label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/77: arrows
236/78:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
# threshed.set_active_scalars("J")
# p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black", label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/79: arrows
236/80:
threshed.set_active_vectors("grad_J")

arrows
236/81:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
# threshed.set_active_scalars("J")
# p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows.GlyphVector, color="black", label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/82:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
# threshed.set_active_scalars("J")
# p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black", label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/83:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
# threshed.set_active_scalars("J")
# p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black", label=None)

# p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/84:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
# p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black", label=None)

# p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/85:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
# p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black", label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/86:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black", label=None)

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/87:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/88:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/89:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='trame')
236/90:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="dsaas", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='trame')
236/91:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='trame')
236/92:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/93:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')

sphere["vectors"]
236/94: mesh["grad_J"]
236/95: mesh["grad_J"] = mesh["grad_J"]*10000
236/96:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

mesh["grad_J"] = mesh["grad_J"]*10000

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/97:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

mesh["grad_J"] = mesh["grad_J"]*1000

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/98:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
236/99:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

mesh["grad_J"] = mesh["grad_J"]*1000

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/100:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

mesh["grad_J"] = mesh["grad_J"]*2000

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/101:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
236/102:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

mesh["grad_J"] = mesh["grad_J"]*1500

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/103:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

mesh["grad_J"] = mesh["grad_J"]*1600

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/104:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
236/105:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

mesh["grad_J"] = mesh["grad_J"]*1600

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/106:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

mesh["grad_J"] = mesh["grad_J"]*9556

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/107:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/108:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
236/109:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/110:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05, orient=True, scale=True, factor=1.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/111:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale=True, orient="grad_J", tolerance=0.05, orient=True, factor=1.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/112:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale=True, orient=True, tolerance=0.05, factor=1.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/113:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale=True, orient=True, tolerance=0.05, factor=2.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/114:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale=True, orient="grad_J", tolerance=0.05, factor=2.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/115:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient="grad_J", tolerance=0.05, factor=2.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/116:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.05, factor=2.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/117:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.05, factor=900.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/118:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.05, factor=9000.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/119:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.8, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.05, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/120:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.2, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.05, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/121:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.2, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.02, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/122:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.2, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
236/123:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
237/1:
%%capture
%run TEAM_13_geometry.ipynb
237/2:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
237/3:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
237/4:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
237/5:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
237/6:
%%capture
%run TEAM_13_geometry.ipynb
237/7:
from sksparse.cholmod import cholesky as chol
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
237/8:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
237/9:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
237/10:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
237/11: x.shape
237/12:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
237/13:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
237/14:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
237/15:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
237/16:
import numpy as np

##############################################################################

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[f_new,new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
238/1:
%%capture
%run current_density.ipynb
238/2:
##############################################################################
# Tree/Cotree gauging
##############################################################################

from mst import *

random = np.random.permutation(MESH.EdgesToVertices[:,:2].shape[0])
newListOfEdges = MESH.EdgesToVertices[random,:2]
# newListOfEdges = MESH.EdgesToVertices[:,:2]

g = Graph(MESH.np)

for i in range(newListOfEdges.shape[0]):
    g.addEdge(newListOfEdges[i,0],newListOfEdges[i,1],i)
    
g.KruskalMST()
indices = np.array(g.MST)[:,2]

LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],random[indices])
# LIST_DOF = np.setdiff1d(np.r_[:MESH.NoEdges],indices)

DD = sp.eye(MESH.NoEdges, format = 'csc')

R = DD[:,LIST_DOF]
183/3: R = pde.tools.tree_cotree_gauge(MESH)
183/4: R
183/5: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
239/1:
print('PyDev console: using IPython 8.15.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
239/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
239/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
239/4: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
240/1:
print('PyDev console: using IPython 8.20.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
240/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
240/3: R
240/4: MESH
240/5: 27728-4131
238/3:
##############################################################################
# Tree/Cotree gauging
##############################################################################

R = pde.tools.tree_cotree_gauge(MESH)
241/1:
%%capture
%run current_density.ipynb
241/2:
##############################################################################
# Tree/Cotree gauging
##############################################################################

R = pde.tools.tree_cotree_gauge(MESH)
242/1:
%%capture
%run current_density.ipynb
242/2:
##############################################################################
# Tree/Cotree gauging
##############################################################################

R = pde.tools.tree_cotree_gauge(MESH)
242/3: R
243/1:
print('PyDev console: using IPython 8.20.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
243/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
242/4:
##############################################################################
# Assembly
##############################################################################

order = 1

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
# R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')

M = phi_H1 @ D @ phi_H1.T

K = dphix_H1 @ D @ dphix_H1.T +\
    dphiy_H1 @ D @ dphiy_H1.T +\
    dphiz_H1 @ D @ dphiz_H1.T

# Kn = RSS @ K @ RSS.T

phix_Hcurl, phiy_Hcurl, phiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = order)
curlphix_Hcurl, curlphiy_Hcurl, curlphiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = order)

M_Hcurl = phix_Hcurl @ D @ phix_Hcurl.T +\
          phiy_Hcurl @ D @ phiy_Hcurl.T +\
          phiz_Hcurl @ D @ phiz_Hcurl.T

K_Hcurl = curlphix_Hcurl @ D @ curlphix_Hcurl.T +\
          curlphiy_Hcurl @ D @ curlphiy_Hcurl.T +\
          curlphiz_Hcurl @ D @ curlphiz_Hcurl.T
          
C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T +\
             phiy_Hcurl @ D @ dphiy_H1.T +\
             phiz_Hcurl @ D @ dphiz_H1.T

curlphix_Hcurl_P0, curlphiy_Hcurl_P0, curlphiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = 0)
phix_Hcurl_P0, phiy_Hcurl_P0, phiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = 0)
dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)

KR = R.T@K_Hcurl@R
MR = R.T@M_Hcurl@R

r = dx_x @ D @ phix_Hcurl.T +\
    dy_x @ D @ phiy_Hcurl.T +\
    dz_x @ D @ phiz_Hcurl.T


cholKR = chol(KR)
x = cholKR.solve_A(R.T@r)
x = R@x



ux = curlphix_Hcurl_P0.T @ x
uy = curlphiy_Hcurl_P0.T @ x
uz = curlphiz_Hcurl_P0.T @ x
242/5:
##############################################################################
# Storing to vtk
##############################################################################

import vtklib

grid = vtklib.createVTK(MESH)
vtklib.add_H1_Scalar(grid, phi_j, 'lel')
# vtklib.add_L2_Vector(grid,evJx,evJy,evJz,'kek')
vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'kek2')
vtklib.add_L2_Vector(grid,ux,uy,uz,'kek3')

vtklib.add_L2_Scalar(grid,dx_x_P0**2+dy_x_P0**2+dz_x_P0**2,'kek2magn')
vtklib.add_L2_Scalar(grid,ux**2+uy**2+uz**2,'kek3norm')
vtklib.writeVTK(grid, 'das2.vtu')
242/6:
##############################################################################
# Storing to vtk
##############################################################################

import vtklib

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
242/7:
##############################################################################
# Assembly
##############################################################################

order = 1

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
# R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')

M = phi_H1 @ D @ phi_H1.T

K = dphix_H1 @ D @ dphix_H1.T +\
    dphiy_H1 @ D @ dphiy_H1.T +\
    dphiz_H1 @ D @ dphiz_H1.T

# Kn = RSS @ K @ RSS.T

phix_Hcurl, phiy_Hcurl, phiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = order)
curlphix_Hcurl, curlphiy_Hcurl, curlphiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = order)

M_Hcurl = phix_Hcurl @ D @ phix_Hcurl.T +\
          phiy_Hcurl @ D @ phiy_Hcurl.T +\
          phiz_Hcurl @ D @ phiz_Hcurl.T

K_Hcurl = curlphix_Hcurl @ D @ curlphix_Hcurl.T +\
          curlphiy_Hcurl @ D @ curlphiy_Hcurl.T +\
          curlphiz_Hcurl @ D @ curlphiz_Hcurl.T
          
C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T +\
             phiy_Hcurl @ D @ dphiy_H1.T +\
             phiz_Hcurl @ D @ dphiz_H1.T

curlphix_Hcurl_P0, curlphiy_Hcurl_P0, curlphiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = 0)
phix_Hcurl_P0, phiy_Hcurl_P0, phiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = 0)
dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)

KR = R.T@K_Hcurl@R
MR = R.T@M_Hcurl@R

r = dx_x @ D @ phix_Hcurl.T +\
    dy_x @ D @ phiy_Hcurl.T +\
    dz_x @ D @ phiz_Hcurl.T


cholKR = chol(KR)
x = cholKR.solve_A(R.T@r)
x = R@x



ux = curlphix_Hcurl_P0.T @ x
uy = curlphiy_Hcurl_P0.T @ x
uz = curlphiz_Hcurl_P0.T @ x
242/8:
##############################################################################
# Storing to vtk
##############################################################################

import vtklib

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
242/9:
##############################################################################
# Storing to vtk
##############################################################################

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
242/10:
##############################################################################
# Storing to vtk
##############################################################################

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'x')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_x')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
242/11:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh
242/12:



mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/13:



mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/14:



mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/15:



mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/16:



mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

# threshed.set_active_vectors("grad_x")
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/17:



mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

# threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
# p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/18:
##############################################################################
# Tree/Cotree gauging
##############################################################################
MESH = pde.mesh3.netgen(geoOCCmesh)
R = pde.tools.tree_cotree_gauge(MESH)
242/19: R
242/20:
##############################################################################
# Assembly
##############################################################################

order = 1

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
# R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')

M = phi_H1 @ D @ phi_H1.T

K = dphix_H1 @ D @ dphix_H1.T +\
    dphiy_H1 @ D @ dphiy_H1.T +\
    dphiz_H1 @ D @ dphiz_H1.T

# Kn = RSS @ K @ RSS.T

phix_Hcurl, phiy_Hcurl, phiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = order)
curlphix_Hcurl, curlphiy_Hcurl, curlphiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = order)

M_Hcurl = phix_Hcurl @ D @ phix_Hcurl.T +\
          phiy_Hcurl @ D @ phiy_Hcurl.T +\
          phiz_Hcurl @ D @ phiz_Hcurl.T

K_Hcurl = curlphix_Hcurl @ D @ curlphix_Hcurl.T +\
          curlphiy_Hcurl @ D @ curlphiy_Hcurl.T +\
          curlphiz_Hcurl @ D @ curlphiz_Hcurl.T
          
C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T +\
             phiy_Hcurl @ D @ dphiy_H1.T +\
             phiz_Hcurl @ D @ dphiz_H1.T

curlphix_Hcurl_P0, curlphiy_Hcurl_P0, curlphiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = 0)
phix_Hcurl_P0, phiy_Hcurl_P0, phiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = 0)
dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)

KR = R.T@K_Hcurl@R
MR = R.T@M_Hcurl@R

r = dx_x @ D @ phix_Hcurl.T +\
    dy_x @ D @ phiy_Hcurl.T +\
    dz_x @ D @ phiz_Hcurl.T


cholKR = chol(KR)
x = cholKR.solve_A(R.T@r)
x = R@x



ux = curlphix_Hcurl_P0.T @ x
uy = curlphiy_Hcurl_P0.T @ x
uz = curlphiz_Hcurl_P0.T @ x
242/21:
##############################################################################
# Storing to vtk
##############################################################################

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'x')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_x')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
242/22:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh
242/23:



mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

# threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
# p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/24:



mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/25: # Magnetostatics solution
242/26:



mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/27:



mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='wireframe', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/28:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='wireframe', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/29:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
# p.add_mesh(threshed, style='wireframe', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/30:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='wireframe', color="w", label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/31:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/32:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2  label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
242/33:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
243/3: KR
243/4: KR.tocsc()
242/34:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/35: p.camera_position
242/36:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 1, 0)]
p.show(jupyter_backend="html")
242/37: p.camera_position
242/38: p.camera_position
242/39:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 1, 0)]
p.show(jupyter_backend="html")
242/40: p.camera_position
242/41:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/42: p.camera_position
242/43:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

# mesh.set_active_vectors("grad_x")
# glyphs = grid.glyph(orient="vectors", factor=0.1)
streamlines = grid.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150)
p.add_mesh(streamlines.tube(radius=0.001))

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/44:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

# mesh.set_active_vectors("grad_x")
# glyphs = grid.glyph(orient="vectors", factor=0.1)
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150)
p.add_mesh(streamlines.tube(radius=0.001))

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/45:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

# mesh.set_active_vectors("grad_x")
# glyphs = grid.glyph(orient="vectors", factor=0.1)
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150)
p.add_mesh(streamlines.tube(radius=2))

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/46:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

# mesh.set_active_vectors("grad_x")
# glyphs = grid.glyph(orient="vectors", factor=0.1)
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150)
p.add_mesh(streamlines.tube(radius=200))

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/47:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

mesh.set_active_vectors("grad_x")
# glyphs = grid.glyph(orient="vectors", factor=0.1)
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150)
p.add_mesh(streamlines.tube(radius=200))

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/48:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=10, n_points=150)
p.add_mesh(streamlines.tube(radius=200))

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/49:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=10, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/50:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=True, source_radius=10, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/51:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=10, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/52:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=10, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/53:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x")
p.add_mesh(streamlines.tube(radius=200))

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/54:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x")
p.add_mesh(streamlines)

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/55: streamlines
242/56:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/57: streamlines
242/58:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

# mesh.set_active_vectors("grad_x")
# streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
# p.add_mesh(streamlines.tube(radius=200))

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/59:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(scale="grad_x", return_source=False, source_radius=1000, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/60: streamlines
242/61:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

streamlines, src = mesh.streamlines(
    return_source=True,
    max_time=100.0,
    initial_step_length=2.0,
    terminal_speed=0.1,
    n_points=100,
    source_radius=100.0,
    source_center=(0, 0, 0),
)

# mesh.set_active_vectors("grad_x")
# streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/62: streamlines
242/63:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

mesh.set_active_vectors("grad_x")
streamlines, src = mesh.streamlines(
    return_source=True,
    max_time=100.0,
    initial_step_length=2.0,
    terminal_speed=0.1,
    n_points=100,
    source_radius=100.0,
    source_center=(0, 0, 0),
)

# mesh.set_active_vectors("grad_x")
# streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/64: streamlines
242/65:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

mesh.set_active_vectors("grad_x")
streamlines, src = mesh.streamlines(
    return_source=True,
    initial_step_length=2.0,
    terminal_speed=0.1,
    n_points=100,
    source_radius=100.0,
    source_center=(0, 0, 0),
)

# mesh.set_active_vectors("grad_x")
# streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/66:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

mesh.set_active_vectors("grad_x")
streamlines, src = mesh.streamlines(
    return_source=True,
    initial_step_length=2.0,
    terminal_speed=0.1,
    n_points=100,
    source_radius=100.0,
    source_center=(0, 0, 0),
)

# mesh.set_active_vectors("grad_x")
# streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
# p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/67: streamlines
242/68:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

mesh.set_active_vectors("grad_x")
streamlines, src = mesh.streamlines(
    return_source=True,
    initial_step_length=2.0,
    terminal_speed=1,
    n_points=100,
    source_radius=100.0,
    source_center=(0, 0, 0),
)

# mesh.set_active_vectors("grad_x")
# streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
# p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/69:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

mesh.set_active_vectors("grad_x")
streamlines, src = mesh.streamlines(
    return_source=True,
    initial_step_length=2.0,
    terminal_speed=1,
    n_points=100,
    source_radius=100.0,
    source_center=(0, 0, 0),
)

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
# p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/70: streamlines
242/71:
stream, src = mesh.streamlines('vectors', return_source=True,
                               terminal_speed=0.0, n_points=200,
                               source_radius=0.1)
242/72:
stream, src = mesh.streamlines('grad_x', return_source=True,
                               terminal_speed=0.0, n_points=200,
                               source_radius=0.1)
242/73:
stream, src = mesh.streamlines('grad_x', return_source=True,
                               terminal_speed=0.0, n_points=200,
                               source_radius=0.1)
stream
242/74:
stream, src = mesh.streamlines('grad_x', return_source=True,
                               terminal_speed=0.0, n_points=200,
                               source_radius=0.1)
stream
242/75:
stream, src = mesh.streamlines('grad_x', return_source=True,
                               terminal_speed=0.0, n_points=200,
                               source_radius=0.1)
stream.size
242/76:
stream, src = mesh.streamlines('grad_x', return_source=True,
                               terminal_speed=0.0, n_points=200,
                               source_radius=0.1)
stream.shape
242/77:
stream, src = mesh.streamlines('grad_x', return_source=True,
                               terminal_speed=0.0, n_points=200,
                               source_radius=0.1)
stream.size
242/78:
stream, src = mesh.streamlines('grad_x', return_source=True,
                               terminal_speed=0.0, n_points=200,
                               source_radius=0.1)
stream.active_normals
242/79:
stream, src = mesh.streamlines('grad_x', return_source=True,
                               terminal_speed=0.0, n_points=200,
                               source_radius=0.1)
stream.
242/80: src
242/81:
stream, src = mesh.streamlines('grad_x', return_source=True,
                               terminal_speed=10, n_points=200,
                               source_radius=0.1)
stream.
242/82: src
242/83:
stream, src = mesh.streamlines('grad_x', return_source=True,
                               terminal_speed=10, n_points=200,
                               source_radius=0.1)
stream
242/84:
stream, src = mesh.streamlines(vector = 'grad_x', return_source=True,
                               terminal_speed=10, n_points=200,
                               source_radius=0.1)
stream
242/85: src
242/86:
stream, src = mesh.streamlines(vectors = 'grad_x', return_source=True,
                               terminal_speed=10, n_points=200,
                               source_radius=0.1)
stream
242/87: src
242/88:
stream, src = mesh.streamlines(vectors = 'grad_x', return_source=True,
                               terminal_speed=10, n_points=1000,
                               source_radius=0.1)
stream
242/89: src
242/90:
stream, src = mesh.streamlines(vectors = 'grad_x')
stream
242/91:
stream = mesh.streamlines(vectors = 'grad_x')
stream
242/92:
stream = mesh.streamlines(vectors = 'grad_x').tube()
stream
242/93:
stream = mesh.streamlines(vectors = 'grad_x').tube()
stream
242/94:
stream = mesh.streamlines(vectors = 'grad_x').tube(radius=200)
# p.add_mesh(streamlines.tube(radius=200))
stream
242/95:
stream = mesh.streamlines(vectors = 'grad_x').tube(radius=200)
p.add_mesh(stream)
stream
242/96: src
242/97:
stream = mesh.streamlines(vectors = 'grad_J').tube(radius=200)
p.add_mesh(stream)
stream
242/98: src
242/99:
stream = mesh2.streamlines(vectors = 'grad_J').tube(radius=200)
p.add_mesh(stream)
stream
242/100:
stream = mesh2.streamlines_from_source(vectors = 'grad_J').tube(radius=200)
p.add_mesh(stream)
stream
242/101:
stream = mesh2.streamlines_from_source(source = 'grad_J').tube(radius=200)
p.add_mesh(stream)
stream
242/102:
##############################################################################
# Storing to vtk
##############################################################################

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'x')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_x')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
242/103:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
# p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/104: p.camera_position
242/105:
stream = mesh2.streamlines_from_source(source = 'grad_J').tube(radius=200)
p.add_mesh(stream)
stream
242/106:
stream = mesh2.streamline(source = 'grad_J').tube(radius=200)
p.add_mesh(stream)
stream
242/107:
stream = mesh.streamline(source = 'grad_J').tube(radius=200)
p.add_mesh(stream)
stream
242/108:
stream = mesh.streamline(source = 'grad_J').tube(radius=200)
p.add_mesh(stream)
stream
mesh
242/109:
mesh
stream = mesh.streamline(source = 'grad_J').tube(radius=200)
p.add_mesh(stream)
stream
mesh
242/110:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# p.add_mesh(stream)
# stream
# mesh
242/111:
mesh
stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# p.add_mesh(stream)
# stream
# mesh
242/112:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# p.add_mesh(stream)
# stream
# mesh
242/113:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# p.add_mesh(stream)
# stream
# mesh
stream, src = mesh.streamlines(
    'vectors', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
)
242/114:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# p.add_mesh(stream)
# stream
# mesh
stream, src = mesh.streamlines(
    'grad_J', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
)
242/115:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# p.add_mesh(stream)
# stream
# mesh
stream, src = mesh.streamlines(
    'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
)
242/116: stream
242/117:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
stream, src = mesh.streamlines(
    'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
)
p.add_mesh(stream)
242/118:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
stream = mesh.streamlines(source_radius=0, n_points=1, source_center=(x, y, z))
p.add_mesh(stream)
242/119:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
stream = mesh.streamlines(source_radius=0, n_points=1, source_center=(0, 0, 0))
p.add_mesh(stream)
242/120:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
stream = mesh.streamlines(source_radius=0, n_points=1, source_center=(0, 0, 0)).tube(radius=0.0015)
p.add_mesh(stream)
242/121:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
stream = mesh.streamlines(source_radius=0, n_points=1, source_center=(0, 0, 0)).tube(radius=321)
p.add_mesh(stream)
242/122:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
stream = mesh.streamlines(source_radius=0, n_points=1, source_center=(0, 0, 0)).tube(radius=2)
p.add_mesh(stream)
242/123:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
stream = mesh.streamlines(source_radius=0, n_points=1, source_center=(0, 0, 0)).tube(radius=1)
p.add_mesh(stream)
242/124:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
stream = mesh.streamlines(source_radius=0, n_points=1, source_center=(0, 0, 0)).tube(radius=0)
p.add_mesh(stream)
242/125:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
stream = mesh.streamlines(source_radius=1, n_points=1, source_center=(0, 0, 0)).tube(radius=1)
p.add_mesh(stream)
242/126:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
mesh.set_active_vectors("grad_x")
stream = mesh.streamlines(source_radius=1, n_points=1, source_center=(0, 0, 0)).tube(radius=1)
p.add_mesh(stream)
242/127: stream
242/128:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
mesh.set_active_vectors("grad_x")
stream = mesh.streamlines(source_radius=1, n_points=1, source_center=(0, 0, 0)).tube(radius=1)
p.add_mesh(stream)
242/129:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
mesh.set_active_vectors("grad_x")
stream = mesh.streamlines(source_radius=1, n_points=1, source_center=(1, 0, 2)).tube(radius=1)
p.add_mesh(stream)
242/130:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
mesh.set_active_vectors("grad_x")
stream = mesh.streamlines(vectors = "grad_x", source_radius=1, n_points=1, source_center=(1, 0, 2)).tube(radius=1)
p.add_mesh(stream)
242/131:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
stream = meshs.streamlines(vectors = "grad_J", source_radius=1, n_points=1, source_center=(1, 0, 2)).tube(radius=1)
p.add_mesh(stream)
242/132:
mesh
# stream = mesh.streamline(source = 'grad_J').tube(radius=200)
# 
# stream
# mesh
# stream, src = mesh.streamlines(
#     'grad_x', return_source=True, max_steps=20000, n_points=200, source_radius=25, source_center=(15, 0, 30)
# )
stream = mesh2.streamlines(vectors = "grad_J", source_radius=1, n_points=1, source_center=(1, 0, 2)).tube(radius=1)
p.add_mesh(stream)
242/133: mesh['grad_x']
242/134: mesh['grad_x'] = mesh['grad_x']*1000
242/135:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
# p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/136:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
# p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/137:
##############################################################################
# Storing to vtk
##############################################################################

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'x')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_x')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
242/138:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
# p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/139:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/140:
##############################################################################
# Storing to vtk
##############################################################################

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'x')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_x')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
242/141:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1000, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/142:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/143:
##############################################################################
# Storing to vtk
##############################################################################

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'x')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_x')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
242/144:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=1500)
p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/145:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150000)
p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/146:
##############################################################################
# Storing to vtk
##############################################################################

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'x')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_x')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
242/147:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150000)
p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/148:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150000)
p.add_mesh(streamlines.tube(radius=200))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/149:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150000)
p.add_mesh(streamlines.tube(radius=25))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/150:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150000)
p.add_mesh(streamlines.tube(radius=1))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/151:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150000)
p.add_mesh(streamlines.tube(radius=0))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/152:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=150000)
p.add_mesh(streamlines.tube(radius=0.001))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/153:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=1, n_points=1846)
p.add_mesh(streamlines.tube(radius=0.001))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/154:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')

mesh['grad_x'] = mesh['grad_x']*1000


mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
# arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000.0)
p.add_mesh(arrows, color="pink")

###

# mesh.set_active_vectors("grad_x")
# streamlines, src = mesh.streamlines(
#     return_source=True,
#     initial_step_length=2.0,
#     terminal_speed=1,
#     n_points=100,
#     source_radius=100.0,
#     source_center=(0, 0, 0),
# )

# mesh.set_active_vectors("grad_x")
streamlines = mesh.streamlines(vectors="grad_x", return_source=False, source_radius=100, n_points=1846)
p.add_mesh(streamlines.tube(radius=0.001))

###

mesh2 = pv.read('current_density.vtu')
arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/155:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/156:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1)
p.add_mesh(arrows, color="black")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/157:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="black")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/158:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", color = "grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="black")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/159:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", color = "orange", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="black")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/160:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", color = "o", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="black")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/161:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="grad_x")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/162:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="grad_x")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="orange")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/163:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="grad_x")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="w")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/164:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="grad_x")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/165:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/166:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 600, 0),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/167:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 0),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/168:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/169: p.camera_posi
242/170: p.camera_position
242/171:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 10, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/172:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, 100, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/173:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -100, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/174:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -1000, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/175:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -100, 60),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/176:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -200, 200),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/177:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -300, 2300),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/178:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -300, 300),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/179:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
242/180:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
244/1:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
245/1:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
245/2:
%%capture
%run current_density.ipynb
245/3:
##############################################################################
# Tree/Cotree gauging
##############################################################################
MESH = pde.mesh3.netgen(geoOCCmesh)
R = pde.tools.tree_cotree_gauge(MESH)
245/4: R
245/5:
##############################################################################
# Assembly
##############################################################################

order = 1

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
# R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')

M = phi_H1 @ D @ phi_H1.T

K = dphix_H1 @ D @ dphix_H1.T +\
    dphiy_H1 @ D @ dphiy_H1.T +\
    dphiz_H1 @ D @ dphiz_H1.T

# Kn = RSS @ K @ RSS.T

phix_Hcurl, phiy_Hcurl, phiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = order)
curlphix_Hcurl, curlphiy_Hcurl, curlphiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = order)

M_Hcurl = phix_Hcurl @ D @ phix_Hcurl.T +\
          phiy_Hcurl @ D @ phiy_Hcurl.T +\
          phiz_Hcurl @ D @ phiz_Hcurl.T

K_Hcurl = curlphix_Hcurl @ D @ curlphix_Hcurl.T +\
          curlphiy_Hcurl @ D @ curlphiy_Hcurl.T +\
          curlphiz_Hcurl @ D @ curlphiz_Hcurl.T
          
C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T +\
             phiy_Hcurl @ D @ dphiy_H1.T +\
             phiz_Hcurl @ D @ dphiz_H1.T

curlphix_Hcurl_P0, curlphiy_Hcurl_P0, curlphiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = 0)
phix_Hcurl_P0, phiy_Hcurl_P0, phiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = 0)
dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)

KR = R.T@K_Hcurl@R
MR = R.T@M_Hcurl@R

r = dx_x @ D @ phix_Hcurl.T +\
    dy_x @ D @ phiy_Hcurl.T +\
    dz_x @ D @ phiz_Hcurl.T


cholKR = chol(KR)
x = cholKR.solve_A(R.T@r)
x = R@x



ux = curlphix_Hcurl_P0.T @ x
uy = curlphiy_Hcurl_P0.T @ x
uz = curlphiz_Hcurl_P0.T @ x
245/6:
##############################################################################
# Storing to vtk
##############################################################################

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'x')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_x')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
245/7:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
245/8:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,5])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
245/9:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,5])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="surface", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
245/10:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,5])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color="", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
245/11:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,5])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
245/12:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,4])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
245/13:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color = "w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
247/1:
%%capture
%run current_density.ipynb
247/2:
##############################################################################
# Tree/Cotree gauging
##############################################################################
MESH = pde.mesh3.netgen(geoOCCmesh)
R = pde.tools.tree_cotree_gauge(MESH)
247/3: R
247/4:
##############################################################################
# Assembly
##############################################################################

order = 1

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
D = pde.int.assemble3(MESH, order = order)
# R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')

M = phi_H1 @ D @ phi_H1.T

K = dphix_H1 @ D @ dphix_H1.T +\
    dphiy_H1 @ D @ dphiy_H1.T +\
    dphiz_H1 @ D @ dphiz_H1.T

# Kn = RSS @ K @ RSS.T

phix_Hcurl, phiy_Hcurl, phiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = order)
curlphix_Hcurl, curlphiy_Hcurl, curlphiz_Hcurl = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = order)

M_Hcurl = phix_Hcurl @ D @ phix_Hcurl.T +\
          phiy_Hcurl @ D @ phiy_Hcurl.T +\
          phiz_Hcurl @ D @ phiz_Hcurl.T

K_Hcurl = curlphix_Hcurl @ D @ curlphix_Hcurl.T +\
          curlphiy_Hcurl @ D @ curlphiy_Hcurl.T +\
          curlphiz_Hcurl @ D @ curlphiz_Hcurl.T
          
C_Hcurl_H1 = phix_Hcurl @ D @ dphix_H1.T +\
             phiy_Hcurl @ D @ dphiy_H1.T +\
             phiz_Hcurl @ D @ dphiz_H1.T

curlphix_Hcurl_P0, curlphiy_Hcurl_P0, curlphiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'K', order = 0)
phix_Hcurl_P0, phiy_Hcurl_P0, phiz_Hcurl_P0 = pde.hcurl.assemble3(MESH, space = 'N0', matrix = 'M', order = 0)
dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)

KR = R.T@K_Hcurl@R
MR = R.T@M_Hcurl@R

r = dx_x @ D @ phix_Hcurl.T +\
    dy_x @ D @ phiy_Hcurl.T +\
    dz_x @ D @ phiz_Hcurl.T


cholKR = chol(KR)
x = cholKR.solve_A(R.T@r)
x = R@x



ux = curlphix_Hcurl_P0.T @ x
uy = curlphiy_Hcurl_P0.T @ x
uz = curlphiz_Hcurl_P0.T @ x
247/5:
##############################################################################
# Storing to vtk
##############################################################################

grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'x')
pde.tools.vtklib.add_L2_Vector(grid,ux,uy,uz,'grad_x')
pde.tools.vtklib.writeVTK(grid, 'magnetostatics_solution.vtu')
247/6:
import pyvista as pv
mesh = pv.read('magnetostatics_solution.vtu')
mesh2 = pv.read('current_density.vtu')

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("x")
p.add_mesh(threshed, style='surface', color = "w", opacity=0.2, label=None)

threshed.set_active_vectors("grad_x")
arrows = mesh.glyph(scale="grad_x", orient=True, tolerance=0.03, factor=1000)
p.add_mesh(arrows, color="orange")

arrows2 = mesh2.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows2, color="black")

p.camera_position = [(0, -400, 400),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend="html")
243/5: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/6: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/7: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/8: RS0
243/9: K
243/10: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/11: n_phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'n*phi', shape = phi_H1.shape, order = order)
243/12: n_phiB_H1
243/13: face_in_1
243/14: pde.h1.assembleBR3
243/15: pde.h1.assembleBR3
243/16: n_phiB_H1.T @ DB @ phiB_H1
243/17: n_phiB_H1 @ DB @ phiB_H1.T
243/18: AA = n_phiB_H1 @ DB @ phiB_H1.T
243/19: AA-AA.T
243/20: (AA-AA.T).max()
243/21: (AA-AA.T).min()
243/22: (AA+AA.T).min()
243/23: (AA+AA.T).max()
243/24: MESH.BoundaryFaces_Region
243/25: MESH.BoundaryFaces_Region==6
243/26: MESH.normals[MESH.BoundaryFaces_Region==6,:]
243/27: plt
243/28: import matplotlib.pyplot as plt
243/29: plt
243/30: ls
243/31: plt.spy(AA)
243/32: AA.A
243/33: AA
243/34: plt.spy(AA,markersize=1)
243/35: plt.spy(AA,markersize=1)
243/36: plt.spy(AA-AA.T,markersize=1)
243/37: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/38: x
243/39: x.max()
243/40: x.min()
243/41: R1
243/42: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/43: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/44: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/45: RS1
243/46:
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')
243/47: RS0
243/48: RS1
243/49:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

R_jump = RS0-RS1

K = R_jump @ K @ R_jump.T
243/50:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

R_jump = RS0-RS1

K = R_jump @ K @ R_jump.T
243/51:

K = R_jump @ K @ R_jump.T
243/52:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

R_jump = RS0-RS1

K = R_jump @ K @ R_jump.T
243/53:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

R_jump = RS0-RS1

K = R_jump @ K @ R_jump.T

RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T
243/54: K
243/55: np.linalg.matrix_rank(K.A)
243/56: R_jump
243/57: R_jump.A
243/58: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo_occ_direct.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/59: box1
243/60: gp_Pnt
243/61: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo_occ_direct.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/62: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo_occ_direct.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/63: TopExp_Explorer
243/64: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo_occ_direct.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/65: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo_occ_direct.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/66: cylinder
243/67: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\t13geo_occ_direct.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
243/68: rounded_box1
243/69: from OCC.Display.SimpleGui import init_display
243/70: init_display
243/71: init_display()
243/72: BRepFilletAPI_MakeFillet
243/73:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh.plot()
243/74: R_jump.shape
243/75:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

R_jump = RS0-RS1

K = R_jump @ K @ R_jump.T
243/76: K
243/77:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

R_jump = RS0-RS1

K = R_jump @ K @ R_jump.T

RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T
243/78: K
243/79: K.shape
243/80: np.linalg.matrix_rank(K.A,tol=1)
243/81: np.linalg.matrix_rank(K.A,tol=1e-12)
243/82: np.linalg.matrix_rank(K.A,tol=1e-14)
243/83: np.linalg.matrix_rank(K.A,tol=1e-12)
243/84: 17*2+819
243/85:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

R_jump = RS0#-RS1

K = R_jump @ K @ R_jump.T

RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T
243/86: K
243/87: np.linalg.matrix_rank(K.A,tol=1e-12)
243/88: RS0
243/89: RS1
243/90: R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new')
243/91: identifications
243/92: MESH.identifications
243/93: MESH.identifications[0,:]
243/94: MESH.identifications[:,0]
243/95: MESH.identifications[:,1]
243/96: MESH.identifications[:,1]
243/97:
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])
243/98:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])

R_jump = RS0-RS1

K = R_jump @ K @ R_jump.T

RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T
243/99: K
243/100: np.linalg.matrix_rank(K.A,tol=1e-12)
243/101: 819+17*2
243/102:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])

R_jump = RS0+RS1

K = R_jump @ K @ R_jump.T

RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T
243/103: np.linalg.matrix_rank(K.A,tol=1e-12)
243/104: K
243/105: np.linalg.matrix_rank(K.A,tol=1e-13)
243/106: np.linalg.matrix_rank(K.A,tol=1e-4)
243/107: np.linalg.matrix_rank(K.A,tol=1e-12)
243/108: R_jump
243/109: indices = np.where((np.diff(K.indptr) != 0))[0]
243/110: indices = np.where((np.diff(K.indptr) != 0))[0]
243/111: indices = np.where((np.diff(K.indptr) != 0))[0]
243/112: indices = np.where((np.diff(K.indptr) != 0))
243/113:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])
243/114:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])

R_jump = RS0-RS1

K = R_jump @ K @ R_jump.T
243/115: K
243/116: indices = np.where((np.diff(K.indptr) != 0))[0]
243/117: indices = np.where((np.diff(K.indptr) != 0))
243/118: K
243/119: plt
243/120: plt.spy(K)
243/121: indices = np.where((np.diff(K.indptr) != 0))
243/122: indices = np.where((np.diff(K.indptr) != 0)).shape
243/123: indices = np.where((np.diff(K.indptr) != 0))[0]
243/124: indices = np.where((np.diff(K.indptr) != 0))[0].shape
248/1:
print('PyDev console: using IPython 8.20.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
248/2: indices = np.where((np.diff(K.indptr) != 0))[0].shape
248/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
248/4: indices = np.where((np.diff(K.indptr) != 0))[0].shape
248/5: indices = np.where((np.diff(K.indptr) != 0))[0]
248/6: indices = np.where((np.diff(K.indptr) != 0))[0]
248/7: print(indices)
248/8: indices = np.where((np.diff(K.indptr) != 0))[0]
249/1:
print('PyDev console: using IPython 8.20.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
249/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
249/3: K
249/4:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])

R_jump = RS0-RS1

K = R_jump @ K @ R_jump.T
249/5: indices = np.where((np.diff(K.indptr) != 0))[0]
249/6: indices = np.where((np.diff(K.indptr) != 0))
249/7: print(indices)
249/8: indices = np.where((np.diff(K.indptr) != 0))[0]
249/9: indices
249/10: indices = np.where((np.diff(K.indptr) != 0))[0].shape
249/11: indices = np.where((np.diff(K.indptr) != 0))[0]
249/12: indices.shape
249/13: K.indptr
249/14:
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])
249/15: RS0
249/16: RS0[1,:]
249/17: RS0[1,:].A
249/18: RS0[1,:].A.argmax()
249/19: RS0[2,:].A.argmax()
249/20: RS0[2,:].A
249/21: RS1[1,:].A.argmax()
249/22: RS0
249/23: RS1
249/24: (RS1-RS0)[1,:].A.argmax()
249/25: (RS1-RS0)[1,:].A
249/26: (RS1)[1,:]
249/27: (RS1)[1,:].A
249/28: (RS0)[1,:].A
249/29: MESH.identifications[:,1]
249/30: MESH.identifications[:,0]
249/31: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
249/32: (RS0)[1,:].A
249/33: (RS1)[1,:].A
250/1:
print('PyDev console: using IPython 8.20.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
250/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
250/3: (RS0)[1,:].A
250/4: (RS1)[1,:].A
250/5: R0
250/6: (R0)[1,:].A
250/7: (R0)[1,:].A.max()
250/8: (R0)[1,:].A.argmax()
250/9: (R1)[1,:].A.argmax()
250/10: MESH.regions_2d
250/11: np.unique(MESH.regions_2d)
250/12:
from scipy.sparse import bmat
R_jump =  bmat([[R_int], [RS0-RS1]])
250/13:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R_out, R_int = pde.hcurl.assembleR(MESH, space = 'P1', edges = 'coil_cut_1,new,ambient_face')
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])


from scipy.sparse import bmat
R_jump =  bmat([[R_int], [RS0-RS1]])
250/14: R_int
250/15: R_int
250/16:
R_out, R_int = pde.hcurl.assembleR3(MESH, space = 'P1', edges = 'coil_cut_1,new,ambient_face')
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])


from scipy.sparse import bmat
R_jump =  bmat([[R_int], [RS0-RS1]])
250/17:
R_out, R_int = pde.h1.assembleR3(MESH, space = 'P1', edges = 'coil_cut_1,new,ambient_face')
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])


from scipy.sparse import bmat
R_jump =  bmat([[R_int], [RS0-RS1]])
250/18:
R_out, R_int = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1,new,ambient_face')
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])


from scipy.sparse import bmat
R_jump =  bmat([[R_int], [RS0-RS1]])
250/19: R_jump
250/20: R_int
250/21:
R_out, R_int = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1,new')
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])


from scipy.sparse import bmat
R_jump =  bmat([[R_int], [RS0-RS1]])
250/22: R_jump
250/23: R_out
250/24: R_int
250/25: RS0
250/26:
R_out, R_int = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1,new')
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])


from scipy.sparse import bmat
R_jump =  bmat([[R_int], [R0-R1]])
250/27: R_jump
250/28:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R_out, R_int = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1,new')
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])


from scipy.sparse import bmat
R_jump =  bmat([[R_int], [R0-R1]])


K = R_jump @ K @ R_jump.T

RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T
250/29: K
250/30: np.linalg.matrix_rank(K.A,tol=1e-12)
250/31: np.linalg.matrix_rank(K.A,tol=1e-10)
250/32:

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R_out, R_int = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1,new')
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])


from scipy.sparse import bmat
R_jump =  bmat([[R_int], [R0+R1]])


K = R_jump @ K @ R_jump.T

RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T
250/33: np.linalg.matrix_rank(K.A,tol=1e-10)
250/34: K
250/35: R1
250/36: K
250/37: np.linalg.matrix_rank(K.A,tol=1e-2)
250/38: np.linalg.matrix_rank(K.A,tol=1e-4)
250/39: np.linalg.matrix_rank(K.A,tol=1e-7)
250/40: np.linalg.matrix_rank(K.A,tol=1e-9)
250/41: np.linalg.matrix_rank(K.A,tol=1e-10)
250/42: np.linalg.matrix_rank(K.A,tol=1e-11)
250/43: np.linalg.matrix_rank(K.A,tol=1e-12)
250/44: np.linalg.matrix_rank(K.A,tol=1e-15)
250/45:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T + \
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T + \
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

R_out, R_int = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1,new')
R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new', listDOF = MESH.identifications[:,0])
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1', listDOF = MESH.identifications[:,1])


from scipy.sparse import bmat
R_jump =  bmat([[R_int], [R0-R1]])


r = -R_jump @ K @ R1.T @ (1+np.zeros(R1.shape[0]))

K = R_jump @ K @ R_jump.T

RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T
250/46: K
250/47: np.linalg.matrix_rank(K.A,tol=1e-12)
250/48: np.linalg.matrix_rank(K.A,tol=1e-10)
250/49: np.linalg.matrix_rank(K.A,tol=1e-2)
250/50: np.linalg.matrix_rank(K.A,tol=1e-0)
250/51: np.linalg.matrix_rank(K.A,tol=1e-1)
250/52: np.linalg.matrix_rank(K.A,tol=1e-4)
250/53: np.linalg.matrix_rank(K.A,tol=1e-7)
250/54: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
250/55: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
250/56: K
250/57: chol(K)
250/58: np.linalg.matrix_rank(K.A,tol=1e-7)
250/59: K
250/60: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
250/61: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
250/62: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
250/63: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
250/64: R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')
250/65: RSS
250/66: R
250/67: R = pde.tools.tree_cotree_gauge(MESH)
250/68: R0, RSS = pde.h1.assembleR3(MESH, space = 'P1', faces = 'ambient_face')
250/69: R0, RSS = pde.hcurl.assembleR3(MESH, space = 'P1', faces = 'ambient_face')
250/70: MESH.BoundaryFaces_Region
251/1:
print('PyDev console: using IPython 8.20.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
%aimport -pydev_umd
251/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/3: R0, RSS = pde.hcurl.assembleR3(MESH, space = 'P1', faces = 'ambient_face')
251/4: R0
251/5: RSS
251/6: R0, RSS = pde.hcurl.assembleR3(MESH, space = 'N0', faces = 'ambient_face')
251/7: edges = []
251/8: edges == []
251/9: edges = ['a']
251/10: edges == []
251/11: edges = []
251/12: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/13: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/14: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/15: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/16: ambient_edges_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
251/17: ambient_edges_indices
251/18: edges
251/19: MESH.EdgesToVertices
251/20: ambient_edges_indices
251/21: MESH.BoundaryFaces_Region
251/22: MESH.EdgesToVertices[:,2]
251/23: np.intersect1d(MESH.EdgesToVertices[:,2],ambient_edges_indices)
251/24: np.argwhere(MESH.EdgesToVertices[:,2],ambient_edges_indices)
251/25: ambient_edges_indices
251/26: MESH.EdgesToVertices[:,:2]
251/27: MESH.EdgesToVertices
251/28: MESH.EdgesToVertices
251/29: MESH.FacesToVertices
251/30: MESH.FacesToVertices
251/31: MESH.TetsToEdges
251/32: MESH.TetsToEdges.shape
251/33: MESH.BoundaryFaces_Region.shape
251/34: MESH.TetsToEdges.shape
251/35: MESH.NoFaces
251/36: MESH.NoEdges
251/37: MESH.TetsToEdges
251/38: MESH.TetsToEdges.shape
251/39: MESH = pde.mesh3.netgen(geoOCCmesh)
251/40: MESH.TetsToEdges
251/41: MESH.TetsToEdges.shape
251/42: MESH
251/43: MESH.TetsToEdges.shape
251/44: MESH.TetsToEdges
251/45: MESH.TetsToFaces
251/46: MESH.TetsToFaces.shape
251/47: MESH.Boundary_Faces
251/48: MESH.FacesToEdges
251/49: MESH.FacesToVertices
251/50: MESH.TetsToEdges
251/51: MESH.TetsToFaces
251/52: MESH.TetsToEdges[:3,:]
251/53: MESH.TetsToEdges[:,:3]
251/54: MESH.TetsToEdges[:,[0,1,2]]
251/55: MESH.TetsToEdges[:,[0,1,2]]
251/56: MESH.TetsToEdges[:,[0,1,3]]
251/57: MESH.TetsToEdges[:,[0,1,1]]
251/58: MESH.TetsToEdges[:,[0,1,2]]
251/59: t[:,0],t[:,1]
251/60: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/61: MESH.TetsToEdges
251/62: MESH.FacesToVertices
251/63: MESH.EdgesToVertices
251/64: MESH.FacesToVertices
251/65: MESH.TetsToFaces
251/66: MESH.TetsToEdges
251/67: np.c_[MESH.TetsToEdges[:,[0,1,1]],MESH.TetsToFaces[:,0]]
251/68:
np.r_[np.c_[MESH.TetsToEdges[:,[0,1,1]],MESH.TetsToFaces[:,0]],
np.c_[MESH.TetsToEdges[:,[0,2,3]],MESH.TetsToFaces[:,1]],
np.c_[MESH.TetsToEdges[:,[0,1,3]],MESH.TetsToFaces[:,2]],
np.c_[MESH.TetsToEdges[:,[0,1,2]],MESH.TetsToFaces[:,3]]]
251/69:
kek = np.r_[np.c_[MESH.TetsToEdges[:,[0,1,1]],MESH.TetsToFaces[:,0]],
np.c_[MESH.TetsToEdges[:,[0,2,3]],MESH.TetsToFaces[:,1]],
np.c_[MESH.TetsToEdges[:,[0,1,3]],MESH.TetsToFaces[:,2]],
np.c_[MESH.TetsToEdges[:,[0,1,2]],MESH.TetsToFaces[:,3]]]
251/70: kek[kek[:, 3].argsort()]
251/71:
kek = np.r_[np.c_[MESH.TetsToEdges[:,[1,2,3]],MESH.TetsToFaces[:,0]],
np.c_[MESH.TetsToEdges[:,[0,2,3]],MESH.TetsToFaces[:,1]],
np.c_[MESH.TetsToEdges[:,[0,1,3]],MESH.TetsToFaces[:,2]],
np.c_[MESH.TetsToEdges[:,[0,1,2]],MESH.TetsToFaces[:,3]]]
251/72: kek[kek[:, 3].argsort()]
251/73: MESH.TetsToFaces[:,3]
251/74: MESH.TetsToFaces
251/75: MESH.TetsToEdges
251/76: MESH.TetsToEdges
251/77:
kek = np.r_[np.c_[MESH.TetsToEdges[:,[3,4,5]],MESH.TetsToFaces[:,0]],
np.c_[MESH.TetsToEdges[:,[1,2,5]],MESH.TetsToFaces[:,1]],
np.c_[MESH.TetsToEdges[:,[0,2,4]],MESH.TetsToFaces[:,2]],
np.c_[MESH.TetsToEdges[:,[0,1,3]],MESH.TetsToFaces[:,3]]]
251/78: kek[kek[:, 3].argsort()]
251/79:
kek = np.r_[np.c_[MESH.TetsToEdges[:,[3,4,5]],MESH.TetsToFaces[:,0]],
np.c_[MESH.TetsToEdges[:,[1,2,5]],MESH.TetsToFaces[:,1]],
np.c_[MESH.TetsToEdges[:,[0,2,4]],MESH.TetsToFaces[:,2]],
np.c_[MESH.TetsToEdges[:,[0,1,3]],MESH.TetsToFaces[:,3]]]

kek = kek[kek[:, 3].argsort()]
kek = np.unique(kek, axis=0)
251/80: kek
251/81: kek.shape
251/82: MESH
251/83: kek.max()
251/84: kek[:,:3]
251/85: kek[:,:3].max()
251/86: MESh
251/87: MESH
251/88: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/89: MESH.EdgesToFaces
251/90: MESH.EdgesToFaces.shape
251/91: MESH.EdgesToFaces.max()
251/92: MESH
251/93: ambient_edges_indices
251/94: MESH.TetsToFaces
251/95: MESH.f
251/96: MESH.f.shape
251/97: MESH.FacesToVertices
251/98: MESH.FacesToVertices.shape
251/99: MESH.FacesToVertices[:,3]
251/100: pde.intersect2d(MESH.FacesToVertices[:,3],ambient_edges_indices)
251/101: MESH.FacesToVertices[:,3]
251/102: np.intersect1d(MESH.FacesToVertices[:,3],ambient_edges_indices)
251/103: np.in1d(MESH.FacesToVertices[:,3],ambient_edges_indices)
251/104:
ambient_edges_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
ambient_edges_indices = np.in1d(MESH.FacesToVertices[:,3],ambient_edges_indices)
251/105: ambient_edges_indices
251/106: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/107: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/108: edges
251/109: MESH.EdgesToVertices[ambient_edges_indices,:2]
251/110: ambient_edges_indices.shape
251/111: MESH.EdgesToVertices.shape
251/112: MESH.FacesToVertices
251/113: MESH.EdgesToFaces
251/114: np.in1d(MESH.EdgesToFaces[:,3],ambient_edges_indices)
251/115: ambient_edges_indices
251/116: ambient_edges_indices.shape
251/117: MESH.EdgesToFaces.shape
251/118: MESH.EdgesToFaces[:,np.in1d(MESH.FacesToVertices[:,3],ambient_edges_indices)]
251/119: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/120: np.in1d(MESH.FacesToVertices[:,3],ambient_edges_indices)
251/121: MESH.EdgesToFaces
251/122: np.in1d(MESH.FacesToVertices[:,3],ambient_edges_indices).shape
251/123: MESH.EdgesToFaces.shape
251/124: MESH.EdgesToFaces[np.in1d(MESH.FacesToVertices[:,3],ambient_edges_indices),:]
251/125: MESH.EdgesToFaces[np.in1d(MESH.FacesToVertices[:,3],ambient_edges_indices)]
251/126: ambient_edges_indices
251/127:
ambient_edges_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
ambient_edges_indices = MESH.EdgesToFaces[np.in1d(MESH.FacesToVertices[:,3],ambient_edges_indices)]
251/128: ambient_edges_indices
251/129:
ambient_edges_indices = pde.tools.getIndices(MESH.regions_2d,'ambient_face')
ambient_edges_indices = np.unique(MESH.EdgesToFaces[np.in1d(MESH.FacesToVertices[:,3],ambient_edges_indices)])
251/130: ambient_edges_indices
251/131: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/132: ambient_edges_indices.shape
251/133: MESH.EdgesToVertices.shape
251/134: np.setdiff1d(np.arange(MESH.NoEdges),ambient_edges_indices)
251/135: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/136: R
251/137: R.shape
251/138: MESH
251/139: 27728-4132
251/140: 27728-4132+1
251/141: K
251/142: np.linalg.matrix_rank(K)
251/143: np.linalg.matrix_rank(K.A)
251/144: K.shape
251/145: EdgesToFaces
251/146: EdgesToFaces
251/147: MESH.EdgesToFaces
251/148: MESH.EdgesToVertices
251/149: edges
251/150: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/151: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
251/152:
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

# K_Hdiv = divphi_Hdiv @ D @ divphi_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T


AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])
251/153: from scipy.sparse import bmat
251/154:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

# K_Hdiv = divphi_Hdiv @ D @ divphi_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T


AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])
251/155:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

# K_Hdiv = divphi_Hdiv @ D @ divphi_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T


AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])
251/156: AA
251/157: plt.spy(AA,markersize=1)
251/158: import matplotlib.pyplot as plt
251/159: plt.spy(AA,markersize=1)
251/160:

RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T
251/161:

RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T
251/162: AA
251/163: plt.spy(AA,markersize=1)
251/164: np.linalg.matrix_rank(AA.A)
251/165: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')
251/166: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'P1', faces = 'coil_face')
251/167: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'P1', faces = 'coil_face')
251/168: R1
251/169: RS1
251/170: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')
251/171: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')
251/172: RS1
251/173: R1
251/174: MESH
251/175: AA = RS1 @ AA @ RS1.T
251/176: AA = RS1 @ AA @ RS1.T
251/177: AA = RS1.T @ AA @ RS1
251/178: RS1
251/179: AA
251/180:
AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])
251/181: AA = RS1.T @ AA @ RS1
251/182: M_Hdiv_coil_full = RS1 @ M_Hdiv_coil_full @RS1.T
251/183: M_Hdiv_coil_full = RS1 @ M_Hdiv_coil_full @RS1.T
251/184: RS1
251/185: M_Hdiv_coil_full
251/186:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

# K_Hdiv = divphi_Hdiv @ D @ divphi_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = RS1 @ M_Hdiv_coil_full @RS1.T
251/187: M_Hdiv_coil_full
251/188: C_Hdiv_L2
251/189:
C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = RS1 @ M_Hdiv_coil_full @RS1.T
C_Hdiv_L2 = RS1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])
251/190:
C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = RS1 @ M_Hdiv_coil_full @RS1.T
C_Hdiv_L2 = RS1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])
251/191:

RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T
251/192: AA
251/193:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

# K_Hdiv = divphi_Hdiv @ D @ divphi_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = RS1 @ M_Hdiv_coil_full @RS1.T
C_Hdiv_L2 = RS1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])


RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T
251/194: AA
251/195: phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)
252/1:
print('PyDev console: using IPython 8.20.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
# %aimport -pydev_umd
252/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
252/3: R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')
252/4:
M_Hdiv_coil_full = RS1 @ M_Hdiv_coil_full @RS1.T
C_Hdiv_L2 = RS1 @ C_Hdiv_L2
252/5:
M_Hdiv_coil_full = RS1 @ M_Hdiv_coil_full @RS1.T
C_Hdiv_L2 = RS1 @ C_Hdiv_L2
252/6:

##############################################################################
# Hdiv solver
##############################################################################

order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = RS1 @ M_Hdiv_coil_full @RS1.T
C_Hdiv_L2 = RS1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])


RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T
252/7: AA
252/8: pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phi_H1.shape, order = order)
252/9: phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phi_H1.shape, order = order)
252/10: phiB_Hdiv
252/11: phiB_Hdiv
252/12: phiB_Hdiv.shape
252/13: phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phi_H1.shape, order = order)
252/14: phiB_Hdiv
253/1:
print('PyDev console: using IPython 8.20.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
# %aimport -pydev_umd
253/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
253/3: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
253/4:

phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
253/5: phiB_Hdiv
253/6: MESH
253/7: unit_coil = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
253/8: unit_coil = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x)
253/9:
phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1')
253/10: unit_coil = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1')
256/1:
print('PyDev console: using IPython 8.20.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
%load_ext autoreload
%autoreload 2
# %aimport -pydev_umd
256/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
256/3:
phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1')
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil @ DB @ phiB_Hdiv
256/4:
phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1')
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil @ DB @ phiB_Hdiv
256/5:
phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1')
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil @ DB @ phiB_Hdiv
256/6: rhs = unit_coil @ DB @ phiB_Hdiv.T
256/7: rhs.shape
256/8:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T
256/9:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T
256/10: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
256/11:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
C_Hdiv_L2 = R1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])
256/12: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
256/13: rhs
256/14: rhs = R1 @ rhs
256/15: rhs = R1 @ rhs
256/16: R1
256/17: rhs
256/18:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T
256/19: M_Hdiv_coil_full
256/20:
phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1')
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
256/21: rhs
256/22:
phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
256/23:
phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
256/24: rhs
256/25: rhs.shape
256/26: AA.shape
256/27: M_Hdiv_coil_full.shape
256/28:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
C_Hdiv_L2 = R1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])


RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T

phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = R1 @ rhs
256/29: rhs.shape
256/30: M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
256/31: M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
256/32:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
256/33: M_Hdiv_coil_full.shape
256/34:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
C_Hdiv_L2 = R1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])


RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T

phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = RZdiv @ R1 @ rhs
256/35:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
C_Hdiv_L2 = R1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])


RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T

phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = RZdiv @ R1 @ rhs
256/36: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
256/37: RZdiv
256/38: rhs = np.r_[rhs,MESH.nt]
256/39:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
C_Hdiv_L2 = R1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])


RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T

phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[rhs,MESH.nt]

rhs = RZdiv @ R1 @ rhs
256/40:
rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[rhs,MESH.nt]
256/41: rhs
256/42: rhs.shape
256/43: RZdiv.shape
256/44:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
C_Hdiv_L2 = R1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])
256/45: AA.shape
256/46: RZdiv
256/47: R1.shape
256/48: MESH
256/49: C_Hdiv_L2.shape
256/50:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
C_Hdiv_L2 = R1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])


RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T

phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[rhs,C_Hdiv_L2.shape[0]]

rhs = RZdiv @ R1 @ rhs
256/51:
order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
C_Hdiv_L2 = R1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])


RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T

phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[rhs,C_Hdiv_L2.shape[0]]

rhs = RZdiv @ R1 @ rhs
256/52:

order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
C_Hdiv_L2 = R1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])


RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T

phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[rhs,C_Hdiv_L2.shape[1]]

rhs = RZdiv @ R1 @ rhs
256/53:

order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
C_Hdiv_L2 = R1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])


RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T

phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[rhs,C_Hdiv_L2.shape[1]]

rhs = RZdiv @ R1 @ rhs
256/54:

order = 1
phix_Hdiv, phiy_Hdiv, phiz_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = order)
divphi_Hdiv = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'K', order = order)

phi_L2 = pde.l2.assemble3(MESH, space = 'P0', matrix = 'M', order = order)

D = pde.int.assemble3(MESH, order = order)

M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T + \
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T + \
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T

C_Hdiv_L2 = divphi_Hdiv @ D @ unit_coil @ phi_L2.T
R1, R = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')

M_Hdiv_coil_full = R1 @ M_Hdiv_coil_full @R1.T
C_Hdiv_L2 = R1 @ C_Hdiv_L2

AA = bmat([[M_Hdiv_coil_full, C_Hdiv_L2],
           [C_Hdiv_L2.T, None]])


RZdiv = pde.tools.removeZeros(AA)
AA = RZdiv @ AA @ RZdiv.T

phiB_Hdiv = pde.hdiv.assembleB3(MESH, space = 'RT0', matrix = 'phi', shape = phix_Hdiv.shape, order = order)
unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
DB = pde.int.assembleB3(MESH, order = order)

rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[rhs,C_Hdiv_L2.shape[1]]

rhs = RZdiv @ R1 @ rhs
256/55:
rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[rhs,C_Hdiv_L2.shape[1]]
256/56: rhs.shape
256/57:
rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[R1@rhs,C_Hdiv_L2.shape[1]]

rhs = RZdiv @ rhs
256/58:
rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[R1@rhs,C_Hdiv_L2.shape[1]]

rhs = RZdiv @ rhs
256/59: rhs = np.r_[R1@rhs,C_Hdiv_L2.shape[1]]
256/60: rhs = np.r_[R1@rhs,C_Hdiv_L2.shape[1]]
256/61: R1@rhs
256/62: R1.T@rhs
256/63: R1
256/64: rhs
256/65: rhs.shape
256/66: R1
256/67:
rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[R1@rhs,MESH.nt]
256/68:
rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[R1@rhs,MESH.nt]
256/69: rhs
256/70: rhs.shape
256/71: MESH.nt
256/72: rhs = np.r_[R1@rhs,MESH.nt]
256/73: rhs = np.r_[R1@rhs,MESH.nt]
256/74:
rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[R1@rhs,MESH.nt]
256/75: rhs.shape
256/76: RZdiv
256/77:
rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[R1@rhs,np.zeros(MESH.nt)]

rhs = RZdiv @ rhs
256/78:
rhs = unit_coil_B @ DB @ phiB_Hdiv.T
rhs = np.r_[R1@rhs,np.zeros(MESH.nt)]

rhs = RZdiv @ rhs
256/79: rhs.shape
257/1:
print('PyDev console: using IPython 8.20.0\n')

import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['C:\\Users\\Radu\\Documents\\GitHub\\fem'])
# %load_ext autoreload
# %autoreload 2
# %aimport -pydev_umd
257/2: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
257/3: rhs.shape
257/4: AA.shape
257/5: import scipy.sparse as sp
257/6: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
257/7: runfile('\\solve_t13_strom.py')
257/8: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
257/9: AA
257/10: np.linalg.matrix_rank(AA.A)
257/11: runfile('C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM\\solve_t13_strom.py', wdir='C:\\Users\\Radu\\Documents\\GitHub\\fem\\PROJECTS\\TEAM')
257/12: np.linalg.matrix_rank(AA.A)
257/13: AA
257/14: M_Hdiv_coil_full
257/15: np.linalg.matrix_rank(M_Hdiv_coil_full.A)
257/16: np.linalg.matrix_rank(C_Hdiv_L2.A)
257/17: C_Hdiv_L2
254/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/2: RZdiv
254/3: AA
254/4: np.linalg.matrix_rank(AA.A)
254/5: np.linalg.matrix_rank(C_Hdiv_L2.A)
254/6: C_Hdiv_L2.shape
254/7: plt
254/8: import matplotlib.pyplot as plt
254/9: plt.spy(AA,markersize=1)
254/10: plt.spy(AA,markersize=1)
254/11: pde.tools.fastBlockInverse(M_Hdiv_coil_full)
254/12: kek = pde.tools.fastBlockInverse(M_Hdiv_coil_full)
254/13: kek
254/14: plt.spy(kek)
254/15: plt.spy(kek,markersize=1)
254/16: MESH.TetsToFaces
254/17:
M_Hdiv_coil_full = phix_Hdiv @ D  @ phix_Hdiv.T +\
                   phiy_Hdiv @ D  @ phiy_Hdiv.T +\
                   phiz_Hdiv @ D  @ phiz_Hdiv.T
254/18: plt.spy(M_Hdiv_coil_full,markersize=1)
254/19: unit_coil
254/20:
M_Hdiv_coil_full = phix_Hdiv @ D @ unit_coil @ phix_Hdiv.T +\
                   phiy_Hdiv @ D @ unit_coil @ phiy_Hdiv.T +\
                   phiz_Hdiv @ D @ unit_coil @ phiz_Hdiv.T
254/21: plt.spy(M_Hdiv_coil_full,markersize=1)
254/22: R1
254/23: MESH
254/24: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/25: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/26: xx
254/27: RZdiv.T@xx
254/28: plt.plot(RZdiv.T@xx)
254/29: plt.plot(RZdiv.T@xx)
254/30: (RZdiv.T@xx)[MESH.nt:-1]
254/31: MESH.nt:-1
254/32: np.r_[MESH.nt:-1]
254/33: np.r_[MESH.nt:]
254/34: np.r_[MESH.nt:-1]
254/35: np.r_[MESH.nt:1]
254/36: np.r_[-MESH.nt:1]
254/37: np.r_[-MESH.nt:]
254/38: (RZdiv.T@xx)[-MESH.nt:].shape
254/39: MESH
254/40: potential = (RZdiv.T@xx)[-MESH.nt:]
254/41: potential.min()
254/42: potential.max()
254/43: np.sort(potential)
254/44: plt.plot(np.sort(potential))
254/45: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/46: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/47: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/48: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/49: runfile('C:/Users/Radu/Documents/GitHub/fem/pde/hdiv/assemble3.py', wdir='C:/Users/Radu/Documents/GitHub/fem/pde/hdiv')
254/50: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/51: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/52: runfile('C:/Users/Radu/Documents/GitHub/fem/pde/hdiv/assemble3.py', wdir='C:/Users/Radu/Documents/GitHub/fem/pde/hdiv')
254/53: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/54: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/55: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/56: MESH.normals
254/57: MESH.normals.shape
254/58: MESH.BoundaryFaces_Region.shape
254/59: MESH.normals[MESH.BoundaryFaces_Region==6,:]
254/60: MESH.regions_2d
254/61: MESH.BoundaryFaces_Region==6
254/62: MESH.BoundaryFaces_Region
254/63: MESH.f
254/64: MESH.f[MESH.BoundaryFaces_Region==6,:]
254/65: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/66: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/67: unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
254/68: plt.plot(unit_coil_B)
254/69: unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'new').diagonal()
254/70: plt.plot(unit_coil_B)
254/71: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/72: np.where(unit_coil_B)
254/73: np.where(unit_coil_B).size
254/74: np.where(unit_coil_B).shape
254/75: np.argwhere(unit_coil_B).size
254/76: unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
254/77: np.argwhere(unit_coil_B).size
254/78: unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'new').diagonal()
254/79: np.argwhere(unit_coil_B).size
254/80: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/81: MESH.detB
254/82: MESH.detB(1,1)
254/83: MESH.detB(1,1).shape
254/84: MESH.normals.shape
254/85: MESH.DirectionFaces
254/86: rhs = unit_coil_B @ DB @ phiB_Hdiv.T
254/87: rhs
254/88: rhs[rhs!=0]
254/89: rhs[rhs!=0].shape
254/90: MESH.normals[MESH.BoundaryFaces_Region==6,:]
254/91: MESH.normals[MESH.BoundaryFaces_Region==6,:].shape
254/92: MESH.regions_2d
254/93: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/94: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/95: potential
254/96: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/97: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/98: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/99: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/100: unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'new').diagonal()
254/101: np.argwhere(unit_coil_B).size
254/102: rhs[rhs!=0].shape
254/103: rhs[rhs!=0]
254/104: MESH.nf
254/105: MESH.DirectionFaces.shape
254/106: MESH.DirectionFaces
254/107: MESH.TetsToFaces
254/108: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/109: unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'new').diagonal()
254/110: unit_coil_B[unit_coil_B!=0]
254/111: rhs = unit_coil_B @ DB @ phiB_Hdiv.T
254/112: rhs[rhs!=0]
254/113: unit_coil_B = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'new').diagonal()
254/114: rhs = unit_coil_B @ DB @ phiB_Hdiv.T
254/115: rhs[rhs!=0]
254/116: rhs = unit_coil_B*N1 @ DB @ phiB_Hdiv.T
254/117: rhs[rhs!=0]
254/118: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/119: rhs[rhs!=0]
254/120: rhs[rhs!=0][-1]=1
254/121: rhs[rhs!=0]
254/122: rhs[rhs!=0][-1]=1
254/123: rhs[rhs!=0]
254/124: rhs
254/125: np.where(rhs!=0)
254/126: np.argwhere(rhs!=0)
254/127: np.argwhere(rhs!=0)[-1]
254/128: rhs[np.argwhere(rhs!=0)[-1]]=-0.5
254/129: rhs[rhs!=0]
254/130: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/131: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/132: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/133: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/134: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/135: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/136: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/137: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/138: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/139: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/140: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/141: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/142: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/143: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/144: rhs[rhs!=0]
254/145: rhs[rhs!=0].size
254/146: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/147: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/148: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/149: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/150: MESH.normals[MESH.BoundaryFaces_Region==0,:]
254/151: MESH.regions_2d
254/152: MESH.normals[MESH.BoundaryFaces_Region==1,:]
254/153: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/154: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/155: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/156: rhs[rhs!=0]
254/157: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/158: rhs[rhs!=0]
254/159: np.argwhere(rhs!=0)[2]
254/160: np.argwhere(rhs!=0)[0]
254/161: np.argwhere(rhs!=0)[1]
254/162: np.argwhere(rhs!=0)[1321]
254/163: np.argwhere(rhs!=0)[13]
254/164: np.argwhere(rhs!=0)[0]
254/165: np.argwhere(rhs!=0)[12]
254/166: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/167: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/168: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/169: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/170: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/171: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/172: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/173: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/174: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/175: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/176: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/177: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/178: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/179: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/180: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/181: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/182: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/183: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/184: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/185: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/186: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/187: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/188: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/189: RS1
254/190: R1
254/191: getIndices(MESH.regions_2d,'coil_face')
254/192: pde.tools.getIndices(MESH.regions_2d,'coil_face')
254/193: MESH.regions_2d
254/194: MESH.BoundaryFaces_Region
254/195: indices = pde.tools.getIndices(MESH.regions_2d,'coil_face')
254/196: ind_faces = pde.tools.getIndices(MESH.regions_2d,'coil_face')
254/197: ind_faces
254/198: indices = npy.in1d(MESH.BoundaryFaces_Region,ind_faces)
254/199: indices
254/200: MESH.BoundaryFaces_Region
254/201: MESH.Boundary_Faces
254/202: MESH.BoundaryFaces_Region
254/203: MESH.Boundary_Faces
254/204: MESH.Boundary_Faces
254/205: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/206: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/207: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/208: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/209: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/210: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/211: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/212: RS1@rhs
254/213: rhs = unit_coil_B @ DB @ phiB_Hdiv.T
254/214: unit_coil_B
254/215: RS1.indptr
254/216: RS1.indices
254/217: R1
254/218: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/219: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/220: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')
254/221: R1
254/222: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face_cut')
254/223: R1
254/224: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_cut_1')
254/225: R1
254/226: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_cut_1,coil_face')
254/227: R1
254/228: 1349+17
254/229: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'new,coil_face')
254/230: R1
254/231: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')
254/232: R1
254/233:
ind_faces = getIndices(MESH.regions_2d,'coil_face')
indices = npy.in1d(MESH.BoundaryFaces_Region,ind_faces)
254/234: ind_faces = pde.tools.getIndices(MESH.regions_2d,'coil_face')
254/235: indices = npy.in1d(MESH.BoundaryFaces_Region,ind_faces)
254/236: sizeM = MESH.FEMLISTS['RT0']['TET']['sizeM']
254/237: LIST_DOF  = npy.unique(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices,:])
254/238: LIST_DOF
254/239: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/240: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/241: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/242: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/243: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/244: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/245: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/246: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/247: ind_faces1
254/248: ind_faces2
254/249:
ind_faces1 = pde.tools.getIndices(MESH.regions_2d,'coil_face')
ind_faces2 = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')

indices1 = np.in1d(MESH.BoundaryFaces_Region,ind_faces1)
indices2 = np.in1d(MESH.BoundaryFaces_Region,ind_faces2)
254/250: indices1
254/251: indices2
254/252: (indices1*indices2)==1
254/253: np.sum(indices1*indices2)
254/254:

ind_faces1 = pde.tools.getIndices(MESH.regions_2d,'coil_face')
ind_faces2 = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')

indices1 = np.in1d(MESH.BoundaryFaces_Region,ind_faces1)
indices2 = np.in1d(MESH.BoundaryFaces_Region,ind_faces2)

sizeM = MESH.FEMLISTS['RT0']['TET']['sizeM']
LIST_DOF1  = np.unique(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:])
LIST_DOF2  = np.unique(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices2,:])
print(LIST_DOF1.shape,LIST_DOF2.shape)
254/255:
ind_faces1 = pde.tools.getIndices(MESH.regions_2d,'coil_face')
ind_faces2 = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
ind_faces3 = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1,coil_face')
254/256: ind_faces1
254/257: ind_faces2
254/258: ind_faces3
254/259:
indices1 = np.in1d(MESH.BoundaryFaces_Region,ind_faces1)
indices2 = np.in1d(MESH.BoundaryFaces_Region,ind_faces2)
indices3 = np.in1d(MESH.BoundaryFaces_Region,ind_faces3)
254/260: indices1
254/261: indices2
254/262: indices3
254/263: np.sum(indices3-indices2-indices1)
254/264: indices3-indices2-indices1
254/265: indices3^indices2^indices1
254/266: np.sum(indices3^indices2^indices1)
254/267: np.where(indices1)
254/268: np.argwhere(indices1).size
254/269: np.argwhere(indices2).size
254/270: np.argwhere(indices3).size
254/271: MESH.FEMLISTS['RT0']['B']['LIST_DOF']
254/272: MESH.FEMLISTS['RT0']['B']['LIST_DOF']
254/273: MESH.Boundary_Faces
254/274: MESH.BoundaryFaces_Region
254/275: MESH.BoundaryFaces_Region.shape
254/276: MESH.Boundary_Faces.shape
254/277: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:]
254/278: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:].shape
254/279: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices2,:].shape
254/280: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices3,:].shape
254/281: 1368+17
254/282:
LIST_DOF1  = np.unique(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:])
LIST_DOF2  = np.unique(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices2,:])
LIST_DOF3  = np.unique(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices3,:])
254/283: LIST_DOF3
254/284: LIST_DOF2
254/285: LIST_DOF1
254/286: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/287: MESH.FacesToVertices
254/288: MESH.Boundary_Faces.shape
254/289: MESH.Boundary_Faces
254/290: MESH.BoundaryFaces_Region
254/291: MESH.FEMLISTS['RT0']['B']['LIST_DOF']
254/292: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:]
254/293:
indices1 = np.in1d(MESH.BoundaryFaces_Region,ind_faces1)
indices2 = np.in1d(MESH.BoundaryFaces_Region,ind_faces2)
indices3 = np.in1d(MESH.BoundaryFaces_Region,ind_faces3)
254/294: indices1
254/295: indices2
254/296: indices3
254/297: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:]
254/298: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices2,:]
254/299: np.unique(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices2,:])
254/300: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices3,:]
254/301: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:]
254/302: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:]
254/303: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:].shape
254/304: np.unique(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:]).shape
254/305: 1349+17
254/306: np.intersect1d(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:],MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices2,:])
254/307: f_new
254/308: f_new[:3]
254/309: f_new[:,3]
254/310: f_new[:,3]==6
254/311: np.argwhere(f_new[:,3]==6).size
254/312: np.argwhere(f_new[:,3]==pde.tools.getindices(regions_2d_new,'face')).size
254/313: np.argwhere(f_new[:,3]==pde.tools.getIndices(regions_2d_new,'face')).size
254/314: np.argwhere(f_new[:,3]==pde.tools.getIndices(regions_2d_new,'coil_face')).size
254/315: np.argwhere(f_new[:,3]==0).size
254/316: pde.tools.getIndices(regions_2d_new,'coil_face')
254/317: pde.tools.getIndices(regions_2d_new,'coil_face').shape
254/318:
a = 0
for i in range(24):
    a = a + np.argwhere(f_new[:,i]==0).size
254/319:
a = 0
for i in range(24):
    a = a + np.argwhere(f_new[pde.tools.getIndices(regions_2d_new,'coil_face')[i],3]==0).size
254/320: a
254/321: np.argwhere(f_new[pde.tools.getIndices(regions_2d_new,'coil_face')[i],3]==0).size
254/322: np.argwhere(f_new[0,3]==0).size
254/323: np.argwhere(f_new[1,3]==0).size
254/324: np.argwhere(f_new[:,3]==pde.tools.getIndices(regions_2d_new,'coil_face')[i]).size
254/325:
a = 0
for i in range(24):
    a = a + np.argwhere(f_new[:,3]==pde.tools.getIndices(regions_2d_new,'coil_face')[i]).size
254/326: a
254/327:
a = 0
for i in range(24):
    a = a + np.argwhere(f_new[:,3]==pde.tools.getIndices(regions_2d_new,'coil_face,coil_cut_1')[i]).size
254/328: a
254/329:
a = 0
for i in range(24):
    a = a + np.argwhere(f_new[:,3]==pde.tools.getIndices(regions_2d_new,'coil_cut_1')[i]).size
254/330: a
254/331: pde.tools.getIndices(regions_2d_new,'coil_cut_1').size
254/332:
a = 0, s = pde.tools.getIndices(regions_2d_new,'coil_cut_1').size
for i in range(s):
    a = a + np.argwhere(f_new[:,3]==pde.tools.getIndices(regions_2d_new,'coil_cut_1')[i]).size
254/333:
a = 0; s = pde.tools.getIndices(regions_2d_new,'coil_cut_1').size
for i in range(s):
    a = a + np.argwhere(f_new[:,3]==pde.tools.getIndices(regions_2d_new,'coil_cut_1')[i]).size
254/334: a
254/335:
a = 0; s = pde.tools.getIndices(regions_2d_new,'coil_cut_1coil_face').size
for i in range(s):
    a = a + np.argwhere(f_new[:,3]==pde.tools.getIndices(regions_2d_new,'coil_cut_1,coil_face')[i]).size
254/336: a
254/337:
a = 0; s = pde.tools.getIndices(regions_2d_new,'coil_cut_1,coil_face').size
for i in range(s):
    a = a + np.argwhere(f_new[:,3]==pde.tools.getIndices(regions_2d_new,'coil_cut_1,coil_face')[i]).size
254/338: a
254/339:
a = 0; s = pde.tools.getIndices(regions_2d_new,'coil_face').size
for i in range(s):
    a = a + np.argwhere(f_new[:,3]==pde.tools.getIndices(regions_2d_new,'coil_face')[i]).size
254/340: a
254/341:
ind_faces1 = pde.tools.getIndices(MESH.regions_2d,'coil_face')
ind_faces2 = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
ind_faces3 = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1,coil_face')

indices1 = np.in1d(MESH.BoundaryFaces_Region,ind_faces1)
indices2 = np.in1d(MESH.BoundaryFaces_Region,ind_faces2)
indices3 = np.in1d(MESH.BoundaryFaces_Region,ind_faces3)
254/342: indices1.shape
254/343: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:].size
254/344: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices2,:].size
254/345: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices3,:].size
254/346:
MESH = pde.mesh3.netgen(geoOCCmesh)

R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')
R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face,coil_cut_1')
R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_cut_1')
254/347: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')
254/348: R1
254/349: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face,coil_cut_1')
254/350: R1
254/351: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_cut_1')
254/352: R1
254/353: 1385-17
254/354: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/355: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')
254/356: R1
254/357: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face,coil_cut_1')
254/358: R1
254/359: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_cut_1')
254/360: R1
254/361: 1349+17
254/362: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/363: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/364: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/365: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/366: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/367: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/368: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/369: 1349+17
254/370: 1368-1349
254/371: 1385-1362
254/372: face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
254/373: face_index
254/374: faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
254/375: faces
254/376: new_faces = faces.copy()
254/377: points_to_duplicate = np.unique(faces.ravel())
254/378: points_to_duplicate
254/379: points_to_duplicate.shape
254/380: faces.shape
254/381: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/382: new_points = np.arange(MESH.np,MESH.np+points_to_duplicate.size)
254/383: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/384: new_points
254/385: points_to_duplicate
254/386: actual_points = MESH.p[points_to_duplicate,:]
254/387: actual_points
254/388: t_new
254/389: MESH.t[:,:4].copy()
254/390: f_new
254/391: new_faces
254/392: new_faces
254/393: new_faces = faces.copy()
254/394: new_faces
254/395:
face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np, MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
p_new = MESH.p.copy()
f_new = MESH.f.copy()

for i,pnt in enumerate(points_to_duplicate):
    
    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])
    
    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]
    
    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i

t_new = np.c_[t_new,MESH.t[:,4]]
254/396: new_faces
254/397:
for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j]
254/398: new_faces
254/399: np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))
254/400: new_faces
254/401: f_new
254/402: new_faces
254/403: new_faces = np.c_[new_faces,np.tile(f_new[:,3].max()+1,(new_faces.shape[0],1))]
254/404: new_faces
254/405: f_new
254/406: f_new = (np.r_[f_new,new_faces]).astype(int)
254/407: f_new
254/408: regions_2d_new
254/409: MESH.regions_2d
254/410: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/411: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/412: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/413: MESH2.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:]
254/414: MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:]
254/415: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/416: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/417: LIST_DOF11
254/418: LIST_DOF10
254/419: np.setdiff1d(LIST_DOF11,LIST_DOF10)
254/420: np.setdiff1d(LIST_DOF11,LIST_DOF10).shape
254/421: np.setdiff1d(LIST_DOF10,LIST_DOF11).shape
254/422: LIST_DOF10.shape
254/423: plt.plot(LIST_DOF11)
254/424: plt.plot(LIST_DOF10)
254/425: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/426: MESH2.f.shape
254/427: MESH.f.shape
254/428: MESH.f
254/429: MESH2.f
254/430: f_new[:,3]
254/431: MESH2.f[-30,:]
254/432: MESH2.f[:,-30]
254/433: MESH2.f[-30,:]
254/434: MESH2.f[-30:,:]
254/435: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/436: MESH2.f
254/437: MESH2.f[-30:,:]
254/438: MESH2.f[:-30,:]
254/439: MESH2.f[:-20,:]
254/440: MESH2.f[:-10,:]
254/441: MESH2.f[:-17,:]
254/442: MESH2.f[:-18,:]
254/443: MESH2.f[:-16,:]
254/444: MESH2.f[:-17,:]
254/445: MESH2.f[:-17,:]-MESH.f
254/446: (MESH2.f[:-17,:]-MESH.f).max()
254/447: (MESH2.f[:-17,:]-MESH.f).min()
254/448: MESH.Boundary_Faces
254/449: MESH2.Boundary_Faces
254/450: MESH2.Boundary_Faces[-17:]
254/451: MESH2.Boundary_Faces[-20:]
254/452: MESH2.Boundary_Faces[:-20]
254/453: MESH2.Boundary_Faces[:-17]
254/454: MESH2.Boundary_Faces[:-17]-MESH.Boundary_Faces
254/455: MESH2.Boundary_Faces[:-17]
254/456: MESH.Boundary_Faces
254/457: MESH.Boundary_Faces
254/458: MESH2.Boundary_Faces
254/459: faces_containing_points = np.argwhere(f_new[:,:4]==pnt)[:,0]
254/460: faces_containing_points
254/461: f_new
254/462: pnt
254/463: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/464: f_new
254/465: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/466: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/467: 1349+17
254/468: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/469: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/470: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/471: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/472: MESH.mp_tet[j,0]
254/473: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/474: 1322+17
254/475: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/476: p_new
254/477: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/478: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/479: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/480: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/481: f_new
254/482: f_new[j,:]
254/483: f_new[j,:]==pnt
254/484: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/485: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/486: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/487: unit_coil_B
254/488: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/489: rhs[rhs!=0]
254/490: np.argwhere(rhs!=0)
254/491: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/492: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/493: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/494: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/495: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/496: AA
254/497: np.linalg.matrix_rank(AA.A)
254/498: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/499: f_new[:,3].max()
254/500: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/501: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/502: f_new[:,:3]
254/503: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/504: f_new
254/505: new_faces
254/506: MESH.f[:,3].max()
254/507: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/508: MESH2.f
254/509: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/510: AA
254/511: np.linalg.matrix_rank(AA.A)
254/512: f_new[:,:3]
254/513: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/514: RZdiv
254/515: AA
254/516: RZdiv
254/517: MESH
254/518: MESH.nt+MESH.NoFaces
254/519: RS1
254/520: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_face')
254/521: R1
254/522: R1, RS1 = pde.hdiv.assembleR3(MESH, space = 'RT0', faces = 'coil_cut_1')
254/523: R1
254/524: x
254/525: x.max()
254/526: x.min()
254/527: plt.plot(x)
254/528: plt.plot(x)
254/529:
K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T

RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))
print('My code took ... ',time.monotonic()-tm)
254/530: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/531: x
254/532: plt.plot(x)
254/533: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/534: x
254/535: plt.plot(x)
254/536: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/537: MESH
254/538: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/539: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/540: RS0
254/541: r = RZ @ r
254/542: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/543: r
254/544: r.shape
254/545: r.max()
254/546: r.min()
254/547: K
254/548: np.linalg.matrix_rank(K.A)
254/549: x = chol(sigma*K).solve_A(r)
254/550: x
254/551: x.shape
254/552: K@x
254/553: plt.plot(K@x)
254/554: plt.plot(r)
254/555: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/556:

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
254/557: r
254/558: r.max()
254/559: r.min()
254/560: RS0
254/561: RS1
254/562: RS0
254/563: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/564: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/565: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/566: MESHf
254/567: MESH
254/568: MESH.f
254/569:
ind_faces2 = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
ind_faces3 = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1,cut')
254/570: ind_faces2
254/571: ind_faces3
254/572: cut
254/573: ind_faces3 = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1,new')
254/574: ind_faces3
254/575:
ind_faces1 = pde.tools.getIndices(MESH.regions_2d,'coil_face')
ind_faces2 = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
ind_faces3 = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1,new')

indices1 = np.in1d(MESH.BoundaryFaces_Region,ind_faces1)
indices2 = np.in1d(MESH.BoundaryFaces_Region,ind_faces2)
indices3 = np.in1d(MESH.BoundaryFaces_Region,ind_faces3)

dphix_H1, dphiy_H1, dphiz_H1 = pde.hdiv.assemble3(MESH, space = 'RT0', matrix = 'M', order = 1)
sizeM = MESH.FEMLISTS['RT0']['TET']['sizeM']
LIST_DOF11  = np.unique(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices1,:])
LIST_DOF21  = np.unique(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices2,:])
LIST_DOF31  = np.unique(MESH.FEMLISTS['RT0']['B']['LIST_DOF'][indices3,:])
254/576:

print(LIST_DOF11.shape,LIST_DOF21.shape,LIST_DOF31.shape)
254/577: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/578: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/579: MESH.f
254/580: MESH.f[MESH.BoundaryFaces_Region==6,:]
254/581: MESH.f[MESH.BoundaryFaces_Region==57,:]
254/582: MESH.f[MESH.BoundaryFaces_Region==58,:]
254/583: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/584: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/585: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/586: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/587: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/588: (RZdiv.T@xx)[1:-MESH.nt:1]
254/589: (RZdiv.T@xx)[1:-MESH.nt:1].shape
254/590: MESH
254/591: (RZdiv.T@xx)[1:-MESH.nt]
254/592: (RZdiv.T@xx)[1:-MESH.nt].shape
254/593: R1.T@(RZdiv.T@xx)[1:-MESH.nt]
254/594: RS1.T@(RZdiv.T@xx)[1:-MESH.nt]
254/595: RS1@(RZdiv.T@xx)[1:-MESH.nt]
254/596: RS1
254/597: (RZdiv.T@xx)[1:-MESH.nt]
254/598: (RZdiv.T@xx)[1:-MESH.nt].shape
254/599: RS1.T@(RZdiv.T@xx)[:-MESH.nt]
254/600: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/601: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/602: phix_Hdiv_P0.T@j_hdiv
254/603: (phix_Hdiv_P0.T@j_hdiv).shapoe
254/604: (phix_Hdiv_P0.T@j_hdiv).shape
254/605: MESH
254/606: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/607: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/608: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/609: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
254/610: pwd
254/611: which python
   1:
%%capture
%run TEAM_13_geometry.ipynb
   2:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
   3:
face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np, MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
f_new = MESH.f[:,:3].copy()
p_new = MESH.p.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i
            
    # finding faces containing the points
    faces_containing_points = np.argwhere(f_new[:,:3]==pnt)[:,0]
    for _,j in enumerate(faces_containing_points):
        #check if face is left
        if 1/3*(p_new[f_new[j,0],0] + p_new[f_new[j,1],0] + p_new[f_new[j,2],0])<0:
            f_new[j,f_new[j,:]==pnt] = MESH.np + i
            
            
    # print(faces_containing_points)

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(MESH.f[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[np.c_[f_new,MESH.f[:,3]],new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
   4:
import numpy as np

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np, MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
f_new = MESH.f[:,:3].copy()
p_new = MESH.p.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i
            
    # finding faces containing the points
    faces_containing_points = np.argwhere(f_new[:,:3]==pnt)[:,0]
    for _,j in enumerate(faces_containing_points):
        #check if face is left
        if 1/3*(p_new[f_new[j,0],0] + p_new[f_new[j,1],0] + p_new[f_new[j,2],0])<0:
            f_new[j,f_new[j,:]==pnt] = MESH.np + i
            
            
    # print(faces_containing_points)

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(MESH.f[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[np.c_[f_new,MESH.f[:,3]],new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
   5:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
x = chol(sigma*K).solve_A(r)
x = RS0.T @ RZ.T @ x + R1.T @ (1+np.zeros(R1.shape[0]))

# MESH.pdesurf(x, faces = 'coil_face')

dx_x = (dphix_H1.T@x)*unit_coil.diagonal()
dy_x = (dphiy_H1.T@x)*unit_coil.diagonal()
dz_x = (dphiz_H1.T@x)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
dx_x_P0 = (dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
dy_x_P0 = (dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
dz_x_P0 = (dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
   6:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, x, 'J')
pde.tools.vtklib.add_L2_Vector(grid,dx_x_P0,dy_x_P0,dz_x_P0,'grad_J')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
   7: x.shape
   8:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
   9:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
  10:
%%capture
%run TEAM_13_geometry.ipynb
  11:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
  12:
import numpy as np

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np, MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
f_new = MESH.f[:,:3].copy()
p_new = MESH.p.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i
            
    # finding faces containing the points
    faces_containing_points = np.argwhere(f_new[:,:3]==pnt)[:,0]
    for _,j in enumerate(faces_containing_points):
        #check if face is left
        if 1/3*(p_new[f_new[j,0],0] + p_new[f_new[j,1],0] + p_new[f_new[j,2],0])<0:
            f_new[j,f_new[j,:]==pnt] = MESH.np + i
            
            
    # print(faces_containing_points)

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(MESH.f[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[np.c_[f_new,MESH.f[:,3]],new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
  13:
import numpy as np

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np, MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
f_new = MESH.f[:,:3].copy()
p_new = MESH.p.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i
            
    # finding faces containing the points
    faces_containing_points = np.argwhere(f_new[:,:3]==pnt)[:,0]
    for _,j in enumerate(faces_containing_points):
        #check if face is left
        if 1/3*(p_new[f_new[j,0],0] + p_new[f_new[j,1],0] + p_new[f_new[j,2],0])<0:
            f_new[j,f_new[j,:]==pnt] = MESH.np + i
            
            
    # print(faces_containing_points)

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(MESH.f[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[np.c_[f_new,MESH.f[:,3]],new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
  14:
import sys
sys.path.insert(0,'../../../') # adds parent directory
import pde
MESH = pde.mesh3.netgen(geoOCCmesh)
MESH
  15:
import numpy as np

face_index = pde.tools.getIndices(MESH.regions_2d,'coil_cut_1')
faces = MESH.f[MESH.BoundaryFaces_Region == face_index,:3]
new_faces = faces.copy()

points_to_duplicate = np.unique(faces.ravel())
new_points = np.arange(MESH.np, MESH.np+points_to_duplicate.size)

actual_points = MESH.p[points_to_duplicate,:]

t_new = MESH.t[:,:4].copy()
f_new = MESH.f[:,:3].copy()
p_new = MESH.p.copy()

for i,pnt in enumerate(points_to_duplicate):

    # append point to list
    p_new = np.vstack([p_new,p_new[pnt,:]])

    # finding tets coordinates containing the ith point to duplicate
    tets_containing_points = np.argwhere(t_new[:,:4]==pnt)[:,0]

    for _,j in enumerate(tets_containing_points):
        #check if tet is left
        if MESH.mp_tet[j,0]<0:
            t_new[j,t_new[j,:]==pnt] = MESH.np + i
            
    # finding faces containing the points
    faces_containing_points = np.argwhere(f_new[:,:3]==pnt)[:,0]
    for _,j in enumerate(faces_containing_points):
        #check if face is left
        if 1/3*(p_new[f_new[j,0],0] + p_new[f_new[j,1],0] + p_new[f_new[j,2],0])<0:
            f_new[j,f_new[j,:]==pnt] = MESH.np + i
            
            
    # print(faces_containing_points)

t_new = np.c_[t_new,MESH.t[:,4]]

for i,j in enumerate(faces.ravel()):
    new_faces.ravel()[i] = new_points[points_to_duplicate==j][0]

new_faces = np.c_[new_faces,np.tile(MESH.f[:,3].max()+1,(new_faces.shape[0],1))]
f_new = (np.r_[np.c_[f_new,MESH.f[:,3]],new_faces]).astype(int)

regions_2d_new = MESH.regions_2d.copy()
regions_2d_new.append('new')

identifications = (np.c_[points_to_duplicate,new_points]).astype(int)
# stop
MESH = pde.mesh3(p_new,MESH.e,f_new,t_new,MESH.regions_3d,regions_2d_new,MESH.regions_1d,identifications = identifications)
MESH
255/1:
tm = time.monotonic()

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)

phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'phi', shape = phi_H1.shape, order = order)
n_phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'n*phi', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

# r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T
# M = phi_H1 @ D @ unit_coil @ phi_H1.T

##############################################################################

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
255/2: R1
255/3: R1.T
255/4:
tm = time.monotonic()

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)

phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'phi', shape = phi_H1.shape, order = order)
n_phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'n*phi', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')
255/5:
phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)

phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'phi', shape = phi_H1.shape, order = order)
n_phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'n*phi', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

# r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T
255/6: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
255/7: R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')
255/8: R1
255/9: R1.T @ (1+np.zeros(R1.shape[0]))
255/10: R1
255/11: MESH
255/12: face_in_1
255/13: R1.T @ (1+np.zeros(R1.shape[0]))-face_in_1
255/14: unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil_face')
255/15: unit_coil.max()
255/16: unit_coil = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil_cut_1')
255/17: unit_coil = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1')
255/18: unit_coil.max()
255/19: unit_coil = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
255/20: unit_coil.max()
255/21: unit_coil.shape
255/22: MESH
255/23: order
255/24: 9228/3
255/25: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
  16:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
p = chol(sigma*K).solve_A(r)
p = RS0.T @ RZ.T @ p + R1.T @ (1+np.zeros(R1.shape[0]))

jx = (dphix_H1.T@p)*unit_coil.diagonal()
jy = (dphiy_H1.T@p)*unit_coil.diagonal()
jz = (dphiz_H1.T@p)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
jx_P0 = -(dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
jy_P0 = -(dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
jz_P0 = -(dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
  17:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, p, 'potential')
pde.tools.vtklib.add_L2_Vector(grid,jx_P0,jy_P0,jz_P0,'j_L2')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
  18: x.shape
  19:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
  20:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("J")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("grad_J")
arrows = mesh.glyph(scale="grad_J", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
  21:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("potential")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("J_L2")
arrows = mesh.glyph(scale="J_L2", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
  22:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, p, 'potential')
pde.tools.vtklib.add_L2_Vector(grid,jx_P0,jy_P0,jz_P0,'J_L2')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
  23:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
  24:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("potential")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("J_L2")
arrows = mesh.glyph(scale="J_L2", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
  25:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

face_in_1 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, faces = 'coil_cut_1').diagonal()
face_in_2 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()
face_in_3 = pde.int.evaluateB3(MESH, order = order, coeff = lambda x,y,z : 0+0*x, faces = 'coil_cut_1').diagonal()

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

r = (face_in_1*N1 + face_in_2*N2 + face_in_3*N3) @ DB @ phiB_H1.T

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
p = chol(sigma*K).solve_A(r)
p = RS0.T @ RZ.T @ p + R1.T @ (1+np.zeros(R1.shape[0]))

jx = (dphix_H1.T@p)*unit_coil.diagonal()
jy = (dphiy_H1.T@p)*unit_coil.diagonal()
jz = (dphiz_H1.T@p)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
jx_P0 = -(dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
jy_P0 = -(dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
jz_P0 = -(dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
  26:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, p, 'potential')
pde.tools.vtklib.add_L2_Vector(grid,jx_P0,jy_P0,jz_P0,'J_L2')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
  27: x.shape
  28:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
  29:
# mesh.plot(jupyter_backend='html')
# mesh.export_html('kek.html')
# p.add_mesh(mesh, style='wireframe', color='blue', label=None)
# p.add_mesh(mesh, label='Clipped')
# clipped = mesh.clip_scalar(scalars="Scalars_", value=1, invert=True)





# sample_function(
#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)

# clipped = mesh.threshold(value=1)
# # p.add_legend()




# plotter = pv.Plotter()
# plotter.add_mesh(mesh.clip_scalar(scalars="Scalars_", value=100, invert=True), opacity=0.8)
# # plotter.show_axes()
# plotter.show(jupyter_backend='html')

# p.add_mesh(clipped, label='Clipped')
# p.add_legend()
# p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]

# threshed.plot(jupyter_backend='html',show_edges=True,color="w")

# mesh["grad_J"] = mesh["grad_J"]

mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("potential")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("J_L2")
arrows = mesh.glyph(scale="J_L2", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
255/26: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
258/1: runfile('C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM/solve_t13_strom.py', wdir='C:/Users/Radu/Documents/GitHub/fem/PROJECTS/TEAM')
  30:
order = 1
D = pde.int.assemble3(MESH, order = order)
DB = pde.int.assembleB3(MESH, order = order)
N1,N2,N3 = pde.int.assembleN3(MESH, order = order)
unit_coil = pde.int.evaluate3(MESH, order = order, coeff = lambda x,y,z : 1+0*x, regions = 'coil')

###########################################################################

phi_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'M', order = order)
dphix_H1, dphiy_H1, dphiz_H1 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = order)
phiB_H1 = pde.h1.assembleB3(MESH, space = 'P1', matrix = 'M', shape = phi_H1.shape, order = order)

R0, RS0 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'new,coil_cut_1')
R1, RS1 = pde.h1.assembleR3(MESH, space = 'P1', faces = 'coil_cut_1')

M = phi_H1 @ D @ unit_coil @ phi_H1.T

K = dphix_H1 @ D @ unit_coil @ dphix_H1.T +\
    dphiy_H1 @ D @ unit_coil @ dphiy_H1.T +\
    dphiz_H1 @ D @ unit_coil @ dphiz_H1.T

r = -RS0 @ K @ R1.T @ (1+np.zeros(R1.shape[0]))
K = RS0 @ K @ RS0.T


RZ = pde.tools.removeZeros(K)
K = RZ @ K @ RZ.T

# M = RS0 @ M @ RS0.T
# M = RZ @ M @ RZ.T

r = RZ @ r

sigma = 1#58.7e6
from sksparse.cholmod import cholesky as chol
p = chol(sigma*K).solve_A(r)
p = RS0.T @ RZ.T @ p + R1.T @ (1+np.zeros(R1.shape[0]))

jx = (dphix_H1.T@p)*unit_coil.diagonal()
jy = (dphiy_H1.T@p)*unit_coil.diagonal()
jz = (dphiz_H1.T@p)*unit_coil.diagonal()

dphix_H1_P0, dphiy_H1_P0, dphiz_H1_P0 = pde.h1.assemble3(MESH, space = 'P1', matrix = 'K', order = 0)
unit_coil_P0 = pde.int.evaluate3(MESH, order = 0, coeff = lambda x,y,z : 1+0*x, regions = 'coil')
jx_P0 = -(dphix_H1_P0.T@x)*unit_coil_P0.diagonal()
jy_P0 = -(dphiy_H1_P0.T@x)*unit_coil_P0.diagonal()
jz_P0 = -(dphiz_H1_P0.T@x)*unit_coil_P0.diagonal()
  31:
grid = pde.tools.vtklib.createVTK(MESH)
pde.tools.vtklib.add_H1_Scalar(grid, p, 'potential')
pde.tools.vtklib.add_L2_Vector(grid,jx_P0,jy_P0,jz_P0,'J_L2')
pde.tools.vtklib.writeVTK(grid, 'current_density.vtu')
  32: x.shape
  33:
import pyvista as pv
mesh = pv.read('current_density.vtu')
mesh
  34:
mesh.set_active_scalars("Scalars_")
threshed = mesh.threshold([0,1])

p = pv.Plotter()
threshed.set_active_scalars("potential")
p.add_mesh(threshed, style='surface', opacity = 0.4, label=None)

threshed.set_active_vectors("J_L2")
arrows = mesh.glyph(scale="J_L2", orient=True, tolerance=0.03, factor=9500.0)
p.add_mesh(arrows, color="black")

p.camera_position = [(0, 0, 600),(0, 0, 0),(0, 0, 0)]
p.show(jupyter_backend='html')
  35: %history -g -f filename
