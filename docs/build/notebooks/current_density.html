

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Computing the current density j in the coil &mdash; FEM  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
      <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
      <script src="../_static/jquery.js"></script>
      <script src="../_static/underscore.js"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script src="../_static/doctools.js"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../_static/iframe_stuff.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Magnetostatics solution" href="magnetostatics.html" />
    <link rel="prev" title="Creating the 3D geometry for TEAM problem 13" href="TEAM_13_geometry.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            FEM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">TEAM 13</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="TEAM_13_geometry.html">Creating the 3D geometry for TEAM problem 13</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Computing the current density j in the coil</a></li>
<li class="toctree-l1"><a class="reference internal" href="magnetostatics.html">Magnetostatics solution</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">FEM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Computing the current density j in the coil</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/notebooks/current_density.ipynb" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Computing-the-current-density-j-in-the-coil">
<h1>Computing the current density j in the coil<a class="headerlink" href="#Computing-the-current-density-j-in-the-coil" title="Permalink to this heading">¶</a></h1>
<p><span class="math notranslate nohighlight">\(\def\curl{\operatorname{curl}}\def\Curl{\operatorname{Curl}}\def\div{\operatorname{div}}\)</span> Before we solve the non-linear magnetostatic problem, we first need to find the current <span class="math notranslate nohighlight">\(j\)</span> flowing inside the coil <span class="math notranslate nohighlight">\(\Omega_c\)</span>.</p>
<p>The first property is that <span class="math notranslate nohighlight">\(j\)</span> is solenoidal, i.e. <span class="math notranslate nohighlight">\(\div(j)=0\)</span>. Further, we presume the existence of a potential <span class="math notranslate nohighlight">\(\phi\)</span> with <span class="math notranslate nohighlight">\(j=-\sigma\nabla\phi\)</span>, where <span class="math notranslate nohighlight">\(\sigma\)</span> denotes the connectivity. As for the boundary conditions, we prescribe <span class="math notranslate nohighlight">\(n\cdot j = -\sigma\partial_n\phi=0\)</span> on the exterior boundary <span class="math notranslate nohighlight">\(\Gamma_{ex}\)</span>, and <span class="math notranslate nohighlight">\(\phi=1\)</span> and <span class="math notranslate nohighlight">\(\phi=0\)</span> on the inflow <span class="math notranslate nohighlight">\(\Gamma_{in}\)</span> and outflow boundary <span class="math notranslate nohighlight">\(\Gamma_{out}\)</span>, respectively. Altogether, we
have</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
j + \sigma\nabla\phi &amp;= 0 \qquad\text{on }\Omega_c \\
\div j &amp;=0  \qquad\text{on }\Omega_c \\
n\cdot j = \sigma\partial_n\phi &amp;= 0 \qquad\text{on }\Gamma_{ex} \\
\phi &amp;= 0 \qquad\text{on }\Gamma_{out} \\
\phi &amp;= 1 \qquad\text{on }\Gamma_{in}
\end{align}\end{split}\]</div>
<p>However, in our case, the coil is a loop with no inflow or outflow boundary. This is where the face “coil_cut_1” we defined in the geometry comes into play. For this purpose, we have to introduce “fictitious” points and introduce a clone of the face “coil_cut_1” in order to be able to prescribe the necessary boundary conditions.</p>
<p>Ok so how do we even solve this? Weak formulation leads to</p>
<div class="math notranslate nohighlight">
\[\begin{align}
-\Delta(\sigma\phi)=0
\end{align}\]</div>
<p>The boundary condition <span class="math notranslate nohighlight">\(\partial_n\phi=0\)</span> on <span class="math notranslate nohighlight">\(\Gamma_{ex}\)</span> is natural, while the Dirichlet conditions are essential and have to included in the space. Further, since we solve the problem only on the coil, the other DOFs have to be eliminated from the final system.</p>
<p>We begin by loading the geometry and the mesh generated in the previous document</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%capture</span>
<span class="o">%</span><span class="n">run</span> <span class="n">TEAM_13_geometry</span><span class="o">.</span><span class="n">ipynb</span>
</pre></div>
</div>
</div>
<p>Create the MESH object from the mesh generated by netgen</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;../../../&#39;</span><span class="p">)</span> <span class="c1"># adds parent directory</span>
<span class="kn">import</span> <span class="nn">pde</span>
<span class="n">MESH</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">mesh3</span><span class="o">.</span><span class="n">netgen</span><span class="p">(</span><span class="n">geoOCCmesh</span><span class="p">)</span>
<span class="n">MESH</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
np:4132, nt:23369, nf:3059, ne:720, nf_all:46966, ne_all:27728
</pre></div></div>
</div>
<p>The piece of code below duplicates the face, as described above, and generates a new MESH object.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">face_index</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">getIndices</span><span class="p">(</span><span class="n">MESH</span><span class="o">.</span><span class="n">regions_2d</span><span class="p">,</span><span class="s1">&#39;coil_cut_1&#39;</span><span class="p">)</span>
<span class="n">faces</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">MESH</span><span class="o">.</span><span class="n">BoundaryFaces_Region</span> <span class="o">==</span> <span class="n">face_index</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">new_faces</span> <span class="o">=</span> <span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">points_to_duplicate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
<span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">MESH</span><span class="o">.</span><span class="n">np</span><span class="p">,</span> <span class="n">MESH</span><span class="o">.</span><span class="n">np</span><span class="o">+</span><span class="n">points_to_duplicate</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

<span class="n">actual_points</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">points_to_duplicate</span><span class="p">,:]</span>

<span class="n">t_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">t</span><span class="p">[:,:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">f_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">f</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">p_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">pnt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points_to_duplicate</span><span class="p">):</span>

    <span class="c1"># append point to list</span>
    <span class="n">p_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">p_new</span><span class="p">,</span><span class="n">p_new</span><span class="p">[</span><span class="n">pnt</span><span class="p">,:]])</span>

    <span class="c1"># finding tets coordinates containing the ith point to duplicate</span>
    <span class="n">tets_containing_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">t_new</span><span class="p">[:,:</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="n">pnt</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tets_containing_points</span><span class="p">):</span>
        <span class="c1">#check if tet is left</span>
        <span class="k">if</span> <span class="n">MESH</span><span class="o">.</span><span class="n">mp_tet</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">t_new</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">t_new</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">==</span><span class="n">pnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">np</span> <span class="o">+</span> <span class="n">i</span>

    <span class="c1"># finding faces containing the points</span>
    <span class="n">faces_containing_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">f_new</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="n">pnt</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">faces_containing_points</span><span class="p">):</span>
        <span class="c1">#check if face is left</span>
        <span class="k">if</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">p_new</span><span class="p">[</span><span class="n">f_new</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_new</span><span class="p">[</span><span class="n">f_new</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_new</span><span class="p">[</span><span class="n">f_new</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">f_new</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">f_new</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">==</span><span class="n">pnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">np</span> <span class="o">+</span> <span class="n">i</span>


    <span class="c1"># print(faces_containing_points)</span>

<span class="n">t_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">t_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">t</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">faces</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
    <span class="n">new_faces</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_points</span><span class="p">[</span><span class="n">points_to_duplicate</span><span class="o">==</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="n">new_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">new_faces</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">MESH</span><span class="o">.</span><span class="n">f</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,(</span><span class="n">new_faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))]</span>
<span class="n">f_new</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">f_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">f</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]],</span><span class="n">new_faces</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

<span class="n">regions_2d_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">regions_2d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">regions_2d_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;new&#39;</span><span class="p">)</span>

<span class="n">identifications</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">points_to_duplicate</span><span class="p">,</span><span class="n">new_points</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="c1"># stop</span>
<span class="n">MESH</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">mesh3</span><span class="p">(</span><span class="n">p_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">e</span><span class="p">,</span><span class="n">f_new</span><span class="p">,</span><span class="n">t_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">regions_3d</span><span class="p">,</span><span class="n">regions_2d_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">regions_1d</span><span class="p">,</span><span class="n">identifications</span> <span class="o">=</span> <span class="n">identifications</span><span class="p">)</span>
<span class="n">MESH</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
np:4149, nt:23369, nf:3076, ne:720, nf_all:47028, ne_all:27806
</pre></div></div>
</div>
<p>As we can see, additional points and faces have been created to accommodate the additional interface.</p>
<p>Next, we proceed to solve the problem in <span class="math notranslate nohighlight">\(H^1\)</span>. In weak form, we have:</p>
<p>Find <span class="math notranslate nohighlight">\(\phi\in V^* = \{u\in H^1\;:\; u|_{\Gamma_{out}}=0 \text{ and } u|_{\Gamma_{in}}=1\}\)</span> such that <span class="math notranslate nohighlight">\((\sigma\nabla\phi,\nabla v) = 0\)</span>, for all <span class="math notranslate nohighlight">\(v\in H^1\)</span></p>
<p>After homogenization, which involves splitting the solution <span class="math notranslate nohighlight">\(\phi = \phi_* + \phi_0\)</span>, where <span class="math notranslate nohighlight">\(\phi_*\in V^*\)</span>, we can instead solve:</p>
<p>Find <span class="math notranslate nohighlight">\(\phi_0\in H^1\setminus\Gamma_{in,out}\)</span> such that <span class="math notranslate nohighlight">\((\sigma\nabla\phi_0,\nabla v) = -(\sigma\nabla\phi_*,\nabla v)\)</span>, for all <span class="math notranslate nohighlight">\(v\in H^1\setminus\Gamma_{in,out}\)</span></p>
<p>After using conforming <span class="math notranslate nohighlight">\(P_1\)</span> continuous finite elements, we solve the discretized system in the following way: we split the discrete solution <span class="math notranslate nohighlight">\(\phi = R^T_{in}\phi_{in} + R^T_{out}\phi_{out} + R^T_{int}\phi_{int} = R^T_{in}\phi_{in} + R^T_{int}\phi_{int}\)</span>, where <span class="math notranslate nohighlight">\(R^T_*\)</span> matrices which assign the correct indices to the boundaries and the interior degrees of freedom. Assume the stiffness matrix is denoted by <span class="math notranslate nohighlight">\(K\)</span> and the right-hand side is <span class="math notranslate nohighlight">\(r\)</span>. Then, purely in
<span class="math notranslate nohighlight">\(H^1\)</span>, the system is of the form <span class="math notranslate nohighlight">\(K\phi=f\)</span>. Plugging in the splitting for <span class="math notranslate nohighlight">\(\phi\)</span> leads to the system <span class="math notranslate nohighlight">\(KR_{int}^T\phi_{int} = -KR_{in}^T\phi_{in}\)</span>. By multiplying from the left with <span class="math notranslate nohighlight">\(R_{int}\)</span>, we obtain the square system</p>
<div class="math notranslate nohighlight">
\[\begin{align}
R_{int}KR_{int}^T\phi_{int} = -R_{int}KR_{in}^T\phi_{in}
\end{align}\]</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">DB</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assembleB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">N1</span><span class="p">,</span><span class="n">N2</span><span class="p">,</span><span class="n">N3</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assembleN3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">unit_coil</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluate3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">regions</span> <span class="o">=</span> <span class="s1">&#39;coil&#39;</span><span class="p">)</span>

<span class="c1">###########################################################################</span>

<span class="n">phi_H1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">dphix_H1</span><span class="p">,</span> <span class="n">dphiy_H1</span><span class="p">,</span> <span class="n">dphiz_H1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">phiB_H1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assembleB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">phi_H1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>

<span class="n">R0</span><span class="p">,</span> <span class="n">RS0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assembleR3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;new,coil_cut_1&#39;</span><span class="p">)</span>
<span class="n">R1</span><span class="p">,</span> <span class="n">RS1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assembleR3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;coil_cut_1&#39;</span><span class="p">)</span>

<span class="n">M</span> <span class="o">=</span> <span class="n">phi_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">phi_H1</span><span class="o">.</span><span class="n">T</span>

<span class="n">K</span> <span class="o">=</span> <span class="n">dphix_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">dphix_H1</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>\
    <span class="n">dphiy_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">dphiy_H1</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>\
    <span class="n">dphiz_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">dphiz_H1</span><span class="o">.</span><span class="n">T</span>

<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">RS0</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">R1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">R1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">RS0</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">RS0</span><span class="o">.</span><span class="n">T</span>


<span class="n">RZ</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">removeZeros</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">RZ</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">RZ</span><span class="o">.</span><span class="n">T</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">RZ</span> <span class="o">@</span> <span class="n">r</span>

<span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span><span class="c1">#58.7e6</span>
<span class="kn">from</span> <span class="nn">sksparse.cholmod</span> <span class="kn">import</span> <span class="n">cholesky</span> <span class="k">as</span> <span class="n">chol</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">chol</span><span class="p">(</span><span class="n">sigma</span><span class="o">*</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">solve_A</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">RS0</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">RZ</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">p</span> <span class="o">+</span> <span class="n">R1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">R1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="n">jx</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphix_H1</span><span class="o">.</span><span class="n">T</span><span class="nd">@p</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jy</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphiy_H1</span><span class="o">.</span><span class="n">T</span><span class="nd">@p</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jz</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphiz_H1</span><span class="o">.</span><span class="n">T</span><span class="nd">@p</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

<span class="n">dphix_H1_P0</span><span class="p">,</span> <span class="n">dphiy_H1_P0</span><span class="p">,</span> <span class="n">dphiz_H1_P0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">unit_coil_P0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluate3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">regions</span> <span class="o">=</span> <span class="s1">&#39;coil&#39;</span><span class="p">)</span>
<span class="n">jx_P0</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphix_H1_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@p</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jy_P0</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphiy_H1_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@p</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jz_P0</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphiz_H1_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@p</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Instead of solving in <span class="math notranslate nohighlight">\(H^1\)</span>, we can instead solve the mixed problem directly by employing <span class="math notranslate nohighlight">\(H(\div)\)</span> conforming finite elements.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">order</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">phix_Hdiv</span><span class="p">,</span> <span class="n">phiy_Hdiv</span><span class="p">,</span> <span class="n">phiz_Hdiv</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">hdiv</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;RT0&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">divphi_Hdiv</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">hdiv</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;RT0&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>

<span class="n">phi_L2</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">l2</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P0&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>

<span class="n">D</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>

<span class="n">M_Hdiv_coil_full</span> <span class="o">=</span> <span class="n">phix_Hdiv</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">phix_Hdiv</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>\
                   <span class="n">phiy_Hdiv</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">phiy_Hdiv</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>\
                   <span class="n">phiz_Hdiv</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">phiz_Hdiv</span><span class="o">.</span><span class="n">T</span>

<span class="n">C_Hdiv_L2</span> <span class="o">=</span> <span class="n">divphi_Hdiv</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">phi_L2</span><span class="o">.</span><span class="n">T</span>
<span class="n">R1</span><span class="p">,</span> <span class="n">RS1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">hdiv</span><span class="o">.</span><span class="n">assembleR3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;RT0&#39;</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;coil_face&#39;</span><span class="p">)</span>

<span class="n">M_Hdiv_coil_full</span> <span class="o">=</span> <span class="n">RS1</span> <span class="o">@</span> <span class="n">M_Hdiv_coil_full</span> <span class="nd">@RS1</span><span class="o">.</span><span class="n">T</span>
<span class="n">C_Hdiv_L2</span> <span class="o">=</span> <span class="n">RS1</span> <span class="o">@</span> <span class="n">C_Hdiv_L2</span>

<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="n">AA</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">bmat</span><span class="p">([[</span><span class="n">M_Hdiv_coil_full</span><span class="p">,</span> <span class="o">-</span><span class="n">C_Hdiv_L2</span><span class="p">],</span>
              <span class="p">[</span><span class="n">C_Hdiv_L2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="kc">None</span><span class="p">]])</span>

<span class="n">RZdiv</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">removeZeros</span><span class="p">(</span><span class="n">AA</span><span class="p">)</span>
<span class="n">AA</span> <span class="o">=</span> <span class="n">RZdiv</span> <span class="o">@</span> <span class="n">AA</span> <span class="o">@</span> <span class="n">RZdiv</span><span class="o">.</span><span class="n">T</span>

<span class="n">phiB_Hdiv</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">hdiv</span><span class="o">.</span><span class="n">assembleB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;RT0&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">phix_Hdiv</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">unit_coil_B</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluateB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;new&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">DB</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assembleB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>

<span class="n">rhs</span> <span class="o">=</span> <span class="n">unit_coil_B</span> <span class="o">@</span> <span class="n">DB</span> <span class="o">@</span> <span class="n">phiB_Hdiv</span><span class="o">.</span><span class="n">T</span>
<span class="n">rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">RS1</span><span class="nd">@rhs</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MESH</span><span class="o">.</span><span class="n">nt</span><span class="p">)]</span>
<span class="n">rhs</span> <span class="o">=</span> <span class="n">RZdiv</span> <span class="o">@</span> <span class="n">rhs</span>

<span class="n">xx</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">AA</span><span class="p">,</span><span class="n">rhs</span><span class="p">)</span>

<span class="n">potential</span> <span class="o">=</span> <span class="p">(</span><span class="n">RZdiv</span><span class="o">.</span><span class="n">T</span><span class="nd">@xx</span><span class="p">)[</span><span class="o">-</span><span class="n">MESH</span><span class="o">.</span><span class="n">nt</span><span class="p">:]</span>
<span class="n">j_hdiv</span> <span class="o">=</span> <span class="n">RS1</span><span class="o">.</span><span class="n">T</span><span class="o">@</span><span class="p">(</span><span class="n">RZdiv</span><span class="o">.</span><span class="n">T</span><span class="nd">@xx</span><span class="p">)[:</span><span class="o">-</span><span class="n">MESH</span><span class="o">.</span><span class="n">nt</span><span class="p">]</span>


<span class="c1">##############################################################################</span>
<span class="n">unit_coil_P0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluate3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">regions</span> <span class="o">=</span> <span class="s1">&#39;coil&#39;</span><span class="p">)</span>

<span class="n">phix_Hdiv_P0</span><span class="p">,</span> <span class="n">phiy_Hdiv_P0</span><span class="p">,</span> <span class="n">phiz_Hdiv_P0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">hdiv</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;RT0&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">jx_hdiv</span> <span class="o">=</span> <span class="p">(</span><span class="n">phix_Hdiv_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@j_hdiv</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jy_hdiv</span> <span class="o">=</span> <span class="p">(</span><span class="n">phiy_Hdiv_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@j_hdiv</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jz_hdiv</span> <span class="o">=</span> <span class="p">(</span><span class="n">phiz_Hdiv_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@j_hdiv</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

<span class="c1">##############################################################################</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">createVTK</span><span class="p">(</span><span class="n">MESH</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">add_H1_Scalar</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s1">&#39;potential_H1&#39;</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">add_L2_Scalar</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">potential</span><span class="p">,</span> <span class="s1">&#39;potential_L2&#39;</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">add_L2_Vector</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">jx_P0</span><span class="p">,</span><span class="n">jy_P0</span><span class="p">,</span><span class="n">jz_P0</span><span class="p">,</span><span class="s1">&#39;J_L2&#39;</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">add_L2_Vector</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">jx_hdiv</span><span class="p">,</span><span class="n">jy_hdiv</span><span class="p">,</span><span class="n">jz_hdiv</span><span class="p">,</span><span class="s1">&#39;J_HDIV&#39;</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">writeVTK</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="s1">&#39;current_density.vtu&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;current_density.vtu&#39;</span><span class="p">)</span>
<span class="n">mesh</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<table style='width: 100%;'><tr><th>Header</th><th>Data Arrays</th></tr><tr><td>
<table style='width: 100%;'>
<tr><th>UnstructuredGrid</th><th>Information</th></tr>
<tr><td>N Cells</td><td>23369</td></tr>
<tr><td>N Points</td><td>4149</td></tr>
<tr><td>X Bounds</td><td>-2.000e+02, 2.000e+02</td></tr>
<tr><td>Y Bounds</td><td>-2.000e+02, 2.000e+02</td></tr>
<tr><td>Z Bounds</td><td>-1.000e+02, 1.000e+02</td></tr>
<tr><td>N Arrays</td><td>5</td></tr>
</table>

</td><td>
<table style='width: 100%;'>
<tr><th>Name</th><th>Field</th><th>Type</th><th>N Comp</th><th>Min</th><th>Max</th></tr>
<tr><td>potential_H1</td><td>Points</td><td>float32</td><td>1</td><td>0.000e+00</td><td>1.000e+00</td></tr>
<tr><td><b>Scalars_</b></td><td>Cells</td><td>float64</td><td>1</td><td>0.000e+00</td><td>5.000e+00</td></tr>
<tr><td>potential_L2</td><td>Cells</td><td>float32</td><td>1</td><td>-9.960e-01</td><td>0.000e+00</td></tr>
<tr><td>J_L2</td><td>Cells</td><td>float32</td><td>3</td><td>-2.110e-03</td><td>2.123e-03</td></tr>
<tr><td>J_HDIV</td><td>Cells</td><td>float32</td><td>3</td><td>-1.902e-03</td><td>1.931e-03</td></tr>
</table>

</td></tr> </table></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;Scalars_&quot;</span><span class="p">)</span>
<span class="n">threshed</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">threshold</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
<span class="n">threshed</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;potential_H1&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">threshed</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;surface&#39;</span><span class="p">,</span> <span class="n">opacity</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="n">mesh</span><span class="o">.</span><span class="n">set_active_vectors</span><span class="p">(</span><span class="s2">&quot;J_L2&quot;</span><span class="p">)</span>
<span class="n">arrows</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">glyph</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="s2">&quot;J_L2&quot;</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">9500.0</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">arrows</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">camera_position</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">600</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="n">p</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">jupyter_backend</span><span class="o">=</span><span class="s1">&#39;html&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "ccc90c23255246e3b80bfba2608deb56", "version_major": 2, "version_minor": 0}</script></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;Scalars_&quot;</span><span class="p">)</span>
<span class="n">threshed</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">threshold</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
<span class="n">threshed</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;potential_L2&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">threshed</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;surface&#39;</span><span class="p">,</span> <span class="n">opacity</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="n">mesh</span><span class="o">.</span><span class="n">set_active_vectors</span><span class="p">(</span><span class="s2">&quot;J_HDIV&quot;</span><span class="p">)</span>
<span class="n">arrows</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">glyph</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="s2">&quot;J_HDIV&quot;</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">9500.0</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">arrows</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">camera_position</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">600</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="n">p</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">jupyter_backend</span><span class="o">=</span><span class="s1">&#39;html&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "977d9f8bae3e4c0ea32638aa7d999eaa", "version_major": 2, "version_minor": 0}</script></div>
</div>
<script type="application/vnd.jupyter.widget-state+json">
{"state": {"48cee0a5d83843778717bd93baeab10a": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {}}, "924a4627a5924433a9c5b611d1452f41": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}, "977d9f8bae3e4c0ea32638aa7d999eaa": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_48cee0a5d83843778717bd93baeab10a", "style": "IPY_MODEL_924a4627a5924433a9c5b611d1452f41", "value": "<iframe srcdoc=\"<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;/>\n    <meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;>\n  </head>\n  <body>\n    <div class=&quot;content&quot;></div>\n<script type=&quot;text/javascript&quot;>\n!function(){var e={334:function(){const e=document.querySelector(&quot;head&quot;);e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement(&quot;link&quot;);n.setAttribute(&quot;rel&quot;,&quot;icon&quot;),n.setAttribute(&quot;href&quot;,`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute(&quot;sizes&quot;,`${t}x${t}`),n.setAttribute(&quot;type&quot;,&quot;image/png&quot;),e.appendChild(n)}))},13:function(e,t,n){&quot;use strict&quot;;n.r(t),n.d(t,{initLocalFileLoader:function(){return ZA},load:function(){return YA}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return E},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return D},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ee},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return De},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i=&quot;undefined&quot;!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],D=r[2],E=Math.hypot(R,M,D);return E<a?null:(R*=E=1/E,M*=E,D*=E,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+D*o,C=D*R*s-M*o,S=R*M*s-D*o,A=M*M*s+i,I=D*M*s+R*o,w=R*D*s+M*o,P=M*D*s-R*o,O=D*D*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),E(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,D=(1-(p+v))*C,E=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=D,e[6]=E,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+D*I+L*w),e[14]=n[2]+w-(R*A+E*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return&quot;mat4(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;, &quot;+e[9]+&quot;, &quot;+e[10]+&quot;, &quot;+e[11]+&quot;, &quot;+e[12]+&quot;, &quot;+e[13]+&quot;, &quot;+e[14]+&quot;, &quot;+e[15]+&quot;)&quot;}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],D=t[12],E=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-D)<=a*Math.max(1,Math.abs(m),Math.abs(D))&&Math.abs(h-E)<=a*Math.max(1,Math.abs(h),Math.abs(E))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return&quot;mat3(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;)&quot;}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function De(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=De,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error(&quot;Invalid VTK object&quot;),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&&quot;object&quot;==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol(&quot;void&quot;),$e={};function qe(){}[&quot;log&quot;,&quot;debug&quot;,&quot;info&quot;,&quot;warn&quot;,&quot;error&quot;,&quot;time&quot;,&quot;timeEnd&quot;,&quot;group&quot;,&quot;groupEnd&quot;].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty(&quot;log&quot;)?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st(&quot;_&quot;===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=[&quot;TB&quot;,&quot;GB&quot;,&quot;MB&quot;,&quot;KB&quot;];let o=Number(e),a=&quot;B&quot;;for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot; &quot;;const n=[];let r=e;for(;r>1e3;)n.push((&quot;000&quot;+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),&quot;classHierarchy&quot;in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He(&quot;vtkObject&quot;);function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==[&quot;mtime&quot;].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||&quot;_&quot;===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(&quot;, &quot;)}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if(&quot;object&quot;==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(&quot;string&quot;==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError(&quot;Set Enum with invalid string argument&quot;)}if(&quot;number&quot;==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError(&quot;Set Enum outside numeric range&quot;)}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError(&quot;Set Enum with invalid argument (String/Number)&quot;)}},object(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(!ke()(t[n.name],o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}return!1}}};function Ct(e){if(&quot;object&quot;==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError(&quot;No setter for field&quot;)}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{&quot;object&quot;==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et(&quot;instance deleted - cannot call any method&quot;);else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=&quot; input ports. To add more input ports, use addInputConnection()&quot;,void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et(&quot;instance deleted - cannot call any method&quot;),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):o(e,i())},e.addInputConnection=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:&quot;Scalars&quot;;for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol(&quot;Event abort&quot;);function Dt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et(&quot;instance deleted - cannot call any method&quot;);const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA(&quot;vtkObject&quot;)}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt=&quot;__root__&quot;;function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=&quot;&quot;+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,[&quot;proxyId&quot;,&quot;proxyGroup&quot;,&quot;proxyName&quot;]),At(e,t,[&quot;proxyManager&quot;]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if(&quot;application&quot;===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,&quot;application&quot;),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return&quot;detail&quot;in e&&(n=e.detail),&quot;wheelDelta&quot;in e&&(n=-e.wheelDelta/120),&quot;wheelDeltaY&quot;in e&&(n=-e.wheelDeltaY/120),&quot;wheelDeltaX&quot;in e&&(t=-e.wheelDeltaX/120),&quot;axis&quot;in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,&quot;deltaY&quot;in e&&(o=e.deltaY),&quot;deltaX&quot;in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Dt,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Et,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Dt,newInstance:Et,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push(&quot;vtkViewNode&quot;),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)r.setVisited(!0);else{const r=e.createViewNode(n);r&&(r.setParent(e),r.setVisited(!0),t._renderableChildMap.set(n,r),t.children.push(r))}},e.addMissingNodes=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r],a=t._renderableChildMap.get(o);if(void 0!==a)a.setVisited(!0);else{const n=e.createViewNode(o);n&&(n.setParent(e),n.setVisited(!0),t._renderableChildMap.set(o,n),t.children.push(n))}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];-1===t.children.indexOf(o)&&(o.setParent(e),t.children.push(o)),o.setVisited(!0)}},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t(&quot;Cannot create view nodes without my own factory&quot;),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),t._renderableChildMap=new Map,jt.get(e,t,[&quot;visited&quot;]),jt.setGet(e,t,[&quot;_parent&quot;,&quot;renderable&quot;,&quot;myFactory&quot;]),jt.getArray(e,t,[&quot;children&quot;]),jt.moveToProtected(e,t,[&quot;parent&quot;]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,&quot;vtkViewNode&quot;),extend:Yt,PASS_TYPES:[&quot;Build&quot;,&quot;Render&quot;]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push(&quot;vtkViewNodeFactory&quot;),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s},e.registerOverride=(e,n)=>{t.overrides[e]=n}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,&quot;vtkViewNodeFactory&quot;),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push(&quot;vtkOpenGLViewNodeFactory&quot;)}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,&quot;vtkOpenGLViewNodeFactory&quot;),extend:sn};function cn(e,t){t.classHierarchy.push(&quot;vtkOpenGLCamera&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,[&quot;context&quot;,&quot;keyMatrixTime&quot;]),cn(e,t)}));rn(&quot;vtkCamera&quot;,dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderer&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn(&quot;No lights are on, creating one.&quot;),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();t.context.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,[&quot;shaderCache&quot;]),At(e,t,[&quot;selector&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),fn(e,t)}),&quot;vtkOpenGLRenderer&quot;);function hn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor&quot;),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkRenderer&quot;,mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor2D&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn(&quot;vtkActor&quot;,yn);const bn={context:null,activeTextures:null};const xn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function Dn(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function En(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn(&quot;vtkActor2D&quot;,xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn=&quot;\\\\s*([+-]?\\\\d+)\\\\s*&quot;,Jn=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*&quot;,er=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*&quot;,tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\\\(${Qn},${Qn},${Qn}\\\\)$`),rr=new RegExp(`^rgb\\\\(${er},${er},${er}\\\\)$`),or=new RegExp(`^rgba\\\\(${Qn},${Qn},${Qn},${Jn}\\\\)$`),ar=new RegExp(`^rgba\\\\(${er},${er},${er},${Jn}\\\\)$`),ir=new RegExp(`^hsl\\\\(${Jn},${er},${er}\\\\)$`),sr=new RegExp(`^hsla\\\\(${Jn},${er},${er},${Jn}\\\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+&quot;&quot;).trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):&quot;transparent&quot;===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?&quot;rgb(&quot;:&quot;rgba(&quot;}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?&quot;)&quot;:`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?&quot;0&quot;:&quot;&quot;)+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?&quot;hsl(&quot;:&quot;hsla(&quot;}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?&quot;)&quot;:`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Dr=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+&quot;&quot;}}return r.gamma=e,r}(1);function Er(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+&quot;&quot;}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&&quot;object&quot;==typeof e||(e={}),null!==t&&&quot;object&quot;==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Er((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Er((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,Fr=new RegExp(_r.source,&quot;g&quot;);function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+=&quot;&quot;,t+=&quot;&quot;;(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+&quot;&quot;}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join(&quot;&quot;)})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||&quot;boolean&quot;===r?Rr(t):(&quot;number&quot;===r?Br:&quot;string&quot;===r?(n=dr(t))?(t=n,Dr):kr:t instanceof dr?Dr:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:&quot;function&quot;!=typeof t.valueOf&&&quot;function&quot;!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error(&quot;invalid format: &quot;+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?&quot; &quot;:e.fill+&quot;&quot;,this.align=void 0===e.align?&quot;>&quot;:e.align+&quot;&quot;,this.sign=void 0===e.sign?&quot;-&quot;:e.sign+&quot;&quot;,this.symbol=void 0===e.symbol?&quot;&quot;:e.symbol+&quot;&quot;,this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?&quot;&quot;:e.type+&quot;&quot;}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf(&quot;e&quot;))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1];return o<0?&quot;0.&quot;+new Array(-o).join(&quot;0&quot;)+r:r.length>o+1?r.slice(0,o+1)+&quot;.&quot;+r.slice(o+1):r+new Array(o-r.length+2).join(&quot;0&quot;)}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?&quot;0&quot;:&quot;&quot;)+(void 0===this.width?&quot;&quot;:Math.max(1,0|this.width))+(this.comma?&quot;,&quot;:&quot;&quot;)+(void 0===this.precision?&quot;&quot;:&quot;.&quot;+Math.max(0,0|this.precision))+(this.trim?&quot;~&quot;:&quot;&quot;)+this.type};var ao={&quot;%&quot;:(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+&quot;&quot;,d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString(&quot;en&quot;).replace(/,/g,&quot;&quot;):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join(&quot;0&quot;):a>0?r.slice(0,a)+&quot;.&quot;+r.slice(a):&quot;0.&quot;+new Array(1-a).join(&quot;0&quot;)+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=[&quot;y&quot;,&quot;z&quot;,&quot;a&quot;,&quot;f&quot;,&quot;p&quot;,&quot;n&quot;,&quot;\u00b5&quot;,&quot;m&quot;,&quot;&quot;,&quot;k&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;,&quot;Z&quot;,&quot;Y&quot;];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?&quot;,f&quot;:r)).type){case&quot;s&quot;:var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case&quot;&quot;:case&quot;e&quot;:case&quot;g&quot;:case&quot;p&quot;:case&quot;r&quot;:null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-(&quot;e&quot;===r.type));break;case&quot;f&quot;:case&quot;%&quot;:null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*(&quot;%&quot;===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+&quot;&quot;,function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?&quot;&quot;:e.currency[0]+&quot;&quot;,a=void 0===e.currency?&quot;&quot;:e.currency[1]+&quot;&quot;,i=void 0===e.decimal?&quot;.&quot;:e.decimal+&quot;&quot;,s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?&quot;%&quot;:e.percent+&quot;&quot;,c=void 0===e.minus?&quot;\u2212&quot;:e.minus+&quot;&quot;,u=void 0===e.nan?&quot;NaN&quot;:e.nan+&quot;&quot;;function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;&quot;n&quot;===y?(m=!0,y=&quot;g&quot;):ao[y]||(void 0===h&&(h=12),v=!0,y=&quot;g&quot;),(f||&quot;0&quot;===t&&&quot;=&quot;===n)&&(f=!0,t=&quot;0&quot;,n=&quot;=&quot;);var T=&quot;$&quot;===p?o:&quot;#&quot;===p&&/[boxX]/.test(y)?&quot;0&quot;+y.toLowerCase():&quot;&quot;,b=&quot;$&quot;===p?a:/[%p]/.test(y)?l:&quot;&quot;,x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if(&quot;c&quot;===y)S=x(e)+S,e=&quot;&quot;;else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case&quot;.&quot;:o=t=r;break;case&quot;0&quot;:0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&&quot;+&quot;!==d&&(A=!1),p=(A?&quot;(&quot;===d?d:c:&quot;-&quot;===d||&quot;(&quot;===d?&quot;&quot;:d)+p,S=(&quot;s&quot;===y?po[8+Qr/3]:&quot;&quot;)+S+(A&&&quot;(&quot;===d?&quot;)&quot;:&quot;&quot;),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):&quot;&quot;;switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=&quot;&quot;),n){case&quot;<&quot;:e=p+e+S+w;break;case&quot;=&quot;:e=p+w+e+S;break;case&quot;^&quot;:e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+&quot;&quot;},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type=&quot;f&quot;,e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:&quot;,&quot;,grouping:[3],currency:[&quot;$&quot;,&quot;&quot;]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Do,ceil:Eo,min:Vo,max:Lo}=Math;const Bo=Ao(&quot;ceilLog2&quot;),No=Ao(&quot;factorial&quot;);function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao(&quot;gaussian&quot;);function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes(&quot;e&quot;))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split(&quot;e&quot;);let r=&quot;&quot;;return+n[1]+t>0&&(r=&quot;+&quot;),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co(&quot;vtkMath::Jacobi: Error extracting eigenfunctions&quot;),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co(&quot;Unable to factor linear system&quot;),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co(&quot;Unable to factor linear system&quot;),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Da(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Ea=Ao(&quot;GetScalarTypeFittingRange&quot;),Va=Ao(&quot;GetAdjustedScalarRange&quot;);const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Do,ceil:Eo,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo(&quot;Number of columns of A must match number of rows of B.&quot;);const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co(&quot;Matrix has 0 determinant&quot;),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co(&quot;Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()&quot;),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Da,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Ea,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;#&quot;;return`${t}${e.map(Ga).join(&quot;&quot;)}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(&quot;, &quot;)})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};const Wa=1e-6,Ha=&quot;coincide&quot;,ja=&quot;disjoint&quot;;function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?&quot;x&quot;:i[1]>i[2]?&quot;y&quot;:&quot;z&quot;;const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case&quot;x&quot;:l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case&quot;y&quot;:l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case&quot;z&quot;:l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha};function Ja(e,t){t.classHierarchy.push(&quot;vtkPlane&quot;),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}const ei={normal:[0,0,1],origin:[0,0,0]};function ti(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ei,n),jt.obj(e,t),jt.setGetArray(e,t,[&quot;normal&quot;,&quot;origin&quot;],3),Ja(e,t)}var ni={newInstance:jt.newInstance(ti,&quot;vtkPlane&quot;),extend:ti,...Qa};const ri=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function oi(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ai(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ii(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function si(e){return ii(e,ri)}function li(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function ci(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)li(e,...t[n]);else for(let n=0;n<t.length;n+=3)li(e,...t.slice(n,n+3));return e}function ui(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function fi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function gi(e,t,n,r){return!!ai(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function mi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function hi(e,t){return e[2*t+1]-e[2*t]}function vi(e){return[hi(e,0),hi(e,1),hi(e,2)]}function yi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function bi(e){return e.slice(4,6)}function xi(e){const t=vi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function Ci(e){if(ai(e)){const t=vi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Si(e){return[e[0],e[2],e[4]]}function Ai(e){return[e[1],e[3],e[5]]}function Ii(e,t){return e<=0&&t>=0||e>=0&&t<=0}function wi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Pi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=wi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return si(n),ci(n,r)}function Ri(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Mi(e,t,n,r){const o=[].concat(ri),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Di(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ni.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!ai(e)||!ai(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Li(e,t){if(!ai(e)||!ai(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Bi(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Ni(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ni.evaluate(n,t,l)}let i=2;for(;i--&&!(Ii(o[r[i][0]],o[r[i][4]])&&Ii(o[r[i][1]],o[r[i][5]])&&Ii(o[r[i][2]],o[r[i][6]])&&Ii(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class _i{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ri))}getBounds(){return this.bounds}equals(e){return oi(this.bounds,e)}isValid(){return ai(this.bounds)}setBounds(e){return ii(this.bounds,e)}reset(){return si(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return li(this.bounds,...t)}addPoints(e){return ci(this.bounds,e)}addBounds(e,t,n,r,o,a){return ui(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return di(this.bounds,e,t,n)}setMaxPoint(e,t,n){return pi(this.bounds,e,t,n)}inflate(e){return fi(this.bounds,e)}scale(e,t,n){return gi(this.bounds,e,t,n)}getCenter(){return mi(this.bounds)}getLength(e){return hi(this.bounds,e)}getLengths(){return vi(this.bounds)}getMaxLength(){return xi(this.bounds)}getDiagonalLength(){return Ci(this.bounds)}getMinPoint(){return Si(this.bounds)}getMaxPoint(){return Ai(this.bounds)}getXRange(){return yi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return bi(this.bounds)}getCorners(e){return wi(this.bounds,e)}computeCornerPoints(e,t){return Pi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Mi(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Ri(this.bounds,e)}cutWithPlane(e,t){return Ni(this.bounds,e,t)}intersectBox(e,t,n,r){return Di(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Li(this.bounds,e)}containsPoint(e,t,n){return Bi(this.bounds,e,t,n)}contains(e){return Li(this.bounds,e)}}var Fi,ki={newInstance:function(e){const t=e&&e.bounds;return new _i(t)},equals:oi,isValid:ai,setBounds:ii,reset:si,addPoint:li,addPoints:ci,addBounds:ui,setMinPoint:di,setMaxPoint:pi,inflate:fi,scale:gi,scaleAboutCenter:function(e,t,n,r){if(!ai(e))return!1;const o=mi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],gi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:mi,getLength:hi,getLengths:vi,getMaxLength:xi,getDiagonalLength:Ci,getMinPoint:Si,getMaxPoint:Ai,getXRange:yi,getYRange:Ti,getZRange:bi,getCorners:wi,computeCornerPoints:Pi,computeLocalBounds:Mi,transformBounds:Oi,computeScale3:Ri,cutWithPlane:Ni,intersectBox:Di,intersectPlane:Ei,intersect:Vi,intersects:Li,containsPoint:Bi,contains:function(e,t){return!!Li(e,t)&&!!Bi(e,...Si(t))&&!!Bi(e,...Ai(t))},INIT_BOUNDS:ri};function Gi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Ui(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function zi(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function Wi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Fi=new i(4),i!=Float32Array&&(Fi[0]=0,Fi[1]=0,Fi[2]=0,Fi[3]=0);var Hi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),Ui(),Ui(),ie();var ji={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Ki}=ji;function $i(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function qi(e,t){t.classHierarchy.push(&quot;vtkProp&quot;),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=$i(&quot;pick&quot;),e.hasKey=$i(&quot;hasKey&quot;),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Ki.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Ki.DISPLAY)}const Xi={allocatedRenderTime:10,coordinateSystem:Ki.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function Yi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xi,n),jt.obj(e,t),jt.get(e,t,[&quot;estimatedRenderTime&quot;,&quot;allocatedRenderTime&quot;]),jt.setGet(e,t,[&quot;_parentProp&quot;,&quot;coordinateSystem&quot;,&quot;dragable&quot;,&quot;pickable&quot;,&quot;renderTimeMultiplier&quot;,&quot;useBounds&quot;,&quot;visibility&quot;]),jt.moveToProtected(e,t,[&quot;parentProp&quot;]),qi(e,t)}var Zi={newInstance:jt.newInstance(Yi,&quot;vtkProp&quot;),extend:Yi,...ji};function Qi(e,t){t.classHierarchy.push(&quot;vtkProp3D&quot;),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Ui();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=Ui();zi(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>ki.getCenter(t.bounds),e.getLength=()=>ki.getLength(t.bounds),e.getXRange=()=>ki.getXRange(t.bounds),e.getYRange=()=>ki.getYRange(t.bounds),e.getZRange=()=>ki.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const Ji={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Zi.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,[&quot;bounds&quot;,&quot;isIdentity&quot;]),jt.getArray(e,t,[&quot;orientation&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;position&quot;,&quot;scale&quot;],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,Qi(e,t)}var ts={newInstance:jt.newInstance(es,&quot;vtkProp3D&quot;),extend:es};const ns={FLAT:0,GOURAUD:1,PHONG:2},rs={POINTS:0,WIREFRAME:1,SURFACE:2};var os={Shading:ns,Representation:rs,Interpolation:ns};const{Representation:as,Interpolation:is}=os;function ss(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ls(e,t){t.classHierarchy.push(&quot;vtkProperty&quot;),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ss(&quot;ComputeCompositeColor&quot;),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ss(&quot;AddShaderVariable&quot;),e.setInterpolationToFlat=()=>e.setInterpolation(is.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(is.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(is.PHONG),e.getInterpolationAsString=()=>jt.enumToString(is,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(as.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(as.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(as.POINTS),e.getRepresentationAsString=()=>jt.enumToString(as,t.representation)}const cs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:is.GOURAUD,representation:as.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function us(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cs,n),jt.obj(e,t),jt.setGet(e,t,[&quot;lighting&quot;,&quot;interpolation&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;metallic&quot;,&quot;roughness&quot;,&quot;normalStrength&quot;,&quot;emission&quot;,&quot;baseIOR&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;opacity&quot;,&quot;edgeVisibility&quot;,&quot;lineWidth&quot;,&quot;pointSize&quot;,&quot;backfaceCulling&quot;,&quot;frontfaceCulling&quot;,&quot;representation&quot;,&quot;diffuseTexture&quot;,&quot;metallicTexture&quot;,&quot;roughnessTexture&quot;,&quot;normalTexture&quot;,&quot;ambientOcclusionTexture&quot;,&quot;emissionTexture&quot;]),jt.setGetArray(e,t,[&quot;ambientColor&quot;,&quot;specularColor&quot;,&quot;diffuseColor&quot;,&quot;edgeColor&quot;],3),ls(e,t)}var ds={newInstance:jt.newInstance(us,&quot;vtkProperty&quot;),extend:us,...os};const{vtkDebugMacro:ps}=jt;function fs(e,t){t.classHierarchy.push(&quot;vtkActor&quot;);const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ds.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){ps(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.concat();const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const gs={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gs,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;backfaceProperty&quot;,&quot;forceOpaque&quot;,&quot;forceTranslucent&quot;,&quot;mapper&quot;]),fs(e,t)}var hs={newInstance:jt.newInstance(ms,&quot;vtkActor&quot;),extend:ms};const vs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},ys={VOID:&quot;&quot;,CHAR:&quot;Int8Array&quot;,SIGNED_CHAR:&quot;Int8Array&quot;,UNSIGNED_CHAR:&quot;Uint8Array&quot;,SHORT:&quot;Int16Array&quot;,UNSIGNED_SHORT:&quot;Uint16Array&quot;,INT:&quot;Int32Array&quot;,UNSIGNED_INT:&quot;Uint32Array&quot;,FLOAT:&quot;Float32Array&quot;,DOUBLE:&quot;Float64Array&quot;};var Ts={DefaultDataType:ys.FLOAT,DataTypeByteSize:vs,VtkDataTypes:ys};const{vtkErrorMacro:bs}=Kt,{DefaultDataType:xs}=Ts,Cs=1e-6;function Ss(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function As(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ss(r,0,1)}return Ss(e,t<0?0:t,n)}function Is(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function ws(e){return Object.prototype.toString.call(e).slice(8,-1)}const Ps={computeRange:As,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ss,getDataType:ws,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Os(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push(&quot;vtkDataArray&quot;),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=As(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Cs;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Ds({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=ws(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||bs(&quot;numberOfComponents must match&quot;);const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Rs={name:&quot;&quot;,numberOfComponents:1,dataType:xs,rangeTuple:[0,0]};function Ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Rs,n),!t.empty&&!t.values&&!t.size)throw new TypeError(&quot;Cannot create vtkDataArray object without: size > 0, values&quot;);if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=ws(t.values)),yt(e,t),St(e,t,[&quot;name&quot;,&quot;numberOfComponents&quot;]),t.size%t.numberOfComponents!=0)throw new RangeError(&quot;model.size is not a multiple of model.numberOfComponents&quot;);Os(e,t)}const Ds=Et(Ms,&quot;vtkDataArray&quot;);var Es={newInstance:Ds,extend:Ms,...Ps,...Ts};function Vs(e,t){t.classHierarchy.push(&quot;vtkAbstractMapper&quot;),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA(&quot;vtkPlane&quot;)&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Ls={clippingPlanes:[]};var Bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ls,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),Vs(e,t)};function Ns(e,t){e.getBounds=()=>(jt.vtkErrorMacro(&quot;vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED&quot;),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=ki.isValid(n)?ki.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return ki.getDiagonalLength(t)}}const _s=e=>({bounds:[...ki.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var Fs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_s(n)),Bs(e,t,n),jt.setGet(e,t,[&quot;viewSpecificProperties&quot;]),Ns(e,t)};const{vtkErrorMacro:ks,vtkWarningMacro:Gs}=jt;function Us(e,t){t.classHierarchy.push(&quot;vtkFieldData&quot;);const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>&quot;number&quot;==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():&quot;&quot;},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else ks(&quot;Unhandled case in passData&quot;);else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Es.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Gs(&quot;Unexpected case in interpolateData&quot;)}else t.insertTuples(s.getTuples());else ks(&quot;Unhandled case in interpolateData&quot;);else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Es.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const zs={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Ws(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zs,n),jt.obj(e,t),Us(e,t)}var Hs={newInstance:jt.newInstance(Ws,&quot;vtkFieldData&quot;),extend:Ws};const js={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ks={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:js,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:&quot;vtkGhostType&quot;};const{AttributeTypes:$s,AttributeCopyOperations:qs}=Ks,{vtkWarningMacro:Xs}=jt;function Ys(e,t){const n=[&quot;Scalars&quot;,&quot;Vectors&quot;,&quot;Normals&quot;,&quot;TCoords&quot;,&quot;Tensors&quot;,&quot;GlobalIds&quot;,&quot;PedigreeIds&quot;];function r(e){let t=n.find((t=>$s[t.toUpperCase()]===e||&quot;number&quot;!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push(&quot;vtkDataSetAttributes&quot;);const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&&quot;PEDIGREEIDS&quot;===a.toUpperCase()&&!n.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if(&quot;PEDIGREEIDS&quot;!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(qs).filter((e=>&quot;ALLCOPY&quot;!==e)).forEach((e=>{t.copyAttributeFlags[qs[e]]=Object.keys($s).filter((e=>&quot;NUM_ATTRIBUTES&quot;!==e)).reduce(((e,t)=>(e[$s[t]]=!0,e)),[])})),t.copyAttributeFlags[qs.COPYTUPLE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.INTERPOLATE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.COPYTUPLE][$s.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||&quot;vtkDataArray&quot;!==t.dataArrays[n].type||e.addArray(Es.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const Zs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Qs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zs,n),Hs.extend(e,t,n),jt.setGet(e,t,[&quot;activeScalars&quot;,&quot;activeNormals&quot;,&quot;activeTCoords&quot;,&quot;activeVectors&quot;,&quot;activeTensors&quot;,&quot;activeGlobalIds&quot;,&quot;activePedigreeIds&quot;]),t.arrays||(t.arrays={}),Ys(e,t)}var Js={newInstance:jt.newInstance(Qs,&quot;vtkDataSetAttributes&quot;),extend:Qs,...Ks};const el=[&quot;pointData&quot;,&quot;cellData&quot;,&quot;fieldData&quot;];function tl(e,t){t.classHierarchy.push(&quot;vtkDataSet&quot;),el.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Js.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),el.forEach((n=>{t[n]=Js.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const nl={};function rl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nl,n),jt.obj(e,t),jt.setGet(e,t,el),tl(e,t)}var ol={newInstance:jt.newInstance(rl,&quot;vtkDataSet&quot;),extend:rl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const al={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var il={StructuredType:al};const{StructuredType:sl}=il;var ll={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?sl.EMPTY:3===t?sl.XYZ_GRID:2===t?e[0]===e[1]?sl.YZ_PLANE:e[2]===e[3]?sl.XZ_PLANE:sl.XY_PLANE:1===t?e[0]<e[1]?sl.X_LINE:e[2]<e[3]?sl.Y_LINE:sl.Z_LINE:sl.SINGLE_POINT},...il};const{vtkErrorMacro:cl}=jt;function ul(e,t){t.classHierarchy.push(&quot;vtkImageData&quot;),e.setExtent=function(){if(t.deleted)return cl(&quot;instance deleted - cannot call any method&quot;),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=ll.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)cl(&quot;instance deleted - cannot call any method&quot;);else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void cl(&quot;Bad dimension specification&quot;);n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return cl(&quot;Requesting a point from an empty image.&quot;),null;const o=new Float64Array(3);switch(t.dataDescription){case al.EMPTY:return null;case al.SINGLE_POINT:break;case al.X_LINE:o[0]=n;break;case al.Y_LINE:o[1]=n;break;case al.Z_LINE:o[2]=n;break;case al.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case al.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case al.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case al.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:cl(&quot;Invalid dataDescription&quot;)}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>ki.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>ki.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>ki.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];ki.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Da(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Da(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return cl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return cl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const dl={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:al.EMPTY};function pl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dl,n),ol.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,[&quot;indexToWorld&quot;,&quot;worldToIndex&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;spacing&quot;],3),jt.setGetArray(e,t,[&quot;direction&quot;],9),jt.getArray(e,t,[&quot;extent&quot;],6),ul(e,t)}var fl={newInstance:jt.newInstance(pl,&quot;vtkImageData&quot;),extend:pl};const gl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var ml={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:gl},hl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:vl,VectorMode:yl}=ml,{VtkDataTypes:Tl}=Es,{ColorMode:bl}=hl,{vtkErrorMacro:xl}=jt;function Cl(e){return e}function Sl(e){return Math.floor(255*e+.5)}function Al(e,t){t.classHierarchy.push(&quot;vtkScalarsToColors&quot;),e.setVectorModeToMagnitude=()=>e.setVectorMode(yl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(yl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(yl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)xl(&quot;Values and annotations do not have the same number of tuples so ignoring&quot;);else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===bl.DEFAULT&&t.getDataType()===Tl.UNSIGNED_CHAR||n===bl.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:&quot;vtkDataArray&quot;,name:&quot;temp&quot;,numberOfComponents:4,dataType:Tl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Es.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,vl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,vl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===yl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==yl.MAGNITUDE||1!==c&&1!==s||(i=yl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case yl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case yl.RGBCOLORS:break;case yl.MAGNITUDE:default:{const o=Es.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Sl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Tl.UNSIGNED_CHAR)return n;const i=Es.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Tl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=Cl;switch(n.getDataType()!==Tl.FLOAT&&n.getDataType()!==Tl.DOUBLE||(s=Sl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return xl(&quot;Cannot convert colors&quot;),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==bl.DEFAULT||n.getDataType()!==Tl.UNSIGNED_CHAR)&&r!==bl.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Il={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:yl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function wl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Il,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,[&quot;vectorSize&quot;,&quot;vectorComponent&quot;,&quot;vectorMode&quot;,&quot;alpha&quot;,&quot;indexedLookup&quot;]),jt.setArray(e,t,[&quot;mappingRange&quot;],2),jt.getArray(e,t,[&quot;mappingRange&quot;]),Al(e,t)}var Pl={newInstance:jt.newInstance(wl,&quot;vtkScalarsToColors&quot;),extend:wl,...ml};const{vtkErrorMacro:Ol}=jt;function Rl(e,t){t.classHierarchy.push(&quot;vtkLookupTable&quot;),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Ol(&quot;Expected 4 components for RGBA colors&quot;),!1;if(n.getDataType()!==ys.UNSIGNED_CHAR)return Ol(&quot;Expected unsigned char values for RGBA colors&quot;),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ml={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Dl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ml,n),Pl.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,[&quot;buildTime&quot;]),jt.setGet(e,t,[&quot;numberOfColors&quot;,&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;]),jt.setArray(e,t,[&quot;alphaRange&quot;,&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;],2),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;,&quot;alphaRange&quot;,&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),Rl(e,t)}var El={newInstance:jt.newInstance(Dl,&quot;vtkLookupTable&quot;),extend:Dl};let Vl=1,Ll=0;const Bl=[&quot;VTK_RESOLVE_OFF&quot;,&quot;VTK_RESOLVE_POLYGON_OFFSET&quot;];function Nl(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;Ll=e}var _l={getResolveCoincidentTopologyAsString:function(){return Bl[Ll]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Vl},getResolveCoincidentTopology:function(){return Ll},setResolveCoincidentTopology:Nl,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){Vl=e},setResolveCoincidentTopologyToDefault:function(){Nl(0)},setResolveCoincidentTopologyToOff:function(){Nl(0)},setResolveCoincidentTopologyToPolygonOffset:function(){Nl(1)}};function Fl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=(e,r)=>{t[n.key]={factor:e,offset:r}}}))}const kl=[&quot;Polygon&quot;,&quot;Line&quot;,&quot;Point&quot;],Gl={};Fl(Gl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},kl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Ul={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,[&quot;resolveCoincidentTopology&quot;]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(_l).forEach((t=>{e[t]=_l[t]})),Object.keys(Gl).forEach((t=>{e[t]=Gl[t]})),Fl(e,t.topologyOffset,kl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=Gl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:Gl,otherStaticMethods:_l,CATEGORIES:kl};const zl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Wl={PassTypes:zl};const{FieldAssociations:Hl}=ol,{staticOffsetAPI:jl,otherStaticMethods:Kl}=Ul,{ColorMode:$l,ScalarMode:ql,GetArray:Xl}=hl,{VectorMode:Yl}=ml,{VtkDataTypes:Zl}=Es;function Ql(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Jl(e,t){t.classHierarchy.push(&quot;vtkMapper&quot;),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString($l,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(ql,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===ql.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===ql.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===ql.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===ql.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_FIELD_DATA){const t=e.getFieldData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==a){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(n))e.mapScalarsToTexture(o,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},e.scalarToTextureCoordinate=(e,t,n)=>{let r=.5,o=1;return _a(e)||(o=.49,r=(e-t)*n,r>1e3?r=1e3:r<-1e3&&(r=-1e3)),{texCoordS:r,texCoordT:o}},e.createColorTextureCoordinates=(t,n,r,o,a,i,s,l,c)=>{const u=(i[1]-i[0])/l,d=[];d[0]=i[0]-u,d[1]=i[1]+u;const p=1/(d[1]-d[0]),f=n.getData(),g=t.getData();let m=0,h=0;if(a<0||a>=o)for(let t=0;t<r;++t){let t=0;for(let e=0;e<o;++e)t+=g[m]*g[m],m++;let n=Math.sqrt(t);c&&(n=El.applyLogScale(n,s,i));const r=e.scalarToTextureCoordinate(n,d[0],p);f[h]=r.texCoordS,f[h+1]=r.texCoordT,h+=2}else{m+=a;for(let t=0;t<r;++t){let t=g[m];c&&(t=El.applyLogScale(t,s,i));const n=e.scalarToTextureCoordinate(t,d[0],p);f[h]=n.texCoordS,f[h+1]=n.texCoordT,h+=2,m+=o}}},e.mapScalarsToTexture=(n,r)=>{const o=t.lookupTable.getRange(),a=t.lookupTable.usingLogScale();a&&El.getLogRange(o,o);const i=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==r){t.lookupTable.setAlpha(r),t.colorTextureMap=null,t.lookupTable.build();let e=t.lookupTable.getNumberOfAvailableColors();e>4094&&(e=4094),e<64&&(e=64),e+=2;const n=(o[1]-o[0])/(e-2),s=new Float64Array(2*e);for(let t=0;t<e;++t)s[t]=o[0]+t*n-n/2,a&&(s[t]=10**s[t]);for(let t=0;t<e;++t)s[t+e]=NaN;t.colorTextureMap=fl.newInstance(),t.colorTextureMap.setExtent(0,e-1,0,1,0,0);const l=Es.newInstance({numberOfComponents:1,values:s});t.colorTextureMap.getPointData().setScalars(t.lookupTable.mapScalars(l,t.colorMode,0)),t.lookupTable.setAlpha(i)}if(!t.colorCoordinates||e.getMTime()>t.colorCoordinates.getMTime()||e.getInputData(0).getMTime()>t.colorCoordinates.getMTime()||t.lookupTable.getMTime()>t.colorCoordinates.getMTime()){t.colorCoordinates=null;const r=n.getNumberOfComponents(),i=n.getNumberOfTuples();t.colorCoordinates=Es.newInstance({numberOfComponents:2,values:new Float32Array(2*i)});let s=t.lookupTable.getVectorComponent();t.lookupTable.getVectorMode()===Yl.MAGNITUDE&&n.getNumberOfComponents()>1&&(s=-1),e.createColorTextureCoordinates(n,t.colorCoordinates,i,r,s,o,t.lookupTable.getRange(),t.colorTextureMap.getPointData().getScalars().getNumberOfTuples()/2-2,a)}},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=n=>{if(!t.interpolateScalarsBeforeMapping)return!1;if(t.lookupTable&&t.lookupTable.getIndexedLookup())return!1;const r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName),o=r.scalars;return!(!o||r.cellFlag||t.colorMode===$l.DEFAULT&&o.getDataType()===Zl.UNSIGNED_CHAR||t.colorMode===$l.DIRECT_SCALARS)},e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=Ql(&quot;AcquireInvertibleLookupTable&quot;),e.valueToColor=Ql(&quot;ValueToColor&quot;),e.colorToValue=Ql(&quot;ColorToValue&quot;),e.useInvertibleColorFor=Ql(&quot;UseInvertibleColorFor&quot;),e.clearInvertibleColor=Ql(&quot;ClearInvertibleColor&quot;),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(zl.ID_LOW24),o=e.getRawPixelBuffer(zl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Hl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Hl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===zl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(zl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===zl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t],n*=256,n+=r[t+1],n*=256,n+=r[t+2];const a=s[n];e.getPixelBuffer(zl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const ec={colorMapColors:null,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function tc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ec,n),Fs(e,t,n),jt.get(e,t,[&quot;colorCoordinates&quot;,&quot;colorMapColors&quot;,&quot;colorTextureMap&quot;,&quot;selectionWebGLIdsToVTKIds&quot;]),jt.setGet(e,t,[&quot;colorByArrayName&quot;,&quot;arrayAccessMode&quot;,&quot;colorMode&quot;,&quot;fieldDataTupleId&quot;,&quot;interpolateScalarsBeforeMapping&quot;,&quot;lookupTable&quot;,&quot;populateSelectionSettings&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;useLookupTableScalarRange&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),Ul.implementCoincidentTopologyMethods(e,t),Jl(e,t)}var nc={newInstance:jt.newInstance(tc,&quot;vtkMapper&quot;),extend:tc,...jl,...Kl,...hl};function rc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function oc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const ac={extractCellSizes:rc,getNumberOfCells:oc};function ic(e,t){t.classHierarchy.push(&quot;vtkCellArray&quot;);const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=oc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=rc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function sc(e){return{empty:!0,numberOfComponents:1,dataType:ys.UNSIGNED_INT,...e}}function lc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Es.extend(e,t,sc(n)),ic(e,t)}var cc={newInstance:jt.newInstance(lc,&quot;vtkCellArray&quot;),extend:lc,...ac};const{vtkErrorMacro:uc}=jt,dc=[1,-1,1,-1,1,-1];function pc(e,t){t.classHierarchy.push(&quot;vtkPoints&quot;),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return uc(`getBounds called on an array with components of\\n        ${e.getNumberOfComponents()}`),dc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const fc={empty:!0,numberOfComponents:3,dataType:ys.FLOAT,bounds:[1,-1,1,-1,1,-1]};function gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fc,n),Es.extend(e,t,n),pc(e,t)}var mc={newInstance:jt.newInstance(gc,&quot;vtkPoints&quot;),extend:gc};function hc(e,t){t.classHierarchy.push(&quot;vtkCell&quot;),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro(&quot;vtkCell.evaluatePosition is not implemented.&quot;)}}const vc={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function yc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vc,n),jt.obj(e,t),t.points||(t.points=mc.newInstance()),jt.get(e,t,[&quot;points&quot;,&quot;pointsIds&quot;]),hc(e,t)}var Tc={newInstance:jt.newInstance(yc,&quot;vtkCell&quot;),extend:yc};function bc(e,t){t.classHierarchy.push(&quot;vtkCellLinks&quot;),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA(&quot;vtkPolyData&quot;)){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Tc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Tc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const xc={array:null,maxId:0,extend:0};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),jt.obj(e,t),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,&quot;vtkCellLinks&quot;),extend:Cc};const Ac=0,Ic=1,wc=2,Pc=3,Oc=4,Rc=5,Mc=6,Dc=7,Ec=9,Vc=21,Lc=41,Bc=42,Nc=[&quot;vtkEmptyCell&quot;,&quot;vtkVertex&quot;,&quot;vtkPolyVertex&quot;,&quot;vtkLine&quot;,&quot;vtkPolyLine&quot;,&quot;vtkTriangle&quot;,&quot;vtkTriangleStrip&quot;,&quot;vtkPolygon&quot;,&quot;vtkPixel&quot;,&quot;vtkQuad&quot;,&quot;vtkTetra&quot;,&quot;vtkVoxel&quot;,&quot;vtkHexahedron&quot;,&quot;vtkWedge&quot;,&quot;vtkPyramid&quot;,&quot;vtkPentagonalPrism&quot;,&quot;vtkHexagonalPrism&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkQuadraticEdge&quot;,&quot;vtkQuadraticTriangle&quot;,&quot;vtkQuadraticQuad&quot;,&quot;vtkQuadraticTetra&quot;,&quot;vtkQuadraticHexahedron&quot;,&quot;vtkQuadraticWedge&quot;,&quot;vtkQuadraticPyramid&quot;,&quot;vtkBiQuadraticQuad&quot;,&quot;vtkTriQuadraticHexahedron&quot;,&quot;vtkQuadraticLinearQuad&quot;,&quot;vtkQuadraticLinearWedge&quot;,&quot;vtkBiQuadraticQuadraticWedge&quot;,&quot;vtkBiQuadraticQuadraticHexahedron&quot;,&quot;vtkBiQuadraticTriangle&quot;,&quot;vtkCubicLine&quot;,&quot;vtkQuadraticPolygon&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkConvexPointSet&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkParametricCurve&quot;,&quot;vtkParametricSurface&quot;,&quot;vtkParametricTriSurface&quot;,&quot;vtkParametricQuadSurface&quot;,&quot;vtkParametricTetraRegion&quot;,&quot;vtkParametricHexRegion&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkHigherOrderEdge&quot;,&quot;vtkHigherOrderTriangle&quot;,&quot;vtkHigherOrderQuad&quot;,&quot;vtkHigherOrderPolygon&quot;,&quot;vtkHigherOrderTetrahedron&quot;,&quot;vtkHigherOrderWedge&quot;,&quot;vtkHigherOrderPyramid&quot;,&quot;vtkHigherOrderHexahedron&quot;],_c={getClassNameFromTypeId:function(e){return e<Nc.length?Nc[e]:&quot;UnknownClass&quot;},getTypeIdFromClassName:function(e){return Nc.findIndex(e)},isLinear:function(e){return e<Vc||e===Lc||e===Bc},hasSubCells:function(e){return e===Mc||e===Oc||e===wc}};function Fc(e,t){t.classHierarchy.push(&quot;vtkCellTypes&quot;),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Ac},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const kc={size:0,maxId:-1,extend:1e3};function Gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kc,n),jt.obj(e,t),jt.get(e,t,[&quot;size&quot;,&quot;maxId&quot;,&quot;extend&quot;]),jt.getArray(e,t,[&quot;typeArray&quot;,&quot;locationArray&quot;]),Fc(e,t)}var Uc={newInstance:jt.newInstance(Gc,&quot;vtkCellTypes&quot;),extend:Gc,..._c},zc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Wc}=zc;function Hc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Hc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Wc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Wc.YES_INTERSECTION:Wc.NO_INTERSECTION}const Kc={distanceToLine:Hc,intersection:jc};function $c(e,t){t.classHierarchy.push(&quot;vtkLine&quot;),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Wc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Hc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Hc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Hc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Hc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const qc={orientations:null};function Xc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qc,n),Tc.extend(e,t,n),jt.setGet(e,t,[&quot;orientations&quot;]),$c(e,t)}var Yc={newInstance:jt.newInstance(Xc,&quot;vtkLine&quot;),extend:Xc,...Kc,...zc};function Zc(e,t){t.classHierarchy.push(&quot;vtkPointSet&quot;),t.points?t.points=We(t.points):t.points=mc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=mc.newInstance(),t.points.shallowCopy(e.getPoints())}}const Qc={};function Jc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qc,n),ol.extend(e,t,n),jt.setGet(e,t,[&quot;points&quot;]),Zc(e,t)}var eu={newInstance:jt.newInstance(Jc,&quot;vtkPointSet&quot;),extend:Jc};function tu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function nu(e,t,n,r){tu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const ru={computeNormalDirection:tu,computeNormal:nu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];nu(e,t,n,d),nu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,D=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ni.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ni.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(D=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[D],P[D]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function ou(e,t){t.classHierarchy.push(&quot;vtkTriangle&quot;),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(nu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ni.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=Yc.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),tu(l,c,u,d),ni.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=Yc.distanceToLine(e,c,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Yc.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Yc.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Yc.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const au={};function iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,au,n),Tc.extend(e,t,n),ou(e,t)}var su={newInstance:jt.newInstance(iu,&quot;vtkTriangle&quot;),extend:iu,...ru};const lu=[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;],{vtkWarningMacro:cu}=jt,uu={[Pc]:Yc,[Oc]:Yc,[Rc]:su};function du(e,t){t.classHierarchy.push(&quot;vtkPolyData&quot;),lu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\\w|[A-Z]|\\b\\w)/g,(e=>e.toUpperCase())).replace(/\\s+/g,&quot;&quot;)}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=cc.newInstance()})),e.getNumberOfCells=()=>lu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),lu.forEach((n=>{t[n]=cc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?wc:Ic,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Oc:Pc,1===t&&cu(&quot;Building VTK_LINE &quot;,n,&quot; with only one point, but VTK_LINE needs at least two points. Check the input.&quot;),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=Rc;break;case 4:l[n]=Ec;break;default:l[n]=Dc}t<3&&cu(&quot;Building VTK_TRIANGLE &quot;,n,&quot; with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.&quot;),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Mc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Uc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Sc.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Ic:case wc:o=t.verts;break;case Pc:case Oc:o=t.lines;break;case Rc:case Ec:case Dc:o=t.polys;break;case Mc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||uu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const pu={};function fu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pu,n),eu.extend(e,t,n),jt.get(e,t,[&quot;cells&quot;,&quot;links&quot;]),jt.setGet(e,t,[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;]),du(e,t)}var gu={newInstance:jt.newInstance(fu,&quot;vtkPolyData&quot;),extend:fu};function mu(e,t){t.classHierarchy.push(&quot;vtkTexture&quot;),e.imageLoaded=()=>{t.image.removeEventListener(&quot;load&quot;,e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener(&quot;load&quot;,e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext(&quot;2d&quot;).getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement(&quot;canvas&quot;);e.width=t.image.width,e.height=t.image.height;const n=e.getContext(&quot;2d&quot;);return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const hu={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hu,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,[&quot;canvas&quot;,&quot;image&quot;,&quot;jsImageData&quot;,&quot;imageLoaded&quot;,&quot;resizable&quot;]),jt.setGet(e,t,[&quot;repeat&quot;,&quot;edgeClamp&quot;,&quot;interpolate&quot;,&quot;mipLevel&quot;]),mu(e,t)}const yu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Tu={newInstance:jt.newInstance(vu,&quot;vtkTexture&quot;),extend:vu,...yu};const bu=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],xu=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Cu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Su=[0,1,0,1,0,1,0,1,2,2,2,2],Au=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Iu=new Float64Array(3),wu=new Float64Array(3),Pu=new Float64Array(3),Ou=new Float64Array(3),Ru=new Float64Array(3),Mu=new Float64Array(3),Du=new Float64Array(16);function Eu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Vu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],Vn(Pu,Iu,r),Pu[0]+=.1,Vn(wu,Pu,o),Pn(Ru,wu,Iu),Pu[0]-=.1,Pu[1]+=.1,Vn(wu,Pu,o),Pn(Mu,wu,Iu);for(let e=0;e<3;e++)Ru[e]/=.05*u[0],Mu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],a[0]<-.5?On(Pu,Ru,a[0]*i-l.width):a[0]>.5?On(Pu,Ru,a[0]*i):On(Pu,Ru,a[0]*i-l.width/2),wn(Iu,Iu,Pu),On(Pu,Mu,a[1]*i-l.height/2),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Pu,Ru,l.width),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Pu,Mu,l.height),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Pu,Ru,l.width),Pn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(Du,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Iu[0]=f[3*u],Iu[1]=f[3*u+1],Iu[2]=f[3*u+2],Vn(Pu,Iu,n),Iu[0]=f[3*u+3],Iu[1]=f[3*u+4],Iu[2]=f[3*u+5],Vn(Ou,Iu,n),Pn(Pu,Pu,Ou);const r=[Pu[0],Pu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Lu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,[&quot;renderable&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;tmActor&quot;,&quot;ticks&quot;]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],Vu(e,t)}),&quot;vtkCubeAxesActorHelper&quot;);function Bu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActor&quot;),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=ki.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Iu[s]=t.dataBounds[a]-.1*r*bu[a][s],Iu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Iu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Pu,Iu,e),Iu[s]=t.dataBounds[a],Vn(Ou,Iu,e),Pn(Pu,Ou,Pu),Mn(Pu,Pu),i=Pu[2]>o,t.camera.getParallelProjection()||(Mn(Ou,Ou),i=Dn(Ou,Pu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Au[t][0]].length+2*r[Au[t][1]].length,a+=r[Au[t][0]].length+r[Au[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Cu[e][0],l[3*u+2]=Cu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Au[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Au[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Su[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=xu[a][e];if(1===n[d]){const e=Su[d],n=3*Cu[d][0],p=3*Cu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Au[a][0]]=.5*(t.dataBounds[2*Au[a][0]]+t.dataBounds[2*Au[a][0]+1]),s[3*l+Au[a][1]]=.5*(t.dataBounds[2*Au[a][1]]+t.dataBounds[2*Au[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[xu[e][t]]++;const a=[],i=[];for(let e=0;e<3;e++){const n=go().domain([t.dataBounds[2*e],t.dataBounds[2*e+1]]);a[e]=n.ticks(5);const r=n.tickFormat(5);i[e]=a[e].map(r)}e.updatePolyData(r,n,a),e.updateTextData(r,n,a,i),(o||t.forceUpdate)&&e.updateTextureAtlas(i)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Eu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Eu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Eu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),ki.setBounds(t.bounds,t.gridActor.getBounds()),ki.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function Nu(e){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...ki.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:12,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},...e}}function _u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nu(n)),hs.extend(e,t,n),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=[&quot;X-Axis&quot;,&quot;Y-Axis&quot;,&quot;Z-Axis&quot;],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.tmTexture=Tu.newInstance(),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=nc.newInstance(),t.polyData=gu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=hs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=gu.newInstance(),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;boundsScaleFactor&quot;,&quot;faceVisibilityAngle&quot;,&quot;gridLines&quot;,&quot;tickLabelPixelOffset&quot;]),jt.setGetArray(e,t,[&quot;dataBounds&quot;],6),jt.setGetArray(e,t,[&quot;axisLabels&quot;],3),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;camera&quot;,&quot;tmTexture&quot;,&quot;textValues&quot;,&quot;textPolyData&quot;,&quot;tickCounts&quot;,&quot;gridActor&quot;]),Bu(e,t)}var Fu={newInstance:jt.newInstance(_u,&quot;vtkCubeAxesActor&quot;),extend:_u,newCubeAxesActorHelper:Lu};function ku(e,t){t.classHierarchy.push(&quot;vtkOpenGLCubeAxesActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gu={};const Uu=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=Fu.newCubeAxesActorHelper(),ku(e,t)}),&quot;vtkOpenGLCubeAxesActor&quot;);rn(&quot;vtkCubeAxesActor&quot;,Uu);const zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Wu={ObjectType:zu};const{ObjectType:Hu}=Wu;function ju(e,t){function n(e){switch(e){case Hu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Hu.TEXTURE_BUFFER:if(&quot;TEXTURE_BUFFER&quot;in t.context)return t.context.TEXTURE_BUFFER;case Hu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push(&quot;vtkOpenGLBufferObject&quot;);let r=null,o=null,a=!0,i=&quot;&quot;;e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i=&quot;Trying to upload array buffer to incompatible buffer.&quot;,!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const Ku={objectType:Hu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function $u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ku,n),jt.obj(e,t),jt.get(e,t,[&quot;_openGLRenderWindow&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),ju(e,t)}var qu={newInstance:jt.newInstance($u),extend:$u,...Wu};const{vtkErrorMacro:Xu}=jt;function Yu(e,t){t.classHierarchy.push(&quot;vtkOpenGLCellArrayBufferObject&quot;),e.setType(zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=qu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n){for(let r=0;r<e;++r)f(t[n+r])},linesToWireframe(e,t,n){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1])},polysToWireframe(e,t,n){if(e>2)for(let r=0;r<e;++r)f(t[n+r]),f(t[n+(r+1)%e])},stripsToWireframe(e,t,n){if(e>2){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1]);for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+2])}},polysToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+0]),f(t[n+r+1]),f(t[n+r+2])},stripsToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+1+r%2]),f(t[n+r+1+(r+1)%2])}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===rs.POINTS||&quot;verts&quot;===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===rs.WIREFRAME||&quot;lines&quot;===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,D=0,E=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];D+=n*n;const r=.5*(t[1]+t[0]);E+=r*r}const V=D>0&&(Math.abs(E)/D>1e6||Math.abs(Math.log10(D))>3||0===D&&E>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;)C(A[e],A,e+1),e+=A[e]+1,T++;return t.elementCount=w,e.upload(O,zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,Ui(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):Xu(&quot;Wrong type for coordScale, expected vec3 or null&quot;):Xu(&quot;Wrong type for coordShift, expected vec3 or null&quot;)}}const Zu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function Qu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zu,n),qu.extend(e,t,n),jt.setGet(e,t,[&quot;colorBO&quot;,&quot;elementCount&quot;,&quot;stride&quot;,&quot;colorBOStride&quot;,&quot;vertexOffset&quot;,&quot;normalOffset&quot;,&quot;tCoordOffset&quot;,&quot;tCoordComponents&quot;,&quot;colorOffset&quot;,&quot;colorComponents&quot;,&quot;customData&quot;]),jt.get(e,t,[&quot;coordShift&quot;,&quot;coordScale&quot;,&quot;coordShiftAndScaleEnabled&quot;,&quot;inverseShiftAndScaleMatrix&quot;]),Yu(e,t)}var Ju={newInstance:jt.newInstance(Qu),extend:Qu};const{vtkErrorMacro:ed}=jt;function td(e,t){t.classHierarchy.push(&quot;vtkShader&quot;),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||&quot;Unknown&quot;===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e=&quot;Fragment&quot;===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return ed(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const nd={shaderType:&quot;Unknown&quot;,source:&quot;&quot;,error:&quot;&quot;,handle:0,dirty:!1,context:null};function rd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nd,n),jt.obj(e,t),jt.setGet(e,t,[&quot;shaderType&quot;,&quot;source&quot;,&quot;error&quot;,&quot;handle&quot;,&quot;context&quot;]),td(e,t)}var od={newInstance:jt.newInstance(rd,&quot;vtkShader&quot;),extend:rd};const{vtkErrorMacro:ad}=jt;function id(e,t){t.classHierarchy.push(&quot;vtkShaderProgram&quot;),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(ad(`Links failed: ${t.error}`),0):(ad(t.error),0):(ad(t.fragmentShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.fragmentShader.getError()),0):(ad(t.vertexShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.vertexShader.getError()),0),e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error=&quot;Program has not been initialized, and/or does not have shaders.&quot;,!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return ad(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error=&quot;Shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===n.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error=&quot;Could not create shader program.&quot;,!1;t.handle=e,t.linked=!1}return&quot;Vertex&quot;===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),&quot;Fragment&quot;===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error=&quot;shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===e.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;switch(0===t.handle&&(t.error=&quot;This shader program has not been initialized yet.&quot;),e.getShaderType()){case&quot;Vertex&quot;:return t.vertexShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case&quot;Fragment&quot;:return t.fragmentShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const sd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:&quot;&quot;,handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=od.newInstance(),t.vertexShader.setShaderType(&quot;Vertex&quot;),t.fragmentShader=od.newInstance(),t.fragmentShader.setShaderType(&quot;Fragment&quot;),t.geometryShader=od.newInstance(),t.geometryShader.setShaderType(&quot;Geometry&quot;),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;error&quot;,&quot;handle&quot;,&quot;compiled&quot;,&quot;bound&quot;,&quot;md5Hash&quot;,&quot;vertexShader&quot;,&quot;fragmentShader&quot;,&quot;geometryShader&quot;,&quot;linked&quot;]),id(e,t)}var cd={newInstance:jt.newInstance(ld,&quot;vtkShaderProgram&quot;),extend:ld,substitute:function(e,t,n,r){const o=&quot;string&quot;==typeof n?n:n.join(&quot;\\n&quot;),a=!1===r?t:new RegExp(t,&quot;g&quot;),i=e.replace(a,o);return{replace:i!==o,result:i}}};function ud(e,t){t.classHierarchy.push(&quot;vtkOpenGLVertexArrayObject&quot;),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;)),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension(&quot;OES_vertex_array_object&quot;),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const dd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,[&quot;supported&quot;]),jt.setGet(e,t,[&quot;forceEmulation&quot;]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,&quot;vtkOpenGLVertexArrayObject&quot;),extend:pd};const gd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function md(e,t){t.classHierarchy.push(&quot;vtkOpenGLHelper&quot;),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===rs.POINTS||n===gd.Points?t.context.POINTS:e===rs.WIREFRAME||n===gd.Lines||n===gd.TrisEdges||n===gd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f(&quot;viewportSize&quot;,o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf(&quot;lineWidthStepSize&quot;,t/Math.ceil(t)),e.getProgram().setUniformf(&quot;halfLineWidth&quot;,n)}t.primitiveType===gd.Points||r.getProperty().getRepresentation()===rs.POINTS?e.getProgram().setUniformf(&quot;pointSize&quot;,r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf(&quot;pointSize&quot;,e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform float pointSize;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot;  gl_PointSize = pointSize;&quot;],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform vec2 viewportSize;&quot;,&quot;uniform float lineWidthStepSize;&quot;,&quot;uniform float halfLineWidth;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot; if (halfLineWidth > 0.0)&quot;,&quot;   {&quot;,&quot;   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;&quot;,&quot;   vec4 tmpPos = gl_Position;&quot;,&quot;   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;&quot;,&quot;   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];&quot;,&quot;   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];&quot;,&quot;   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);&quot;,&quot;   }&quot;]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===gd.Points?2:t.primitiveType===gd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const hd={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,[&quot;program&quot;,&quot;shaderSourceTime&quot;,&quot;VAO&quot;,&quot;attributeUpdateTime&quot;,&quot;CABO&quot;,&quot;primitiveType&quot;,&quot;pointPicking&quot;]),t.program=cd.newInstance(),t.VAO=fd.newInstance(),t.CABO=Ju.newInstance(),md(e,t)}var yd={newInstance:jt.newInstance(vd),extend:vd,primTypes:gd};const Td={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},bd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var xd={Wrap:Td,Filter:bd};const Cd=new Float32Array(1),Sd=new Int32Array(Cd.buffer);var Ad={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Cd[0]=e;const t=Sd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};const{Wrap:Id,Filter:wd}=xd,{VtkDataTypes:Pd}=Es,{vtkDebugMacro:Od,vtkErrorMacro:Rd,vtkWarningMacro:Md}=Kt,{toHalf:Dd}=Ad;function Ed(e,t){function n(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==Pd.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==Pd.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Dd(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o}function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension(&quot;OES_texture_half_float&quot;),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Ad.toHalf(Ad.fromHalf(e[u][l+s+t])*h*(1-v)+Ad.fromHalf(e[u][l+p+t])*h*v+Ad.fromHalf(e[u][c+s+t])*m*(1-v)+Ad.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&t.oglNorm16Ext)||e!==Pd.UNSIGNED_SHORT&&e!==Pd.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}const s=i&&(function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a);t.useHalfFloat=s}(a,c.offset,c.scale,r),t.useHalfFloat||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}t.classHierarchy.push(&quot;vtkOpenGLTexture&quot;),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent()),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(wd.LINEAR),e.setMagnificationFilter(wd.LINEAR)):(e.setMinificationFilter(wd.NEAREST),e.setMagnificationFilter(wd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Id.REPEAT),e.setWrapS(Id.REPEAT),e.setWrapT(Id.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()},e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Md(&quot;impossible case&quot;),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Od(`Unable to find suitable internal format for T=${n} NC= ${r}`),t.internalFormat),e.getDefaultInternalFormat=(e,n)=>{let r=0;return r=t._openGLRenderWindow.getDefaultTextureInternalFormat(e,n,t.oglNorm16Ext,t.useHalfFloat),r||(r||(Od(&quot;Unsupported internal texture type!&quot;),Od(`Unable to find suitable internal format for T=${e} NC= ${n}`)),r)},e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=e=>{if(t._openGLRenderWindow.getWebgl2())switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.SHORT:return t.context.SHORT;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case t.useHalfFloat&&Pd.SHORT:case t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case Pd.FLOAT:case Pd.VOID:default:return t.context.FLOAT}switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case Pd.FLOAT:case Pd.VOID:default:if(t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))return t.context.FLOAT;{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);if(e&&t.context.getExtension(&quot;OES_texture_half_float_linear&quot;))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case wd.NEAREST:return t.context.NEAREST;case wd.LINEAR:return t.context.LINEAR;case wd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case wd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case wd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case wd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Id.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Id.REPEAT:return t.context.REPEAT;case Id.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=n(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(n(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createDepthFromRaw=(n,r,a,i)=>(e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===Pd.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=r,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0):(Rd(&quot;Failed to determine texture parameters.&quot;),!1)),e.create2DFromImage=n=>{if(e.getOpenGLDataType(Pd.UNSIGNED_CHAR),e.getInternalFormat(Pd.UNSIGNED_CHAR,4),e.getFormat(Pd.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const r=!(t._openGLRenderWindow.getWebgl2()||Fo(n.width)&&Fo(n.height)),a=document.createElement(&quot;canvas&quot;);a.width=r?_o(n.width):n.width,a.height=r?_o(n.height):n.height,t.width=a.width,t.height=a.height;const i=a.getContext(&quot;2d&quot;);i.translate(0,a.height),i.scale(1,-1),i.drawImage(n,0,0,n.width,n.height,0,0,a.width,a.height);const s=a;return o(Pd.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Pd.UNSIGNED_CHAR,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Es.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.create3DFromRaw=(a,i,s,l,c,u)=>{if(e.getOpenGLDataType(c),e.getInternalFormat(c,l),e.getFormat(c,l),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=r(n(c,[u],!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(c)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=d[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,d[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,d[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(c,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Es.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=n*r*i,g=[],m=[];for(let e=0;e<c;++e)g[e]=0,m[e]=1;t.volumeInfo={scale:m,offset:g,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i};const h=structuredClone(p);if(t._openGLRenderWindow.getWebgl2()){if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=32767;return e.create3DFromRaw(n,r,i,c,u,d)}if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.UNSIGNED_SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=65535;return e.create3DFromRaw(n,r,i,c,u,d)}if(u===Pd.FLOAT||t.useHalfFloat&&(u===Pd.SHORT||u===Pd.UNSIGNED_SHORT))return e.create3DFromRaw(n,r,i,c,u,d);if(u===Pd.UNSIGNED_CHAR){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=255;return e.create3DFromRaw(n,r,i,c,u,d)}const o=new Float32Array(f*c);t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;let a=0;const s=h.scale.map((e=>1/e));for(let e=0;e<f;e++)for(let e=0;e<c;e++)o[a]=(d[a]-h.offset[e])*s[e],a++;return e.create3DFromRaw(n,r,i,c,Pd.FLOAT,o)}let v=(e,t,n,r,o)=>{e[t]=n},y=Pd.UNSIGNED_CHAR;if(u===Pd.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)?(y=Pd.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=Pd.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===Pd.FLOAT||c>=3)&&(T=4096);let b=1,x=1;f>T*T&&(b=Math.ceil(Math.sqrt(f/(T*T))),x=b);let C=Math.sqrt(f)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===Pd.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1}const Vd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Id.CLAMP_TO_EDGE,wrapT:Id.CLAMP_TO_EDGE,wrapR:Id.CLAMP_TO_EDGE,minificationFilter:wd.NEAREST,magnificationFilter:wd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,useHalfFloat:!0,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0};function Ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,[&quot;format&quot;,&quot;openGLDataType&quot;]),At(e,t,[&quot;keyMatrixTime&quot;,&quot;minificationFilter&quot;,&quot;magnificationFilter&quot;,&quot;wrapS&quot;,&quot;wrapT&quot;,&quot;wrapR&quot;,&quot;generateMipmap&quot;,&quot;oglNorm16Ext&quot;]),bt(e,t,[&quot;width&quot;,&quot;height&quot;,&quot;volumeInfo&quot;,&quot;components&quot;,&quot;handle&quot;,&quot;target&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),Ed(e,t)}const Bd=Et(Ld,&quot;vtkOpenGLTexture&quot;);var Nd={newInstance:Bd,extend:Ld,...xd};rn(&quot;vtkTexture&quot;,Bd);var _d=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexMC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\nvoid main()\\n{\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::PrimID::Impl\\n\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,Fd=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the polydata mappers fragment shader\\n\\nuniform int PrimitiveIDOffset;\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// optional color passed in from the vertex shader, vertexColor\\n//VTK::Color::Dec\\n\\n// optional surface normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// Depth Peeling Support\\n//VTK::DepthPeeling::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// label outline \\n//VTK::LabelOutline::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n//VTK::LabelOutlineHelperFunction\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::Color::Impl\\n\\n  // Generate the normal if we are not passed in one\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Light::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,kd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::Coincident::Dec&quot;,[&quot;uniform float cfactor;&quot;,&quot;uniform float coffset;&quot;]).result,t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;&quot;).result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;&quot;).result),n.Fragment=e}}},Gd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=cd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&&quot;&quot;!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&&quot;&quot;!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Ud}=ol,{primTypes:zd}=yd,{Representation:Wd,Shading:Hd}=ds,{ScalarMode:jd}=nc,{Filter:Kd,Wrap:$d}=Nd,{vtkErrorMacro:qd}=Kt,Xd={type:&quot;StartEvent&quot;},Yd={type:&quot;EndEvent&quot;},{CoordinateSystem:Zd}=Zi;function Qd(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType(&quot;vtkOpenGLActor&quot;),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=zd.Start;e<zd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let l=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;,&quot;uniform vec3 ambientColorUniform;&quot;,&quot;uniform vec3 diffuseColorUniform;&quot;];s&&(l=l.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let c=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];s&&(c=c.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),c=c.concat([&quot;  ambientColor = ambientColorUniform;&quot;,&quot;  diffuseColor = diffuseColorUniform;&quot;,&quot;  opacity = opacityUniform;&quot;]),s&&(c=c.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 scalarColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput =  scalarColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?t.renderable.getInterpolateScalarsBeforeMapping()&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);&quot;,&quot;  diffuseColor = texColor.rgb;&quot;,&quot;  ambientColor = texColor.rgb;&quot;,&quot;  opacity = opacity*texColor.a;&quot;])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat([&quot;uniform float opacityUniformBF; // the fragment opacity&quot;,&quot;uniform float ambientIntensityBF; // the material ambient&quot;,&quot;uniform float diffuseIntensityBF; // the material diffuse&quot;,&quot;uniform vec3 ambientColorUniformBF; // ambient material color&quot;,&quot;uniform vec3 diffuseColorUniformBF; // diffuse material color&quot;]),s?(l=l.concat([&quot;uniform float specularIntensityBF; // the material specular intensity&quot;,&quot;uniform vec3 specularColorUniformBF; // intensity weighted color&quot;,&quot;uniform float specularPowerUniformBF;&quot;]),c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  specularColor = specularIntensityBF * specularColorUniformBF;&quot;,&quot;  specularPower = specularPowerUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])):c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat([&quot;uniform samplerBuffer texture1;&quot;])),i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c).result):i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),i=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);let s=[];switch(a){case 0:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 1:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  float df = max(0.0, normalVCVSOutput.z);&quot;,&quot;  float sf = pow(df, specularPower);&quot;,&quot;  vec3 diffuseL = df * diffuseColor;&quot;,&quot;  vec3 specularL = sf * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,&quot;    {&quot;,`    float sf = sign(df)*pow(max(1e-5,\\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\\n                                                  normalize(-vertexVC.xyz))),\\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  vec3 vertLightDirectionVC;&quot;,&quot;  float attenuation;&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([&quot;  attenuation = 1.0;&quot;,`  if (lightPositional${e} == 0)`,&quot;    {&quot;,`      vertLightDirectionVC = lightDirectionVC${e};`,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,&quot;    float distanceVC = length(vertLightDirectionVC);&quot;,&quot;    vertLightDirectionVC = normalize(vertLightDirectionVC);&quot;,&quot;    attenuation = 1.0 /&quot;,`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,&quot;    // per OpenGL standard cone angle is 90 or less for a spot light&quot;,`    if (lightConeAngle${e} <= 90.0)`,&quot;      {&quot;,`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,&quot;      // if inside the cone&quot;,`      if (coneDot >= cos(radians(lightConeAngle${e})))`,&quot;        {&quot;,`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,&quot;        }&quot;,&quot;      else&quot;,&quot;        {&quot;,&quot;        attenuation = 0.0;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));&quot;,`    diffuseL += ((df) * lightColor${e});`,&quot;    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)&quot;,&quot;      {&quot;,`      float sf = sign(df)*attenuation*pow(max(1e-5,\\n                                                           dot(reflect(lightDirectionVC${e},\\n                                                                       normalVCVSOutput),\\n                                                               normalize(-vertexVC.xyz))),\\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;default:qd(&quot;bad light complexity&quot;)}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * normalMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Dec&quot;,[&quot;in vec3 normalVCVSOutput[];&quot;,&quot;out vec3 normalVCGSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCGSOutput = normalVCVSOutput[i];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;varying vec3 normalVCVSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalVCVSOutput);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.haveCellNormals?(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform mat3 normalMatrix;&quot;,&quot;uniform samplerBuffer textureN;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalMatrix *&quot;,&quot;    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput;&quot;,&quot;  if (abs(fdx.x) > 0.0)&quot;,&quot;    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }&quot;,&quot;  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}&quot;]).result):(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;&quot;]).result,a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;  fdx = normalize(fdx);&quot;,&quot;  fdy = normalize(fdy);&quot;,&quot;  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));&quot;,&quot;  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;,&quot;  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(o=cd.substitute(o,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCVSOutput = MCVCMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;in vec4 vertexVCVSOutput[];&quot;,&quot;out vec4 vertexVCGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCGSOutput = vertexVCVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;&quot;]).result):(o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,a&&a.length>=1)switch(i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}}else switch(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec3 tcoordVCVSOutput[];&quot;,&quot;out vec3 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec3 tcoordVCVSOutput;&quot;,&quot;uniform samplerCube texture1;&quot;]).result,i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`varying float clipDistancesVSOutput[${e}];`]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()||o.getEdgeVisibility()&&o.getRepresentation()===Wd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===zd.Points||o.getRepresentation()===Wd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===zd.Lines||o.getRepresentation()===Wd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==zd.Tris&&e!==zd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==zd.TrisEdges&&e!==zd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform int picking;&quot;,&quot;//VTK::Picking::Dec&quot;]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==zl.ID_LOW24&&t.lastSelectionState!==zl.ID_HIGH24||(a=cd.substitute(a,&quot;//VTK::Picking::Dec&quot;,[&quot;flat out int vertexIDVSOutput;\\n&quot;,&quot;uniform int VertexIDOffset;\\n&quot;]).result,a=cd.substitute(a,&quot;//VTK::Picking::Impl&quot;,&quot;  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;flat in int vertexIDVSOutput;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,[&quot;  int idx = vertexIDVSOutput;&quot;,&quot;//VTK::Picking::Impl&quot;]).result),t.lastSelectionState){case zl.ID_LOW24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);&quot;).result;break;case zl.ID_HIGH24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);&quot;).result;break;default:o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;uniform vec3 mapperIndex;&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===Hd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),h=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&n.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),n.getProgram().isUniformUsed(&quot;VertexIDOffset&quot;)&&n.getProgram().setUniformi(&quot;VertexIDOffset&quot;,t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;normalMC&quot;)&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;normalMC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting normalMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;normalMC&quot;),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||qd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||qd(&quot;Error setting tcoordMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),n.getProgram().isAttributeUsed(&quot;scalarColor&quot;)&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),&quot;scalarColor&quot;,n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||qd(&quot;Error setting scalarColor in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;scalarColor&quot;),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,r)}t.internalColorTexture&&n.getProgram().isUniformUsed(&quot;texture1&quot;)&&n.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi(&quot;picking&quot;,i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===Zd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4)}else s.setUniformMatrix(&quot;MCPCMatrix&quot;,n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed(&quot;MCVCMatrix&quot;)&&s.setUniformMatrix(&quot;MCVCMatrix&quot;,n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed(&quot;normalMatrix&quot;)&&s.setUniformMatrix3x3(&quot;normalMatrix&quot;,n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf(&quot;opacityUniform&quot;,i),o.setUniform3fArray(&quot;ambientColorUniform&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniform&quot;,l),o.setUniformf(&quot;ambient&quot;,c),o.setUniformf(&quot;diffuse&quot;,u);const f=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray(&quot;specularColorUniform&quot;,g),o.setUniformf(&quot;specularPowerUniform&quot;,p),o.setUniformf(&quot;specular&quot;,d),o.isUniformUsed(&quot;ambientIntensityBF&quot;)){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf(&quot;ambientIntensityBF&quot;,c),o.setUniformf(&quot;diffuseIntensityBF&quot;,u),o.setUniformf(&quot;opacityUniformBF&quot;,i),o.setUniform3fArray(&quot;ambientColorUniformBF&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniformBF&quot;,l),f<1)return;o.setUniformf(&quot;specularIntensityBF&quot;,d),o.setUniform3fArray(&quot;specularColorUniformBF&quot;,g),o.setUniformf(&quot;specularPowerUniformBF&quot;,p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():zl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Wd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===zl.ID_LOW24||t.lastSelectionState===zl.ID_HIGH24);for(let i=zd.Start;i<zd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===zd.TrisEdges||i===zd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(Xd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Yd),!t.currentInput)return void qd(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(null===o)return;t.renderable.mapScalars(o,1);const a=t.renderable.getColorMapColors();t.haveCellScalars=!1;const i=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(i!==jd.USE_CELL_DATA&&i!==jd.USE_CELL_FIELD_DATA&&i!==jd.USE_FIELD_DATA&&o.getPointData().getScalars()||i===jd.USE_POINT_FIELD_DATA||!a||(t.haveCellScalars=!0));let s=r.getProperty().getInterpolation()!==Hd.FLAT?o.getPointData().getNormals():null;null===s&&o.getCellData().getNormals()&&(t.haveCellNormals=!0,s=o.getCellData().getNormals());const l=r.getProperty().getRepresentation();let c=o.getPointData().getTCoords();if(t.openGLActor.getActiveTextures()||(c=null),t.renderable.getColorCoordinates()){c=t.renderable.getColorCoordinates(),t.internalColorTexture||(t.internalColorTexture=Nd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Kd.NEAREST),e.setMagnificationFilter(Kd.NEAREST),e.setWrapS($d.CLAMP_TO_EDGE),e.setWrapT($d.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${o.getMTime()}A${l}B${o.getMTime()}C${s?s.getMTime():1}D${a?a.getMTime():1}E${r.getProperty().getEdgeVisibility()}F${c?c.getMTime():1}`;if(t.VBOBuildString!==u){const n={points:o.getPoints(),normals:s,tcoords:c,colors:a,cellOffset:0,vertexOffset:0,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>o.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const i=[{inRep:&quot;verts&quot;,cells:o.getVerts()},{inRep:&quot;lines&quot;,cells:o.getLines()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()}],d=r.getProperty().getEdgeVisibility()&&l===Wd.SURFACE;for(let e=zd.Start;e<zd.End;e++)e!==zd.TrisEdges&&e!==zd.TriStripsEdges?(n.cellOffset+=t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,l,n,t.selectionWebGLIdsToVTKIds),n.vertexOffset+=t.primitives[e].getCABO().getElementCount()):d?t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,Wd.WIREFRAME,{...n,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[e].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&(t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),e.updateMaximumPointCellIds()),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Jd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:zl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function ep(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jd,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=zd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=zd.Start;e<zd.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),Qd(e,t)}const tp=Et(ep,&quot;vtkOpenGLPolyDataMapper&quot;);var np={newInstance:tp,extend:ep};rn(&quot;vtkMapper&quot;,tp);const{ColorMode:rp,ScalarMode:op,GetArray:ap}=hl;function ip(e,t){t.classHierarchy.push(&quot;vtkMapper2D&quot;),e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString(rp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(op,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===op.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===op.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===op.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===op.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_FIELD_DATA){const t=e.getFieldData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const sp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function lp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sp,n),Bs(e,t,n),jt.get(e,t,[&quot;colorMapColors&quot;]),jt.setGet(e,t,[&quot;arrayAccessMode&quot;,&quot;colorByArrayName&quot;,&quot;colorMode&quot;,&quot;lookupTable&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;transformCoordinate&quot;,&quot;useLookupTableScalarRange&quot;,&quot;viewSpecificProperties&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),ip(e,t)}var cp={newInstance:jt.newInstance(lp,&quot;vtkMapper2D&quot;),extend:lp};const up=1,{primTypes:dp}=yd,{ScalarMode:pp}=cp,{vtkErrorMacro:fp}=Kt,gp={type:&quot;StartEvent&quot;},mp={type:&quot;EndEvent&quot;};function hp(e,t){t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper2D&quot;),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType(&quot;vtkOpenGLActor2D&quot;),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model Coordinates\\n// WC - WC world coordinates\\n// VC - View Coordinates\\n// DC - Display Coordinates\\n\\nin vec4 vertexWC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nuniform mat4 WCVCMatrix;  // World to view matrix\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  gl_Position = WCVCMatrix*vertexWC;\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::PositionVC::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nuniform int PrimitiveIDOffset;\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Scalar coloring\\n//VTK::Color::Dec\\n\\n// Depth Peeling\\n//VTK::DepthPeeling::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Color::Impl\\n  //VTK::TCoord::Impl\\n\\n  //VTK::DepthPeeling::Impl\\n  //VTK::Picking::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=dp.Start;e<dp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(gp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(mp),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):fp(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==pp.USE_CELL_DATA&&a!==pp.USE_CELL_FIELD_DATA&&a!==pp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===pp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=mc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[dp.Points].getCABO().createVBO(r.getVerts(),&quot;verts&quot;,i,a),a.cellOffset+=t.primitives[dp.Lines].getCABO().createVBO(r.getLines(),&quot;lines&quot;,i,a),a.cellOffset+=t.primitives[dp.Tris].getCABO().createVBO(r.getPolys(),&quot;polys&quot;,i,a),a.cellOffset+=t.primitives[dp.TriStrips].getCABO().createVBO(r.getStrips(),&quot;strips&quot;,i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=dp.Start;a<dp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform samplerBuffer texture1;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);&quot;]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 diffuseColor;&quot;,&quot;out vec4 fcolorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorVSOutput = diffuseColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput[];\\n&quot;,&quot;out vec4 fcolorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorGSOutput = fcolorVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = fcolorVSOutput;&quot;]).result):(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform vec4 diffuseColor;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = diffuseColor;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordMC;&quot;,&quot;out float tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput[];\\n&quot;,&quot;out float tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,[&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));&quot;]).result):2===a&&(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordMC;&quot;,&quot;out vec2 tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];\\n&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);&quot;]).result),t.haveCellScalars&&(r=cd.substitute(r,&quot;//VTK::PrimID::Impl&quot;,[&quot;gl_PrimitiveID = gl_PrimitiveIDIn;&quot;]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=cd.substitute(r,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&e.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),e.getProgram().isAttributeUsed(&quot;vertexWC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;vertexWC&quot;,e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||fp(&quot;Error setting vertexWC in shader VAO.&quot;)),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||fp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;tcoordMC&quot;,e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||fp(&quot;Error setting tcoordMC in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),t.internalColorTexture&&e.getProgram().isUniformUsed(&quot;texture1&quot;)&&e.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi(&quot;picking&quot;,a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f(&quot;diffuseColor&quot;,i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===up?-1:1,x[15]=1,m(x,x),a.setUniformMatrix(&quot;WCVCMatrix&quot;,(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const vp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const yp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=dp,t.tmpMat4=g(new Float64Array(16));for(let e=dp.Start;e<dp.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),hp(e,t)}),&quot;vtkOpenGLPolyDataMapper2D&quot;);rn(&quot;vtkMapper2D&quot;,yp);const{VectorMode:Tp}=Pl;function bp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function xp(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Cp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Sp(e,t){t.classHierarchy.push(&quot;vtkScalarBarActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;;const n={},r=new Map;let o=0,a=1;bp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,bp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),&quot;NaN&quot;,&quot;Below&quot;,&quot;Above&quot;];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{bp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s(&quot;NaN&quot;,[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s(&quot;Below&quot;,[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s(&quot;ticks&quot;,t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s(&quot;Above&quot;,[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p=&quot;vertical&quot;===a?[1,0]:[0,1];&quot;vertical&quot;===a?(d[0]=l.width,d[1]=-l.height,&quot;middle&quot;===o[0]?n[1]-=l.width/2:&quot;right&quot;===o[0]&&(n[1]-=l.width),&quot;middle&quot;===o[1]?n[0]+=l.height/2:&quot;top&quot;===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,&quot;middle&quot;===o[0]?n[0]-=l.width/2:&quot;right&quot;===o[0]&&(n[0]-=l.width),&quot;middle&quot;===o[1]?n[1]-=l.height/2:&quot;top&quot;===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?[&quot;right&quot;,&quot;middle&quot;]:[&quot;middle&quot;,&quot;bottom&quot;];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;top&quot;],&quot;vertical&quot;,[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];&quot;ticks&quot;===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,&quot;horizontal&quot;,g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,&quot;horizontal&quot;,g,c)}const b=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Tp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Es.newInstance({numberOfComponents:i,values:c,name:&quot;Scalars&quot;});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Ap=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;tickLabelPixelOffset&quot;,&quot;renderable&quot;,&quot;topTitle&quot;,&quot;ticks&quot;,&quot;tickStrings&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;lastTickBounds&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;barActor&quot;,&quot;tmActor&quot;]),jt.getArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.barMapper=nc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=gu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=hs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Tu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Sp(e,t)}),&quot;vtkScalarBarActorHelper&quot;);function Ip(e,t){t.classHierarchy.push(&quot;vtkScalarBarActor&quot;),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(xp(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Cp())}}function wp(e){return{automated:!0,autoLayout:null,axisLabel:&quot;Scalar Value&quot;,barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:14,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function Pp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wp(n)),t.autoLayout||(t.autoLayout=xp(0,t)),t.generateTicks||(t.generateTicks=Cp()),hs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,[&quot;automated&quot;,&quot;autoLayout&quot;,&quot;axisTitlePixelOffset&quot;,&quot;axisLabel&quot;,&quot;scalarsToColors&quot;,&quot;tickLabelPixelOffset&quot;,&quot;generateTicks&quot;,&quot;drawNanAnnotation&quot;,&quot;drawBelowRangeSwatch&quot;,&quot;drawAboveRangeSwatch&quot;]),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;]),jt.getArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;],2),Ip(e,t)}var Op={newInstance:jt.newInstance(Pp,&quot;vtkScalarBarActor&quot;),extend:Pp,newScalarBarActorHelper:Ap};function Rp(e,t){t.classHierarchy.push(&quot;vtkOpenGLScalarBarActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Mp={};const Dp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Op.newScalarBarActorHelper(),Rp(e,t)}),&quot;vtkOpenGLScalarBarActor&quot;);rn(&quot;vtkScalarBarActor&quot;,Dp);const{vtkErrorMacro:Ep}=Kt;function Vp(e,t){t.classHierarchy.push(&quot;vtkOpenGLSkybox&quot;),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi(&quot;sbtexture&quot;,n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix(&quot;IMCPCMatrix&quot;,a),&quot;box&quot;===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f(&quot;camPos&quot;,e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Es.newInstance({numberOfComponents:3,values:e});n.setName(&quot;points&quot;);const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),&quot;box&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec3 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = wpos.xyz/wpos.w;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec3 TexCoords;\\n             uniform samplerCube sbtexture;\\n             uniform vec3 camPos;\\n             void main () {\\n               // skybox looks from inside out\\n               // which means we have to adjust\\n               // our tcoords. Otherwise text would\\n               // be flipped\\n               vec3 tc = normalize(TexCoords - camPos);\\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\\n               {\\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\\n               }\\n               else\\n               {\\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\\n               }\\n               gl_FragData[0] = textureCube(sbtexture, tc);\\n             }&quot;,&quot;&quot;)),&quot;background&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec2 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec2 TexCoords;\\n             uniform sampler2D sbtexture;\\n             void main () {\\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\\n             }&quot;,&quot;&quot;)),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),&quot;vertexMC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Ep(&quot;Error setting vertexMC in shader VAO.&quot;));const e=t.renderable.getTextures();e.length||Ep(&quot;vtkSkybox requires a texture map&quot;),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Lp={context:null};const Bp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lp,n),Zt.extend(e,t,n),t.openGLTexture=Nd.newInstance(),t.tris=yd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Vp(e,t)}));rn(&quot;vtkSkybox&quot;,Bp);const{FieldAssociations:Np}=ol;function _p(e,t){t.classHierarchy.push(&quot;vtkHardwareSelector&quot;),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const Fp={fieldAssociation:Np.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function kp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fp,n),jt.obj(e,t),jt.setGet(e,t,[&quot;fieldAssociation&quot;,&quot;captureZValues&quot;]),_p(e,t)}var Gp={newInstance:jt.newInstance(kp,&quot;vtkHardwareSelector&quot;),extend:kp};function Up(e,t){t.classHierarchy.push(&quot;vtkFramebuffer&quot;),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling saveCurrentBindings&quot;);const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling restorePreviousBindings&quot;);const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et(&quot;you must set the OpenGLRenderWindow before calling create&quot;)},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et(&quot;you must set the OpenGLRenderWindow before calling setColorBuffer&quot;);let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et(&quot;you must set the OpenGLRenderWindow before calling removeColorBuffer&quot;);let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et(&quot;Attaching depth buffer textures to fbo requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling setDepthBuffer&quot;)},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et(&quot;Attaching depth buffer textures to framebuffers requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling removeDepthBuffer&quot;)},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>{const e=[0,0];return null!==t.glFramebuffer&&(e[0]=t.glFramebuffer.width,e[1]=t.glFramebuffer.height),e},e.populateFramebuffer=()=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling populateFrameBuffer&quot;);e.bind();const n=t.context,r=Nd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(bd.LINEAR),r.setMagnificationFilter(bd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,ys.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const zp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Wp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zp,n),yt(e,t),t.colorBuffers&&et(&quot;you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.&quot;),t.colorBuffers=[],It(e,t,[&quot;colorBuffers&quot;]),Up(e,t)}var Hp={newInstance:Et(Wp,&quot;vtkFramebuffer&quot;),extend:Wp};function jp(e,t){t.classHierarchy.push(&quot;vtkSelectionNode&quot;),e.getBounds=()=>t.points.getBounds()}const Kp={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function $p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kp,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,[&quot;contentType&quot;,&quot;fieldType&quot;,&quot;properties&quot;,&quot;selectionList&quot;]),jp(e,t)}var qp={newInstance:jt.newInstance($p,&quot;vtkSelectionNode&quot;),extend:$p,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Xp}=Wl,{SelectionContent:Yp,SelectionField:Zp}=qp,{FieldAssociations:Qp}=ol,{vtkErrorMacro:Jp}=jt;function ef(e){return`${e.propID} ${e.compositeID}`}function tf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function nf(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function rf(e,t){let n=t;return n<<=24,n|=e,n}function of(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=nf(n[0],n[1],e.pixBuffer[Xp.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=nf(n[0],n[1],e.pixBuffer[Xp.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Xp.ID_LOW24]&&0===tf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area))return a;const s=nf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area),l=nf(n[0],n[1],e.pixBuffer[Xp.ID_HIGH24],e.area);return a.attributeID=rf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=of(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=of(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=of(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function af(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=qp.newInstance();switch(l.setContentType(Yp.INDICES),e){case Qp.FIELD_ASSOCIATION_CELLS:l.setFieldType(Zp.CELL);break;case Qp.FIELD_ASSOCIATION_POINTS:l.setFieldType(Zp.POINT);break;default:Jp(&quot;Unknown field association&quot;)}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function sf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=of(e,[n,t],0,u);if(r&&r.valid){const t=ef(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return af(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function lf(e,t){t.classHierarchy.push(&quot;vtkOpenGLHardwareSelector&quot;),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e[0]!==n[0]||e[1]!==n[1]?(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer()):t.framebuffer.bind()}else t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return sf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return Jp(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:&quot;StartEvent&quot;}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();for(e.beginSelection(),t.currentPass=Xp.MIN_KNOWN_PASS;t.currentPass<=Xp.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Xp.ACTOR_PASS&&&quot;function&quot;==typeof n[0].requestDepth&&&quot;function&quot;==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),e.processPixelBuffers());return e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:&quot;EndEvent&quot;}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Xp.ID_HIGH24){if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Xp.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if(&quot;function&quot;==typeof e[0].requestDepth&&&quot;function&quot;==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=nf(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Xp.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Xp.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(Xp,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=nf(e[0],e[1],t.pixBuffer[Xp.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=nf(e[0],e[1],t.pixBuffer[Xp.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Xp.ID_LOW24]&&0===tf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area))return a;const s=nf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area),l=nf(e[0],e[1],t.pixBuffer[Xp.ID_HIGH24],t.area);return a.attributeID=rf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=ef(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return af(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const cf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cf,n),Gp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,[&quot;area&quot;],4),jt.setGet(e,t,[&quot;_renderer&quot;,&quot;currentPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;maximumPointId&quot;,&quot;maximumCellId&quot;]),jt.setGetArray(e,t,[&quot;propColorValue&quot;],3),jt.moveToProtected(e,t,[&quot;renderer&quot;,&quot;openGLRenderWindow&quot;]),jt.event(e,t,&quot;event&quot;),lf(e,t)}var df={newInstance:jt.newInstance(uf,&quot;vtkOpenGLHardwareSelector&quot;),extend:uf,...Wl};const{vtkErrorMacro:pf}=Kt,{Representation:ff}=ds,{ObjectType:gf}=qu,{PassTypes:mf}=df,hf={type:&quot;StartEvent&quot;},vf={type:&quot;EndEvent&quot;};function yf(e,t){t.classHierarchy.push(&quot;vtkOpenGLGlyph3DMapper&quot;);const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(hf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(vf),!t.currentInput)return void pf(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;attribute mat3 gNormal;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * gNormal * normalMC;&quot;]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;];a&&(i=i.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let s=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];a&&(s=s.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),s=s.concat([&quot;  opacity = opacityUniform;&quot;]),a&&(s=s.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),t.drawingEdges||(i=i.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),n=cd.substitute(n,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 gColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput = gColor;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result,s=s.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])),o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,s).result,o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;vertexVCVSOutput = MCVCMatrix * gVertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result):(n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;]).result,n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=cd.substitute(n,&quot;//VTK::Picking::Dec&quot;,[&quot;attribute vec3 mapperIndexVS;&quot;,&quot;varying vec3 mapperIndexVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Picking::Impl&quot;,&quot;  mapperIndexVSOutput = mapperIndexVS;&quot;).result,e.Vertex=n,t=cd.substitute(t,&quot;//VTK::Picking::Dec&quot;,[&quot;varying vec3 mapperIndexVSOutput;&quot;,&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,t=cd.substitute(t,&quot;//VTK::Picking::Impl&quot;,[&quot;  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);&quot;,&quot;  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];&quot;]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3(&quot;normalMatrix&quot;,t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix(&quot;MCVCMatrix&quot;,t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray(&quot;ambientColorUniform&quot;,t.tmpColor),u.setUniform3fArray(&quot;diffuseColorUniform&quot;,t.tmpColor)}c&&u.setUniform3fArray(&quot;mapperIndex&quot;,c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===ff.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===mf.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed(&quot;normalMatrix&quot;),v=g.isUniformUsed(&quot;MCVCMatrix&quot;);if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed(&quot;gMatrix&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,&quot;gMatrix&quot;,0,64,t.context.FLOAT,4,!1,1)||pf(&quot;Error setting gMatrix in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gMatrix&quot;),e.getProgram().isAttributeUsed(&quot;gNormal&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,&quot;gNormal&quot;,0,36,t.context.FLOAT,3,!1,1)||pf(&quot;Error setting gNormal in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gNormal&quot;),e.getProgram().isAttributeUsed(&quot;gColor&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,&quot;gColor&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting gColor in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gColor&quot;),e.getProgram().isAttributeUsed(&quot;mapperIndexVS&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,&quot;mapperIndexVS&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting mapperIndexVS in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;mapperIndexVS&quot;),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=qu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=qu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=qu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=qu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,gf.ARRAY_BUFFER),t.normalBuffer.upload(n,gf.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),gf.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,gf.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Tf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const bf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),np.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),yf(e,t)}),&quot;vtkOpenGLGlyph3DMapper&quot;);rn(&quot;vtkGlyph3DMapper&quot;,bf);const{vtkErrorMacro:xf}=jt;class Cf{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Sf(e,t){t.classHierarchy.push(&quot;vtkClosedPolyLineToSurfaceFilter&quot;),e.requestData=(e,t)=>{const n=e[0];if(!n)return void xf(&quot;Invalid or missing input&quot;);const r=gu.newInstance();r.shallowCopy(n);const o=new Cf,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(cc.newInstance({values:c,name:&quot;faces&quot;})),t[0]=r}}const Af={};function If(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Af,n),jt.obj(e,t),jt.algo(e,t,1,1),Sf(e,t)}var wf={newInstance:jt.newInstance(If,&quot;vtkClosedPolyLineToSurfaceFilter&quot;),extend:If};const{vtkErrorMacro:Pf}=Kt;function Of(e,t){t.classHierarchy.push(&quot;vtkCutter&quot;);const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Pf(&quot;Invalid or missing input&quot;);if(!t.cutFunction)return void Pf(&quot;Missing cut function&quot;);const o=gu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error(&quot;Iterator is done&quot;);r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const Rf={cutFunction:null,cutScalars:null,cutValue:0};function Mf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),yt(e,t),Rt(e,t,1,1),At(e,t,[&quot;cutFunction&quot;,&quot;cutValue&quot;]),Of(e,t)}var Df={newInstance:Et(Mf,&quot;vtkCutter&quot;),extend:Mf};const Ef=e=>e,Vf=1e-6;class Lf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Ef}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=Dn(n,r);return a>=1||(En(this.tmp,n,r),Sn(this.tmp)<Vf&&(En(this.tmp,[1,0,0],e),Sn(this.tmp)<Vf&&En(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Bf=function(){return new Lf(!0)},Nf=function(){return new Lf(!1)};const _f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],Ff=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function kf(e,t){t.classHierarchy.push(&quot;vtkCubeSource&quot;),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=gu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Es.newInstance({name:&quot;Normals&quot;,values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Es.newInstance({name:&quot;TextureCoordinates&quot;,values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Bf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Nf().translate(...t.center).apply(o),t.matrix){Nf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Nf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Gf={xLength:1,yLength:1,zLength:1,pointType:&quot;Float64Array&quot;,generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;xLength&quot;,&quot;yLength&quot;,&quot;zLength&quot;,&quot;generate3DTextureCoordinates&quot;,&quot;generateFaces&quot;,&quot;generateLines&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;rotations&quot;],3),jt.setGetArray(e,t,[&quot;matrix&quot;],16),t._polys=cc.newInstance({values:Uint16Array.from(Ff)}),t._lineCells=cc.newInstance({values:Uint16Array.from(_f)}),jt.moveToProtected(e,t,[&quot;polys&quot;,&quot;lineCells&quot;]),jt.algo(e,t,0,1),kf(e,t)}var zf={newInstance:jt.newInstance(Uf,&quot;vtkCubeSource&quot;),extend:Uf};const{vtkErrorMacro:Wf}=jt;function Hf(e,t){t.classHierarchy.push(&quot;vtkImageDataOutlineFilter&quot;);const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA(&quot;vtkImageData&quot;))return void Wf(&quot;Invalid or missing input&quot;);const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Wf(&quot;Unable to fetch spatial extents of input image.&quot;)},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const jf={};function Kf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jf,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=zf.newInstance(),jt.moveToProtected(e,t,[&quot;cubeSource&quot;,&quot;tmpOut&quot;]),Hf(e,t)}var $f={newInstance:jt.newInstance(Kf,&quot;vtkImageDataOutlineFilter&quot;),extend:Kf};let qf;function Xf(e,t){t.classHierarchy.push(&quot;vtkAbstractTransform&quot;,&quot;vtkHomogeneousTransform&quot;,&quot;vtkTransform&quot;),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>qf({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const Yf={preMultiplyFlag:!1,matrix:[...vo]};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;preMultiplyFlag&quot;]),jt.setGetArray(e,t,[&quot;matrix&quot;],16),Xf(e,t)}qf=jt.newInstance(Zf,&quot;vtkTransform&quot;);var Qf={newInstance:qf,extend:Zf};const Jf={NEAREST:0,LINEAR:1};var eg={InterpolationType:Jf};const{vtkErrorMacro:tg}=Kt;function ng(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function rg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function og(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageResliceMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:&quot;EndEvent&quot;})):tg(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Jf.NEAREST?(t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.openGLTexture.setMinificationFilter(bd.LINEAR),t.openGLTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime(),e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(!r)return;const o=r.getPointData()?.getScalars();if(!o)return;t._scalars!==o&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=o);const a=o.getNumberOfComponents();let i=`${r.getMTime()}A${o.getMTime()}`;const s=t._openGLRenderWindow.getGraphicsResourceForObject(o);if(s?.vtkObj&&s?.hash===i&&t.openGLTextureString===i)t.openGLTexture=s.vtkObj,t.openGLTextureString=s.hash;else{t.openGLTexture||(t.openGLTexture=Nd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const e=r.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],o),t.openGLTextureString=i,o&&t._openGLRenderWindow.setGraphicsResourceForObject(o,t.openGLTexture,t.openGLTextureString)}const l=n.getProperty(),c=l.getIndependentComponents(),u=c?a:1,d=c?2*u:1,p=l.getRGBTransferFunction();i=ng(l,p,u);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===i&&t.colorTextureString===i)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(e*d*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),p){const r=new Float32Array(3*e);for(let t=0;t<u;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),c)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=i,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}const g=l.getPiecewiseFunction();i=ng(l,g,u);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(m?.vtkObj&&m?.hash===i&&t.pwfTextureString===i)t.pwfTexture=m.vtkObj,t.pwfTextureString=m.hash;else{const e=1024,n=e*d,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),g){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<u;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=i,g&&t._openGLRenderWindow.setGraphicsResourceForObject(g,t.pwfTexture,t.pwfTextureString)}const h=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==h){const e=Es.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName(&quot;points&quot;);const n=Es.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:tg(&quot;Slab mode requested without normals&quot;)}t.tris.getCABO().createVBO(n,&quot;polys&quot;,rs.SURFACE,r)}t.VBOBuildString=h,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed(&quot;texture1&quot;)&&a.setUniformi(&quot;texture1&quot;,t.openGLTexture.getTextureUnit()),a.isAttributeUsed(&quot;vertexWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexWC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting vertexWC in shader VAO.&quot;)),a.isAttributeUsed(&quot;normalWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;normalWC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting normalWC in shader VAO.&quot;)),a.isUniformUsed(&quot;slabThickness&quot;)&&a.setUniformf(&quot;slabThickness&quot;,t.renderable.getSlabThickness()),a.isUniformUsed(&quot;spacing&quot;)&&a.setUniform3fv(&quot;spacing&quot;,t.currentInput.getSpacing()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabTrapezoid&quot;)&&a.setUniformi(&quot;slabTrapezoid&quot;,t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed(&quot;WCTCMatrix&quot;)){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix(&quot;WCTCMatrix&quot;,t.tmpMat4)}a.isUniformUsed(&quot;vboScaling&quot;)&&a.setUniform3fv(&quot;vboScaling&quot;,n.getCABO().getCoordScale()),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed(&quot;MCPCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCPCMatrix&quot;,rg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed(&quot;MCVCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCVCMatrix&quot;,rg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d),o.setUniform4fv(&quot;backgroundColor&quot;,t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model coordinates\\n// WC - World coordinates\\n// VC - View coordinates\\n// DC - Display coordinates\\n// TC - Texture coordinates\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvoid main()\\n{\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the gpu image mapper fragment shader\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  //VTK::TCoord::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform mat4 WCTCMatrix;&quot;,&quot;out vec3 fragTexCoord;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;fragTexCoord = (WCTCMatrix * vertexWC).xyz;&quot;]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=[&quot;in vec3 fragTexCoord;&quot;,&quot;uniform highp sampler3D texture1;&quot;,&quot;uniform mat4 WCTCMatrix;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}s>0&&(u=u.concat([&quot;uniform vec3 spacing;&quot;,&quot;uniform float slabThickness;&quot;,&quot;uniform int slabType;&quot;,&quot;uniform int slabTrapezoid;&quot;,&quot;uniform vec3 vboScaling;&quot;]),u=u.concat([&quot;vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)&quot;,&quot;{&quot;,&quot;  vec4 retVal = vec4(1.0);&quot;,&quot;  if (slabType == 0) // min&quot;,&quot;  {&quot;,&quot;    retVal = min(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 1) // max&quot;,&quot;  {&quot;,&quot;    retVal = max(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 3) // sum&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  else // mean&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  return retVal;&quot;,&quot;}&quot;])),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,u).result;let d=[&quot;if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(texture1, fragTexCoord);&quot;];if(s>0&&(d=d.concat([&quot;// Get the first and last samples&quot;,&quot;int numSlices = 1;&quot;,&quot;float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;&quot;,&quot;vec3 normalxspacing = scaling * normalWCVSOutput;&quot;,&quot;float distTraveled = length(normalxspacing);&quot;,&quot;int trapezoid = 0;&quot;,&quot;while (distTraveled < slabThickness * 0.5)&quot;,&quot;{&quot;,&quot;  distTraveled += length(normalxspacing);&quot;,&quot;  float fnumSlices = float(numSlices);&quot;,&quot;  if (distTraveled > slabThickness * 0.5)&quot;,&quot;  {&quot;,&quot;    // Before stepping outside the slab, sample at the boundaries&quot;,&quot;    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;&quot;,&quot;    trapezoid = slabTrapezoid;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordNeg);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordPos);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;}&quot;,&quot;// Finally, if slab type is *mean*, divide the sum by the numSlices&quot;,&quot;if (slabType == 2)&quot;,&quot;{&quot;,&quot;  tvalue = tvalue / float(numSlices);&quot;,&quot;}&quot;])),c){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(l){case 1:d=d.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:d=d.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=[&quot;attribute vec4 vertexWC;&quot;];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat([&quot;attribute vec3 normalWC;&quot;,&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,c).result;let u=[&quot;gl_Position = MCPCMatrix * vertexWC;&quot;];l>0&&(u=u.concat([&quot;normalWCVSOutput = normalWC;&quot;,&quot;vertexWCVSOutput = vertexWC;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,u).result,a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result;let d=[];l>0&&(d=d.concat([&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),s=cd.substitute(s,&quot;//VTK::PositionVC::Dec&quot;,d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e=&quot;&quot;;const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`));const t=ue(n?.getDirection());ge(t,t);const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999||o>.999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ni.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getDimensions(),l=[0,i[0]-1,0,i[1]-1,0,i[2]-1];let c=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[c+a]=r[a],e[c+o[0]]=l[2*o[0]+n],e[c+o[1]]=l[2*o[1]+t],c+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const u=new Uint16Array(8);u[0]=3,u[1]=0,u[2]=1,u[3]=3,u[4]=3,u[5]=0,u[6]=3,u[7]=2;const d=s.getNormal();za.normalize(d);const p=new Float32Array(12);for(let e=0;e<4;++e)p[3*e]=d[0],p[3*e+1]=d[1],p[3*e+2]=d[2];t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(u,1);const f=Es.newInstance({numberOfComponents:3,values:p,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(f)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=gu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Es.newInstance({numberOfComponents:3,values:a,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(i)}else tg(&quot;Something went wrong.&quot;,&quot;A default slice plane should have been created in the beginning of&quot;,&quot;updateResliceGeometry.&quot;);t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)}}const ag={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,openGLTextureString:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1,_scalars:null};const ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ag,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=$f.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=gu.newInstance(),t.cutter=Df.newInstance(),t.lineToSurfaceFilter=wf.newInstance(),t.transform=Qf.newInstance(),bt(e,t,[&quot;openGLTexture&quot;]),og(e,t)}),&quot;vtkOpenGLImageResliceMapper&quot;);rn(&quot;vtkImageResliceMapper&quot;,ig);var sg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:lg}=Kt,{SlicingMode:cg}=sg;function ug(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function dg(e){const t=e.split(&quot;\\n&quot;),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function pg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t.renderable.isA(&quot;vtkImageMapper&quot;)&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(n.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,a=cd.substitute(a,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result,a=cd.substitute(a,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform sampler2D labelOutlineTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform float outlineOpacity;&quot;];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}}if(i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,c).result,!0===o.getProperty().getUseLabelOutline()&&(i=cd.substitute(i,&quot;//VTK::LabelOutline::Dec&quot;,[&quot;uniform int outlineThickness;&quot;,&quot;uniform float vpWidth;&quot;,&quot;uniform float vpHeight;&quot;,&quot;uniform float vpOffsetX;&quot;,&quot;uniform float vpOffsetY;&quot;,&quot;uniform mat4 PCWCMatrix;&quot;,&quot;uniform mat4 vWCtoIDX;&quot;,&quot;uniform ivec3 imageDimensions;&quot;]).result,i=cd.substitute(i,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result,i=cd.substitute(i,&quot;//VTK::LabelOutlineHelperFunction&quot;,[&quot;#ifdef vtkImageLabelOutlineOn&quot;,&quot;vec3 fragCoordToIndexSpace(vec4 fragCoord) {&quot;,&quot;  vec4 pcPos = vec4(&quot;,&quot;    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,&quot;,&quot;    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,&quot;,&quot;    (fragCoord.z - 0.5) * 2.0,&quot;,&quot;    1.0);&quot;,&quot;&quot;,&quot;  vec4 worldCoord = PCWCMatrix * pcPos;&quot;,&quot;  vec4 vertex = (worldCoord/worldCoord.w);&quot;,&quot;&quot;,&quot;  vec3 index = (vWCtoIDX * vertex).xyz;&quot;,&quot;&quot;,&quot;  // half voxel fix for labelmapOutline&quot;,&quot;  return (index + vec3(0.5)) / vec3(imageDimensions);&quot;,&quot;}&quot;,&quot;#endif&quot;]).result),l){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];let t=[&quot;vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);&quot;];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, opacity);&quot;]);break;case 2:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,t).result}else switch(s){case 1:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[...dg(&quot;\\n                #ifdef vtkImageLabelOutlineOn\\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); \\n                  float centerValue = texture2D(texture1, centerPosIS.xy).r;\\n                  bool pixelOnBorder = false;\\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\\n                  float opacityToUse = scalarOpacity * opacity;\\n                  int segmentIndex = int(centerValue * 255.0);\\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\\n                  int actualThickness = int(textureValue * 255.0);\\n\\n                  if (actualThickness == 0) {\\n                    gl_FragData[0] = vec4(0.0, 0.0, 1.0, 1.0);\\n                    return;\\n                  }\\n                  if (opacityToUse > 0.01) {\\n                    for (int i = -actualThickness; i <= actualThickness; i++) {\\n                      for (int j = -actualThickness; j <= actualThickness; j++) {\\n                        if (i == 0 || j == 0) {\\n                          continue;\\n                        }\\n                        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n                          gl_FragCoord.y + float(j),\\n                          gl_FragCoord.z, gl_FragCoord.w);\\n                        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n                        float value = texture2D(texture1, neighborPosIS.xy).r;\\n                        if (value != centerValue) {\\n                          pixelOnBorder = true;\\n                          break;\\n                        }\\n                      }\\n                      if (pixelOnBorder == true) {\\n                        break;\\n                      }\\n                    }\\n                    if (pixelOnBorder == true) {\\n                      gl_FragData[0] = vec4(tColor, outlineOpacity);\\n                    }\\n                    else {\\n                      gl_FragData[0] = vec4(tColor, opacityToUse);\\n                    }\\n                  }\\n                #else\\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\\n                #endif\\n                &quot;)]).result;break;case 2:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;float intensity = tcolor.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);&quot;]).result;break;case 3:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]).result;break;default:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;]).result}t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||lg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||lg(&quot;Error setting tcoordMC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi(&quot;texture1&quot;,a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi(&quot;colorTexture1&quot;,c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi(&quot;pwfTexture1&quot;,u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;labelOutlineTexture1&quot;,p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf(&quot;outlineOpacity&quot;,e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();a.setUniform3i(&quot;imageDimensions&quot;,o[0],o[1],1),a.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const i=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,i.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const l=e.getRenderTargetSize();a.setUniformf(&quot;vpWidth&quot;,l[0]),a.setUniformf(&quot;vpHeight&quot;,l[1]);const c=e.getRenderTargetOffset();a.setUniformf(&quot;vpOffsetX&quot;,c[0]/l[0]),a.setUniformf(&quot;vpOffsetY&quot;,c[1]/l[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf(&quot;opacity&quot;,o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):lg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=ug(l,f,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.vtkObj&&m?.hash===g&&t.colorTextureString===g)t.colorTexture=m.vtkObj,t.colorTextureString=m.hash;else{const e=1024,n=new Uint8Array(e*p*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST)):(t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR)),f){const r=new Float32Array(3*e);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),u)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,p,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=g,f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,t.colorTextureString)}const h=l.getPiecewiseFunction(),v=ug(l,h,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.vtkObj&&y?.hash===v&&t.pwfTextureString===v)t.pwfTexture=y.vtkObj,t.pwfTextureString=y.hash;else{const e=1024,n=e*p,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),h){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<d;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),u)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,p,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=v,h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,t.pwfTextureString)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA(&quot;vtkImageArrayMapper&quot;)?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===cg.I&&(S=x-C[0]),T===cg.J&&(S=x-C[2]),T!==cg.K&&T!==cg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Nd.newInstance({resizable:!0}),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(new Set([1,3,4]).has(s)&&i===ys.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.NEAREST)):t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST)):(4!==s||i!==ys.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(bd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(bd.LINEAR)),t.openGLTexture.setWrapS(Td.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Td.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[cg.X,cg.Y,cg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===cg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===cg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===cg.K||T===cg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):lg(&quot;Reformat slicing not yet supported.&quot;);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);m?.vtkObj?(t.openGLTexture=m.vtkObj,t.VBOBuildString=m.hash):(t._scalars!==g&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=g),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t._openGLRenderWindow.setGraphicsResourceForObject(g,t.openGLTexture,t.VBOBuildString)),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Es.newInstance({numberOfComponents:3,values:r});h.setName(&quot;points&quot;);const v=Es.newInstance({numberOfComponents:2,values:l});v.setName(&quot;tcoords&quot;);const y=new Uint16Array(8);y[0]=3,y[1]=0,y[2]=1,y[3]=3,y[4]=3,y[5]=0,y[6]=3,y[7]=2;const C=Es.newInstance({numberOfComponents:1,values:y});t.tris.getCABO().createVBO(C,&quot;polys&quot;,rs.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=e=>{t.labelOutlineThicknessTexture||(t.labelOutlineThicknessTexture=Nd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]}}const fg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,_scalars:null};const gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fg,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),pg(e,t)}),&quot;vtkOpenGLImageMapper&quot;);rn(&quot;vtkAbstractImageMapper&quot;,gg);const{vtkErrorMacro:mg}=jt;function hg(e,t,n){if(t.apply(e)){const t=e.getIndependentComponents();return`${e.getMTime()}-${t}-${n}`}return&quot;0&quot;}function vg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageCPRMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow))},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentImageDataInput,o=t.currentCenterlineInput;n.getProperty().getInterpolationType()===Jf.NEAREST?(t.volumeTexture.setMinificationFilter(bd.NEAREST),t.volumeTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.volumeTexture.setMinificationFilter(bd.LINEAR),t.volumeTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR));const a=r.getMTime();if(t.volumeTextureTime!==a){const e=r.getDimensions(),n=r.getPointData().getScalars();if(!n)return;t.volumeTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.volumeTexture.releaseGraphicsResources(t._openGLRenderWindow),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromRaw(e[0],e[1],e[2],n.getNumberOfComponents(),n.getDataType(),n.getData(),t.renderable.getPreferSizeOverAccuracy()),t.volumeTextureTime=a}const i=r.getPointData()&&r.getPointData().getScalars();if(!i)return;const s=i.getNumberOfComponents(),l=n.getProperty(),c=l.getIndependentComponents(),u=c?s:1,d=c?2*u:1,p=hg(l,l.getRGBTransferFunction,u);if(t.colorTextureString!==p){const e=1024,n=new Uint8Array(e*d*3);let r=l.getRGBTransferFunction();if(r){const o=new Float32Array(3*e);for(let t=0;t<u;t++){r=l.getRGBTransferFunction(t);const a=r.getRange();if(r.getTable(a[0],a[1],e,o,1),c)for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r],n[t*e*6+r+3*e]=255*o[r];else for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=p}const f=hg(l,l.getPiecewiseFunction,u);if(t.pwfTextureString!==f){const e=1024,n=e*d,r=new Uint8Array(n);let o=l.getPiecewiseFunction();if(t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),o){const r=new Float32Array(n),a=new Float32Array(e);for(let t=0;t<u;++t)if(o=l.getPiecewiseFunction(t),null===o)r.fill(1);else{const n=o.getRange();if(o.getTable(n[0],n[1],e,a,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=a[n],r[t*e*2+n+e]=a[n];else for(let n=0;n<e;n++)r[t*e*2+n]=a[n]}t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=f}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<o.getMTime()){const e=o.getNumberOfPoints(),n=e<=1?0:e-1,r=o.getDistancesToFirstPoint(),a=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,a-r[e],0],t),t+=3,s.set([l,a-r[e],0],t),t+=3,s.set([l,a-r[e+1],0],t),t+=3,s.set([0,a-r[e+1],0],t),t+=3;const c=Es.newInstance({numberOfComponents:3,values:s});c.setName(&quot;points&quot;);const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Es.newInstance({numberOfComponents:1,values:u}),p=o.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Es.newInstance({numberOfComponents:3,values:f,name:&quot;centerlinePosition&quot;}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Es.newInstance({numberOfComponents:1,values:v,name:&quot;quadIndex&quot;})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getCenterlineTangentDirections(),r=new Float32Array(3*i),o=new Float32Array(3*i);for(let t=0,a=0;t<n;++t){const n=3*t;for(let t=0;t<4;++t)r[a+0]=e[n+0],r[a+1]=e[n+1],r[a+2]=e[n+2],o[a+0]=e[n+3],o[a+1]=e[n+4],o[a+2]=e[n+5],a+=3}const a=Es.newInstance({numberOfComponents:3,values:r,name:&quot;centerlineTopDirection&quot;}),s=Es.newInstance({numberOfComponents:3,values:o,name:&quot;centerlineBotDirection&quot;});y.push(a,s)}t.tris.getCABO().createVBO(d,&quot;polys&quot;,rs.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result;const s=[&quot;attribute vec3 centerlinePosition;&quot;,&quot;attribute float quadIndex;&quot;,&quot;uniform float width;&quot;,&quot;out vec2 quadOffsetVSOutput;&quot;,&quot;out vec3 centerlinePosVSOutput;&quot;],l=t.renderable.getUseUniformOrientation();l?s.push(&quot;out vec3 centerlineDirVSOutput;&quot;,&quot;uniform vec3 centerlineDirection;&quot;):s.push(&quot;out vec3 centerlineTopDirVSOutput;&quot;,&quot;out vec3 centerlineBotDirVSOutput;&quot;,&quot;out float centerlineAngleVSOutput;&quot;,&quot;attribute vec3 centerlineTopDirection;&quot;,&quot;attribute vec3 centerlineBotDirection;&quot;),a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,s).result;const c=[&quot;quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);&quot;,&quot;centerlinePosVSOutput = centerlinePosition;&quot;];l?c.push(&quot;centerlineDirVSOutput = centerlineDirection;&quot;):c.push(&quot;vec3 sumVec = centerlineTopDirection + centerlineBotDirection;&quot;,&quot;float sumLen2 = dot(sumVec, sumVec);&quot;,&quot;float diffLen2 = 4.0 - sumLen2;&quot;,&quot;if (diffLen2 < 0.001) {&quot;,&quot;  // vectors are too close to each other, use lerp&quot;,&quot;  centerlineAngleVSOutput = -1.0; // use negative angle as a flag for lerp&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection;&quot;,&quot;} else if (sumLen2 == 0.0) {&quot;,&quot;  // vector are opposite to each other, don't make a choice for the user&quot;,&quot;  // use slerp without direction, it will display the centerline color on each row of pixel&quot;,&quot;  centerlineAngleVSOutput = 0.0;&quot;,&quot;  centerlineTopDirVSOutput = vec3(0.0);&quot;,&quot;  centerlineBotDirVSOutput = vec3(0.0);&quot;,&quot;} else {&quot;,&quot;  // use slerp&quot;,&quot;  centerlineAngleVSOutput = 2.0 * atan(sqrt(diffLen2/sumLen2));&quot;,&quot;  float sinAngle = sin(centerlineAngleVSOutput);&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection / sinAngle;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection / sinAngle;&quot;,&quot;}&quot;),a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,c).result;const u=t.volumeTexture.getComponents(),d=o.getProperty().getIndependentComponents();let p=[&quot;uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates&quot;,&quot;in vec2 quadOffsetVSOutput;&quot;,&quot;in vec3 centerlinePosVSOutput;&quot;,&quot;uniform highp sampler3D volumeTexture;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;];l?p.push(&quot;in vec3 centerlineDirVSOutput;&quot;):p.push(&quot;in vec3 centerlineTopDirVSOutput;&quot;,&quot;in vec3 centerlineBotDirVSOutput;&quot;,&quot;in float centerlineAngleVSOutput;&quot;);const f=t.renderable.getCenterPoint();if(f&&p.push(&quot;uniform vec3 globalCenterPoint;&quot;),d){for(let e=1;e<u;e++)p=p.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(u){case 1:p=p.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,p).result;let g=[];if(l?g.push(&quot;vec3 interpolatedCenterlineDir = centerlineDirVSOutput;&quot;):g.push(&quot;vec3 interpolatedCenterlineDir;&quot;,&quot;if (centerlineAngleVSOutput < 0.0) {&quot;,&quot;  // Lerp&quot;,&quot;  interpolatedCenterlineDir = quadOffsetVSOutput.y * centerlineTopDirVSOutput + (1.0 - quadOffsetVSOutput.y) * centerlineBotDirVSOutput;&quot;,&quot;} else {&quot;,&quot;  // Slerp&quot;,&quot;  float topInterpolationAngle = quadOffsetVSOutput.y * centerlineAngleVSOutput;&quot;,&quot;  float botInterpolationAngle = centerlineAngleVSOutput - topInterpolationAngle;&quot;,&quot;  interpolatedCenterlineDir = sin(topInterpolationAngle) * centerlineTopDirVSOutput + sin(botInterpolationAngle) * centerlineBotDirVSOutput;&quot;,&quot;}&quot;,&quot;// Slerp should give a normalized vector but when sin(angle) is small, rounding error occurs&quot;,&quot;// Normalize for both lerp and slerp&quot;,&quot;interpolatedCenterlineDir = normalize(interpolatedCenterlineDir);&quot;),f?g.push(&quot;float baseOffset = dot(interpolatedCenterlineDir, globalCenterPoint - centerlinePosVSOutput);&quot;,&quot;float horizontalOffset = quadOffsetVSOutput.x + baseOffset;&quot;):g.push(&quot;float horizontalOffset = quadOffsetVSOutput.x;&quot;),g.push(&quot;vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * interpolatedCenterlineDir;&quot;,&quot;vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;&quot;,&quot;if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(volumeTexture, volumePosTC);&quot;),d){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<u;++t)g=g.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(u){case 1:g=g.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(u){case 1:g=g.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:g=g.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,g).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||mg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getCABO().getCustomData().forEach((e=>{e&&n.getProgram().isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),e.name,e.offset,n.getCABO().getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&mg(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const a=t.volumeTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;volumeTexture&quot;,a),n.getProgram().setUniformf(&quot;width&quot;,t.renderable.getWidth()),n.getProgram().setUniform4f(&quot;backgroundColor&quot;,...t.renderable.getBackgroundColor()),n.getProgram().isUniformUsed(&quot;centerlineDirection&quot;)){const e=t.renderable.getUniformDirection();n.getProgram().setUniform3fArray(&quot;centerlineDirection&quot;,e)}if(n.getProgram().isUniformUsed(&quot;globalCenterPoint&quot;)){const e=t.renderable.getCenterPoint();n.getProgram().setUniform3fArray(&quot;globalCenterPoint&quot;,e)}const i=t.currentImageDataInput,s=i.getWorldToIndex(),l=P(new Float32Array(16),Rn([],i.getDimensions())),c=oe(l,l,s);if(n.getProgram().setUniformMatrix(&quot;MCTCMatrix&quot;,c),t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)}}const yg={currentRenderPass:null,volumeTexture:null,volumeTextureTime:0,colorTexture:null,colorTextureString:null,pwfTexture:null,pwfTextureString:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Tg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yg,n),Zt.extend(e,t,n),kd(e,t,n),jt.algo(e,t,2,0),t.tris=yd.newInstance(),t.volumeTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.pwfTexture=Nd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),vg(e,t)}),&quot;vtkOpenGLImageCPRMapper&quot;);function bg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageSlice&quot;),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkImageCPRMapper&quot;,Tg);const xg={context:null,keyMatrixTime:null,keyMatrices:null};const Cg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bg(e,t)}),&quot;vtkOpenGLImageSlice&quot;);function Sg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolume&quot;),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn(&quot;vtkImageSlice&quot;,Cg);const Ag={};const Ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ag,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,[&quot;context&quot;]),Sg(e,t)}),&quot;vtkOpenGLVolume&quot;);rn(&quot;vtkVolume&quot;,Ig);const wg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},Pg={FRACTIONAL:0,PROPORTIONAL:1};var Og={InterpolationType:wg,OpacityMode:Pg};const Rg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5};var Mg={BlendMode:Rg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Dg,vtkErrorMacro:Eg}=Kt;function Vg(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function Lg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolumeMapper&quot;),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType(&quot;vtkOpenGLVolume&quot;);const n=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const r=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera()),e.renderPiece(r,n)}},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\n\\nvarying vec3 vertexVCVSOutput;\\nuniform mat4 PCVCMatrix;\\n\\nuniform float dcxmin;\\nuniform float dcxmax;\\nuniform float dcymin;\\nuniform float dcymax;\\n\\nvoid main()\\n{\\n  // dcsmall is the device coords reduced to the\\n  // x y area covered by the volume\\n  vec4 dcsmall = vec4(\\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\\n    vertexDC.z,\\n    vertexDC.w);\\n  vec4 vcpos = PCVCMatrix * dcsmall;\\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\\n  gl_Position = dcsmall;\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkVolumeFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the volume mappers fragment shader\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvarying vec3 vertexVCVSOutput;\\n\\n// first declare the settings from the mapper\\n// that impact the code paths in here\\n\\n// always set vtkNumComponents 1,2,3,4\\n//VTK::NumComponents\\n\\n// possibly define vtkTrilinearOn\\n//VTK::TrilinearOn\\n\\n// possibly define vtkIndependentComponents\\n//VTK::IndependentComponentsOn\\n\\n// possibly define any \\&quot;proportional\\&quot; components\\n//VTK::vtkProportionalComponents\\n\\n// Define the blend mode to use\\n#define vtkBlendMode //VTK::BlendMode\\n\\n// Possibly define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n#ifdef vtkImageLabelOutlineOn\\n\\nuniform float outlineOpacity;\\nuniform float vpWidth;\\nuniform float vpHeight;\\nuniform float vpOffsetX;\\nuniform float vpOffsetY;\\nuniform mat4 PCWCMatrix;\\nuniform mat4 vWCtoIDX;\\n#endif\\n\\n// define vtkLightComplexity\\n//VTK::LightComplexity\\n#if vtkLightComplexity > 0\\nuniform float vSpecularPower;\\nuniform float vAmbient;\\nuniform float vDiffuse;\\nuniform float vSpecular;\\n//VTK::Light::Dec\\n#endif\\n\\n//VTK::VolumeShadowOn\\n//VTK::SurfaceShadowOn\\n//VTK::localAmbientOcclusionOn\\n//VTK::LAO::Dec\\n//VTK::VolumeShadow::Dec\\n\\n// define vtkComputeNormalFromOpacity\\n//VTK::vtkComputeNormalFromOpacity\\n\\n// possibly define vtkGradientOpacityOn\\n//VTK::GradientOpacityOn\\n#ifdef vtkGradientOpacityOn\\nuniform float goscale0;\\nuniform float goshift0;\\nuniform float gomin0;\\nuniform float gomax0;\\n#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\nuniform float goscale1;\\nuniform float goshift1;\\nuniform float gomin1;\\nuniform float gomax1;\\n#if vtkNumComponents >= 3\\nuniform float goscale2;\\nuniform float goshift2;\\nuniform float gomin2;\\nuniform float gomax2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float goscale3;\\nuniform float goshift3;\\nuniform float gomin3;\\nuniform float gomax3;\\n#endif\\n#endif\\n#endif\\n\\n// if you want to see the raw tiled\\n// data in webgl1 uncomment the following line\\n// #define debugtile\\n\\n// camera values\\nuniform float camThick;\\nuniform float camNear;\\nuniform float camFar;\\nuniform int cameraParallel;\\n\\n// values describing the volume geometry\\nuniform vec3 vOriginVC;\\nuniform vec3 vSpacing;\\nuniform ivec3 volumeDimensions; // 3d texture dimensions\\nuniform vec3 vPlaneNormal0;\\nuniform float vPlaneDistance0;\\nuniform vec3 vPlaneNormal1;\\nuniform float vPlaneDistance1;\\nuniform vec3 vPlaneNormal2;\\nuniform float vPlaneDistance2;\\nuniform vec3 vPlaneNormal3;\\nuniform float vPlaneDistance3;\\nuniform vec3 vPlaneNormal4;\\nuniform float vPlaneDistance4;\\nuniform vec3 vPlaneNormal5;\\nuniform float vPlaneDistance5;\\n\\n//VTK::ClipPlane::Dec\\n\\n// opacity and color textures\\nuniform sampler2D otexture;\\nuniform float oshift0;\\nuniform float oscale0;\\nuniform sampler2D ctexture;\\nuniform float cshift0;\\nuniform float cscale0;\\n\\n// jitter texture\\nuniform sampler2D jtexture;\\nuniform sampler2D ttexture;\\n\\n\\n// some 3D texture values\\nuniform float sampleDistance;\\nuniform vec3 vVCToIJK;\\n\\n// the heights defined below are the locations\\n// for the up to four components of the tfuns\\n// the tfuns have a height of 2XnumComps pixels so the\\n// values are computed to hit the middle of the two rows\\n// for that component\\n#ifdef vtkIndependentComponentsOn\\n#if vtkNumComponents == 2\\nuniform float mix0;\\nuniform float mix1;\\n#define height0 0.25\\n#define height1 0.75\\n#endif\\n#if vtkNumComponents == 3\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\n#define height0 0.17\\n#define height1 0.5\\n#define height2 0.83\\n#endif\\n#if vtkNumComponents == 4\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\nuniform float mix3;\\n#define height0 0.125\\n#define height1 0.375\\n#define height2 0.625\\n#define height3 0.875\\n#endif\\n#endif\\n\\n#if vtkNumComponents >= 2\\nuniform float oshift1;\\nuniform float oscale1;\\nuniform float cshift1;\\nuniform float cscale1;\\n#endif\\n#if vtkNumComponents >= 3\\nuniform float oshift2;\\nuniform float oscale2;\\nuniform float cshift2;\\nuniform float cscale2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float oshift3;\\nuniform float oscale3;\\nuniform float cshift3;\\nuniform float cscale3;\\n#endif\\n\\nuniform vec4 ipScalarRangeMin;\\nuniform vec4 ipScalarRangeMax;\\n\\n// declaration for intermixed geometry\\n//VTK::ZBuffer::Dec\\n\\n//=======================================================================\\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\\nvec3 rayDirVC;\\nfloat sampleDistanceISVS;\\nfloat sampleDistanceIS;\\n\\n#define SQRT3    1.7321\\n#define INV4PI   0.0796\\n#define EPSILON  0.001\\n#define PI       3.1415\\n#define PI2      9.8696\\n\\n//=======================================================================\\n// Webgl2 specific version of functions\\n#if __VERSION__ == 300\\n\\nuniform highp sampler3D texture1;\\n\\nvec4 getTextureValue(vec3 pos)\\n{\\n  vec4 tmp = texture(texture1, pos);\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.a = tmp.g;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n  return tmp;\\n}\\n\\n//=======================================================================\\n// WebGL1 specific version of functions\\n#else\\n\\nuniform sampler2D texture1;\\n\\nuniform float texWidth;\\nuniform float texHeight;\\nuniform int xreps;\\nuniform int xstride;\\nuniform int ystride;\\n\\n// if computing trilinear values from multiple z slices\\n#ifdef vtkTrilinearOn\\nvec4 getTextureValue(vec3 ijk)\\n{\\n  float zoff = 1.0/float(volumeDimensions.z);\\n  vec4 val1 = getOneTextureValue(ijk);\\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\\n\\n  float indexZ = float(volumeDimensions)*ijk.z;\\n  float zmix =  indexZ - floor(indexZ);\\n\\n  return mix(val1, val2, zmix);\\n}\\n\\nvec4 getOneTextureValue(vec3 ijk)\\n#else // nearest or fast linear\\nvec4 getTextureValue(vec3 ijk)\\n#endif\\n{\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n#ifdef debugtile\\n  vec2 tpos = vec2(ijk.x, ijk.y);\\n  vec4 tmp = texture2D(texture1, tpos);\\n  tmp.a = 1.0;\\n\\n#else\\n  int z = int(ijk.z * tdims.z);\\n  int yz = z / xreps;\\n  int xz = z - yz*xreps;\\n\\n  int tileWidth = volumeDimensions.x/xstride;\\n  int tileHeight = volumeDimensions.y/ystride;\\n\\n  xz *= tileWidth;\\n  yz *= tileHeight;\\n\\n  float ni = float(xz) + (ijk.x*float(tileWidth));\\n  float nj = float(yz) + (ijk.y*float(tileHeight));\\n\\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\\n\\n  vec4 tmp = texture2D(texture1, tpos);\\n\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.g = tmp.a;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n#endif\\n\\n  return tmp;\\n}\\n\\n// End of Webgl1 specific code\\n//=======================================================================\\n#endif\\n\\n//=======================================================================\\n// transformation between VC and IS space\\n\\n// convert vector position from idx to vc\\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\\nvec3 IStoVC(vec3 posIS){\\n  vec3 posVC = posIS / vVCToIJK;\\n  return posVC.x * vPlaneNormal0 +\\n         posVC.y * vPlaneNormal2 +\\n         posVC.z * vPlaneNormal4 +\\n         vOriginVC;\\n}\\n\\n// convert vector position from vc to idx\\nvec3 VCtoIS(vec3 posVC){\\n  posVC = posVC - vOriginVC;\\n  posVC = vec3(\\n    dot(posVC, vPlaneNormal0),\\n    dot(posVC, vPlaneNormal2),\\n    dot(posVC, vPlaneNormal4));\\n  return posVC * vVCToIJK;\\n}\\n#endif\\n\\n//Rotate vector to view coordinate\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\nvoid rotateToViewCoord(inout vec3 dirIS){\\n  dirIS.xyz =\\n    dirIS.x * vPlaneNormal0 +\\n    dirIS.y * vPlaneNormal2 +\\n    dirIS.z * vPlaneNormal4;\\n}\\n\\n//Rotate vector to idx coordinate\\nvec3 rotateToIDX(vec3 dirVC){\\n  vec3 dirIS;\\n  dirIS.xyz = vec3(\\n    dot(dirVC, vPlaneNormal0),\\n    dot(dirVC, vPlaneNormal2),\\n    dot(dirVC, vPlaneNormal4));\\n  return dirIS;\\n}\\n#endif\\n\\n//=======================================================================\\n// Given a normal compute the gradient opacity factors\\nfloat computeGradientOpacityFactor(\\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\\n{\\n#if defined(vtkGradientOpacityOn)\\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\\n#else\\n  return 1.0;\\n#endif\\n}\\n\\n//=======================================================================\\n// compute the normal and gradient magnitude for a position, uses forward difference\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\n#ifdef vtkClippingPlanesOn\\n  void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\\n  {\\n    vec3 g1VC[3];\\n    for (int i = 0; i < 3; ++i)\\n    {\\n      g1VC[i] = IStoVC(texPos[i]);\\n    }\\n    vec3 posVC = IStoVC(pos);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      for (int j = 0; j < 3; ++j)\\n      {\\n        if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\\n        {\\n          g1[j] = 0.0;\\n        }\\n      }\\n    }\\n  }\\n#endif\\n\\n  #ifdef vtkComputeNormalFromOpacity\\n    #ifdef vtkGradientOpacityOn\\n      vec4 computeDensityNormal(float gradientMag, vec3 scalarInterp[2])\\n      {\\n    #else\\n      //if gradient opacity not on but using density gradient\\n      vec4 computeDensityNormal(vec3 scalarInterp[2])\\n      {\\n    #endif\\n        vec3 opacityG1, opacityG2;\\n        opacityG1.x = texture2D(otexture, vec2(scalarInterp[0].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.y = texture2D(otexture, vec2(scalarInterp[0].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.z = texture2D(otexture, vec2(scalarInterp[0].z * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.x = texture2D(otexture, vec2(scalarInterp[1].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.y = texture2D(otexture, vec2(scalarInterp[1].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.z = texture2D(otexture, vec2(scalarInterp[1].z * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n        float gradOpacityFactor = 1.0f;\\n        if (gradientMag >= 0.0){\\n          gradOpacityFactor = computeGradientOpacityFactor(gradientMag, goscale0, goshift0, gomin0, gomax0);\\n        }\\n        opacityG1.xyz *= gradOpacityFactor;\\n        opacityG2.xyz *= gradOpacityFactor;\\n    #endif\\n\\n        vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\\n        // divide by spacing\\n        opacityG.xyz /= vSpacing;\\n        opacityG.w = length(opacityG.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(opacityG.xyz);\\n        if (length(opacityG.xyz) > 0.0) {\\n          return vec4(normalize(opacityG.xyz),opacityG.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n\\n      vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2])\\n      {\\n        vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n        vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n        vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n        vec3 texPosPVec[3];\\n        texPosPVec[0] = pos + xvec;\\n        texPosPVec[1] = pos + yvec;\\n        texPosPVec[2] = pos + zvec;\\n        vec3 texPosNVec[3];\\n        texPosNVec[0] = pos - xvec;\\n        texPosNVec[1] = pos - yvec;\\n        texPosNVec[2] = pos - zvec;\\n        vec3 g1, g2;\\n\\n        scalarInterp[0].x = getTextureValue(texPosPVec[0]).a;\\n        scalarInterp[0].y = getTextureValue(texPosPVec[1]).a;\\n        scalarInterp[0].z = getTextureValue(texPosPVec[2]).a;\\n        scalarInterp[1].x = getTextureValue(texPosNVec[0]).a;\\n        scalarInterp[1].y = getTextureValue(texPosNVec[1]).a;\\n        scalarInterp[1].z = getTextureValue(texPosNVec[2]).a;\\n\\n        #ifdef vtkClippingPlanesOn\\n          adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\\n          adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\\n        #endif\\n        vec4 result;\\n        result.x = scalarInterp[0].x - scalarInterp[1].x;\\n        result.y = scalarInterp[0].y - scalarInterp[1].y;\\n        result.z = scalarInterp[0].z - scalarInterp[1].z;\\n        // divide by spacing\\n        result.xyz /= vSpacing;\\n        result.w = length(result.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(result.xyz);\\n        if (length(result.xyz) > 0.0) {\\n          return vec4(normalize(result.xyz),result.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n  #endif\\n\\n  vec4 computeNormal(vec3 pos, vec3 tstep)\\n  {\\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n    vec3 texPosPVec[3];\\n    texPosPVec[0] = pos + xvec;\\n    texPosPVec[1] = pos + yvec;\\n    texPosPVec[2] = pos + zvec;\\n    vec3 texPosNVec[3];\\n    texPosNVec[0] = pos - xvec;\\n    texPosNVec[1] = pos - yvec;\\n    texPosNVec[2] = pos - zvec;\\n    vec3 g1, g2;\\n    g1.x = getTextureValue(texPosPVec[0]).a;\\n    g1.y = getTextureValue(texPosPVec[1]).a;\\n    g1.z = getTextureValue(texPosPVec[2]).a;\\n    g2.x = getTextureValue(texPosNVec[0]).a;\\n    g2.y = getTextureValue(texPosNVec[1]).a;\\n    g2.z = getTextureValue(texPosNVec[2]).a;\\n    #ifdef vtkClippingPlanesOn\\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\\n    #endif\\n    vec4 result;\\n    result = vec4(g1 - g2, -1.0);\\n    // divide by spacing\\n    result.xyz /= vSpacing;\\n    result.w = length(result.xyz);\\n    if (result.w > 0.0){\\n      // rotate to View Coords\\n      rotateToViewCoord(result.xyz);\\n      return vec4(normalize(result.xyz),result.w);\\n    } else {\\n      return vec4(0.0);\\n    }\\n  }\\n#endif\\n\\n#ifdef vtkImageLabelOutlineOn\\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\\n  vec4 pcPos = vec4(\\n    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\\n    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\\n    (fragCoord.z - 0.5) * 2.0,\\n    1.0);\\n\\n  vec4 worldCoord = PCWCMatrix * pcPos;\\n  vec4 vertex = (worldCoord/worldCoord.w);\\n\\n  vec3 index = (vWCtoIDX * vertex).xyz;\\n\\n  // half voxel fix for labelmapOutline\\n  return (index + vec3(0.5)) / vec3(volumeDimensions);\\n}\\n#endif\\n\\n//=======================================================================\\n// compute the normals and gradient magnitudes for a position\\n// for independent components\\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\\n{\\n  mat4 result;\\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\\n\\n  // divide by spacing\\n  distX /= vSpacing.x;\\n  distY /= vSpacing.y;\\n  distZ /= vSpacing.z;\\n\\n  mat3 rot;\\n  rot[0] = vPlaneNormal0;\\n  rot[1] = vPlaneNormal2;\\n  rot[2] = vPlaneNormal4;\\n\\n#if !defined(vtkComponent0Proportional)\\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\\n  result[0].a = length(result[0].xyz);\\n  result[0].xyz *= rot;\\n  if (result[0].w > 0.0)\\n  {\\n    result[0].xyz /= result[0].w;\\n  }\\n#endif\\n\\n// optionally compute the 2nd component\\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\\n  result[1].a = length(result[1].xyz);\\n  result[1].xyz *= rot;\\n  if (result[1].w > 0.0)\\n  {\\n    result[1].xyz /= result[1].w;\\n  }\\n#endif\\n\\n// optionally compute the 3rd component\\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\\n  result[2].a = length(result[2].xyz);\\n  result[2].xyz *= rot;\\n  if (result[2].w > 0.0)\\n  {\\n    result[2].xyz /= result[2].w;\\n  }\\n#endif\\n\\n// optionally compute the 4th component\\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\\n  result[3].a = length(result[3].xyz);\\n  result[3].xyz *= rot;\\n  if (result[3].w > 0.0)\\n  {\\n    result[3].xyz /= result[3].w;\\n  }\\n#endif\\n\\n  return result;\\n}\\n\\n//=======================================================================\\n// global shadow - secondary ray\\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\\nfloat random()\\n{\\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\\n  uint pcg_state = floatBitsToUint(jitter);\\n  uint state = pcg_state;\\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\\n}\\n#endif\\n\\n#ifdef VolumeShadowOn\\n// henyey greenstein phase function\\nfloat phase_function(float cos_angle)\\n{\\n  // divide by 2.0 instead of 4pi to increase intensity\\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\\n}\\n\\n// Computes the intersection between a ray and a box\\nstruct Hit\\n{\\n  float tmin;\\n  float tmax;\\n};\\n\\nstruct Ray\\n{\\n  vec3 origin;\\n  vec3 dir;\\n  vec3 invDir;\\n};\\n\\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\\n{\\n  vec3 tbot = r.invDir * (boundMin - r.origin);\\n  vec3 ttop = r.invDir * (boundMax - r.origin);\\n  vec3 tmin = min(ttop, tbot);\\n  vec3 tmax = max(ttop, tbot);\\n  vec2 t = max(tmin.xx, tmin.yz);\\n  float t0 = max(t.x, t.y);\\n  t = min(tmax.xx, tmax.yz);\\n  float t1 = min(t.x, t.y);\\n  hit.tmin = t0;\\n  hit.tmax = t1;\\n  return t1 > max(t0,0.0);\\n}\\n\\n// As BBoxIntersect requires the inverse of the ray coords,\\n// this function is used to avoid numerical issues\\nvoid safe_0_vector(inout Ray ray)\\n{\\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\\n}\\n\\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\\n{\\n  float shadow = 1.0;\\n  float opacity = 0.0;\\n\\n  // modify sample distance with a random number between 1.5 and 3.0\\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\\n\\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\\n\\n  // compute the start and end points for the ray\\n  Ray ray;\\n  Hit hit;\\n  ray.origin = posIS;\\n  ray.dir = lightDirNormIS;\\n  safe_0_vector(ray);\\n  ray.invDir = 1.0/ray.dir;\\n\\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\\n  {\\n    return 1.0;\\n  }\\n  float maxdist = hit.tmax;\\n\\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\\n  maxdist = min(maxdist,maxgi);\\n  if(maxdist < EPSILON) {\\n    return 1.0;\\n  }\\n\\n  // support gradient opacity\\n  #ifdef vtkGradientOpacityOn\\n    vec4 normal;\\n  #endif\\n\\n  float current_dist = 0.0;\\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\\n  float clamped_step = 0.0;\\n\\n  vec4 scalar = vec4(0.0);\\n  while(current_dist < maxdist)\\n  {\\n#ifdef vtkClippingPlanesOn\\n    vec3 posVC = IStoVC(posIS);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\\n      {\\n        current_dist = maxdist;\\n      }\\n    }\\n#endif\\n    scalar = getTextureValue(posIS);\\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n      normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    shadow *= 1.0 - opacity;\\n\\n    // optimization: early termination\\n    if (shadow < EPSILON){\\n      return 0.0;\\n    }\\n\\n    clamped_step = min(maxdist - current_dist, current_step);\\n    posIS += clamped_step * lightDirNormIS;\\n    current_dist += current_step;\\n  }\\n\\n  return shadow;\\n}\\n\\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\\n{\\n  vec3 vertLight = vec3(0.0);\\n  vec3 secondary_contrib = vec3(0.0);\\n  // here we assume only positional light, no effect of cones\\n  for (int i = 0; i < lightNum; i++)\\n  {\\n    #if(vtkLightComplexity==3)\\n      if (lightPositional[i] == 1){\\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\\n      }else{\\n        vertLight = - lightDirectionVC[i];\\n      }\\n    #else\\n      vertLight = - lightDirectionVC[i];\\n    #endif\\n    // here we assume achromatic light, only intensity\\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\\n    float phase_attenuation = 0.5;\\n    if (abs(anisotropy) > EPSILON){\\n      phase_attenuation = phase_function(dDotL);\\n    }\\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\\n    secondary_contrib += tColor * vAmbient;\\n  }\\n  return secondary_contrib;\\n}\\n#endif\\n\\n//=======================================================================\\n// local ambient occlusion\\n#ifdef localAmbientOcclusionOn\\nvec3 sample_direction_uniform(int i)\\n{\\n  float rand = random() * 0.5;\\n  float theta = PI2 * (kernelSample[i][0] + rand);\\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\\n}\\n\\n// return a matrix that transform startDir into z axis; startDir should be normalized\\nmat3 zBaseRotationalMatrix(vec3 startDir){\\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\\n  float cosA = startDir.z;\\n  float k = 1.0 / (1.0 + cosA);\\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\\n  return matrix;\\n}\\n\\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\\n  // apply LAO only at selected locations, otherwise return full brightness\\n  if (normal.w > 0.0 && op > 0.05){\\n    float total_transmittance = 0.0;\\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\\n    vec3 currPos, randomDirStep;\\n    float weight, transmittance, opacity;\\n    for (int i = 0; i < kernelSize; i++)\\n    {\\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\\n      currPos = posIS;\\n      transmittance = 1.0;\\n      for (int j = 0; j < kernelRadius ; j++){\\n        currPos += randomDirStep;\\n        // check if it's at clipping plane, if so return full brightness\\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\\n          #ifdef vtkGradientOpacityOn\\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n          #endif\\n          transmittance *= 1.0 - opacity;\\n        }\\n        else{\\n          break;\\n        }\\n      }\\n      total_transmittance += transmittance / float(kernelRadius) * weight;\\n\\n      // early termination if fully translucent\\n      if (total_transmittance > 1.0 - EPSILON){\\n        return 1.0;\\n      }\\n    }\\n    // average transmittance and reduce variance\\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\\n  } else {\\n    return 1.0;\\n  }\\n}\\n#endif\\n\\n//=======================================================================\\n// surface light contribution\\n#if vtkLightComplexity > 0\\n  void applyLighting(inout vec3 tColor, vec4 normal)\\n  {\\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\\n    vec3 specular = vec3(0.0, 0.0, 0.0);\\n    float df, sf = 0.0;\\n    for (int i = 0; i < lightNum; i++){\\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\\n        diffuse += df * lightColor[i];\\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\\n        specular += sf * lightColor[i];\\n    }\\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\\n  }\\n  #ifdef SurfaceShadowOn\\n  #if vtkLightComplexity < 3\\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float ndotL,vdotR;\\n        vertLightDirection = lightDirectionVC[i];\\n        ndotL = dot(normal.xyz, vertLightDirection);\\n        if (ndotL < 0.0 && twoSidedLighting)\\n        {\\n          ndotL = -ndotL;\\n        }\\n        if (ndotL > 0.0)\\n        {\\n          diffuse += ndotL * lightColor[i];\\n          //specular\\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n          if (vdotR > 0.0)\\n          {\\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n          }\\n        }\\n        #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n        #endif\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #else\\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float distance,attenuation,ndotL,vdotR;\\n        vec3 lightDir;\\n        if (lightPositional[i] == 1){\\n          lightDir = lightDirectionVC[i];\\n          vertLightDirection = posVC - lightPositionVC[i];\\n          distance = length(vertLightDirection);\\n          vertLightDirection = normalize(vertLightDirection);\\n          attenuation = 1.0 / (lightAttenuation[i].x\\n                              + lightAttenuation[i].y * distance\\n                              + lightAttenuation[i].z * distance * distance);\\n          // per OpenGL standard cone angle is 90 or less for a spot light\\n          if (lightConeAngle[i] <= 90.0){\\n            float coneDot = dot(vertLightDirection, lightDir);\\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\\n            }\\n            else {\\n              attenuation = 0.0;\\n            }\\n          }\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * attenuation * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        } else {\\n          vertLightDirection = lightDirectionVC[i];\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        }\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #endif\\n  #endif\\n#endif\\n\\n//=======================================================================\\n// Given a texture value compute the color and opacity\\n//\\nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\\n{\\n#ifdef vtkImageLabelOutlineOn\\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\\n  vec4 centerValue = getTextureValue(centerPosIS);\\n  bool pixelOnBorder = false;\\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\\n\\n  // Get alpha of segment from opacity function.\\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n  int segmentIndex = int(centerValue.r * 255.0);\\n  \\n  // Use texture sampling for outlineThickness\\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\\n\\n  int actualThickness = int(textureValue * 255.0);\\n\\n  if (actualThickness == 0) {\\n    return vec4(0, 0, 1, 1);\\n  }\\n\\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\\n  // Saves a bunch of needless checks on the background.\\n  // TODO define epsilon when building shader?\\n  if (float(tColor.a) > 0.01) {\\n    for (int i = -actualThickness; i <= actualThickness; i++) {\\n      for (int j = -actualThickness; j <= actualThickness; j++) {\\n        if (i == 0 || j == 0) {\\n          continue;\\n        }\\n\\n        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n          gl_FragCoord.y + float(j),\\n          gl_FragCoord.z, gl_FragCoord.w);\\n\\n        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n        vec4 value = getTextureValue(neighborPosIS);\\n\\n        // If any of my neighbours are not the same value as I\\n        // am, this means I am on the border of the segment.\\n        // We can break the loops\\n        if (any(notEqual(value, centerValue))) {\\n          pixelOnBorder = true;\\n          break;\\n        }\\n      }\\n\\n      if (pixelOnBorder == true) {\\n        break;\\n      }\\n    }\\n\\n    // If I am on the border, I am displayed at full opacity\\n    if (pixelOnBorder == true) {\\n      tColor.a = outlineOpacity;\\n    }\\n  }\\n\\n#else\\n  // compute the normal and gradient magnitude if needed\\n  // We compute it as a vec4 if possible otherwise a mat4\\n  //\\n  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);\\n\\n  // compute the normal vectors as needed\\n  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\\n      #if !defined(vtkComponent0Proportional)\\n        vec4 normal0 = normalMat[0];\\n      #endif\\n      #if !defined(vtkComponent1Proportional)\\n        vec4 normal1 = normalMat[1];\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          vec4 normal2 = normalMat[2];\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            vec4 normal3 = normalMat[3];\\n          #endif\\n        #endif\\n      #endif\\n    #else\\n      vec4 normalLight;\\n      #ifdef vtkComputeNormalFromOpacity\\n        vec3 scalarInterp[2];\\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp);\\n        if (length(normal0)>0.0){\\n          #ifdef vtkGradientOpacityOn\\n            normalLight = computeDensityNormal(normal0.w, scalarInterp);\\n          #else\\n            normalLight = computeDensityNormal(scalarInterp);\\n          #endif\\n          if (length(normalLight) == 0.0){\\n            normalLight = normal0;\\n          }\\n        }\\n      #else\\n        vec4 normal0 = computeNormal(posIS, tstep);\\n        normalLight = normal0;\\n      #endif\\n    #endif\\n  #endif\\n\\n  // compute gradient opacity factors as needed\\n  #if defined(vtkGradientOpacityOn)\\n    #if !defined(vtkComponent0Proportional)\\n      goFactor.x =\\n        computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      #if !defined(vtkComponent1Proportional)\\n        goFactor.y =\\n          computeGradientOpacityFactor(normal1.a, goscale1, goshift1, gomin1, gomax1);\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          goFactor.z =\\n            computeGradientOpacityFactor(normal2.a, goscale2, goshift2, gomin2, gomax2);\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            goFactor.w =\\n              computeGradientOpacityFactor(normal3.a, goscale3, goshift3, gomin3, gomax3);\\n          #endif\\n        #endif\\n      #endif\\n    #endif\\n  #endif\\n\\n  // single component is always independent\\n  #if vtkNumComponents == 1\\n    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n    if (tColor.a < EPSILON){\\n      return vec4(0.0);\\n    }\\n  #endif\\n\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));\\n    #if !defined(vtkComponent0Proportional)\\n      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n      tColor *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));\\n    #endif\\n\\n    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\\n    #if !defined(vtkComponent1Proportional)\\n      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n      tColor1 *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));\\n    #endif\\n\\n    #if vtkNumComponents >= 3\\n      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\\n      #if !defined(vtkComponent2Proportional)\\n        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n      #else\\n        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n        tColor2 *= pwfValue;\\n        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));\\n      #endif\\n\\n      #if vtkNumComponents >= 4\\n        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\\n        #if !defined(vtkComponent3Proportional)\\n          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n        #else\\n          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n          tColor3 *= pwfValue;\\n          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));\\n        #endif\\n      #endif\\n    #endif\\n  #else // then not independent\\n\\n  #if vtkNumComponents == 2\\n    float lum = tValue.r * cscale0 + cshift0;\\n    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\\n    vec4 tColor = vec4(lum, lum, lum, alpha);\\n  #endif\\n  #if vtkNumComponents == 3\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\\n  #endif\\n  #if vtkNumComponents == 4\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\\n  #endif\\n  #endif // dependent\\n\\n  // apply lighting if requested as appropriate\\n  #if vtkLightComplexity > 0\\n    #if !defined(vtkComponent0Proportional)\\n      #if vtkNumComponents == 1\\n        #ifdef SurfaceShadowOn\\n            #if vtkLightComplexity < 3\\n                vec3 tColorS = applyLightingDirectional(posIS, tColor, normalLight);\\n            #else\\n                vec3 tColorS = applyLightingPositional(posIS, tColor, normalLight, IStoVC(posIS));\\n            #endif\\n        #endif\\n\\n        #ifdef VolumeShadowOn\\n          vec3 tColorVS = applyShadowRay(tColor.rgb, posIS, rayDirVC);\\n          #ifdef SurfaceShadowOn\\n            float vol_coef = volumetricScatteringBlending * (1.0 - tColor.a / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\\n            tColor.rgb = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\\n          #else\\n            tColor.rgb = tColorVS;\\n          #endif\\n        #else\\n            tColor.rgb = tColorS;\\n        #endif\\n\\n      #else\\n        applyLighting(tColor.rgb, normal0);\\n      #endif\\n    #endif\\n\\n    #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n      #if !defined(vtkComponent1Proportional)\\n        applyLighting(tColor1, normal1);\\n      #endif\\n    #if vtkNumComponents >= 3\\n      #if !defined(vtkComponent2Proportional)\\n        applyLighting(tColor2, normal2);\\n      #endif\\n    #if vtkNumComponents >= 4\\n      #if !defined(vtkComponent3Proportional)\\n        applyLighting(tColor3, normal3);\\n      #endif\\n    #endif\\n    #endif\\n    #endif\\n  #endif\\n\\n// perform final independent blend as needed\\n#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n  tColor.rgb += tColor1;\\n#if vtkNumComponents >= 3\\n  tColor.rgb += tColor2;\\n#if vtkNumComponents >= 4\\n  tColor.rgb += tColor3;\\n#endif\\n#endif\\n#endif\\n\\n#endif\\nreturn tColor;\\n}\\n\\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\\n  bool withinRange = false;\\n  #if vtkNumComponents == 1\\n    if (val.r >= min.r && val.r <= max.r) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2\\n     if (val.r >= min.r && val.r <= max.r &&\\n        val.g >= min.g && val.g <= max.g) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3\\n    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\\n        all(lessThanEqual(val, ipScalarRangeMax))) {\\n      withinRange = true;\\n    }\\n  #endif\\n  return withinRange;\\n}\\n\\n//=======================================================================\\n// Apply the specified blend mode operation along the ray's path.\\n//\\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\\n{\\n  vec3 tstep = 1.0/tdims;\\n\\n  // start slightly inside and apply some jitter\\n  vec3 delta = endIS - posIS;\\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\\n  float raySteps = length(delta)/sampleDistanceIS;\\n\\n  // avoid 0.0 jitter\\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\\n  float stepsTraveled = jitter;\\n\\n  // local vars for the loop\\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\\n  vec4 tValue;\\n  vec4 tColor;\\n\\n  // if we have less than one step then pick the middle point\\n  // as our value\\n  // if (raySteps <= 1.0)\\n  // {\\n  //   posIS = (posIS + endIS)*0.5;\\n  // }\\n\\n  // Perform initial step at the volume boundary\\n  // compute the scalar\\n  tValue = getTextureValue(posIS);\\n\\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\\n    // now map through opacity and color\\n    tColor = getColorForValue(tValue, posIS, tstep);\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\\n      gl_FragData[0] = tColor;\\n      return;\\n    }\\n\\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n\\n      float mix = (1.0 - color.a);\\n\\n      // this line should not be needed but nvidia seems to not handle\\n      // the break correctly on windows/chrome 58 angle\\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\\n\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n      stepsTraveled++;\\n      posIS += stepIS;\\n      if (color.a > 0.99) { color.a = 1.0; break; }\\n    }\\n\\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\\n    {\\n      posIS = endIS;\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\\n\\n      float mix = (1.0 - color.a);\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n    }\\n\\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\\n  #endif\\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\\n    // Find maximum/minimum intensity along the ray.\\n\\n    // Define the operation we will use (min or max)\\n    #if vtkBlendMode == 1\\n    #define OP max\\n    #else\\n    #define OP min\\n    #endif\\n\\n    // If the clipping range is shorter than the sample distance\\n    // we can skip the sampling loop along the ray.\\n    if (raySteps <= 1.0)\\n    {\\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\\n      return;\\n    }\\n\\n    vec4 value = tValue;\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // Update the maximum value if necessary\\n      value = OP(tValue, value);\\n\\n      // Otherwise, continue along the ray\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n    tValue = getTextureValue(posIS);\\n    value = OP(tValue, value);\\n\\n    // Now map through opacity and color\\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\\n    vec4 sum = vec4(0.);\\n\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n    }\\n\\n    if (raySteps <= 1.0) {\\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\\n      // Notes:\\n      // - We are comparing all values in the texture to see if any of them\\n      //   are outside of the scalar range. In the future we might want to allow\\n      //   scalar ranges for each component.\\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n        // Sum the values across each step in the path\\n        sum += tValue;\\n      }\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n\\n    // compute the scalar\\n    tValue = getTextureValue(posIS);\\n\\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n\\n      stepsTraveled++;\\n    }\\n\\n    #if vtkBlendMode == 3 // Average\\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\\n    #endif\\n\\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 5 // RADON\\n    float normalizedRayIntensity = 1.0;\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tValue = getTextureValue(posIS);\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar value\\n      tValue = getTextureValue(posIS);\\n\\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n      posIS += stepIS;\\n      stepsTraveled++;\\n    }\\n\\n    // map normalizedRayIntensity to color\\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\\n\\n  #endif\\n}\\n\\n//=======================================================================\\n// Compute a new start and end point for a given ray based\\n// on the provided bounded clipping plane (aka a rectangle)\\nvoid getRayPointIntersectionBounds(\\n  vec3 rayPos, vec3 rayDir,\\n  vec3 planeDir, float planeDist,\\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\\n  float vSize1, float vSize2)\\n{\\n  float result = dot(rayDir, planeDir);\\n  if (abs(result) < 1e-6)\\n  {\\n    return;\\n  }\\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\\n  vec3 xposVC = rayPos + rayDir*result;\\n  vec3 vxpos = xposVC - vOriginVC;\\n  vec2 vpos = vec2(\\n    dot(vxpos, vPlaneX),\\n    dot(vxpos, vPlaneY));\\n\\n  // on some apple nvidia systems this does not work\\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\\n  //     vpos.y < 0.0 || vpos.y > vSize2)\\n  // even just\\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\\n  // fails\\n  // so instead we compute a value that represents in and out\\n  //and then compute the return using this value\\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\\n\\n  tbounds = mix(\\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\\n   tbounds, // out value\\n   check);  // 0 in 1 out\\n}\\n\\n//=======================================================================\\n// given a\\n// - ray direction (rayDir)\\n// - starting point (vertexVCVSOutput)\\n// - bounding planes of the volume\\n// - optionally depth buffer values\\n// - far clipping plane\\n// compute the start/end distances of the ray we need to cast\\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\\n{\\n  vec2 dists = vec2(100.0*camFar, -1.0);\\n\\n  vec3 vSize = vSpacing*tdims;\\n\\n  // all this is in View Coordinates\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n\\n  //VTK::ClipPlane::Impl\\n\\n  // do not go behind front clipping plane\\n  dists.x = max(0.0,dists.x);\\n\\n  // do not go PAST far clipping plane\\n  float farDist = -camThick/rayDir.z;\\n  dists.y = min(farDist,dists.y);\\n\\n  // Do not go past the zbuffer value if set\\n  // This is used for intermixing opaque geometry\\n  //VTK::ZBuffer::Impl\\n\\n  return dists;\\n}\\n\\n//=======================================================================\\n// Compute the index space starting position (pos) and end\\n// position\\n//\\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\\n{\\n  // compute starting and ending values in volume space\\n  pos = vertexVCVSOutput + dists.x*rayDir;\\n  pos = pos - vOriginVC;\\n  // convert to volume basis and origin\\n  pos = vec3(\\n    dot(pos, vPlaneNormal0),\\n    dot(pos, vPlaneNormal2),\\n    dot(pos, vPlaneNormal4));\\n\\n  endPos = vertexVCVSOutput + dists.y*rayDir;\\n  endPos = endPos - vOriginVC;\\n  endPos = vec3(\\n    dot(endPos, vPlaneNormal0),\\n    dot(endPos, vPlaneNormal2),\\n    dot(endPos, vPlaneNormal4));\\n\\n  float delta = length(endPos - pos);\\n\\n  pos *= vVCToIJK;\\n  endPos *= vVCToIJK;\\n\\n  float delta2 = length(endPos - pos);\\n  sampleDistanceIS = sampleDistance*delta2/delta;\\n  #ifdef VolumeShadowOn\\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\\n  #endif\\n}\\n\\nvoid main()\\n{\\n\\n  if (cameraParallel == 1)\\n  {\\n    // Camera is parallel, so the rayDir is just the direction of the camera.\\n    rayDirVC = vec3(0.0, 0.0, -1.0);\\n  } else {\\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\\n    rayDirVC = normalize(vertexVCVSOutput);\\n  }\\n\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n  // compute the start and end points for the ray\\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\\n\\n  // do we need to composite? aka does the ray have any length\\n  // If not, bail out early\\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\\n  {\\n    discard;\\n  }\\n\\n  // IS = Index Space\\n  vec3 posIS;\\n  vec3 endIS;\\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\\n\\n  // Perform the blending operation along the ray\\n  applyBlend(posIS, endIS, tdims);\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Fragment;o.getProperty().getInterpolationType()===wg.LINEAR&&(a=cd.substitute(a,&quot;//VTK::TrilinearOn&quot;,&quot;#define vtkTrilinearOn&quot;).result),!0===o.getProperty().getUseLabelOutline()&&(a=cd.substitute(a,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result);const i=t.scalarTexture.getComponents();a=cd.substitute(a,&quot;//VTK::NumComponents&quot;,`#define vtkNumComponents ${i}`).result;const s=o.getProperty().getIndependentComponents();if(s){a=cd.substitute(a,&quot;//VTK::IndependentComponentsOn&quot;,&quot;#define vtkIndependentComponentsOn&quot;).result;const e=[];for(let t=0;t<i;t++)o.getProperty().getOpacityMode(t)===Pg.PROPORTIONAL&&e.push(`#define vtkComponent${t}Proportional`);e.length>0&&(a=cd.substitute(a,&quot;//VTK::vtkProportionalComponents&quot;,e.join(&quot;\\n&quot;)).result)}const l=t.currentInput.getSpatialExtent(),c=t.currentInput.getSpacing(),u=new Float64Array(3);In(u,(l[1]-l[0])*c[0],(l[3]-l[2])*c[1],(l[5]-l[4])*c[2]);const d=Sn(u)/e.getCurrentSampleDistance(r);a=cd.substitute(a,&quot;//VTK::MaximumSamplesValue&quot;,`${Math.ceil(d)}`).result,a=cd.substitute(a,&quot;//VTK::LightComplexity&quot;,`#define vtkLightComplexity ${t.lastLightComplexity}`).result,t.lastLightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(a=cd.substitute(a,&quot;//VTK::VolumeShadowOn&quot;,&quot;#define VolumeShadowOn&quot;).result),t.renderable.getVolumetricScatteringBlending()<1&&(a=cd.substitute(a,&quot;//VTK::SurfaceShadowOn&quot;,&quot;#define SurfaceShadowOn&quot;).result),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0&&(a=cd.substitute(a,&quot;//VTK::localAmbientOcclusionOn&quot;,&quot;#define localAmbientOcclusionOn&quot;).result)),t.gopacity=o.getProperty().getUseGradientOpacity(0);for(let e=1;s&&!t.gopacity&&e<i;++e)o.getProperty().getUseGradientOpacity(e)&&(t.gopacity=!0);t.gopacity&&(a=cd.substitute(a,&quot;//VTK::GradientOpacityOn&quot;,&quot;#define vtkGradientOpacityOn&quot;).result),t.renderable.getComputeNormalFromOpacity()&&(a=cd.substitute(a,&quot;//VTK::vtkComputeNormalFromOpacity&quot;,&quot;#define vtkComputeNormalFromOpacity&quot;).result),null!==t.zBufferTexture&&(a=cd.substitute(a,&quot;//VTK::ZBuffer::Dec&quot;,[&quot;uniform sampler2D zBufferTexture;&quot;,&quot;uniform float vpZWidth;&quot;,&quot;uniform float vpZHeight;&quot;]).result,a=cd.substitute(a,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));&quot;,&quot;float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;&quot;,&quot;zdepth = zdepth * 2.0 - 1.0;&quot;,&quot;if (cameraParallel == 0) {&quot;,&quot;zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}&quot;,&quot;else {&quot;,&quot;zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\\n&quot;,&quot;zdepth = -zdepth/rayDir.z;&quot;,&quot;dists.y = min(zdepth,dists.y);&quot;]).result),a=cd.substitute(a,&quot;//VTK::BlendMode&quot;,`${t.renderable.getBlendMode()}`).result,n.Fragment=a,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lastLightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[&quot;uniform int lightNum;&quot;,&quot;uniform bool twoSidedLighting;&quot;,`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,&quot;//VTK::Light::Dec&quot;],!1).result,3===t.lastLightComplexity&&(o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=cd.substitute(o,&quot;//VTK::VolumeShadow::Dec&quot;,[&quot;uniform float volumetricScatteringBlending;&quot;,&quot;uniform float giReach;&quot;,&quot;uniform float volumeShadowSamplingDistFactor;&quot;,&quot;uniform float anisotropy;&quot;,&quot;uniform float anisotropy2;&quot;],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=cd.substitute(o,&quot;//VTK::LAO::Dec&quot;,[&quot;uniform int kernelRadius;&quot;,`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,&quot;uniform int kernelSize;&quot;],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=cd.substitute(o,&quot;//VTK::ClipPlane::Dec&quot;,[&quot;uniform vec3 vClipPlaneNormals[6];&quot;,&quot;uniform float vClipPlaneDistances[6];&quot;,&quot;uniform vec3 vClipPlaneOrigins[6];&quot;,&quot;uniform int clip_numPlanes;&quot;,&quot;//VTK::ClipPlane::Dec&quot;,&quot;#define vtkClippingPlanesOn&quot;],!1).result,o=cd.substitute(o,&quot;//VTK::ClipPlane::Impl&quot;,[`for(int i = 0; i < ${e}; i++) {`,&quot;  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);&quot;,&quot;  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];&quot;,&quot;  if (rayDirRatio == 0.0)&quot;,&quot;  {&quot;,&quot;    if (equationResult < 0.0) dists.x = dists.y;&quot;,&quot;    continue;&quot;,&quot;  }&quot;,&quot;  float result = -1.0 * equationResult / rayDirRatio;&quot;,&quot;  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);&quot;,&quot;  else dists.x = max(dists.x, result);&quot;,&quot;}&quot;,&quot;//VTK::ClipPlane::Impl&quot;],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{let a=0;o.getProperty().getShade()&&t.renderable.getBlendMode()===Rg.COMPOSITE_BLEND&&(a=0,t.numberOfLights=0,r.getLights().forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===a&&(a=1)),1===a&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(a=2),a<3&&e.getPositional()&&(a=3)})));let i=!1;t.lastLightComplexity!==a&&(t.lastLightComplexity=a,i=!0);const s=t.scalarTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=!1;const u=[];if(l){for(let e=0;e<s;e++)u.push(o.getProperty().getOpacityMode(e));u.length>0&&(c=!0)}const d=t.currentInput.getSpatialExtent(),p=t.currentInput.getSpacing(),f=new Float64Array(3);In(f,(d[1]-d[0])*p[0],(d[3]-d[2])*p[1],(d[5]-d[4])*p[2]);const g=Sn(f)/e.getCurrentSampleDistance(r),m={interpolationType:o.getProperty().getInterpolationType(),useLabelOutline:o.getProperty().getUseLabelOutline(),numComp:s,usesProportionalComponents:c,iComps:l,maxSamples:g,useGradientOpacity:o.getProperty().getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),proportionalComponents:u};return t.previousState&&t.previousState.interpolationType===m.interpolationType&&t.previousState.useLabelOutline===m.useLabelOutline&&t.previousState.numComp===m.numComp&&t.previousState.usesProportionalComponents===m.usesProportionalComponents&&t.previousState.iComps===m.iComps&&t.previousState.maxSamples===m.maxSamples&&t.previousState.useGradientOpacity===m.useGradientOpacity&&t.previousState.blendMode===m.blendMode&&function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(t.previousState.proportionalComponents,m.proportionalComponents)?!!(0===n.getProgram()?.getHandle()||i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||!!t.lastZBufferTexture!=!!t.zBufferTexture||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime())&&(t.lastZBufferTexture=t.zBufferTexture,!0):(t.previousState={...m},!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed(&quot;vertexDC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexDC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified()),a.setUniformi(&quot;texture1&quot;,t.scalarTexture.getTextureUnit()),a.setUniformf(&quot;sampleDistance&quot;,e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange(),l=[],c=[];for(let e=0;e<4;e++)l[e]=s[0]*i.dataComputedScale[e]+i.dataComputedOffset[e],c[e]=s[1]*i.dataComputedScale[e]+i.dataComputedOffset[e],l[e]=(l[e]-i.offset[e])/i.scale[e],c[e]=(c[e]-i.offset[e])/i.scale[e];if(a.setUniform4f(&quot;ipScalarRangeMin&quot;,l[0],l[1],l[2],l[3]),a.setUniform4f(&quot;ipScalarRangeMax&quot;,c[0],c[1],c[2],c[3]),null!==t.zBufferTexture){a.setUniformi(&quot;zBufferTexture&quot;,t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf(&quot;vpZWidth&quot;,e[0]),a.setUniformf(&quot;vpZHeight&quot;,e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf(&quot;camThick&quot;,c[1]-c[0]),s.setUniformf(&quot;camNear&quot;,c[0]),s.setUniformf(&quot;camFar&quot;,c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf(&quot;dcxmin&quot;,g),s.setUniformf(&quot;dcxmax&quot;,m),s.setUniformf(&quot;dcymin&quot;,v),s.setUniformf(&quot;dcymax&quot;,y),s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f(&quot;vSpacing&quot;,x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f(&quot;vOriginVC&quot;,p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Dg(`The number of steps required ${Math.ceil(A)} is larger than the\\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\\n        Please either change the\\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f(&quot;vVCToIJK&quot;,I[0],I[1],I[2]),s.setUniform3i(&quot;volumeDimensions&quot;,d[0],d[1],d[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf(&quot;texWidth&quot;,t.scalarTexture.getWidth()),s.setUniformf(&quot;texHeight&quot;,t.scalarTexture.getHeight()),s.setUniformi(&quot;xreps&quot;,e.xreps),s.setUniformi(&quot;xstride&quot;,e.xstride),s.setUniformi(&quot;ystride&quot;,e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*Dn(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(o.getProperty().getUseLabelOutline()){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf(&quot;vpWidth&quot;,u[0]),s.setUniformf(&quot;vpHeight&quot;,u[1]);const d=e.getRenderTargetOffset();s.setUniformf(&quot;vpOffsetX&quot;,d[0]/u[0]),s.setUniformf(&quot;vpOffsetY&quot;,d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix(&quot;PCVCMatrix&quot;,t.projectionToView),0===t.lastLightComplexity)return;let O=0;const R=[],M=[],D=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],D[0+3*O]=-.5*w[0],D[1+3*O]=-.5*w[1],D[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi(&quot;twoSidedLighting&quot;,r.getTwoSidedLighting()),s.setUniformi(&quot;lightNum&quot;,O),s.setUniform3fv(&quot;lightColor&quot;,R),s.setUniform3fv(&quot;lightDirectionVC&quot;,M),s.setUniform3fv(&quot;lightHalfAngleVC&quot;,D),3===t.lastLightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv(&quot;lightPositionVC&quot;,e),s.setUniform3fv(&quot;lightAttenuation&quot;,n),s.setUniformfv(&quot;lightConeAngle&quot;,o),s.setUniformfv(&quot;lightExponent&quot;,a),s.setUniformiv(&quot;lightPositional&quot;,i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf(&quot;giReach&quot;,t.renderable.getGlobalIlluminationReach()),s.setUniformf(&quot;volumetricScatteringBlending&quot;,t.renderable.getVolumetricScatteringBlending()),s.setUniformf(&quot;volumeShadowSamplingDistFactor&quot;,t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf(&quot;anisotropy&quot;,t.renderable.getAnisotropy()),s.setUniformf(&quot;anisotropy2&quot;,t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi(&quot;kernelSize&quot;,e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv(&quot;kernelSample&quot;,n),s.setUniformi(&quot;kernelRadius&quot;,t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi(&quot;ctexture&quot;,t.colorTexture.getTextureUnit()),o.setUniformi(&quot;otexture&quot;,t.opacityTexture.getTextureUnit()),o.setUniformi(&quot;jtexture&quot;,t.jitterTexture.getTextureUnit()),o.setUniformi(&quot;ttexture&quot;,t.labelOutlineThicknessTexture.getTextureUnit());const a=t.scalarTexture.getVolumeInfo(),i=r.getProperty(),s=t.scalarTexture.getComponents(),l=r.getProperty().getIndependentComponents();if(l&&s>=2)for(let e=0;e<s;e++)o.setUniformf(`mix${e}`,r.getProperty().getComponentWeight(e));for(let e=0;e<s;e++){const t=l?e:0,n=a.scale[e],r=i.getScalarOpacity(t).getRange(),s=n/(r[1]-r[0]),c=(a.offset[e]-r[0])/(r[1]-r[0]);o.setUniformf(`oshift${e}`,c),o.setUniformf(`oscale${e}`,s);const u=i.getRGBTransferFunction(t).getRange(),d=(a.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);o.setUniformf(`cshift${e}`,d),o.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(l)for(let e=0;e<s;++e){const t=a.scale[e];if(i.getUseGradientOpacity(e)){const n=i.getGradientOpacityMinimumOpacity(e),r=i.getGradientOpacityMaximumOpacity(e);o.setUniformf(`gomin${e}`,n),o.setUniformf(`gomax${e}`,r);const a=[i.getGradientOpacityMinimumValue(e),i.getGradientOpacityMaximumValue(e)];o.setUniformf(`goscale${e}`,t*(r-n)/(a[1]-a[0])),o.setUniformf(`goshift${e}`,-a[0]*(r-n)/(a[1]-a[0])+n)}else o.setUniformf(`gomin${e}`,1),o.setUniformf(`gomax${e}`,1),o.setUniformf(`goscale${e}`,0),o.setUniformf(`goshift${e}`,1)}else{const e=a.scale[s-1],t=i.getGradientOpacityMinimumOpacity(0),n=i.getGradientOpacityMaximumOpacity(0);o.setUniformf(&quot;gomin0&quot;,t),o.setUniformf(&quot;gomax0&quot;,n);const r=[i.getGradientOpacityMinimumValue(0),i.getGradientOpacityMaximumValue(0)];o.setUniformf(&quot;goscale0&quot;,e*(n-t)/(r[1]-r[0])),o.setUniformf(&quot;goshift0&quot;,-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===r.getProperty().getUseLabelOutline()){const e=r.getProperty().getLabelOutlineOpacity();o.setUniformf(&quot;outlineOpacity&quot;,e)}t.lastLightComplexity>0&&(o.setUniformf(&quot;vAmbient&quot;,i.getAmbient()),o.setUniformf(&quot;vDiffuse&quot;,i.getDiffuse()),o.setUniformf(&quot;vSpecular&quot;,i.getSpecular()),o.setUniformf(&quot;vSpecularPower&quot;,i.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*Dn(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv(&quot;vClipPlaneNormals&quot;,o),c.setUniformfv(&quot;vClipPlaneDistances&quot;,a),c.setUniform3fv(&quot;vClipPlaneOrigins&quot;,i),c.setUniformi(&quot;clip_numPlanes&quot;,l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===wg.NEAREST?(t.scalarTexture.setMinificationFilter(bd.NEAREST),t.scalarTexture.setMagnificationFilter(bd.NEAREST)):(t.scalarTexture.setMinificationFilter(bd.LINEAR),t.scalarTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null,null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;uniform vec2 tfactor;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),[&quot;//VTK::System::Dec&quot;,&quot;//VTK::Output::Dec&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { gl_FragData[0] = texture2D(texture1,tcoord); }&quot;].join(&quot;\\n&quot;),&quot;&quot;);const e=t.copyShader;t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in copy shader VAO.&quot;)}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi(&quot;texture&quot;,n.getTextureUnit()),t.copyShader.setUniform2f(&quot;tfactor&quot;,t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Eg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;t._scalars!==a&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=a);const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(bd.LINEAR),t.jitterTexture.setMagnificationFilter(bd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,ys.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=i.getIndependentComponents()?s:1,c=i.getScalarOpacity(),u=t._openGLRenderWindow.getGraphicsResourceForObject(c);let d=Vg(i,c,l);if(u.vtkObj&&u.hash===d&&t.opacityTextureString===d)t.opacityTexture=u.vtkObj,t.opacityTextureString=u.hash;else{const r=1024,o=2*r*l,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<l;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.releaseGraphicsResources(t._openGLRenderWindow),t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(bd.LINEAR),t.opacityTexture.setMagnificationFilter(bd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))t.opacityTexture.create2DFromRaw(r,2*l,1,ys.FLOAT,a);else{const e=new Uint8Array(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*l,1,ys.UNSIGNED_CHAR,e)}t.opacityTextureString=d,c&&t._openGLRenderWindow.setGraphicsResourceForObject(c,t.opacityTexture,t.opacityTextureString)}const p=i.getRGBTransferFunction();d=Vg(i,p,l);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===d&&t.colorTextureString===d)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(2*e*l*3),r=new Float32Array(3*e);for(let t=0;t<l;++t){const o=i.getRGBTransferFunction(t),a=o.getRange();o.getTable(a[0],a[1],e,r,1);for(let o=0;o<3*e;++o)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.create2DFromRaw(e,2*l,3,ys.UNSIGNED_CHAR,n),t.colorTextureString=d,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}e.updateLabelOutlineThicknessTexture(r);const g=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(d=`${o.getMTime()}A${a.getMTime()}`,g?.vtkObj&&g?.hash===d&&t.scalarTextureString===d)t.scalarTexture=g.vtkObj,t.scalarTextureString=g.hash;else{const e=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.scalarTexture.releaseGraphicsResources(t._openGLRenderWindow),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],a,t.renderable.getPreferSizeOverAccuracy()),t.scalarTextureString=d,a&&t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,t.scalarTextureString)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Es.newInstance({numberOfComponents:3,values:e});r.setName(&quot;points&quot;);const o=Es.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=e=>{const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}}}const Bg={context:null,VBOBuildTime:null,scalarTexture:null,scalarTextureString:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lastLightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0,_scalars:null};const Ng=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bg,n),Zt.extend(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),t.scalarTexture=Nd.newInstance(),t.opacityTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.jitterTexture=Nd.newInstance(),t.jitterTexture.setWrapS(Td.REPEAT),t.jitterTexture.setWrapT(Td.REPEAT),t.labelOutlineThicknessTexture=Nd.newInstance(),t.framebuffer=Hp.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,[&quot;context&quot;]),Lg(e,t)}),&quot;vtkOpenGLVolumeMapper&quot;);rn(&quot;vtkVolumeMapper&quot;,Ng);const{vtkDebugMacro:_g}=Kt;function Fg(e,t){t.classHierarchy.push(&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent();const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():_g(&quot;No framebuffer to save/restore&quot;);const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const kg={};const Gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kg,n),Zt.extend(e,t,n),Fg(e,t)}),&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;);rn(&quot;vtkPixelSpaceCallbackMapper&quot;,Gg);var Ug=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtktextureObjectVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\nattribute vec2 tcoordDC;\\nvarying vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  tcoordVC = tcoordDC;\\n  gl_Position = vertexDC;\\n}\\n&quot;;const{Representation:zg}=ds;function Wg(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Nd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,&quot;Float32Array&quot;,null),s.activate(),s.sendParameters(),s.deactivate(),s}function Hg(e,t){return Wg(e,t,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE)}function jg(e,t){t.classHierarchy.push(&quot;vtkLICPingPongBufferManager&quot;),t._openGLRenderWindow?(t.quad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,zg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=Hg(t._openGLRenderWindow,t.size),t.seedTexture0=Hg(t._openGLRenderWindow,t.size),t.licTexture1=Hg(t._openGLRenderWindow,t.size),t.seedTexture1=Hg(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?Wg(t._openGLRenderWindow,t.size,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return Wg(e,t,Nd.Filter.LINEAR,Nd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error(&quot;Pass renderwindow to ping pong manager&quot;)}const Kg={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function $g(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kg,n),jt.obj(e,t),jt.get(e,t,[&quot;readIndex&quot;]),jt.setGet(e,t,[&quot;doEEPass&quot;,&quot;doVTPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;vectorTexture&quot;,&quot;maskVectorTexture&quot;,&quot;noiseTexture&quot;,&quot;framebuffer&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),jg(e,t)}var qg={newInstance:jt.newInstance($g,&quot;vtkLICPingPongBufferManager&quot;),extend:$g};const Xg=0,Yg=1,Zg=2,Qg=3,Jg=1;function em(e,t){function n(e,t){e.setUniformi(&quot;texLIC&quot;,t.getLICTextureUnit()),e.setUniformi(&quot;texSeedPts&quot;,t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push(&quot;vtkLineIntegralConvolution2D&quot;),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Hp.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t=&quot;xyzw&quot;;return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n/**\\nThis shader initializes the convolution for the LIC computation.\\n*/\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texMaskVectors;\\nuniform sampler2D texNoise;\\nuniform sampler2D texLIC;\\n\\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the *whole* domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value. this\\n// depends on the pass number.\\nvec2 getNoiseTC(vec2 vectc)\\n{\\n  // in pass 1 : convert from vector tc to noise tc\\n  // in pass 2 : use vector tc\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(vectc);\\n    }\\n  else\\n    {\\n    return vectc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the\\n// need to convert to noise texture coordinates.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 vectc = tcoordVC.st;\\n\\n  // lic => (convolution, mask, 0, step count)\\n  if (uStepNo == 0)\\n    {\\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\\n    float maskFlag;\\n    if (maskCriteria <= uMaskThreshold)\\n      {\\n      maskFlag = 1.0;\\n      }\\n    else\\n      {\\n      maskFlag = 0.0;\\n      }\\n    float noise = getNoise(vectc);\\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = texture2D(texLIC, vectc);\\n    }\\n\\n  // initial seed\\n  SeedOutput = vec4(vectc, 0.0, 1.0);\\n}\\n&quot;);const n=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// move vector field to normalized image space\\n// pre-processing for vtkLineIntegralConvolution2D\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Fragment shader used by the gaussian blur filter render pass.\\n\\nuniform sampler2D texVectors; // input texture\\nuniform vec2      uTexSize;   // size of texture\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  //VTK::LICComponentSelection::Impl\\n  V = V/uTexSize;\\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\\n}\\n&quot;,&quot;//VTK::LICComponentSelection::Impl&quot;,`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D  texVectors;\\nuniform sampler2D  texNoise;\\nuniform sampler2D  texLIC;\\nuniform sampler2D  texSeedPts;\\n\\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\\nuniform float uStepSize;        // step size in parametric space\\n\\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n//VTK::LICVectorLookup::Impl\\n\\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\\n// are very poorly supported in webgl\\nvec2 clampToBorder(vec2 uv){\\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\\n  {\\n    return vec2(0.0, 0.0);\\n  }\\n  return getVector(uv);\\n}\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the whole domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value.\\n// in pass 1 repeatedly tile the noise texture across\\n// the computational domain.\\nvec2 getNoiseTC(vec2 tc)\\n{\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(tc);\\n    }\\n  else\\n    {\\n    return tc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the need\\n// to convert to either noise or lic texture coordinates in\\n// pass 1 and 2 respectively.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\n// fourth-order Runge-Kutta streamline integration\\n// no bounds checks are made, therefore it's essential\\n// to have the entire texture initialized to 0\\n// and set clamp to border and have border color 0\\n// an integer is set if the step was taken, keeping\\n// an accurate step count is necessary to prevent\\n// boundary artifacts. Don't count the step if\\n// all vector lookups are identically 0. This is\\n// a proxy for \\&quot;stepped outside valid domain\\&quot;\\nvec2 rk4(vec2 pt0, float dt, out bool count)\\n{\\n  count=true;\\n  float dtHalf = dt * 0.5;\\n  vec2 pt1;\\n\\n  vec2 v0 = clampToBorder(pt0);\\n  pt1 = pt0 + v0 * dtHalf;\\n\\n  vec2 v1 = clampToBorder(pt1);\\n  pt1 = pt0 + v1 * dtHalf;\\n\\n  vec2 v2 = clampToBorder(pt1);\\n  pt1 = pt0 + v2 * dt;\\n\\n  vec2 v3 = clampToBorder(pt1);\\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\\n\\n  if (vSum == vec2(0.0, 0.0))\\n    {\\n      count = false;\\n    }\\n\\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\\n\\n return pt1;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic = texture2D(texLIC, lictc);\\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\\n\\n  bool count;\\n  vec2 pt1 = rk4(pt0, uStepSize, count);\\n\\n  if (count)\\n    {\\n    // accumulate lic step\\n    // (lic, mask, 0, step count)\\n    float noise = getNoise(pt1);\\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\\n    SeedOutput = vec4(pt1, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    // keep existing values\\n    LICOutput = lic;\\n    SeedOutput = vec4(pt0, 0.0, 1.0);\\n    }\\n}\\n&quot;,&quot;//VTK::LICVectorLookup::Impl&quot;,function(){const e=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      vec2 V = texture2D( texVectors, vectc ).xy;\\n\\n      // normalize if |V| not 0\\n\\n      float lenV = length( V );\\n\\n      if ( lenV > 1.0e-8 )\\n\\n        {\\n\\n        return V/lenV;\\n\\n        }\\n\\n      else\\n\\n        {\\n\\n        return vec2( 0.0, 0.0 );\\n\\n        }\\n\\n      }\\n\\n    &quot;,t=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      return texture2D( texVectors, vectc ).xy;\\n\\n      }\\n\\n    &quot;;return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(&quot; //VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n/**\\nThis shader finalizes the convolution for the LIC computation\\napplying the normalization. eg. if box kernel is used the this\\nis the number of steps taken.\\n*/\\n\\nuniform sampler2D texLIC;\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\\n  conv.r = conv.r/conv.a;\\n  // lic => (convolution, mask, 0, 1)\\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.CEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// gray scale contrast enhance stage implemented via histogram stretching\\n// if the min and max are tweaked it can generate out-of-range values\\n// these will be clamped in 0 to 1\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n\\nuniform sampler2D texLIC;  // most recent lic pass\\nuniform float uMin;        // min gray scale color value\\nuniform float uMaxMinDiff; // max-min\\n\\nin vec2 tcoordVC;\\n\\nvoid main( void )\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g!=0.0)\\n    {\\n    LICOutput = lic;\\n    }\\n  else\\n    {\\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\\n    LICOutput = vec4(CElic, lic.gb, 1.0);\\n    }\\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.EEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\\n// noise for pass2.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 EEOutput;\\n\\nuniform sampler2D texLIC; // most recent lic pass\\nuniform float     uDx;    // fragment size\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// kernel for simple laplace edge enhancement.\\n// p=Laplace(p)+p\\nfloat K[9] = float[9](\\n  -1.0, -1.0, -1.0,\\n  -1.0,  9.0, -1.0,\\n  -1.0, -1.0, -1.0\\n  );\\n\\n// determine if the fragment was masked\\nbool Masked(float val) { return val != 0.0; }\\n\\nvoid main(void)\\n{\\n  // tex coord neighbor offsets\\n  vec2 fragDx[9] = vec2[9](\\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\\n    );\\n\\n  vec2 lictc = tcoordVC.st;\\n\\n  // compute the convolution but don't use convovled values if\\n  // any masked fragments on the stencil. Fragments outside\\n  // the valid domain are masked during initialization, and\\n  // texture wrap parameters are clamp to border with border\\n  // color that contains masked flag\\n  float conv = 0.0;\\n  bool dontUse = false;\\n  for (int i=0; i<9; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    vec4 lic = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic.g);\\n    conv = conv + K[i] * lic.r;\\n    }\\n\\n  if (dontUse)\\n    {\\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    conv = clamp(conv, 0.0, 1.0);\\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\\n    }\\n\\n}\\n&quot;),t.AAHProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// horizontal pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDx;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.AAVProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// vertical pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\\n\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDy[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;)},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;f&&o[0]===f.getSize()[0]&&o[1]===f.getSize()[1]||(f=Hp.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=qg.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const g=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],m=1/o[0],h=1/o[1],v=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;v.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f(&quot;uTexSize&quot;,...o),e.setUniformi(&quot;texVectors&quot;,t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,0),y.setUniformf(&quot;uMaskThreshold&quot;,t.maskThreshold),y.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),y.setUniformi(&quot;texMaskVectors&quot;,t.bufs.getMaskVectorTextureUnit()),y.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:T}=t;v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,0),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),T.setUniformi(&quot;texVectors&quot;,t.bufs.getImageVectorTextureUnit()),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:b}=t;if(v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),r(t.bufs,o,b),t.enhancedLIC){t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDx&quot;,m),a.setUniformf(&quot;uDy&quot;,h),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,1),n(y,t.bufs),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,1),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),b.setUniformi(&quot;texSeedPts&quot;,t.bufs.getSeedTextureUnit()),r(t.bufs,o,b)}if(t.antiAlias){const e=t.AAHProgram;v.readyShaderProgram(e),e.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),e.setUniformf(&quot;uDx&quot;,m);const a=t.AAVProgram;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDy&quot;,h);for(let i=0;i<t.antiAlias;++i)v.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),v.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error(&quot;Invalid color range: &quot;,i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),c.setUniformf(&quot;uMin&quot;,i),c.setUniformf(&quot;uMaxMinDiff&quot;,l),r(t.bufs,o,c)}}const tm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function nm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tm,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;nuberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;componentIds&quot;,&quot;isComposite&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),em(e,t)}var rm={newInstance:jt.newInstance(nm,&quot;vtkLineIntegralConvolution2D&quot;),extend:nm};function om(e,t){t.classHierarchy.push(&quot;vtkSurfaceLICInterface&quot;)}const am={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Xg,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:Jg,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function im(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,am,n),jt.obj(e,t),jt.setGet(e,t,[&quot;enableLIC&quot;,&quot;numberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;transformVectors&quot;,&quot;maskOnSurface&quot;,&quot;maskThreshold&quot;,&quot;maskColor&quot;,&quot;maskIntensity&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;noiseTextureSize&quot;,&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;noiseGeneratorSeed&quot;,&quot;viewPortScale&quot;,&quot;rebuildNoiseTexture&quot;]),om(0,t)}var sm={newInstance:jt.newInstance(im,&quot;vtkSurfaceLICInterface&quot;),extend:im};const{Representation:lm}=ds;function cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICInterface&quot;),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get(&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;);n=r===Jg?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Nd.newInstance({wrapS:Nd.Wrap.REPEAT,wrapT:Nd.Wrap.REPEAT,minificationFilter:Nd.Filter.NEAREST,magnificationFilter:Nd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,&quot;Float32Array&quot;,d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.allocateTextures=()=>{const n=Nd.Filter.NEAREST,r=Nd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Nd.newInstance({wrapS:Nd.Wrap.CLAMP_TO_EDGE,wrapT:Nd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,&quot;Float32Array&quot;,null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Nd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,&quot;Float32Array&quot;,null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=Hp.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader combines surface geometry, LIC, and  scalar colors.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 RGBOutput;\\nlayout(location = 1) out vec4 HSLOutput;\\n\\nuniform sampler2D texVectors;       // vectors, depth\\nuniform sampler2D texGeomColors;    // scalar colors + lighting\\nuniform sampler2D texLIC;           // image lic\\nuniform int       uScalarColorMode; // select between blend, and map shader\\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\\nuniform float     uMaskIntensity;   // blending factor for mask color\\nuniform vec3      uMaskColor;       // color for the masked out fragments\\n\\nin vec2 tcoordVC;\\n\\n/**\\nConvert from RGB color space into HSL colorspace.\\n*/\\nvec3 RGBToHSL(vec3 RGB)\\n{\\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\\n\\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\\n  float RGBMaxMinDiff = RGBMax - RGBMin;\\n\\n  HSL.z = (RGBMax + RGBMin) / 2.0;\\n\\n  if (RGBMaxMinDiff == 0.0)\\n    {\\n    // Gray scale\\n    HSL.x = 0.0;\\n    HSL.y = 0.0;\\n    }\\n  else\\n    {\\n    // Color\\n    if (HSL.z < 0.5)\\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\\n    else\\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\\n\\n    float dR\\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dG\\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dB\\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n\\n    if (RGB.r == RGBMax)\\n      HSL.x = dB - dG;\\n    else\\n    if (RGB.g == RGBMax)\\n      HSL.x = (1.0 / 3.0) + dR - dB;\\n    else\\n    if (RGB.b == RGBMax)\\n      HSL.x = (2.0 / 3.0) + dG - dR;\\n\\n    if (HSL.x < 0.0)\\n      HSL.x += 1.0;\\n\\n    if (HSL.x > 1.0)\\n      HSL.x -= 1.0;\\n    }\\n\\n  return HSL;\\n}\\n\\n/**\\nHelper for HSL to RGB conversion.\\n*/\\nfloat Util(float v1, float v2, float vH)\\n{\\n  if (vH < 0.0)\\n    vH += 1.0;\\n\\n  if (vH > 1.0)\\n     vH -= 1.0;\\n\\n  if ((6.0 * vH) < 1.0)\\n    return (v1 + (v2 - v1) * 6.0 * vH);\\n\\n  if ((2.0 * vH) < 1.0)\\n    return (v2);\\n\\n  if ((3.0 * vH) < 2.0)\\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\\n\\n  return v1;\\n}\\n\\n/**\\nConvert from HSL space into RGB space.\\n*/\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  if (HSL.y == 0.0)\\n    {\\n    // Gray\\n    RGB.r = HSL.z;\\n    RGB.g = HSL.z;\\n    RGB.b = HSL.z;\\n    }\\n  else\\n    {\\n    // Chromatic\\n    float v2;\\n    if (HSL.z < 0.5)\\n      v2 = HSL.z * (1.0 + HSL.y);\\n    else\\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\\n\\n    float v1 = 2.0 * HSL.z - v2;\\n\\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\\n    RGB.g = Util(v1, v2, HSL.x);\\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\\n    }\\n\\n  return RGB.rgb;\\n}\\n\\nvoid main()\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n\\n  // depth is used to determine which fragment belong to us\\n  // and we can change\\n  float depth = texture2D(texVectors, tcoordVC.st).a;\\n\\n  vec3 fragColorRGB;\\n  float valid;\\n  if (depth > 1.0e-3)\\n    {\\n    // we own it\\n    // shade LIC'ed geometry, or apply mask\\n    if (lic.g!=0.0)\\n      {\\n      // it's masked\\n      // apply fragment mask\\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\\n      valid = 0.0;\\n      }\\n    else\\n      {\\n      if (uScalarColorMode==0)\\n        {\\n        // blend with scalars\\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\\n        }\\n      else\\n        {\\n        // multiply with scalars\\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\\n        }\\n      if (lic.b != 0.0)\\n        {\\n        // didn't have the required guard pixels\\n        // don't consider it in min max estimation\\n        // for histpgram stretching\\n        valid = 0.0;\\n        }\\n      else\\n        {\\n        // ok to use in min/max estimates for histogram\\n        // stretching\\n        valid = 1.0;\\n        }\\n      }\\n    }\\n  else\\n    {\\n    // we don't own it\\n    // pass through scalars\\n    fragColorRGB = geomColor.rgb;\\n    valid = 0.0;\\n    }\\n\\n  // if no further stages this texture is\\n  // copied to the screen\\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\\n\\n  // if further stages, move to hsl space for contrast\\n  // enhancement. encoding validity saves moving a texture to the cpu\\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\\n  HSLOutput = vec4(fragColorHSL, valid);\\n}\\n&quot;),t.licCopyPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader copies fragments and depths to the output buffer\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texDepth;     // z values from vertex shader\\nuniform sampler2D texRGBColors; // final rgb LIC colors\\n\\nin vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\\n\\n  // since we render a screen aligned quad\\n  // we're going to be writing fragments\\n  // not touched by the original geometry\\n  // it's critical not to modify those\\n  // fragments.\\n  if (gl_FragDepth == 1.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;),t.enhanceContrastPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// color contrast enhance stage implemented via histogram stretching\\n// on lightness channel. if the min and max are tweaked it can generate\\n// out-of-range values these will be clamped in 0 to 1\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texGeomColors; // scalars + lighting\\nuniform sampler2D texLIC;        // image lic, mask\\nuniform sampler2D texHSLColors;  // hsla colors\\n\\nuniform float     uLMin;         // min lightness over all fragments\\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\\n\\nin vec2 tcoordVC;\\n\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  float v;\\n  float h = HSL.x;\\n  float sl = HSL.y;\\n  float l = HSL.z;\\n\\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\\n  if (v <= 0.0) {\\n    RGB = vec3(0.0,0.0,0.0);\\n  } else {\\n    float m;\\n    int sextant;\\n    float fract, vsf, mid1, mid2;\\n\\n    m = l + l - v;\\n    h *= 6.0;\\n    sextant = int(h);\\n    fract = h - float(sextant);\\n\\n    vsf = (v - m) * fract;\\n    mid1 = m + vsf;\\n    mid2 = v - vsf;\\n    switch (sextant) {\\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\\n    }\\n  }\\n  return RGB;\\n}\\n\\nvoid main()\\n{\\n  // lookup hsl color , mask\\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\\n\\n  // don't modify masked fragments (masked => lic.g==1)\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g==0.0)\\n    {\\n    // normalize lightness channel\\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\\n    }\\n\\n  // back into rgb space\\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\\n\\n  // add alpha\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n  fragColor.a = geomColor.a;\\n\\n  gl_FragData[0] = fragColor;\\n}\\n&quot;),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,lm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=rm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi(&quot;texDepth&quot;,t.depthTexture.getTextureUnit()),r.setUniformi(&quot;texRGBColors&quot;,t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi(&quot;texVectors&quot;,t.vectorImage.getTextureUnit()),o.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get(&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;maskIntensity&quot;,&quot;maskColor&quot;,&quot;enhanceContrast&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;);if(o.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),o.setUniformi(&quot;uScalarColorMode&quot;,a),o.setUniformf(&quot;uLICIntensity&quot;,i),o.setUniformf(&quot;uMapBias&quot;,s),o.setUniformf(&quot;uMaskIntensity&quot;,l),o.setUniform3f(&quot;uMaskColor&quot;,...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===Zg||u===Qg){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit()),s.setUniformi(&quot;texHSLColors&quot;,t.HSLColorImage.getTextureUnit()),s.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),s.setUniformf(&quot;uLMin&quot;,o),s.setUniformf(&quot;uLMaxMinDiff&quot;,i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get(&quot;stepSize&quot;,&quot;numberOfSteps&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;transformVectors&quot;),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error(&quot;Failed to compute image LIC&quot;),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const um={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function dm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,um,n),sm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;reallocateTextures&quot;,&quot;licInterface&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cm(e,t)}var pm={newInstance:jt.newInstance(dm,&quot;vtkSurfaceLICInterface&quot;),extend:dm};const{vtkErrorMacro:fm}=Kt;function gm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICMapper&quot;);const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=cd.substitute(s,&quot;//VTK::Output::Dec&quot;,[&quot;//VTK::Output::Dec&quot;,&quot;layout(location = 2) out vec4 vectorTexture;&quot;,&quot;layout(location = 3) out vec4 maskVectorTexture;&quot;]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,[`attribute vec3 ${n};`,&quot;out vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[`licOutput = ${n};`,&quot;//VTK::TCoord::Impl&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform int uMaskOnSurface;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;in vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Impl&quot;,[&quot;// projected vectors&quot;,&quot;  vec3 tcoordLIC = normalMatrix * licOutput;&quot;,&quot;  vec3 normN = normalize(normalVCVSOutput);&quot;,&quot;  float k = dot(tcoordLIC, normN);&quot;,&quot;  vec3 projected = (tcoordLIC - k*normN);&quot;,&quot;  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;// vectors for fragment masking&quot;,&quot;  if (uMaskOnSurface == 0)&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(licOutput, 1.0);&quot;,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;    }&quot;,&quot;//VTK::TCoord::Impl&quot;],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi(&quot;uMaskOnSurface&quot;,t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(fm(&quot;SurfaceLICMapper Requires WebGL 2&quot;),a=!1),t.context.getExtension(&quot;EXT_color_buffer_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)||(fm(&quot;SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions.&quot;),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(fm(&quot;No input&quot;),a=!1);let i=t.renderable.getLicInterface();i||(i=sm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=pm.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(fm(&quot;No vector input array&quot;),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const mm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const hm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mm,n),np.extend(e,t,n),gm(e,t),At(e,t,[&quot;openGLLicInterface&quot;])}),&quot;vtkOpenGLSurfaceLICMapper&quot;);rn(&quot;vtkSurfaceLICMapper&quot;,hm);const{vtkErrorMacro:vm}=Kt;function ym(e,t){t.classHierarchy.push(&quot;vtkOpenGLSphereMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkSphereMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Spheres\\n\\nattribute vec4 vertexMC;\\nattribute vec2 offsetMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\n\\nuniform int cameraParallel;\\nuniform float scaleFactor;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  // compute the projected vertex position\\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\\n\\n  // make the triangle face the camera\\n  if (cameraParallel == 0)\\n    {\\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\\n    vec3 base1 = cross(base2,dir);\\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\\n    }\\n  else\\n    {\\n    // add in the offset\\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\\n    }\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;\\n&quot;]).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform float invertedDepth;\\n&quot;,&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float b = 2.0*dot(EyePos,EyeDir);\\n&quot;,&quot;  float c = dot(EyePos,EyePos) - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t = (-b - invertedDepth*sqrt(d))*0.5;\\n&quot;,&quot;    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\\n&quot;,&quot;    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;offsetMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||vm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isUniformUsed(&quot;invertedDepth&quot;)&&e.getProgram().setUniformf(&quot;invertedDepth&quot;,t.invert?-1:1),e.getProgram().isUniformUsed(&quot;scaleFactor&quot;)){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf(&quot;scaleFactor&quot;,t.renderable.getScaleFactor()):e.getProgram().setUniformf(&quot;scaleFactor&quot;,1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),o.isUniformUsed(&quot;MCVCMatrix&quot;))if(r.getIsIdentity())o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,n)}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Tm={};const bm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tm,n),np.extend(e,t,n),ym(e,t)}),&quot;vtkOpenGLSphereMapper&quot;);rn(&quot;vtkSphereMapper&quot;,bm);const{vtkErrorMacro:xm}=Kt;function Cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLStickMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkStickMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Sticks\\n\\nattribute vec4 vertexMC;\\nattribute vec3 orientMC;\\nattribute vec4 offsetMC;\\nattribute float radiusMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying float lengthVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\nvarying vec3 orientVCVSOutput;\\n\\nuniform int cameraParallel;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = radiusMC;\\n  lengthVCVSOutput = length(orientMC);\\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\\n\\n  // make sure it is pointing out of the screen\\n  if (orientVCVSOutput.z < 0.0)\\n    {\\n    orientVCVSOutput = -orientVCVSOutput;\\n    }\\n\\n  // make the basis\\n  vec3 xbase;\\n  vec3 ybase;\\n  vec3 dir = vec3(0.0,0.0,1.0);\\n  if (cameraParallel == 0)\\n    {\\n    dir = normalize(-vertexVCVSOutput.xyz);\\n    }\\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\\n    {\\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\\n    ybase = cross(xbase,orientVCVSOutput);\\n    }\\n  else\\n    {\\n    xbase = normalize(cross(orientVCVSOutput,dir));\\n    ybase = cross(orientVCVSOutput,xbase);\\n    }\\n\\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\\n    radiusVCVSOutput*offsets.x*xbase +\\n    radiusVCVSOutput*offsets.y*ybase +\\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,&quot;varying vec4 vertexVCVSOutput;&quot;).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,&quot;  vec4 vertexVC = vertexVCVSOutput;\\n&quot;).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 orientVCVSOutput;\\n&quot;,&quot;varying float lengthVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  vec3 base1;\\n&quot;,&quot;  if (abs(orientVCVSOutput.z) < 0.99) {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\\n&quot;,&quot;  vec3 base2 = cross(orientVCVSOutput,base1);\\n&quot;,&quot;  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\\n&quot;,&quot;  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n&quot;,&quot;  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n&quot;,&quot;  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*a*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t =  (-b - sqrt(d))/(2.0*a);\\n&quot;,&quot;    float tz = EyePos.z + t*EyeDir.z;\\n&quot;,&quot;    vec3 iPoint = EyePos + t*EyeDir;\\n&quot;,&quot;    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\\n&quot;,&quot;      float t2 = (-b + sqrt(d))/(2.0*a);\\n&quot;,&quot;      float tz2 = EyePos.z + t2*EyeDir.z;\\n&quot;,&quot;      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\\n&quot;,&quot;      else {\\n&quot;,&quot;        normalVCVSOutput = orientVCVSOutput;\\n&quot;,&quot;        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\\n&quot;,&quot;        iPoint = EyePos + t3*EyeDir;\\n&quot;,&quot;        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;        }\\n&quot;,&quot;      }\\n&quot;,&quot;    else {\\n&quot;,&quot;      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\\n&quot;,&quot;      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;      }\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed(&quot;orientMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;orientMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||xm(&quot;Error setting 'orientMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),&quot;offsetMC&quot;,0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||xm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;radiusMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;radiusMC&quot;,24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||xm(&quot;Error setting 'radiusMC' in shader VAO.&quot;))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),r.getIsIdentity())o.isUniformUsed(&quot;MCVCMatrix&quot;)&&o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc),o.isUniformUsed(&quot;normalMatrix&quot;)&&o.setUniformMatrix3x3(&quot;normalMatrix&quot;,i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed(&quot;MCVCMatrix&quot;)){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,t)}if(o.isUniformUsed(&quot;normalMatrix&quot;)){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3(&quot;normalMatrix&quot;,t)}}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():xm([&quot;Error setting orientationArray.\\n&quot;,&quot;You have to specify the stick orientation&quot;]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,zu.ARRAY_BUFFER),a.getColorBO().upload(g,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Sm={};const Am=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sm,n),np.extend(e,t,n),Cm(e,t)}),&quot;vtkOpenGLStickMapper&quot;);rn(&quot;vtkStickMapper&quot;,Am);const Im=[];Im[&quot;-&quot;.charCodeAt(0)]=62,Im[&quot;_&quot;.charCodeAt(0)]=63;const wm=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;for(let e=0;e<wm.length;e++)Im[wm.charCodeAt(e)]=e;function Pm(e){return void 0!==Im[e.charCodeAt(0)]}function Om(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<18;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<12;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<6;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<10;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<4;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<2;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error(&quot;BASE64: remain 1 should not happen&quot;)}return u}function Rm(e,t,n){const r=(e<<16)+(t<<8)+n;return wm[r>>18]+wm[r>>12&63]+wm[r>>6&63]+wm[63&r]}function Mm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Rm(t[n],t[n+1],t[n+2])}if(n>0){const e=Rm(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join(&quot;&quot;)}var Dm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)Pm(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):&quot;=&quot;===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Om(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Em={};function Vm(e,t){Em[e]=t}var Lm=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;http&quot;,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Em[e](t)},Bm=Uint8Array,Nm=Uint16Array,_m=Uint32Array,Fm=new Bm([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),km=new Bm([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Gm=new Bm([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Um=function(e,t){for(var n=new Nm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new _m(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},zm=Um(Fm,2),Wm=zm[0],Hm=zm[1];Wm[28]=258,Hm[258]=28;for(var jm=Um(km,0),Km=jm[0],$m=(jm[1],new Nm(32768)),qm=0;qm<32768;++qm){var Xm=(43690&qm)>>>1|(21845&qm)<<1;Xm=(61680&(Xm=(52428&Xm)>>>2|(13107&Xm)<<2))>>>4|(3855&Xm)<<4,$m[qm]=((65280&Xm)>>>8|(255&Xm)<<8)>>>1}var Ym=function(e,t,n){for(var r=e.length,o=0,a=new Nm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Nm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Nm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[$m[d]>>>l]=c}else for(i=new Nm(r),o=0;o<r;++o)e[o]&&(i[o]=$m[s[e[o]-1]++]>>>15-e[o]);return i},Zm=new Bm(288);for(qm=0;qm<144;++qm)Zm[qm]=8;for(qm=144;qm<256;++qm)Zm[qm]=9;for(qm=256;qm<280;++qm)Zm[qm]=7;for(qm=280;qm<288;++qm)Zm[qm]=8;var Qm=new Bm(32);for(qm=0;qm<32;++qm)Qm[qm]=5;var Jm=Ym(Zm,9,1),eh=Ym(Qm,5,1),th=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},nh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},rh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},oh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Nm:4==e.BYTES_PER_ELEMENT?_m:Bm)(n-t);return r.set(e.subarray(t,n)),r},ah=[&quot;unexpected EOF&quot;,&quot;invalid block type&quot;,&quot;invalid length/literal&quot;,&quot;invalid distance&quot;,&quot;stream finished&quot;,&quot;no stream handler&quot;,,&quot;no callback&quot;,&quot;invalid UTF-8 data&quot;,&quot;extra field too long&quot;,&quot;date not in range 1980-2099&quot;,&quot;filename too long&quot;,&quot;stream finishing&quot;,&quot;invalid zip data&quot;],ih=function(e,t,n){var r=new Error(t||ah[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,ih),!n)throw r;return r},sh=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new Bm(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new Bm(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new Bm(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=nh(e,c,1);var h=nh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&ih(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=Jm,p=eh,f=9,g=5;else if(2==h){var T=nh(e,c,31)+257,b=nh(e,c+10,15)+4,x=T+nh(e,c+5,31)+1;c+=14;for(var C=new Bm(x),S=new Bm(19),A=0;A<b;++A)S[Gm[A]]=nh(e,c+3*A,7);c+=3*b;var I=th(S),w=(1<<I)-1,P=Ym(S,I,1);for(A=0;A<x;){var O,R=P[nh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,D=0;for(16==O?(D=3+nh(e,c,3),c+=2,M=C[A-1]):17==O?(D=3+nh(e,c,7),c+=3):18==O&&(D=11+nh(e,c,127),c+=7);D--;)C[A++]=M}}var E=C.subarray(0,T),V=C.subarray(T);f=th(E),g=th(V),d=Ym(E,f,1),p=Ym(V,g,1)}else ih(1);if(c>m){a&&ih(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[rh(e,c)&L])>>>4;if((c+=15&M)>m){a&&ih(0);break}if(M||ih(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Fm[A=_-257];F=nh(e,c,(1<<k)-1)+Wm[A],c+=k}var G=p[rh(e,c)&B],U=G>>>4;if(G||ih(3),c+=15&G,V=Km[U],U>3&&(k=km[U],V+=rh(e,c)&(1<<k)-1,c+=k),c>m){a&&ih(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:oh(t,0,u)},lh=new Bm(0),ch=function(e,t){return e[t]|e[t+1]<<8},uh=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},dh=function(e,t){return uh(e,t)+4294967296*uh(e,t+4)};function ph(e,t){return sh(e,t)}function fh(e,t){return sh(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||ih(6,&quot;invalid gzip data&quot;);var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new Bm((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function gh(e,t){return sh(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&ih(6,&quot;invalid zlib data&quot;),32&n[1]&&ih(6,&quot;invalid zlib data: preset dictionaries not supported&quot;),e.subarray(2,-4)),t);var n}function mh(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?fh(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?ph(e,t):gh(e,t)}var hh=&quot;undefined&quot;!=typeof TextEncoder&&new TextEncoder,vh=&quot;undefined&quot;!=typeof TextDecoder&&new TextDecoder;try{vh.decode(lh,{stream:!0})}catch(e){}function yh(e,t){if(t){for(var n=&quot;&quot;,r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(vh)return vh.decode(e);var o=function(e){for(var t=&quot;&quot;,n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,oh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&ih(8),a}var Th=function(e,t){return t+30+ch(e,t+26)+ch(e,t+28)},bh=function(e,t,n){var r=ch(e,t+28),o=yh(e.subarray(t+46,t+46+r),!(2048&ch(e,t+8))),a=t+46+r,i=uh(e,t+20),s=n&&4294967295==i?xh(e,a):[i,uh(e,t+24),uh(e,t+42)],l=s[0],c=s[1],u=s[2];return[ch(e,t+10),l,c,o,a+ch(e,t+30)+ch(e,t+32),u]},xh=function(e,t){for(;1!=ch(e,t);t+=4+ch(e,t+2));return[dh(e,t+12),dh(e,t+4),dh(e,t+20)]};function Ch(e,t){for(var n={},r=e.length-22;101010256!=uh(e,r);--r)(!r||e.length-r>65558)&&ih(13);var o=ch(e,r+8);if(!o)return{};var a=uh(e,r+16),i=4294967295==a;i&&(r=uh(e,r-12),101075792!=uh(e,r)&&ih(13),o=uh(e,r+32),a=uh(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=bh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Th(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=ph(e.subarray(h,h+d),new Bm(p)):ih(14,&quot;unknown compression type &quot;+u):n[f]=oh(e,h,h+d))}return n}function Sh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?&quot;LittleEndian&quot;:2712847316===n[0]?&quot;BigEndian&quot;:null}&quot;function&quot;==typeof queueMicrotask?queueMicrotask:&quot;function&quot;==typeof setTimeout&&setTimeout;var Ah=Sh(),Ih=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:wh,vtkDebugMacro:Ph}=jt;let Oh=0;function Rh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener(&quot;progress&quot;,n.progressCallback),r}const Mh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;);const s=Rh(&quot;GET&quot;,i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(Ph(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&wh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||&quot;string&quot;!==n.dataType?&quot;arraybuffer&quot;:&quot;text&quot;,s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(yh(mh(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&&quot;gz&quot;!==n.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(yh(mh(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&&quot;gz&quot;!==t.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Rh(&quot;GET&quot;,e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(mh(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType=&quot;arraybuffer&quot;,o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};Vm(&quot;http&quot;,(e=>Mh));const{vtkDebugMacro:Dh}=jt;function Eh(e,t){t.classHierarchy.push(&quot;vtkCamera&quot;);const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;);const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Gi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Gi(o,[...t.position,1],n),Gi(a,[...t.focalPoint,1],n),Gi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=Hi(e[0],e[1],e[2],e[3]),n=Ui(),r=Hi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],Wi(r,t,r),Wi(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error(&quot;Off-Axis projection is not supported at this time&quot;);{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=Ui();zi(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const Vh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Lh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vh,n),jt.obj(e,t),jt.get(e,t,[&quot;distance&quot;]),jt.setGet(e,t,[&quot;parallelProjection&quot;,&quot;useHorizontalViewAngle&quot;,&quot;viewAngle&quot;,&quot;parallelScale&quot;,&quot;useOffAxisProjection&quot;,&quot;freezeFocalPoint&quot;,&quot;physicalScale&quot;]),jt.getArray(e,t,[&quot;directionOfProjection&quot;,&quot;viewPlaneNormal&quot;,&quot;position&quot;,&quot;focalPoint&quot;]),jt.setGetArray(e,t,[&quot;clippingRange&quot;,&quot;windowCenter&quot;],2),jt.setGetArray(e,t,[&quot;viewUp&quot;,&quot;screenBottomLeft&quot;,&quot;screenBottomRight&quot;,&quot;screenTopRight&quot;,&quot;physicalTranslation&quot;,&quot;physicalViewUp&quot;,&quot;physicalViewNorth&quot;],3),Eh(e,t)}var Bh={newInstance:jt.newInstance(Lh,&quot;vtkCamera&quot;),extend:Lh};function Nh(e,t){t.classHierarchy.push(&quot;vtkLight&quot;);const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType(&quot;HeadLight&quot;)},e.setLightTypeToCameraLight=()=>{e.setLightType(&quot;CameraLight&quot;)},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType(&quot;SceneLight&quot;)},e.lightTypeIsHeadLight=()=>&quot;HeadLight&quot;===t.lightType,e.lightTypeIsSceneLight=()=>&quot;SceneLight&quot;===t.lightType,e.lightTypeIsCameraLight=()=>&quot;CameraLight&quot;===t.lightType}const _h={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:&quot;SceneLight&quot;,shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_h,n),jt.obj(e,t),jt.setGet(e,t,[&quot;intensity&quot;,&quot;switch&quot;,&quot;positional&quot;,&quot;exponent&quot;,&quot;coneAngle&quot;,&quot;coneFalloff&quot;,&quot;transformMatrix&quot;,&quot;lightType&quot;,&quot;shadowAttenuation&quot;,&quot;attenuationValues&quot;]),jt.setGetArray(e,t,[&quot;color&quot;,&quot;position&quot;,&quot;focalPoint&quot;,&quot;attenuationValues&quot;],3),Nh(e,t)}var kh={newInstance:jt.newInstance(Fh,&quot;vtkLight&quot;),extend:Fh,LIGHT_TYPES:[&quot;HeadLight&quot;,&quot;CameraLight&quot;,&quot;SceneLight&quot;]};const{vtkErrorMacro:Gh}=jt;function Uh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push(&quot;vtkViewport&quot;),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Gh(&quot;call displayToView on your view instead&quot;),e.viewToDisplay=()=>Gh(&quot;callviewtodisplay on your view instead&quot;),e.getSize=()=>Gh(&quot;call getSize on your View instead&quot;),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=(&quot;PickPropFrom&quot;,()=>Gh(&quot;vtkViewport::PickPropFrom - NOT IMPLEMENTED&quot;))}const zh={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function Wh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zh,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),jt.setGetArray(e,t,[&quot;viewport&quot;],4),jt.setGetArray(e,t,[&quot;background&quot;,&quot;background2&quot;],3),Uh(e,t)}var Hh={newInstance:jt.newInstance(Wh,&quot;vtkViewport&quot;),extend:Wh};const{vtkDebugMacro:jh,vtkErrorMacro:Kh,vtkWarningMacro:$h}=Kt;function qh(e){return()=>Kh(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function Xh(e,t){t.classHierarchy.push(&quot;vtkRenderer&quot;);const n={type:&quot;ComputeVisiblePropBoundsEvent&quot;,renderer:e},r={type:&quot;ResetCameraClippingRangeEvent&quot;,renderer:e},o={type:&quot;ResetCameraEvent&quot;,renderer:e};e.updateCamera=()=>(t.activeCamera||(jh(&quot;No cameras are on, creating one.&quot;),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Kh(&quot;light has unknown light type&quot;,e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=qh(&quot;allocateTime&quot;),e.updateGeometry=qh(&quot;updateGeometry&quot;),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{jh(e.getClassName(),e,&quot;setting Layer to &quot;,n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:&quot;ActiveCameraEvent&quot;,camera:n}),!0),e.makeCamera=()=>{const t=Bh.newInstance();return e.invokeEvent({type:&quot;CreateCameraEvent&quot;,camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=kh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;WorldToView: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=ki.INIT_BOUNDS[0],t.allBounds[1]=ki.INIT_BOUNDS[1],t.allBounds[2]=ki.INIT_BOUNDS[2],t.allBounds[3]=ki.INIT_BOUNDS[3],t.allBounds[4]=ki.INIT_BOUNDS[4],t.allBounds[5]=ki.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),jh(&quot;Can't compute bounds, no 3D props are visible&quot;)),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return jh(&quot;Cannot reset camera!&quot;),!1;let i=null;if(!e.getActiveCamera())return Kh(&quot;Trying to reset non-existent camera&quot;),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&($h(&quot;Resetting view-up since view plane normal is parallel&quot;),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return jh(&quot;Cannot reset camera clipping range!&quot;),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Kh(&quot;Trying to reset clipping range of non-existent camera&quot;),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const Yh={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Zh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Yh,n),Hh.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,[&quot;_renderWindow&quot;,&quot;allocatedRenderTime&quot;,&quot;timeFactor&quot;,&quot;lastRenderTimeInSeconds&quot;,&quot;numberOfPropsRendered&quot;,&quot;lastRenderingUsedDepthPeeling&quot;,&quot;selector&quot;]),At(e,t,[&quot;twoSidedLighting&quot;,&quot;lightFollowCamera&quot;,&quot;automaticLightCreation&quot;,&quot;erase&quot;,&quot;draw&quot;,&quot;nearClippingPlaneTolerance&quot;,&quot;clippingRangeExpansion&quot;,&quot;backingStore&quot;,&quot;interactive&quot;,&quot;layer&quot;,&quot;preserveColorBuffer&quot;,&quot;preserveDepthBuffer&quot;,&quot;useDepthPeeling&quot;,&quot;occlusionRatio&quot;,&quot;maximumNumberOfPeels&quot;,&quot;delegate&quot;,&quot;backgroundTexture&quot;,&quot;texturedBackground&quot;,&quot;environmentTexture&quot;,&quot;environmentTextureDiffuseStrength&quot;,&quot;environmentTextureSpecularStrength&quot;,&quot;useEnvironmentTextureAsBackground&quot;,&quot;useShadows&quot;,&quot;pass&quot;]),It(e,t,[&quot;actors&quot;,&quot;volumes&quot;,&quot;lights&quot;]),Pt(e,t,[&quot;background&quot;],4,1),Ot(0,t,[&quot;renderWindow&quot;]),Xh(e,t)}var Qh={newInstance:Et(Zh,&quot;vtkRenderer&quot;),extend:Zh};const Jh=Object.create(null);function ev(e,t){Jh[e]=t}function tv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Jh[e]&&Jh[e](t)}function nv(e,t){t.classHierarchy.push(&quot;vtkRenderWindow&quot;),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return tv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6;const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join(&quot;\\n&quot;),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))}}const rv={defaultViewAPI:&quot;WebGL&quot;,renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1};function ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rv,n),jt.obj(e,t),jt.setGet(e,t,[&quot;interactor&quot;,&quot;numberOfLayers&quot;,&quot;_views&quot;,&quot;defaultViewAPI&quot;]),jt.get(e,t,[&quot;neverRendered&quot;]),jt.getArray(e,t,[&quot;renderers&quot;]),jt.moveToProtected(e,t,[&quot;views&quot;]),jt.event(e,t,&quot;completion&quot;),nv(e,t)}var av={newInstance:jt.newInstance(ov,&quot;vtkRenderWindow&quot;),extend:ov,registerViewConstructor:ev,listViewAPIs:function(){return Object.keys(Jh)},newAPISpecificView:tv};const iv={Unknown:0,LeftController:1,RightController:2},sv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var lv={Device:iv,Input:sv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:cv,Input:uv}=lv,{vtkWarningMacro:dv,vtkErrorMacro:pv,normalizeWheel:fv,vtkOnceErrorMacro:gv}=jt,mv={ctrlKey:!1,altKey:!1,shiftKey:!1},hv={&quot;xr-standard&quot;:[uv.Trigger,uv.Grip,uv.TrackPad,uv.Thumbstick,uv.A,uv.B]},vv=[&quot;StartAnimation&quot;,&quot;Animation&quot;,&quot;EndAnimation&quot;,&quot;PointerEnter&quot;,&quot;PointerLeave&quot;,&quot;MouseEnter&quot;,&quot;MouseLeave&quot;,&quot;StartMouseMove&quot;,&quot;MouseMove&quot;,&quot;EndMouseMove&quot;,&quot;LeftButtonPress&quot;,&quot;LeftButtonRelease&quot;,&quot;MiddleButtonPress&quot;,&quot;MiddleButtonRelease&quot;,&quot;RightButtonPress&quot;,&quot;RightButtonRelease&quot;,&quot;KeyPress&quot;,&quot;KeyDown&quot;,&quot;KeyUp&quot;,&quot;StartMouseWheel&quot;,&quot;MouseWheel&quot;,&quot;EndMouseWheel&quot;,&quot;StartPinch&quot;,&quot;Pinch&quot;,&quot;EndPinch&quot;,&quot;StartPan&quot;,&quot;Pan&quot;,&quot;EndPan&quot;,&quot;StartRotate&quot;,&quot;Rotate&quot;,&quot;EndRotate&quot;,&quot;Button3D&quot;,&quot;Move3D&quot;,&quot;StartPointerLock&quot;,&quot;EndPointerLock&quot;,&quot;StartInteraction&quot;,&quot;Interaction&quot;,&quot;EndInteraction&quot;,&quot;AnimationFrameRateUpdate&quot;];function yv(e){e.cancelable&&e.preventDefault()}function Tv(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function bv(e,t){t.classHierarchy.push(&quot;vtkRenderWindowInteractor&quot;);const n=new Set,r=new Map;let o=1;function a(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{pv(&quot;you want to call setView(view) instead of setRenderWindow on a vtk.js interactor&quot;)},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>dv(&quot;empty event loop&quot;),e.getCurrentRenderer=()=>(t.currentRenderer||a(0,0),t.currentRenderer);const i=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),o=n.getBoundingClientRect(),i=n.width/o.width,s=n.height/o.height,l={x:i*(e.clientX-o.left),y:s*(o.height-e.clientY+o.top),z:0};return(r.size<=1||!t.currentRenderer)&&a(l.x,l.y),l};function s(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function l(e){const t=s(e);return{key:e.key,keyCode:e.charCode,...t}}function c(e){return e.pointerType||&quot;&quot;}function u(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.bindEvents=n=>{t.container=n,n.addEventListener(&quot;contextmenu&quot;,yv),n.addEventListener(&quot;wheel&quot;,e.handleWheel),n.addEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.addEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.addEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.addEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.addEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.addEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.addEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.addEventListener(&quot;keypress&quot;,e.handleKeyPress),document.addEventListener(&quot;keydown&quot;,e.handleKeyDown),document.addEventListener(&quot;keyup&quot;,e.handleKeyUp),document.addEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),n.style.touchAction=&quot;none&quot;,n.style.userSelect=&quot;none&quot;,n.style.webkitTapHighlightColor=&quot;rgba(0,0,0,0)&quot;},e.unbindEvents=()=>{const{container:n}=t;n.removeEventListener(&quot;contextmenu&quot;,yv),n.removeEventListener(&quot;wheel&quot;,e.handleWheel),n.removeEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.removeEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.removeEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.removeEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.removeEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.removeEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.removeEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.removeEventListener(&quot;keypress&quot;,e.handleKeyPress),document.removeEventListener(&quot;keydown&quot;,e.handleKeyDown),document.removeEventListener(&quot;keyup&quot;,e.handleKeyUp),document.removeEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),t.container=null,r.clear()},e.handleKeyPress=t=>{const n=l(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=l(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=l(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerEnterEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerLeaveEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&yv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),r.has(n.pointerId)&&dv(&quot;[RenderWindowInteractor] duplicate pointerId detected&quot;),r.set(n.pointerId,{pointerId:n.pointerId,position:i(n)}),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(r.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&yv(n),r.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(r.has(t.pointerId))switch(r.delete(t.pointerId),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(r.has(t.pointerId)&&(r.get(t.pointerId).position=i(t)),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:pv(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=r=>{void 0!==r?n.has(r)?dv(&quot;requester is already registered for animating&quot;):(n.add(r),t.animationRequest||1!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):pv(&quot;undefined requester, can not start animating&quot;)},e.extendAnimation=r=>{const o=Date.now()+r;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(r){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.has(r))n.delete(r),t.animationRequest&&0===n.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=r&&r.getClassName?r.getClassName():r;dv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==n.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=n.gamepad,s=n.handedness;if(i){i.index in t.lastGamepadValues||(t.lastGamepadValues[i.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<i.buttons.length;++r)r in t.lastGamepadValues[i.index][s].buttons||(t.lastGamepadValues[i.index][s].buttons[r]=!1),t.lastGamepadValues[i.index][s].buttons[r]!==i.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,pressed:i.buttons[r].pressed,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController,input:hv[i.mapping]&&hv[i.mapping][r]?hv[i.mapping][r]:uv.Trigger}),t.lastGamepadValues[i.index][s].buttons[r]=i.buttons[r].pressed),t.lastGamepadValues[i.index][s].buttons[r]&&null!=a&&e.move3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController})}}))},e.handleMouseMove=n=>{const r={...s(n),position:i(n),deviceType:c(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const r=Date.now();t._animationFrameCount++,r-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(r-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=r,t._animationFrameCount=1),e.animationEvent(),u(),n.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{yv(n);const r={...fv(n),...s(n),position:i(n),deviceType:c(n)};0===t.wheelTimeoutID&&(o=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=o,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:pv(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);if(2===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture(&quot;TouchStart&quot;,t)}else if(1===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const o=[...r.values()];if(t.recognizeGestures)if(0===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonReleaseEvent(t)}else if(1===o.length){const t=Tv(r);e.recognizeGesture(&quot;TouchEnd&quot;,t);const a={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonPressEvent(a)}else{const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||u()},vv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void gv(&quot;\\n          Can not forward events without a current renderer on the interactor.\\n        &quot;);const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),&quot;TouchStart&quot;===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture=&quot;Start&quot;);if(&quot;TouchEnd&quot;===n)return&quot;Pinch&quot;===t.currentGesture&&(e.render(),e.endPinchEvent()),&quot;Rotate&quot;===t.currentGesture&&(e.render(),e.endRotateEvent()),&quot;Pan&quot;===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture=&quot;Start&quot;,void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,&quot;TouchMove&quot;===n)if(&quot;Start&quot;===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture=&quot;Pinch&quot;;const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture=&quot;Rotate&quot;;const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture=&quot;Pan&quot;;const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if(&quot;Rotate&quot;===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if(&quot;Pinch&quot;===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if(&quot;Pan&quot;===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e};const d=e.delete;e.delete=()=>{for(;n.size;)e.cancelAnimation(n.values().next().value);void 0!==document.hidden&&document.removeEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange),t.container&&e.unbindEvents(),d()},void 0!==document.hidden&&document.addEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange,!1)}const xv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:&quot;Start&quot;,animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,&quot;RenderEvent&quot;),vv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,[&quot;initialized&quot;,&quot;container&quot;,&quot;interactorStyle&quot;,&quot;lastFrameTime&quot;,&quot;recentAnimationFrameRate&quot;,&quot;_view&quot;]),jt.setGet(e,t,[&quot;lightFollowCamera&quot;,&quot;enabled&quot;,&quot;enableRender&quot;,&quot;recognizeGestures&quot;,&quot;desiredUpdateRate&quot;,&quot;stillUpdateRate&quot;,&quot;picker&quot;,&quot;preventDefaultOnPointerDown&quot;,&quot;preventDefaultOnPointerUp&quot;,&quot;mouseScrollDebounceByPass&quot;]),jt.moveToProtected(e,t,[&quot;view&quot;]),bv(e,t)}var Sv={newInstance:jt.newInstance(Cv,&quot;vtkRenderWindowInteractor&quot;),extend:Cv,handledEvents:vv,...lv};const{vtkErrorMacro:Av,VOID:Iv}=jt;function wv(e,t){t.classHierarchy.push(&quot;vtkInteractorObserver&quot;);const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Sv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):Iv),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Av(&quot;\\n          The interactor must be set before subscribing to events\\n        &quot;)),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const Pv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pv,n),jt.obj(e,t),jt.event(e,t,&quot;InteractionEvent&quot;),jt.event(e,t,&quot;StartInteractionEvent&quot;),jt.event(e,t,&quot;EndInteractionEvent&quot;),jt.get(e,t,[&quot;_interactor&quot;,&quot;enabled&quot;]),jt.setGet(e,t,[&quot;priority&quot;,&quot;processEvents&quot;]),jt.moveToProtected(e,t,[&quot;interactor&quot;]),wv(e,t)}var Rv={newInstance:jt.newInstance(Ov,&quot;vtkInteractorObserver&quot;),extend:Ov,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},Mv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Dv}=Mv,Ev={Rotate:Dv.IS_ROTATE,Pan:Dv.IS_PAN,Spin:Dv.IS_SPIN,Dolly:Dv.IS_DOLLY,CameraPose:Dv.IS_CAMERA_POSE,WindowLevel:Dv.IS_WINDOW_LEVEL,Slice:Dv.IS_SLICE};function Vv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyle&quot;),Object.keys(Ev).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Dv.IS_NONE&&(t.state=Ev[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:&quot;StartInteractionEvent&quot;}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Ev[n]&&(t.state=Dv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:&quot;EndInteractionEvent&quot;}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case&quot;r&quot;:case&quot;R&quot;:e.pokedRenderer.resetCamera(),n.render();break;case&quot;w&quot;:case&quot;W&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case&quot;s&quot;:case&quot;S&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case&quot;v&quot;:case&quot;V&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Lv={state:Dv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function Bv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lv,n),Rv.extend(e,t,n),Vv(e,t)}var Nv={newInstance:jt.newInstance(Bv,&quot;vtkInteractorStyle&quot;),extend:Bv,...Mv};const{States:_v}=Mv;function Fv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyleTrackballCamera&quot;),e.handleMouseMove=n=>{const r=n.position,o=n.pokedRenderer;switch(t.state){case _v.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad?!n||n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad||t.state!==_v.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===_v.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const t=e.pokedRenderer.getActiveCamera(),n=t.getPhysicalTranslation(),r=.025*t.getPhysicalScale(),o=t.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);t.setPhysicalTranslation(n[0]+o[0]*r,n[1]+o[1]*r,n[2]+o[2]*r)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case _v.IS_DOLLY:e.endDolly();break;case _v.IS_PAN:e.endPan();break;case _v.IS_SPIN:e.endSpin();break;case _v.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(n.pokedRenderer,n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=n.pokedRenderer.getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(n.pokedRenderer,o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(n.pokedRenderer,o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(n.pokedRenderer,o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&n.pokedRenderer.updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=e.pokedRenderer.getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(n.pokedRenderer,r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const kv={motionFactor:10,zoomFactor:10};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Nv.extend(e,t,n),jt.setGet(e,t,[&quot;motionFactor&quot;,&quot;zoomFactor&quot;]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,&quot;vtkInteractorStyleTrackballCamera&quot;),extend:Gv};function zv(e){return e}function Wv(e){return null===e||&quot;null&quot;===e?null:&quot;true&quot;===e||&quot;false&quot;!==e&&(void 0!==e&&&quot;undefined&quot;!==e?&quot;[&quot;===e[0]&&&quot;]&quot;===e[e.length-1]?e.substring(1,e.length-1).split(&quot;,&quot;).map((e=>Wv(e.trim()))):&quot;&quot;===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var Hv=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?Wv:zv,o=(t||&quot;&quot;).replace(/#.*/,&quot;&quot;).replace(&quot;?&quot;,&quot;&quot;).split(&quot;&&quot;);return o.forEach((e=>{const[t,o]=e.split(&quot;=&quot;).map((e=>decodeURIComponent(e)));t&&(n[t]=!o||r(o))})),n};function jv(e,t){t.classHierarchy.push(&quot;vtkRenderPass&quot;),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const Kv={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),jt.obj(e,t),jt.get(e,t,[&quot;currentOperation&quot;]),jt.setGet(e,t,[&quot;delegates&quot;,&quot;_currentParent&quot;,&quot;preDelegateOperations&quot;,&quot;postDelegateOperations&quot;]),jt.moveToProtected(e,t,[&quot;currentParent&quot;]),jv(e,t)}var qv={newInstance:jt.newInstance($v,&quot;vtkRenderPass&quot;),extend:$v};const{Representation:Xv}=ds,{vtkErrorMacro:Yv}=jt;function Zv(e){const t=cd.substitute(e.Fragment,&quot;//VTK::RenderPassFragmentShader::Impl&quot;,&quot;\\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\\n      gl_FragData[1].r = weight;\\n    &quot;,!1);e.Fragment=t.result}function Qv(e,t){t.classHierarchy.push(&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Es.newInstance({numberOfComponents:3,values:e});o.setName(&quot;points&quot;);const a=Es.newInstance({numberOfComponents:2,values:n});a.setName(&quot;tcoords&quot;);const i=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,&quot;polys&quot;,Xv.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Nd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,&quot;Float32Array&quot;,null),t.translucentRTexture=Nd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,&quot;Float32Array&quot;,null),t.translucentZTexture=Nd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],&quot;Float32Array&quot;,null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;attribute vec2 tcoordTC;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = tcoordTC; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),&quot;//VTK::System::Dec\\n\\nin vec2 tcoord;\\n\\nuniform sampler2D translucentRTexture;\\nuniform sampler2D translucentRGBATexture;\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\\n  float t2Color = texture(translucentRTexture, tcoord).r;\\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\\n}\\n&quot;,&quot;&quot;)},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;tcoordTC&quot;,t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;)},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension(&quot;EXT_color_buffer_half_float&quot;)&&!i.getExtension(&quot;EXT_color_buffer_float&quot;))return e.setCurrentOperation(&quot;translucentPass&quot;),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation(&quot;opaqueZBufferPass&quot;),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation(&quot;translucentPass&quot;),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi(&quot;translucentRGBATexture&quot;,t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi(&quot;translucentRTexture&quot;,t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate()},e.getShaderReplacement=()=>t._supported?Zv:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const Jv={framebuffer:null,copyShader:null,tris:null};function ey(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jv,n),qv.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),jt.get(e,t,[&quot;framebuffer&quot;]),Qv(e,t)}var ty={newInstance:jt.newInstance(ey,&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),extend:ey};function ny(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];if(s.getDraw()&&s.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=Hp.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation(&quot;zBufferPass&quot;),i.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation(&quot;opaquePass&quot;),i.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=ty.newInstance()),t.translucentPass.traverse(n,i,e)),t.volumeCount>0&&(e.setCurrentOperation(&quot;volumePass&quot;),i.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation(&quot;overlayPass&quot;),i.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const ry={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ry,n),qv.extend(e,t,n),jt.get(e,t,[&quot;framebuffer&quot;,&quot;opaqueActorCount&quot;,&quot;translucentActorCount&quot;,&quot;volumeCount&quot;]),ny(e,t)}var ay={newInstance:jt.newInstance(oy,&quot;vtkForwardPass&quot;),extend:oy},iy=n(594),sy=n.n(iy);const ly=[&quot;lastShaderProgramBound&quot;,&quot;context&quot;,&quot;_openGLRenderWindow&quot;];function cy(e,t){t.classHierarchy.push(&quot;vtkShaderCache&quot;),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=cd.substitute(o,&quot;VSOut&quot;,&quot;GSOut&quot;).result);const a=t._openGLRenderWindow.getWebgl2();let i=&quot;\\n&quot;,s=&quot;#version 100\\n&quot;;a?s=&quot;#version 300 es\\n#define attribute in\\n#define textureCube texture\\n#define texture2D texture\\n#define textureCubeLod textureLod\\n#define texture2DLod textureLod\\n&quot;:(t.context.getExtension(&quot;OES_standard_derivatives&quot;),t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(i=&quot;#extension GL_EXT_frag_depth : enable\\n&quot;),t.context.getExtension(&quot;EXT_shader_texture_lod&quot;)&&(i+=&quot;#extension GL_EXT_shader_texture_lod : enable\\n#define textureCubeLod textureCubeLodEXT\\n#define texture2DLod texture2DLodEXT&quot;)),o=cd.substitute(o,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,a?&quot;&quot;:&quot;#extension GL_OES_standard_derivatives : enable\\n&quot;,i,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;let l=cd.substitute(e,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;if(a){l=cd.substitute(l,&quot;varying&quot;,&quot;out&quot;).result,o=cd.substitute(o,&quot;varying&quot;,&quot;in&quot;).result;let e=&quot;&quot;,t=0;for(;o.includes(`gl_FragData[${t}]`);)o=cd.substitute(o,`gl_FragData\\\\[${t}\\\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\\n`,t++;o=cd.substitute(o,&quot;//VTK::Output::Dec&quot;,e).result}return{VSSource:l,FSSource:o,GSSource:cd.substitute(r,&quot;//VTK::System::Dec&quot;,s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=sy().hash(o);if(!(a in t.shaderPrograms)){const o=cd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const uy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,ly),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cy(e,t)}var py={newInstance:jt.newInstance(dy,&quot;vtkShaderCache&quot;),extend:dy};const{vtkErrorMacro:fy}=jt;function gy(e,t){t.classHierarchy.push(&quot;vtkOpenGLTextureUnitManager&quot;),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&fy(&quot;some texture units  were not properly released&quot;);t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const my={context:null,numberOfTextureUnits:0,textureUnits:0};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,[&quot;numberOfTextureUnits&quot;]),jt.setGet(e,t,[&quot;context&quot;]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,&quot;vtkOpenGLTextureUnitManager&quot;),extend:hy};function yy(e,t){t.classHierarchy.push(&quot;vtkRenderWindowViewNode&quot;),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.createSelector=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)}}const Ty={size:void 0,selector:void 0};function by(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ty,n),t.size||(t.size=[300,300]),jt.getArray(e,t,[&quot;size&quot;],2),jt.get(e,t,[&quot;selector&quot;]),Zt.extend(e,t,n),yy(e,t)}var xy={newInstance:jt.newInstance(by,&quot;vtkRenderWindowViewNode&quot;),extend:by};const{vtkDebugMacro:Cy,vtkErrorMacro:Sy}=jt,Ay={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Iy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let wy=0;const Py=[];function Oy(){wy++,Py.forEach((e=>e(wy)))}function Ry(){wy--,Py.forEach((e=>e(wy)))}function My(e){e.preventDefault()}function Dy(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderWindow&quot;);const n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if(&quot;__getUnderlyingContext&quot;===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}();e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener(&quot;webglcontextlost&quot;,My,!1),t.canvas.addEventListener(&quot;webglcontextrestored&quot;,e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow(e)}))}},e.initialize=()=>{if(!t.initialized){t.context=e.get3DContext(),t.textureUnitManager=vy.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND),t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Sy(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.activeFramebuffer?t.activeFramebuffer.getSize():t.size,e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:&quot;high-performance&quot;},r=null;const o=&quot;undefined&quot;!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext(&quot;webgl2&quot;,e),r&&(t.webgl2=!0,Cy(&quot;using webgl2&quot;))),r||(Cy(&quot;using webgl1&quot;),r=t.canvas.getContext(&quot;webgl&quot;,e)||t.canvas.getContext(&quot;experimental-webgl&quot;,e)),new Proxy(r,n)},e.restoreContext=()=>{const t=qv.newInstance();t.setCurrentOperation(&quot;Release&quot;),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?Sy(&quot;Hardware does not support the number of textures defined.&quot;):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case ys.CHAR:case ys.SIGNED_CHAR:case ys.UNSIGNED_CHAR:return 1;case n:case r:case ys.UNSIGNED_SHORT:case ys.SHORT:case ys.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case ys.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&ys.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&ys.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return t.context.R16F;case 2:return t.context.RG16F;case 3:return t.context.RGB16F;default:return t.context.RGBA16F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Ay,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension(&quot;OES_texture_float&quot;),o=n.getExtension(&quot;OES_texture_half_float&quot;),a=n.getExtension(&quot;WEBGL_debug_renderer_info&quot;),i=n.getExtension(&quot;WEBGL_draw_buffers&quot;),s=n.getExtension(&quot;EXT_texture_filter_anisotropic&quot;)||n.getExtension(&quot;WEBKIT_EXT_texture_filter_anisotropic&quot;),l=[[&quot;Max Vertex Attributes&quot;,&quot;MAX_VERTEX_ATTRIBS&quot;,n.getParameter(n.MAX_VERTEX_ATTRIBS)],[&quot;Max Varying Vectors&quot;,&quot;MAX_VARYING_VECTORS&quot;,n.getParameter(n.MAX_VARYING_VECTORS)],[&quot;Max Vertex Uniform Vectors&quot;,&quot;MAX_VERTEX_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],[&quot;Max Fragment Uniform Vectors&quot;,&quot;MAX_FRAGMENT_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],[&quot;Max Fragment Texture Image Units&quot;,&quot;MAX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],[&quot;Max Vertex Texture Image Units&quot;,&quot;MAX_VERTEX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],[&quot;Max Combined Texture Image Units&quot;,&quot;MAX_COMBINED_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],[&quot;Max 2D Texture Size&quot;,&quot;MAX_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_TEXTURE_SIZE)],[&quot;Max Cube Texture Size&quot;,&quot;MAX_CUBE_MAP_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],[&quot;Max Texture Anisotropy&quot;,&quot;MAX_TEXTURE_MAX_ANISOTROPY_EXT&quot;,s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],[&quot;Point Size Range&quot;,&quot;ALIASED_POINT_SIZE_RANGE&quot;,n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(&quot; - &quot;)],[&quot;Line Width Range&quot;,&quot;ALIASED_LINE_WIDTH_RANGE&quot;,n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(&quot; - &quot;)],[&quot;Max Viewport Dimensions&quot;,&quot;MAX_VIEWPORT_DIMS&quot;,n.getParameter(n.MAX_VIEWPORT_DIMS).join(&quot; - &quot;)],[&quot;Max Renderbuffer Size&quot;,&quot;MAX_RENDERBUFFER_SIZE&quot;,n.getParameter(n.MAX_RENDERBUFFER_SIZE)],[&quot;Framebuffer Red Bits&quot;,&quot;RED_BITS&quot;,n.getParameter(n.RED_BITS)],[&quot;Framebuffer Green Bits&quot;,&quot;GREEN_BITS&quot;,n.getParameter(n.GREEN_BITS)],[&quot;Framebuffer Blue Bits&quot;,&quot;BLUE_BITS&quot;,n.getParameter(n.BLUE_BITS)],[&quot;Framebuffer Alpha Bits&quot;,&quot;ALPHA_BITS&quot;,n.getParameter(n.ALPHA_BITS)],[&quot;Framebuffer Depth Bits&quot;,&quot;DEPTH_BITS&quot;,n.getParameter(n.DEPTH_BITS)],[&quot;Framebuffer Stencil Bits&quot;,&quot;STENCIL_BITS&quot;,n.getParameter(n.STENCIL_BITS)],[&quot;Framebuffer Subpixel Bits&quot;,&quot;SUBPIXEL_BITS&quot;,n.getParameter(n.SUBPIXEL_BITS)],[&quot;MSAA Samples&quot;,&quot;SAMPLES&quot;,n.getParameter(n.SAMPLES)],[&quot;MSAA Sample Buffers&quot;,&quot;SAMPLE_BUFFERS&quot;,n.getParameter(n.SAMPLE_BUFFERS)],[&quot;Supported Formats for UByte Render Targets     &quot;,&quot;UNSIGNED_BYTE RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.UNSIGNED_BYTE)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.UNSIGNED_BYTE)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.UNSIGNED_BYTE)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Half Float Render Targets&quot;,&quot;HALF FLOAT RENDER TARGET FORMATS&quot;,[o&&Iy(n,n.RGBA,o.HALF_FLOAT_OES)?&quot;RGBA&quot;:&quot;&quot;,o&&Iy(n,n.RGB,o.HALF_FLOAT_OES)?&quot;RGB&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?&quot;LUMINANCE&quot;:&quot;&quot;,o&&Iy(n,n.ALPHA,o.HALF_FLOAT_OES)?&quot;ALPHA&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Full Float Render Targets&quot;,&quot;FLOAT RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.FLOAT)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.FLOAT)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.FLOAT)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.FLOAT)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.FLOAT)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Max Multiple Render Targets Buffers&quot;,&quot;MAX_DRAW_BUFFERS_WEBGL&quot;,i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],[&quot;High Float Precision in Vertex Shader&quot;,&quot;HIGH_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Vertex Shader&quot;,&quot;MEDIUM_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Vertex Shader&quot;,&quot;LOW_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Float Precision in Fragment Shader&quot;,&quot;HIGH_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Fragment Shader&quot;,&quot;MEDIUM_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Fragment Shader&quot;,&quot;LOW_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Vertex Shader&quot;,&quot;HIGH_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Vertex Shader&quot;,&quot;MEDIUM_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Vertex Shader&quot;,&quot;LOW_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Fragment Shader&quot;,&quot;HIGH_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Fragment Shader&quot;,&quot;MEDIUM_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Fragment Shader&quot;,&quot;LOW_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Supported Extensions&quot;,&quot;EXTENSIONS&quot;,n.getSupportedExtensions().join(&quot;<br/>\\t\\t\\t\\t\\t    &quot;)],[&quot;WebGL Renderer&quot;,&quot;RENDERER&quot;,n.getParameter(n.RENDERER)],[&quot;WebGL Vendor&quot;,&quot;VENDOR&quot;,n.getParameter(n.VENDOR)],[&quot;WebGL Version&quot;,&quot;VERSION&quot;,n.getParameter(n.VERSION)],[&quot;Shading Language Version&quot;,&quot;SHADING_LANGUAGE_VERSION&quot;,n.getParameter(n.SHADING_LANGUAGE_VERSION)],[&quot;Unmasked Renderer&quot;,&quot;UNMASKED_RENDERER&quot;,a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],[&quot;Unmasked Vendor&quot;,&quot;UNMASKED_VENDOR&quot;,a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],[&quot;WebGL Version&quot;,&quot;WEBGL_VERSION&quot;,t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}()},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=df.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((function(){t.canvas.removeEventListener(&quot;webglcontextlost&quot;,My),t.canvas.removeEventListener(&quot;webglcontextrestored&quot;,e.restoreContext)}),e.delete,e.setViewStream,Ry),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.getGraphicsResourceForObject=e=>e?{vtkObj:t._graphicsResources.get(e),hash:t._graphicsResourceHash.get(e)}:null,e.setGraphicsResourceForObject=(e,n,r)=>{e&&(t._graphicsResources.set(e,n),t._graphicsResourceHash.set(e,r))},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach(((t,n)=>{e+=t.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResourcesForObject=n=>!!n&&(t._graphicsResources.get(n)?.releaseGraphicsResources(e),t._graphicsResources.delete(n)&&t._graphicsResourceHash.delete(n)),e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach(((t,n)=>{t.releaseGraphicsResources(e)})),t._graphicsResources.clear(),t._graphicsResourceHash.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))}}const Ey={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1};const Vy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),xy.extend(e,t,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,Oy(),t.selector||(t.selector=df.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,t._textureResourceIds=new Map,t._graphicsResources=new Map,t._graphicsResourceHash=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Vy),t.shaderCache=py.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=ay.newInstance(),jt.event(e,t,&quot;imageReady&quot;),jt.get(e,t,[&quot;shaderCache&quot;,&quot;textureUnitManager&quot;,&quot;webgl2&quot;,&quot;useBackgroundImage&quot;,&quot;activeFramebuffer&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;defaultToWebgl2&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Dy(e,t)}),&quot;vtkOpenGLRenderWindow&quot;);function Ly(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderModule&quot;),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}ev(&quot;WebGL&quot;,Vy);const By={device:null,handle:null};function Ny(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,By,n),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;handle&quot;]),Ly(e,t)}var _y={newInstance:jt.newInstance(Ny,&quot;vtkWebGPUShaderModule&quot;),extend:Ny};function Fy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderCache&quot;),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=_y.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const ky={shaderModules:null,device:null,window:null};function Gy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ky,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;,&quot;window&quot;]),Fy(e,t)}var Uy={newInstance:jt.newInstance(Gy,&quot;vtkWebGPUShaderCache&quot;),extend:Gy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join(&quot;\\n&quot;):n;let a=!1;-1!==e.search(t)&&(a=!0);let i=&quot;&quot;;r&&(i=&quot;g&quot;);const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function zy(e,t){t.classHierarchy.push(&quot;vtkWebGPUBindGroup&quot;),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join(&quot;\\n&quot;)}}const Wy={device:null,handle:null,label:null};function Hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;label&quot;,&quot;device&quot;,&quot;arrayInformation&quot;]),zy(e,t)}var jy={newInstance:jt.newInstance(Hy),extend:Hy};function Ky(e,t){t.classHierarchy.push(&quot;vtkWebGPUPipeline&quot;),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);&quot;vertex&quot;===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint=&quot;main&quot;),&quot;fragment&quot;===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint=&quot;main&quot;)}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const $y={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$y,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,[&quot;handle&quot;,&quot;pipelineDescription&quot;]),At(e,t,[&quot;device&quot;,&quot;renderEncoder&quot;,&quot;topology&quot;,&quot;vertexState&quot;]),Ky(e,t)}var Xy={newInstance:Et(qy,&quot;vtkWebGPUPipeline&quot;),extend:qy};function Yy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderDescription&quot;),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push(&quot;};&quot;),o=n,r[r.length-1]+=&quot;,&quot;,r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Input&quot;,r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push(&quot;};&quot;),o=o.concat(e),t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Output&quot;,[`-> ${t.type}Output`]).result}t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Dec&quot;,o).result}}const Zy={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function Qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zy,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,[&quot;type&quot;,&quot;hash&quot;,&quot;code&quot;]),jt.getArray(e,t,[&quot;outputTypes&quot;,&quot;outputNames&quot;,&quot;outputInterpolations&quot;]),Yy(e,t)}var Jy={newInstance:jt.newInstance(Qy,&quot;vtkWebGPUShaderDescription&quot;),extend:Qy};const eT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;sint&quot;},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;uint&quot;},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:&quot;sint&quot;},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:&quot;float&quot;},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;uint&quot;},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;sint&quot;},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:&quot;uint&quot;},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:&quot;sint&quot;},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:&quot;uint&quot;},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:&quot;sint&quot;},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:&quot;float&quot;},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;rgba8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;uint&quot;},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;sint&quot;},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;bgra8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:&quot;float&quot;},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:&quot;uint&quot;},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:&quot;sint&quot;},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:&quot;uint&quot;},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:&quot;sint&quot;},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:&quot;float&quot;},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:&quot;uint&quot;},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:&quot;sint&quot;},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:&quot;unfilterable-float&quot;},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;depth&quot;},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:&quot;depth&quot;},&quot;depth24plus-stencil8&quot;:{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:&quot;mixed&quot;},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;depth&quot;}};var tT=function(e){return!e||e.length<6?0:e in eT==1?eT[e]:(et(`unknown format ${e}`),null)},nT=function(e){if(!e||e.length<5)return 0;let t=1;&quot;x&quot;===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},rT=function(e){if(!e||e.length<5)return 0;let t;if(&quot;f&quot;===e[0])t=&quot;Float&quot;;else if(&quot;s&quot;===e[0])t=&quot;Int&quot;;else{if(&quot;u&quot;!==e[0])return void et(`unknown format ${e}`);t=&quot;Uint&quot;}const n=e.split(&quot;x&quot;)[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+=&quot;Array&quot;,t;et(`unknown format ${e}`)},oT=function(e){let t;if(&quot;f&quot;===e[0]||&quot;n&quot;===e[1])t=&quot;f32&quot;;else if(&quot;s&quot;===e[0]&&&quot;i&quot;===e[1])t=&quot;i32&quot;;else{if(&quot;u&quot;!==e[0]||&quot;i&quot;!==e[1])return void et(`unknown format ${e}`);t=&quot;u32&quot;}let n=1;return&quot;x&quot;===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},aT=function(e){if(!e)return 0;let t=1;return&quot;vec&quot;===e.substring(0,3)?t=Number(e[3]):&quot;mat&quot;===e.substring(0,3)&&(t=e[3]*e[5]),4*t},iT=function(e){if(e)return e.includes(&quot;f32&quot;)?&quot;Float32Array&quot;:e.includes(&quot;i32&quot;)?&quot;Int32Array&quot;:e.includes(&quot;u32&quot;)?&quot;Uint32Array&quot;:void et(`unknown format ${e}`)};function sT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function lT(e,t){t.classHierarchy.push(&quot;vtkWebGPUVertexInput&quot;),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:&quot;vertex&quot;,o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(sT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e=&quot;&quot;,n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=oT(a.format);n>0&&(e+=&quot;,\\n&quot;),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const cT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function uT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,[&quot;created&quot;,&quot;device&quot;,&quot;handle&quot;,&quot;indexBuffer&quot;]),lT(e,t)}var dT={newInstance:Et(uT,&quot;vtkWebGPUVertexInput&quot;),extend:uT};const pT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  // var vertex: vec4<f32> = vertexBC;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n&quot;,fT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function gT(e,t){t.classHierarchy.push(&quot;vtkWebGPUSimpleMapper&quot;),e.generateShaderDescriptions=(n,r,o)=>{const a=Jy.newInstance({type:&quot;vertex&quot;,hash:n,code:t.vertexShaderTemplate}),i=Jy.newInstance({type:&quot;fragment&quot;,hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp(&quot;//VTK::[^:]*::&quot;,&quot;g&quot;),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];&quot;replaceShaderIOStructs&quot;!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.replaceShaderCode(null,n),t.getShaderDescription(&quot;fragment&quot;).replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set(&quot;replaceShaderRenderEncoder&quot;,e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderRenderer&quot;,e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);s.addBuiltinInput(&quot;bool&quot;,&quot;@builtin(front_facing) frontFacing&quot;),i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderMapper&quot;,e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;    output.Position = rendererUBO.SCPCMatrix*vertexBC;&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription(&quot;vertex&quot;).addOutput(&quot;vec2<f32>&quot;,&quot;tcoordVS&quot;)},t.shaderReplacements.set(&quot;replaceShaderTCoord&quot;,e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=Xy.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const mT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:&quot;triangle-list&quot;,UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function hT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=dT.newInstance(),t.bindGroup=jy.newInstance({label:&quot;mapperBG&quot;}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||fT,t.vertexShaderTemplate=t.vertexShaderTemplate||pT,t.shaderReplacements=new Map,jt.get(e,t,[&quot;pipeline&quot;,&quot;vertexInput&quot;]),jt.setGet(e,t,[&quot;additionalBindables&quot;,&quot;device&quot;,&quot;fragmentShaderTemplate&quot;,&quot;interpolate&quot;,&quot;numberOfInstances&quot;,&quot;numberOfVertices&quot;,&quot;pipelineHash&quot;,&quot;shaderReplacements&quot;,&quot;SSBO&quot;,&quot;textureViews&quot;,&quot;topology&quot;,&quot;UBO&quot;,&quot;vertexShaderTemplate&quot;,&quot;WebGPURenderer&quot;]),gT(e,t)}var vT={newInstance:jt.newInstance(hT,&quot;vtkWebGPUSimpleMapper&quot;),extend:hT};function yT(e,t){t.classHierarchy.push(&quot;vtkWebGPUFullScreenQuad&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;),r.addOutput(&quot;vec4<f32>&quot;,&quot;vertexVC&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;,&quot;output.vertexVC = vec4<f32>(vertexBC, 1);&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,[&quot;vertexBC&quot;]),t.numberOfVertices=6}}const TT={};function bT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,TT,n),vT.extend(e,t,n),yT(e,t)}var xT={newInstance:jt.newInstance(bT,&quot;vtkWebGPUFullScreenQuad&quot;),extend:bT};const CT=[&quot;setBindGroup&quot;,&quot;setIndexBuffer&quot;,&quot;setVertexBuffer&quot;,&quot;draw&quot;,&quot;drawIndexed&quot;];function ST(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderEncoder&quot;),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!(&quot;depthStencil&quot;in n))console.log(&quot;mismatched depth attachments&quot;),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\\n${o}\\n versus pipeline\\n${a}\\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<CT.length;n++)e[CT[n]]=function(){return t.handle[CT[n]](...arguments)}}const AT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function IT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}],depthStencilAttachment:{view:void 0,depthLoadOp:&quot;clear&quot;,depthClearValue:0,depthStoreOp:&quot;store&quot;}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = computedColor;&quot;]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater-equal&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}},t.colorTextureViews=[],bt(e,t,[&quot;boundPipeline&quot;,&quot;colorTextureViews&quot;]),At(e,t,[&quot;depthTextureView&quot;,&quot;description&quot;,&quot;handle&quot;,&quot;label&quot;,&quot;pipelineHash&quot;,&quot;pipelineSettings&quot;,&quot;replaceShaderCodeFunction&quot;]),ST(e,t)}var wT={newInstance:Et(IT,&quot;vtkWebGPURenderEncoder&quot;),extend:IT},PT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const OT=[&quot;getMappedRange&quot;,&quot;mapAsync&quot;,&quot;unmap&quot;];function RT(e,t){t.classHierarchy.push(&quot;vtkWebGPUBuffer&quot;),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<OT.length;n++)e[OT[n]]=function(){return t.handle[OT[n]](...arguments)}}const MT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;strideInBytes&quot;,&quot;device&quot;,&quot;arrayInformation&quot;,&quot;label&quot;,&quot;sourceTime&quot;]),RT(e,t)}var ET={newInstance:jt.newInstance(DT),extend:DT,...PT};const{Representation:VT}=ds,{PrimitiveTypes:LT}=PT;class BT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function NT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function _T(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=NT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=NT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=NT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=NT(n,o,t),n.ibo[n.iboId++]=a}function FT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let kT;const GT=new Uint32Array(1),UT=new Uint32Array(2),zT=new Uint32Array(3),WT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)GT[0]=t[n+a],kT(GT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)UT[0]=t[n+a],UT[1]=t[n+(a+1)%e],kT(UT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o);for(let a=0;a<e-2;a++)UT[0]=t[n+a],UT[1]=t[n+a+2],kT(UT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n],zT[1]=t[n+a+1],zT[2]=t[n+a+2],kT(zT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n+a],zT[1]=t[n+a+1+a%2],zT[2]=t[n+a+1+(a+1)%2],kT(zT,r,o)}};function HT(e,t){t.classHierarchy.push(&quot;vtkWebGPUIndexBuffer&quot;),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case LT.Points:return&quot;points&quot;;case LT.Lines:return&quot;lines&quot;;case LT.Triangles:case LT.TriangleEdges:return&quot;polys&quot;;case LT.TriangleStripEdges:case LT.TriangleStrips:return&quot;strips&quot;;default:return&quot;&quot;}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new BT};let d=null;d=o===VT.POINTS||r===LT.Points?WT.anythingToPoints:o===VT.WIREFRAME||r===LT.Lines?WT[`${l}ToWireframe`]:WT[`${l}ToSurface`],kT=FT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format=&quot;uint16&quot;):(u.ibo=new Uint32Array(u.iboSize),e.format=&quot;uint32&quot;),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),kT=_T,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const jT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function KT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jT,n),ET.extend(e,t,n),jt.setGet(e,t,[&quot;flatIdToPointId&quot;,&quot;flatIdToCellId&quot;,&quot;flatSize&quot;,&quot;indexCount&quot;]),HT(e,t)}var $T={newInstance:jt.newInstance(KT),extend:KT,...PT};const{BufferUsage:qT}=PT,{vtkErrorMacro:XT}=Kt,{VtkDataTypes:YT}=Es;function ZT(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,&quot;packExtra&quot;)&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function QT(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function JT(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===qT.Index&&(n=$T.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=ET.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===qT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===qT.PointArray){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=ZT(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?&quot;flat&quot;:&quot;perspective&quot;}])}if(e.usage===qT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=QT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=ZT(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:&quot;flat&quot;}])}return e.usage===qT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push(&quot;vtkWebGPUBufferManager&quot;),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case YT.UNSIGNED_CHAR:t=&quot;uint8&quot;;break;case YT.FLOAT:t=&quot;float32&quot;;break;case YT.UNSIGNED_INT:t=&quot;uint32&quot;;break;case YT.INT:t=&quot;sint32&quot;;break;case YT.DOUBLE:t=&quot;float32&quot;;break;case YT.UNSIGNED_SHORT:t=&quot;uint16&quot;;break;case YT.SHORT:t=&quot;sin16&quot;;break;default:t=&quot;float32&quot;}switch(e.getNumberOfComponents()){case 2:t+=&quot;x2&quot;;break;case 3:t.includes(&quot;32&quot;)||XT(`unsupported x3 type for ${t}`),t+=&quot;x3&quot;;break;case 4:t+=&quot;x4&quot;}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:qT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=ET.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:&quot;float32x3&quot;}]),t.fullScreenQuadBuffer}}const eb={device:null,fullScreenQuadBuffer:null};function tb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eb,n),yt(e,t),At(e,t,[&quot;device&quot;]),JT(e,t)}var nb={newInstance:Et(tb),extend:tb,...PT};function rb(e,t){t.classHierarchy.push(&quot;vtkWebGPUSampler&quot;),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:&quot;clamp-to-edge&quot;,t.options.addressModeV=n.addressModeV?n.addressModeV:&quot;clamp-to-edge&quot;,t.options.addressModeW=n.addressModeW?n.addressModeW:&quot;clamp-to-edge&quot;,t.options.magFilter=n.magFilter?n.magFilter:&quot;nearest&quot;,t.options.minFilter=n.minFilter?n.minFilter:&quot;nearest&quot;,t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:&quot;nearest&quot;,t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const ob={device:null,handle:null,label:null,options:null};function ab(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ob,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;options&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;]),rb(e,t)}var ib={newInstance:jt.newInstance(ab),extend:ab};function sb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTextureView&quot;),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r=&quot;f32&quot;;&quot;sint&quot;===t.bindGroupLayoutEntry.texture.sampleType?r=&quot;i32&quot;:&quot;uint&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(r=&quot;u32&quot;);let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return&quot;depth&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=ib.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const lb={texture:null,handle:null,sampler:null,label:null};function cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:&quot;float&quot;,viewDimension:&quot;2d&quot;}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;texture&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;sampler&quot;]),sb(e,t)}var ub={newInstance:jt.newInstance(cb),extend:cb};const{BufferUsage:db}=nb;function pb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTexture&quot;),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?&quot;2d&quot;:&quot;3d&quot;;t.format=n.format?n.format:&quot;rgba8unorm&quot;,t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:&quot;rgba8unorm&quot;,t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format=&quot;rgba8unorm&quot;,n.flip=!0,n.nativeArray=n.jsImageData.data);const o=tT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&&quot;float&quot;===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?&quot;Uint16Array&quot;:i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Ad.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement(&quot;canvas&quot;);e.width=n.image.width,e.height=n.image.height;const t=e.getContext(&quot;2d&quot;);t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Tu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:db.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:db.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=tT(t.format);return 2===e.elementSize&&&quot;float&quot;===e.sampleType?1:255},e.getNumberOfComponents=()=>tT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?&quot;2d&quot;:&quot;3d&quot;);const o=ub.newInstance({label:n});return o.create(e,r),o}}const fb={device:null,handle:null,buffer:null,ready:!1,label:null};function gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fb,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;ready&quot;,&quot;width&quot;,&quot;height&quot;,&quot;depth&quot;,&quot;format&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;label&quot;]),pb(e,t)}var mb={newInstance:jt.newInstance(gb),extend:gb};function hb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOpaquePass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;opaquePassColor&quot;}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView(&quot;opaquePassColorTexture&quot;);t.renderEncoder.setColorTextureView(0,n),t.depthFormat=&quot;depth32float&quot;,t.depthTexture=mb.newInstance({label:&quot;opaquePassDepth&quot;}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;opaquePassDepthTexture&quot;);t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;opaquePass&quot;),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=wT.newInstance({label:&quot;OpaquePass&quot;}),t.renderEncoder.setPipelineHash(&quot;op&quot;)}}const vb={renderEncoder:null,colorTexture:null,depthTexture:null};function yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vb,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),hb(e,t)}var Tb={newInstance:jt.newInstance(yb,&quot;vtkWebGPUOpaquePass&quot;),extend:yb};function bb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=mb.newInstance({label:&quot;translucentPassColor&quot;}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView(&quot;oitpColorTexture&quot;);t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=mb.newInstance({label:&quot;translucentPassAccumulate&quot;}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView(&quot;oitpAccumTexture&quot;);t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=xT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash(&quot;oitpfsq&quot;),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\\n  if (reveal == 1.0) { discard; }\\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\\n  var total: f32 = max(tcolor.a, 0.01);\\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;)}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;translucentPass&quot;),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=wT.newInstance({label:&quot;translucentRender&quot;});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:void 0,clearValue:[1,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}],e.depthStencilAttachment={view:void 0,depthLoadOp:&quot;load&quot;,depthStoreOp:&quot;store&quot;},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addOutput(&quot;f32&quot;,&quot;outAccum&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);&quot;,&quot;output.outColor = vec4<f32>(computedColor.rgb*w, w);&quot;,&quot;output.outAccum = computedColor.a;&quot;]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash(&quot;oitpr&quot;),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!1,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;zero&quot;,dstFactor:&quot;one-minus-src&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=wT.newInstance({label:&quot;translucentFinal&quot;}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash(&quot;oitpf&quot;),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})}}const xb={colorTextureView:null,depthTextureView:null};function Cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),bb(e,t)}var Sb={newInstance:jt.newInstance(Cb,&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),extend:Cb};const{BufferUsage:Ab}=nb,{vtkErrorMacro:Ib}=jt;function wb(e,t){t.classHierarchy.push(&quot;vtkWebGPUUniformBuffer&quot;),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Ib(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:aT(n),offset:-1,nativeType:iT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Ab.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join(&quot;\\n&quot;)}}const Pb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function Ob(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;uniform&quot;}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,[&quot;binding&quot;,&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;,&quot;sizeInBytes&quot;]),wb(e,t)}var Rb={newInstance:jt.newInstance(Ob,&quot;vtkWebGPUUniformBuffer&quot;),extend:Ob};const{BufferUsage:Mb}=nb,{vtkErrorMacro:Db}=jt;function Eb(e,t){t.classHierarchy.push(&quot;vtkWebGPUStorageBuffer&quot;),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void Db(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=aT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:iT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Mb.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\\n};\\nstruct ${t.label}Struct\\n{\\n  values: array<${t.label}StructEntry>,\\n};\\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\\n`),r.join(&quot;\\n&quot;)},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Vb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function Lb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;read-only-storage&quot;}},jt.get(e,t,[&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;numberOfInstances&quot;,&quot;sizeInBytes&quot;]),Eb(e,t)}var Bb={newInstance:jt.newInstance(Lb,&quot;vtkWebGPUStorageBuffer&quot;),extend:Lb};const Nb=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Volume::TraverseDec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\\n{\\n  // todo multicomponent support\\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\\n}\\n\\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\\n{\\n  var result: vec4<f32>;\\n\\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\\n  result.w = 0.0;\\n\\n  // divide by spacing as that is our delta\\n  result = result / volumeSSBO.values[vNum].spacing;\\n  // now we have a gradient in unit tcoords\\n\\n  var grad: f32 = length(result.xyz);\\n  if (grad > 0.0)\\n  {\\n    // rotate to View Coords, needed for lighting and shading\\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\\n    result = nMat * result;\\n    result = result / length(result);\\n  }\\n\\n  // store gradient magnitude in .w\\n  result.w = grad;\\n\\n  return result;\\n}\\n\\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\\n{\\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n\\n  // convert to tcoords and reject if outside the volume\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\\n\\n  var scalar: f32 = getTextureValue(vTex, tpos);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n\\n  var gofactor: f32 = 1.0;\\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    normal = getGradient(vTex, tpos, vNum, scalar);\\n    if (componentSSBO.values[cNum].gomin <  1.0)\\n    {\\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\\n    }\\n  }\\n\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n\\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    color = color*abs(normal.z);\\n  }\\n\\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\\n\\n  return outColor;\\n}\\n\\n// adjust the start and end point of a raycast such that it intersects the unit cube.\\n// This function is used to take a raycast starting point and step vector\\n// and numSteps and return the startijng and ending steps for intersecting the\\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\\n// and bound it to intersecting the texture.\\n//\\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\\n{\\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\\n\\n  // move tpos to the start of the volume\\n  var adjust: f32 =\\n    min(\\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\\n      min(\\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\\n  if (adjust < 0.0)\\n  {\\n    result.x = result.x - adjust;\\n  }\\n\\n  // adjust length to the end\\n  adjust =\\n    max(\\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\\n      max(\\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\\n  if (adjust > 0.0)\\n  {\\n    result.y = result.y - adjust;\\n  }\\n\\n  return result;\\n}\\n\\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\\n{\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n  return vec4<f32>(color.rgb, opacity);\\n}\\n\\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var maxVal: f32 = -1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar > maxVal)\\n    {\\n      maxVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\\n}\\n\\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var minVal: f32 = 1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar < minVal)\\n    {\\n      minVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\\n}\\n\\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var avgVal: f32 = 0.0;\\n  var sampleCount: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      avgVal = avgVal + sample;\\n      sampleCount = sampleCount + 1.0;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  if (sampleCount <= 0.0)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\\n}\\n\\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var sumVal: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      sumVal = sumVal + sample;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\\n}\\n\\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\\n{\\n  // initial ray position is at the beginning\\n  var rayPosSC: vec4<f32> = minPosSC;\\n\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var curDist: f32 = 0.0;\\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n  var sampleColor: vec4<f32>;\\n//VTK::Volume::TraverseCalls\\n\\n  loop\\n  {\\n    // for each volume, sample and accumulate color\\n//VTK::Volume::CompositeCalls\\n\\n    // increment position\\n    curDist = curDist + mapperUBO.SampleDistance;\\n    rayPosSC = rayPosSC + rayStepSC;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayLengthSC) { break; }\\n    if (computedColor.a > 0.98) { break; }\\n  }\\n  return computedColor;\\n}\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\\n\\n  // discard empty rays\\n  if (rayMax <= rayMin) { discard; }\\n  else\\n  {\\n    // compute start and end ray positions in view coordinates\\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\\n\\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\\n    rayStepSC.w = 0.0;\\n\\n    var computedColor: vec4<f32>;\\n\\n//VTK::Volume::Loop\\n\\n//VTK::RenderEncoder::Impl\\n  }\\n\\n  return output;\\n}\\n&quot;,_b=new Float64Array(16),Fb=new Float64Array(16);function kb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePassFSQ&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;]).result,r.setCode(o),t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription(&quot;fragment&quot;);let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===Rg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push(&quot;    computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;)):(s.push(`  sampleColor = traverseVals[${e}];`),s.push(&quot;  computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;));a=Uy.substitute(a,&quot;//VTK::Volume::CompositeCalls&quot;,i).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseCalls&quot;,s).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseDec&quot;,[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===Rg.COMPOSITE_BLEND?l=!0:n===Rg.MAXIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.MINIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.AVERAGE_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.ADDITIVE_INTENSITY_BLEND&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result)}l&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[&quot;    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);&quot;]).result),o.setCode(a)},t.shaderReplacements.set(&quot;replaceShaderVolume&quot;,e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8Array(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;rgba8unorm&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;tfunTexture&quot;);t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;r16float&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;ofunTexture&quot;);t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(_b),b(_b,_b,o);const p=n.getMatrix();m(Fb,p),h(Fb,Fb),T(_b,Fb,_b);const f=d.getWorldToIndex();T(_b,f,_b);const v=d.getDimensions();g(Fb),x(Fb,Fb,[1/v[0],1/v[1],1/v[2]]),T(_b,Fb,_b);for(let t=0;t<16;t++)a[16*e+t]=_b[t];h(_b,_b);for(let t=0;t<4;t++)i[16*e+4*t]=_b[4*t],i[16*e+4*t+1]=_b[4*t+1],i[16*e+4*t+2]=_b[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry(&quot;SCTCMatrix&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;planeNormals&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;shade&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;tstep&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;spacing&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;ipScalarRange&quot;,&quot;vec4<f32>&quot;),t.SSBO.setAllInstancesFromArray(&quot;SCTCMatrix&quot;,a),t.SSBO.setAllInstancesFromArray(&quot;planeNormals&quot;,i),t.SSBO.setAllInstancesFromArray(&quot;shade&quot;,l),t.SSBO.setAllInstancesFromArray(&quot;tstep&quot;,s),t.SSBO.setAllInstancesFromArray(&quot;spacing&quot;,c),t.SSBO.setAllInstancesFromArray(&quot;ipScalarRange&quot;,u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=tT(l),u={scale:[255],offset:[0]};2===c.elementSize&&&quot;float&quot;===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry(&quot;cScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;cShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomin&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomax&quot;,&quot;f32&quot;),t.componentSSBO.setAllInstancesFromArray(&quot;cScale&quot;,d),t.componentSSBO.setAllInstancesFromArray(&quot;cShift&quot;,p),t.componentSSBO.setAllInstancesFromArray(&quot;oScale&quot;,f),t.componentSSBO.setAllInstancesFromArray(&quot;oShift&quot;,v),t.componentSSBO.setAllInstancesFromArray(&quot;goScale&quot;,A),t.componentSSBO.setAllInstancesFromArray(&quot;goShift&quot;,S),t.componentSSBO.setAllInstancesFromArray(&quot;gomin&quot;,y),t.componentSSBO.setAllInstancesFromArray(&quot;gomax&quot;,C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue(&quot;SampleDistance&quot;,r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=ib.newInstance({label:&quot;clampSampler&quot;}),t.clampSampler.create(t.device,{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}))},e.computePipelineHash=()=>{t.pipelineHash=&quot;volfsq&quot;;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Gb={volumes:null,rowLength:1024,lastVolumeLength:0};function Ub(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gb,n),xT.extend(e,t,n),t.fragmentShaderTemplate=Nb,t.UBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t.UBO.addEntry(&quot;SampleDistance&quot;,&quot;f32&quot;),t.SSBO=Bb.newInstance({label:&quot;volumeSSBO&quot;}),t.componentSSBO=Bb.newInstance({label:&quot;componentSSBO&quot;}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),kb(e,t)}var zb={newInstance:jt.newInstance(Ub,&quot;vtkWebGPUVolumePassFSQ&quot;),extend:Ub};const{Representation:Wb}=ds,{BufferUsage:Hb,PrimitiveTypes:jb}=nb,Kb=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],$b=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::VolumePass::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::VolumePass::Impl\\n\\n  // use the maximum (closest) of the current value and the zbuffer\\n  // the blend func will then take the min to find the farthest stop value\\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function qb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePass&quot;),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=zb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=xT.newInstance(),t._volumeCopyQuad.setPipelineHash(&quot;volpassfsq&quot;),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._copyUBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t._copyUBO.addEntry(&quot;tscale&quot;,&quot;vec2<f32>&quot;),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray(&quot;tscale&quot;,[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray(&quot;tscale&quot;,[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:Hb.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:jb.Triangles,representation:Wb.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:Hb.PointArray,format:&quot;float32x4&quot;,hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,[&quot;vertexBC&quot;]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+Kb[e][0],l[n++]=r+Kb[e][1],l[n++]=r+Kb[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation(&quot;volumeDepthRangePass&quot;),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=wT.newInstance({label:&quot;VolumePass DepthRange&quot;}),t._depthRangeEncoder.setPipelineHash(&quot;volr&quot;),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor1&quot;),t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor2&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);&quot;,&quot;output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);&quot;]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:null,clearValue:[1,1,1,1],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;}}}]}}),t._depthRangeTexture=mb.newInstance({label:&quot;volumePassMaxDepth&quot;}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView(&quot;maxTexture&quot;);t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=mb.newInstance({label:&quot;volumePassDepthMin&quot;}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView(&quot;minTexture&quot;);t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=mb.newInstance({label:&quot;volumePassColor&quot;}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;bgra8unorm&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView(&quot;volumePassColorTexture&quot;),t._colorTextureView.addSampler(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._clearEncoder=wT.newInstance({label:&quot;VolumePass Clear&quot;}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._clearEncoder.setPipelineHash(&quot;volpf&quot;),t._clearEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=wT.newInstance({label:&quot;volumePassCopy&quot;}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._copyEncoder.setPipelineHash(&quot;volcopypf&quot;),t._copyEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=wT.newInstance({label:&quot;volumePassMerge&quot;}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash(&quot;volpf&quot;),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const Xb={colorTextureView:null,depthTextureView:null,volumes:null};function Yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xb,n),qv.extend(e,t,n),t._mapper=vT.newInstance(),t._mapper.setFragmentShaderTemplate($b),t._mapper.getShaderReplacements().set(&quot;replaceShaderVolumePass&quot;,((e,t,n)=>{t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)})),t._boundsPoly=gu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),qb(e,t)}var Zb={newInstance:jt.newInstance(Yb,&quot;vtkWebGPUVolumePass&quot;),extend:Yb};function Qb(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e),t.opaquePass||(t.opaquePass=Tb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Sb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=Zb.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=wT.newInstance({label:&quot;forwardPassBlit&quot;}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._finalBlitEncoder.setPipelineHash(&quot;fpf&quot;),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}}),t._fsqSampler=ib.newInstance({label:&quot;finalPassSampler&quot;}),t._fsqSampler.create(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._fullScreenQuad=xT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash(&quot;fpfsq&quot;),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0),vec4<f32>(0.0),vec4<f32>(1.0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._finalBlitOutputTextureView=ub.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const Jb={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;opaquePass&quot;,&quot;translucentPass&quot;,&quot;volumePass&quot;]),Qb(e,t)}var tx={newInstance:jt.newInstance(ex,&quot;vtkForwardPass&quot;),extend:ex};const{VtkDataTypes:nx}=Es;function rx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format=&quot;r&quot;;break;case 2:e.format=&quot;rg&quot;;break;default:e.format=&quot;rgba&quot;}switch(e.dataArray.getDataType()){case nx.UNSIGNED_CHAR:e.format+=&quot;8unorm&quot;;break;case nx.FLOAT:case nx.UNSIGNED_INT:case nx.INT:case nx.DOUBLE:case nx.UNSIGNED_SHORT:case nx.SHORT:default:e.format+=&quot;16float&quot;}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format=&quot;rgba8unorm&quot;),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=mb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push(&quot;vtkWebGPUTextureManager&quot;),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const ox={handle:null,device:null};function ax(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ox,n),jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;]),rx(e,t)}var ix={newInstance:jt.newInstance(ax),extend:ax};class sx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&&quot;object&quot;==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function lx(e,t){t.classHierarchy.push(&quot;vtkWebGPUDevice&quot;),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro(&quot;layout not found&quot;),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro(&quot;attempt to cache an object without a hash&quot;),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const cx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cx,n),yt(e,t),At(e,t,[&quot;handle&quot;]),bt(e,t,[&quot;bufferManager&quot;,&quot;shaderCache&quot;,&quot;textureManager&quot;]),t.objectCache=new sx,t.shaderCache=Uy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=nb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=ix.newInstance(),t.textureManager.setDevice(e),t.pipelines={},lx(e,t)}var dx={newInstance:Et(ux,&quot;vtkWebGPUDevice&quot;),extend:ux};function px(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelectionPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;hardwareSelectorColor&quot;}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;rgba32uint&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView(&quot;hardwareSelectColorTexture&quot;);t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=mb.newInstance({label:&quot;hardwareSelectorDepth&quot;}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;depth32float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;hardwareSelectDepthTexture&quot;);t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation(&quot;cameraPass&quot;),r.traverse(e),e.setCurrentOperation(&quot;opaquePass&quot;),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=wT.newInstance({label:&quot;HardwareSelectionPass&quot;}),t.selectionRenderEncoder.setPipelineHash(&quot;sel&quot;),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<u32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);&quot;]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba32uint&quot;,blend:void 0}]}})}}const fx={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function gx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fx,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),px(e,t)}var mx={newInstance:jt.newInstance(gx,&quot;vtkWebGPUHardwareSelectionPass&quot;),extend:gx};const{SelectionContent:hx,SelectionField:vx}=qp,{FieldAssociations:yx}=ol,{vtkErrorMacro:Tx}=jt;function bx(e){return`${e.propID} ${e.compositeID}`}function xx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Cx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=xx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=xx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Cx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Cx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Cx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Cx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Cx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Sx(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelector&quot;),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Tx(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=ET.newInstance({label:&quot;hardwareSelectColorBuffer&quot;});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=ET.newInstance({label:&quot;hardwareSelectDepthBuffer&quot;}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:&quot;depth-only&quot;},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Cx(e,[n,t],0,u);if(r){const t=bx(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=qp.newInstance();switch(i.setContentType(hx.INDICES),e){case yx.FIELD_ASSOCIATION_CELLS:i.setFieldType(vx.CELL);break;case yx.FIELD_ASSOCIATION_POINTS:i.setFieldType(vx.POINT);break;default:Tx(&quot;Unknown field association&quot;)}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Ax={};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),Gp.extend(e,t,n),t._selectionPass=mx.newInstance(),jt.setGet(e,t,[&quot;_WebGPURenderWindow&quot;]),jt.moveToProtected(e,t,[&quot;WebGPURenderWindow&quot;]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,&quot;vtkWebGPUHardwareSelector&quot;),extend:Ix};const Px=Object.create(null);function Ox(e,t){t.classHierarchy.push(&quot;vtkWebGPUViewNodeFactory&quot;)}const Rx={};function Mx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rx,n),t.overrides=Px,tn.extend(e,t,n),Ox(0,t)}var Dx={newInstance:jt.newInstance(Mx,&quot;vtkWebGPUViewNodeFactory&quot;),extend:Mx};const{vtkErrorMacro:Ex}=jt,Vx={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Lx(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderWindow&quot;),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:&quot;premultiplied&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Ex(&quot;WebGPU is not enabled.&quot;);e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Ex(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:&quot;high-performance&quot;}),t.deleted||(t.device=dx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext(&quot;webgpu&quot;))},e.releaseGraphicsResources=()=>{const n=qv.newInstance();n.setCurrentOperation(&quot;Release&quot;),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Vx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=ET.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Ad.fromHalf(r.colorValues[o]),s[n+1]=255*Ad.fromHalf(r.colorValues[o+1]),s[n+2]=255*Ad.fromHalf(r.colorValues[o+2]),s[n+3]=255*Ad.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=wx.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Bx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Nx=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,xy.extend(e,t,n),t.myFactory=Dx.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Nx),t.renderPasses[0]=tx.newInstance(),t.selector||(t.selector=wx.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,&quot;imageReady&quot;),jt.event(e,t,&quot;initialized&quot;),jt.get(e,t,[&quot;commandEncoder&quot;,&quot;device&quot;,&quot;presentationFormat&quot;,&quot;useBackgroundImage&quot;,&quot;xrSupported&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;device&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Lx(e,t)}),&quot;vtkWebGPURenderWindow&quot;);ev(&quot;WebGPU&quot;,Nx);const _x=Hv(),Fx={margin:&quot;0&quot;,padding:&quot;0&quot;,position:&quot;absolute&quot;,top:&quot;0&quot;,left:&quot;0&quot;,width:&quot;100%&quot;,height:&quot;100%&quot;,overflow:&quot;hidden&quot;},kx={position:&quot;absolute&quot;,left:&quot;25px&quot;,top:&quot;25px&quot;,backgroundColor:&quot;white&quot;,borderRadius:&quot;5px&quot;,listStyle:&quot;none&quot;,padding:&quot;5px 10px&quot;,margin:&quot;0&quot;,display:&quot;block&quot;,border:&quot;solid 1px black&quot;,maxWidth:&quot;calc(100% - 70px)&quot;,maxHeight:&quot;calc(100% - 60px)&quot;,overflow:&quot;auto&quot;};function Gx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Ux(e,t){t.classHierarchy.push(&quot;vtkFullScreenRenderWindow&quot;);const n=document.querySelector(&quot;body&quot;);t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement(&quot;div&quot;),Gx(t.container,t.containerStyle||Fx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height=&quot;100%&quot;,n.style.height=&quot;100%&quot;,n.style.padding=&quot;0&quot;,n.style.margin=&quot;0&quot;),t.renderWindow=av.newInstance(),t.renderer=Qh.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(_x.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Sv.newInstance(),t.interactor.setInteractorStyle(Uv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?&quot;block&quot;:&quot;none&quot;)},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement(&quot;div&quot;),Gx(t.controlContainer,t.controlPanelStyle||kx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener(&quot;keypress&quot;,(t=>{&quot;c&quot;===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}))},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener(&quot;resize&quot;,e.resize),e.resize()}const zx={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Wx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zx,n),jt.obj(e,t),jt.get(e,t,[&quot;renderWindow&quot;,&quot;renderer&quot;,&quot;apiSpecificRenderWindow&quot;,&quot;interactor&quot;,&quot;rootContainer&quot;,&quot;container&quot;,&quot;controlContainer&quot;]),Ux(e,t)}var Hx={newInstance:jt.newInstance(Wx),extend:Wx},jx={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:Kx,Scale:$x}=jx,{ScalarMappingTarget:qx}=Pl,{vtkDebugMacro:Xx,vtkErrorMacro:Yx,vtkWarningMacro:Zx}=jt;function Qx(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Jx(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function eC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];Qx(o,i),Qx(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Jx(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Jx(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function tC(e,t){t.classHierarchy.push(&quot;vtkColorTransferFunction&quot;),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Yx(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(s<0||s>1)return Yx(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===$x.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Do(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===Kx.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===Kx.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;,t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===Kx.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===Kx.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;);for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Yx(&quot;Attempting to lookup a value with no points in the function&quot;),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Yx(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Yx(&quot;Index out of range!&quot;),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>t.indexedLookup&&e.getSize()?e.getSize():t.tableSize?t.tableSize:16777216,e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void Yx(&quot;attempt to set zero width color range&quot;);const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):Xx(&quot;Transfer Function Has No Points!&quot;)},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void Zx(&quot;Transfer Function Has No Points!&quot;);const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===qx.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===qx.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===qx.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===qx.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=Kx[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Yx(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=Kx.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const nC={clamping:!0,colorSpace:Kx.RGB,hSVWrap:!0,scale:$x.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function rC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nC,n),Pl.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,[&quot;buildTime&quot;,&quot;mappingRange&quot;]),jt.setGet(e,t,[&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;,&quot;colorSpace&quot;,&quot;discretize&quot;,&quot;numberOfValues&quot;]),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),tC(e,t)}var oC={newInstance:jt.newInstance(rC,&quot;vtkColorTransferFunction&quot;),extend:rC,...jx},aC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:iC,ScaleModes:sC}=aC,{vtkErrorMacro:lC}=jt;function cC(e,t){t.classHierarchy.push(&quot;vtkGlyph3DMapper&quot;),e.getOrientationModeAsString=()=>jt.enumToString(iC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(iC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(iC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(iC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(sC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(sC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(sC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(sC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===sC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(lC(&quot;Cannot scale by components since scale array does not have 3 components.&quot;),a=null);const l=r.getBounds(),c=[];ki.getCorners(l,c),t.bounds[0]=ki.INIT_BOUNDS[0],t.bounds[1]=ki.INIT_BOUNDS[1],t.bounds[2]=ki.INIT_BOUNDS[2],t.bounds[3]=ki.INIT_BOUNDS[3],t.bounds[4]=ki.INIT_BOUNDS[4],t.bounds[5]=ki.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case iC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case iC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case iC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case sC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case sC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case sC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const uC={orient:!0,orientationMode:iC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:sC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function dC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uC,n),nc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,[&quot;orient&quot;,&quot;orientationMode&quot;,&quot;orientationArray&quot;,&quot;scaleArray&quot;,&quot;scaleFactor&quot;,&quot;scaleMode&quot;,&quot;scaling&quot;]),jt.get(e,t,[&quot;colorArray&quot;,&quot;matrixArray&quot;,&quot;normalArray&quot;,&quot;buildTime&quot;]),cC(e,t)}var pC={newInstance:jt.newInstance(dC,&quot;vtkGlyph3DMapper&quot;),extend:dC,...aC};const{vtkErrorMacro:fC}=jt;function gC(e,t){t.classHierarchy.push(&quot;vtkPiecewiseFunction&quot;),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return&quot;Constant&quot;;case 1:return&quot;NonDecreasing&quot;;case 2:return&quot;NonIncreasing&quot;;default:return&quot;Varied&quot;}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(fC(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return fC(&quot;Index out of range!&quot;),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return fC(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(a<0||a>1)return fC(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const mC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function hC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,[&quot;allowDuplicateScalars&quot;,&quot;clamping&quot;]),jt.setArray(e,t,[&quot;range&quot;],2),jt.getArray(e,t,[&quot;range&quot;]),gC(e,t)}var vC={newInstance:jt.newInstance(hC,&quot;vtkPiecewiseFunction&quot;),extend:hC};const{InterpolationType:yC,OpacityMode:TC}=Og,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push(&quot;vtkVolumeProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(bC(&quot;Bad index - must be between 0 and 3&quot;),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=vC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=oC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=vC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return bC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(bC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(yC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(yC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(yC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(yC,t.interpolationType),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const CC={independentComponents:!0,interpolationType:yC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,CC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:TC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;shade&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,&quot;vtkVolumeProperty&quot;),extend:SC,...Og};const{vtkDebugMacro:IC}=jt;function wC(e,t){t.classHierarchy.push(&quot;vtkVolume&quot;),e.getVolumes=()=>e,e.makeProperty=AC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){IC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e));const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const PC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),wC(e,t)}var RC={newInstance:jt.newInstance(OC,&quot;vtkVolume&quot;),extend:OC};const{BlendMode:MC,FilterMode:DC}=Mg,EC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=vC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function VC(e,t){t.classHierarchy.push(&quot;vtkVolumeMapper&quot;);const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(MC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(MC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(MC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(MC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(MC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(MC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(MC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn(&quot;setAverageIPScalarRange is deprecated use setIpScalarRange&quot;),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(DC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(DC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(DC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(DC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Do(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const LC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:MC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:DC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LC,n),Bs(e,t,n),jt.setGet(e,t,[&quot;sampleDistance&quot;,&quot;imageSampleDistance&quot;,&quot;maximumSamplesPerRay&quot;,&quot;autoAdjustSampleDistances&quot;,&quot;initialInteractionScale&quot;,&quot;interactionSampleDistanceFactor&quot;,&quot;blendMode&quot;,&quot;filterMode&quot;,&quot;preferSizeOverAccuracy&quot;,&quot;computeNormalFromOpacity&quot;,&quot;volumetricScatteringBlending&quot;,&quot;globalIlluminationReach&quot;,&quot;volumeShadowSamplingDistFactor&quot;,&quot;anisotropy&quot;,&quot;localAmbientOcclusion&quot;,&quot;LAOKernelSize&quot;,&quot;LAOKernelRadius&quot;]),jt.setGetArray(e,t,[&quot;ipScalarRange&quot;],2),jt.event(e,t,&quot;lightingActivated&quot;),VC(e,t)}var NC={newInstance:jt.newInstance(BC,&quot;vtkVolumeMapper&quot;),extend:BC,...EC};const{InterpolationType:_C}=eg,{vtkErrorMacro:FC}=jt;function kC(e,t){t.classHierarchy.push(&quot;vtkImageProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return FC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(FC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(_C.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(_C.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(_C,t.interpolationType)}const GC={independentComponents:!1,interpolationType:_C.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function UC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,GC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;colorWindow&quot;,&quot;colorLevel&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;opacity&quot;,&quot;useLookupTableScalarRange&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),kC(e,t)}var zC={newInstance:jt.newInstance(UC,&quot;vtkImageProperty&quot;),extend:UC};const{vtkDebugMacro:WC}=jt;function HC(e,t){t.classHierarchy.push(&quot;vtkImageSlice&quot;),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=zC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){WC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),ki.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!ki.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),ki.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const jC={mapper:null,property:null,bounds:[...ki.INIT_BOUNDS]};function KC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),HC(e,t)}var $C={newInstance:jt.newInstance(KC,&quot;vtkImageSlice&quot;),extend:KC};function qC(e,t){t.classHierarchy.push(&quot;vtkAbstractImageMapper&quot;),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro(&quot;vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED&quot;),Fa())}const XC={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var YC=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,XC,n),Fs(e,t,n),jt.setGet(e,t,[&quot;slice&quot;,&quot;useCustomExtents&quot;]),jt.setGetArray(e,t,[&quot;customDisplayExtent&quot;],6),jt.setGetArray(e,t,[&quot;backgroundColor&quot;],4),qC(e,t)};function ZC(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA(&quot;vtkImageArrayMapper&quot;)?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ni.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:QC,otherStaticMethods:JC}=Ul,{SlicingMode:eS}=sg;function tS(e,t){function n(){let n;switch(t.slicingMode){case eS.X:n=0;break;case eS.Y:n=1;break;case eS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push(&quot;vtkImageMapper&quot;),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case eS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case eS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case eS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case eS.I:l=Ma(a[0],i[0],i[1]);break;case eS.J:l=Ma(a[1],i[2],i[3]);break;case eS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case eS.I:case eS.J:case eS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case eS.X:e.setSlice(r[0]);break;case eS.Y:e.setSlice(r[1]);break;case eS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(eS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(eS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(eS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(eS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(eS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(eS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case eS.X:n[0]=1;break;case eS.Y:n[1]=1;break;case eS.Z:n[2]=1;break;case eS.I:ea(r,[1,0,0],n);break;case eS.J:ea(r,[0,1,0],n);break;case eS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==eS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case eS.I:r[0]=a,r[1]=a;break;case eS.J:r[2]=a,r[3]=a;break;case eS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case eS.I:a[0]=s-r,a[1]=s+r;break;case eS.J:a[2]=s-r,a[3]=s+r;break;case eS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const nS={slicingMode:eS.NONE,closestIJKAxis:{ijkMode:eS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function rS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nS,n),YC(e,t,n),jt.get(e,t,[&quot;slicingMode&quot;]),jt.setGet(e,t,[&quot;closestIJKAxis&quot;,&quot;renderToRectangle&quot;,&quot;sliceAtFocalPoint&quot;,&quot;preferSizeOverAccuracy&quot;]),Ul.implementCoincidentTopologyMethods(e,t),tS(e,t)}var oS={newInstance:jt.newInstance(rS,&quot;vtkImageMapper&quot;),extend:rS,...QC,...JC,...sg};const{vtkErrorMacro:aS}=jt;function iS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function sS(e,t){t.classHierarchy.push(&quot;vtkAppendPolyData&quot;),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void aS(&quot;No input specified.&quot;);if(1===o)return void(r[0]=n[0]);const a=gu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===js.SINGLE?s=ys.FLOAT:t.outputPointsPrecision===js.DOUBLE&&(s=ys.DOUBLE);const v=mc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Es.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Es.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Es.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),iS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),iS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),iS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),iS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const lS={outputPointsPrecision:js.DEFAULT};function cS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lS,n),jt.setGet(e,t,[&quot;outputPointsPrecision&quot;]),jt.obj(e,t),jt.algo(e,t,1,1),sS(e,t)}var uS={newInstance:jt.newInstance(cS,&quot;vtkAppendPolyData&quot;),extend:cS};function dS(e,t){t.classHierarchy.push(&quot;vtkConeSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Nf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=gu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const pS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:&quot;Float64Array&quot;};function fS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),dS(e,t)}var gS={newInstance:jt.newInstance(fS,&quot;vtkConeSource&quot;),extend:fS};function mS(e,t){t.classHierarchy.push(&quot;vtkCylinderSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Es.newInstance({numberOfComponents:3,values:u,name:&quot;Normals&quot;}),p=new Float32Array(2*a),f=Es.newInstance({numberOfComponents:2,values:p,name:&quot;TCoords&quot;}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Nf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=gu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const hS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:&quot;Float64Array&quot;};function vS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;initAngle&quot;,&quot;otherRadius&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),mS(e,t)}var yS={newInstance:jt.newInstance(vS,&quot;vtkCylinderSource&quot;),extend:vS};function TS(e,t){t.classHierarchy.push(&quot;vtkArrowSource&quot;),e.requestData=function(e,n){if(t.deleted)return;const r=yS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Bf().rotateZ(-90).apply(a).apply(i);const s=gS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Nf().translate(1-.5*t.tipLength,0,0).apply(c);const u=uS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Nf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Nf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Nf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const bS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:&quot;Float64Array&quot;};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;tipResolution&quot;,&quot;tipRadius&quot;,&quot;tipLength&quot;,&quot;shaftResolution&quot;,&quot;shaftRadius&quot;,&quot;invert&quot;]),jt.setGetArray(e,t,[&quot;direction&quot;],3),jt.algo(e,t,0,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,&quot;vtkArrowSource&quot;),extend:xS};function SS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Bf().translate(...n).apply(e.getPoints().getData())}function AS(e,t){const n=e.getPoints().getBounds(),r=[0,0,0];r[t]=-n[2*t],Bf().translate(...r).apply(e.getPoints().getData())}function IS(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8Array(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Es.newInstance({name:&quot;color&quot;,numberOfComponents:3,values:a}))}function wS(e,t){t.classHierarchy.push(&quot;vtkAxesActor&quot;);const n=nc.newInstance();e.setMapper(n),e.update=()=>{const e=CS.newInstance({direction:[1,0,0],...t.config}).getOutputData();t.config.recenter?SS(e):AS(e,0),IS(e,...t.xAxisColor);const r=CS.newInstance({direction:[0,1,0],...t.config}).getOutputData();t.config.recenter?SS(r):AS(r,1),IS(r,...t.yAxisColor);const o=CS.newInstance({direction:[0,0,1],...t.config}).getOutputData();t.config.recenter?SS(o):AS(o,2),IS(o,...t.zAxisColor);const a=uS.newInstance();a.setInputData(e),a.addInputData(r),a.addInputData(o),n.setInputConnection(a.getOutputPort())},e.update();const r=jt.debounce(e.update,0),{setConfig:o,setXAxisColor:a,setYAxisColor:i,setZAxisColor:s}=e;e.setConfig=e=>!!o(e)&&(r(),!0),e.setXAxisColor=e=>!!a(e)&&(r(),!0),e.setYAxisColor=e=>!!i(e)&&(r(),!0),e.setZAxisColor=e=>!!s(e)&&(r(),!0)}const PS={config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1},xAxisColor:[255,0,0],yAxisColor:[255,255,0],zAxisColor:[0,128,0]};function OS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PS,n),hs.extend(e,t,n),jt.setGet(e,t,[&quot;config&quot;]),jt.setGetArray(e,t,[&quot;xAxisColor&quot;,&quot;yAxisColor&quot;,&quot;zAxisColor&quot;],3,255),wS(e,t)}var RS={newInstance:jt.newInstance(OS,&quot;vtkAxesActor&quot;),extend:OS};const MS=&quot;resetcamera&quot;,DS=&quot;orientation&quot;,ES={MODE_RESET_CAMERA:MS,MODE_ORIENTATION:DS,MODE_SAME:&quot;same&quot;};function VS(e,t){t.classHierarchy.push(&quot;vtkCameraSynchronizer&quot;);const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName(&quot;position&quot;),s=e.getReferenceByName(&quot;focalPoint&quot;),l=e.getReferenceByName(&quot;viewUp&quot;),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===DS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===MS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const LS={mode:DS,focalPoint:[0,0,0],distance:6.8,active:!0};function BS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LS,n),yt(e,t),At(e,t,[&quot;mode&quot;,&quot;active&quot;,&quot;srcRenderer&quot;,&quot;dstRenderer&quot;,&quot;distance&quot;]),Pt(e,t,[&quot;focalPoint&quot;],3,0),VS(e,t)}var NS={newInstance:Et(BS,&quot;vtkCameraSynchronizer&quot;),extend:BS,SynchronizationMode:ES};const _S={},FS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=NS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:NS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var kS=function(e,t,n){const r=e.get(&quot;synchronizedViewId&quot;).synchronizedViewId;if(!t.behaviors||!r)return;_S[r]||(_S[r]={});const o=_S[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=NS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];FS[e.type]?o[r]=new FS[e.type](n,e):console.log(&quot;No mapping for&quot;,e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const GS={},US=/instance:\\${([^}]+)}/,zS={},WS=[],HS={},jS={vtkPoints:mc,vtkCellArray:cc,vtkDataArray:Es};function KS(e){return e.map((e=>US.exec(e))).filter((e=>e)).map((e=>e[1]))}function $S(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),$S(e,t)})),t}function qS(e,t,n,r){if(!t)return Promise.reject(new Error(&quot;No instance provided.&quot;));const o=GS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function XS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=GS[e];return n&&n.build?n.build(t):(console.log(&quot;No builder for&quot;,e),null)}function YS(){Object.keys(GS).forEach((e=>{delete GS[e]}))}function ZS(){Object.keys(zS).forEach((e=>{delete zS[e]}))}function QS(e){if(1===e[1].length)return-1===WS.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===WS.indexOf(e[1][n]);return t}function JS(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(HS[r]){const{key:n,value:o}=HS[r];if(!n||e.properties[n]===o)return void WS.push((e=>`instance:\\${${e}}`)(t))}let o=n.getInstance(t);o||(o=XS(r,{managedInstanceId:t}),n.registerInstance(t,o)),qS(r,o,e,n)})),t.calls&&t.calls.filter(QS).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=US.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:&quot;addArray&quot;,a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:&quot;vtkDataArray&quot;,l=jS[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log(&quot;Error fetching array&quot;,JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error(&quot;Error in array handling for state&quot;,JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function eA(e,t,n){zS[t.id]||JS(e,t,n),zS[t.id]=!0}function tA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function nA(e){const t=e.name?`_${e.name}`:&quot;&quot;;return`${e.hash}_${e.dataType}${t}`}function rA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=nA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=nA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),tA(t.getPointData(),i.pointData),tA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=JS(t,s,r);return r.end(),l}}const oA=rA([&quot;points&quot;,&quot;polys&quot;,&quot;verts&quot;,&quot;lines&quot;,&quot;strips&quot;]),aA=rA([]);function iA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:JS;XS||qS?GS[e]={build:t,update:n}:delete GS[e]}const sA={vtkMapper:[&quot;vtkOpenGLPolyDataMapper&quot;,&quot;vtkCompositePolyDataMapper2&quot;,&quot;vtkDataSetMapper&quot;],vtkProperty:[&quot;vtkOpenGLProperty&quot;],vtkRenderer:[&quot;vtkOpenGLRenderer&quot;],vtkCamera:[&quot;vtkOpenGLCamera&quot;],vtkColorTransferFunction:[&quot;vtkPVDiscretizableColorTransferFunction&quot;],vtkActor:[&quot;vtkOpenGLActor&quot;,&quot;vtkPVLODActor&quot;],vtkLight:[&quot;vtkOpenGLLight&quot;,&quot;vtkPVLight&quot;],vtkTexture:[&quot;vtkOpenGLTexture&quot;],vtkImageMapper:[&quot;vtkOpenGLImageSliceMapper&quot;],vtkVolumeMapper:[&quot;vtkFixedPointVolumeRayCastMapper&quot;]},lA={vtkAxesActor:{build:RS.newInstance,update:JS},vtkRenderWindow:{build:av.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(QS).filter((e=>&quot;removeRenderer&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),JS(e,t,n),kS(e,t,n)}},vtkRenderer:{build:Qh.newInstance,update:function(e,t,n){JS(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=$S(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(QS).filter((e=>&quot;removeViewProp&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{const t=n.getInstance(e).get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:El.newInstance,update:JS},vtkCamera:{build:Bh.newInstance,update:eA},vtkPolyData:{build:gu.newInstance,update:oA},vtkImageData:{build:fl.newInstance,update:aA},vtkMapper:{build:nc.newInstance,update:JS},vtkGlyph3DMapper:{build:pC.newInstance,update:JS},vtkProperty:{build:ds.newInstance,update:JS},vtkActor:{build:hs.newInstance,update:JS},vtkLight:{build:kh.newInstance,update:JS},vtkColorTransferFunction:{build:oC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Tu.newInstance,update:JS},vtkVolume:{build:RC.newInstance,update:JS},vtkVolumeMapper:{build:NC.newInstance,update:JS},vtkVolumeProperty:{build:AC.newInstance,update:JS},vtkImageSlice:{build:$C.newInstance,update:JS},vtkImageMapper:{build:oS.newInstance,update:JS},vtkImageProperty:{build:zC.newInstance,update:JS},vtkPiecewiseFunction:{build:vC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:Fu.newInstance,update:JS},vtkScalarBarActor:{build:Op.newInstance,update:JS}};function cA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&YS(),Object.keys(lA).forEach((e=>{const t=lA[e];iA(e,t.build,t.update)}))}function uA(){Object.keys(sA).forEach((e=>{sA[e].forEach((t=>{GS[t]=GS[e]}))}))}cA(),uA(),HS.vtkPVLight={};var dA={build:XS,update:qS,genericUpdater:JS,oneTimeGenericUpdater:eA,setTypeMapping:iA,clearTypeMapping:YS,getSupportedTypes:function(){return Object.keys(GS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return ZS();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete zS[e]})),r},updateRenderWindow:function(e,t,n){return qS(&quot;vtkRenderWindow&quot;,e,t,n)},excludeInstance:function(e,t,n){HS[e]={key:t,value:n}},setDefaultMapping:cA,applyDefaultAliases:uA,alwaysUpdateCamera:function(){iA(&quot;vtkCamera&quot;,Bh.newInstance),uA()}};const pA={};function fA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if(&quot;string&quot;==typeof t&&(i=Dm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log(&quot;Error getting data array:&quot;),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use &quot;setArrayFetcher&quot; to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function gA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function mA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Dt(t,n,&quot;progressEvent&quot;),Dt(t,n,&quot;progressDone&quot;),t}function hA(){const e={};let t=&quot;default&quot;;return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function vA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;default&quot;,t=pA[e];return t||(t={...fA(),...gA(),...mA(),...hA()},pA[e]=t),t}function yA(e,t){let n=-1,r=100;const o=e=>e.get(&quot;managedInstanceId&quot;).managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get(&quot;synchronizedViewId&quot;).synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),dA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){dA.clearOneTimeUpdaters(a())}}}function TA(e,t){t.classHierarchy.push(&quot;vtkSynchronizableRenderWindow&quot;),t.synchronizerContext||(t.synchronizerContext=vA(t.synchronizerContextName));const n=yA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const bA={synchronizerContextName:&quot;default&quot;,synchronizerContext:null,synchronizedViewId:null};function xA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bA,n),av.extend(e,t),bt(e,t,[&quot;synchronizerContext&quot;]),TA(e,t)}var CA={newInstance:Et(xA,&quot;vtkSynchronizableRenderWindow&quot;),extend:xA,getSynchronizerContext:vA,setSynchronizerContext:function(e,t){pA[e]=t},clearSynchronizerContext:function(e){if(e&&pA[e]&&delete pA[e],!e){const e=Object.keys(pA);for(let t=0;t<e.length;t++)delete pA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;default&quot;;const n=yA(e,vA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:gA,createArrayHandler:fA,createProgressHandler:mA,createSceneMtimeHandler:hA,vtkObjectManager:dA};const{vtkErrorMacro:SA,vtkDebugMacro:AA}=jt;let IA=0;function wA(e){const t=document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`);return t?t.innerHTML:null}function PA(e){return&quot;/&quot;===e[0]?e.substr(1):e}const OA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=wA(PA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=wA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=PA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;)),s=wA(i);if(null===s)a(new Error(`No such array ${i}`));else{if(&quot;string&quot;===n.dataType){let e=atob(s);r.compression&&(e=yh(mh(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Dm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(AA(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&SA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--IA&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};Vm(&quot;html&quot;,(e=>OA));const{vtkErrorMacro:RA,vtkDebugMacro:MA}=jt;function DA(e){return function(e){return&quot;/&quot;===e[0]?e.substr(1):e}(function(e){return new URL(e,&quot;http://any&quot;).pathname}(e))}const EA=function(e){let t=!1,n=0,r=null,o=&quot;&quot;;var a;return(a=e.zipContent,new Promise(((e,t)=>{&quot;string&quot;==typeof a?e(function(e,t){if(t){for(var n=new Bm(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(hh)return hh.encode(e);var o=e.length,a=new Bm(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new Bm(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return oh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error(&quot;Invalid datatype to unpack.&quot;))}))).then((n=>{r=Ch(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith(&quot;index.json&quot;)&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\\.json$/,&quot;&quot;),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||RA(&quot;ERROR!!! zip not ready...&quot;);const u=DA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join(&quot;/&quot;));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if(&quot;string&quot;!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&(&quot;string&quot;===e.dataType||&quot;JSON&quot;===e.dataType?e.buffer=yh(mh(new Uint8Array(e.buffer))):e.buffer=mh(new Uint8Array(e.buffer)).buffer),&quot;JSON&quot;===e.ref.encode?e.values=JSON.parse(e.buffer):(Ah!==e.ref.encode&&Ah&&(MA(`Swap bytes of ${e.name}`),Ih(e.buffer,vs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&RA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(yh(mh(r))):JSON.parse(r),n()}}(i,s.compression,d);e(yh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];if(a.compression){if(&quot;gz&quot;===a.compression){const e=yh(mh(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error(&quot;Invalid compression&quot;))}return Promise.resolve(JSON.parse(yh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(yh(Ch(s))):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(yh(s))},fetchImage(e,n){const a=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=Mm(i.buffer);n.src=`data:image/${function(e){const t=e.split(&quot;.&quot;).pop().toLowerCase();return&quot;jpg&quot;===t?&quot;jpeg&quot;:t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(mh(s).buffer):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(s.buffer)}}};Vm(&quot;zip&quot;,(e=>EA(e)));var VA=n(892),LA=n.n(VA),BA=n(760),NA=n.n(BA),_A=n(311),FA=n.n(_A),kA=n(192),GA=n.n(kA),UA=n(60),zA=n.n(UA),WA=n(865),HA=n.n(WA),jA=n(34),KA={};KA.styleTagTransform=HA(),KA.setAttributes=GA(),KA.insert=FA().bind(null,&quot;head&quot;),KA.domAPI=NA(),KA.insertStyleElement=zA(),LA()(jA.Z,KA);var $A=jA.Z&&jA.Z.locals?jA.Z.locals:void 0;let qA=!0;function XA(e){e.preventDefault(),e.stopPropagation()}function YA(e,t){qA=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=Hx.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:&quot;100%&quot;,width:&quot;100%&quot;,position:&quot;absolute&quot;}}).getRenderWindow(),o=CA.getSynchronizerContext(),a=CA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement(&quot;div&quot;);n.setAttribute(&quot;class&quot;,$A.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?Mh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Lm(&quot;zip&quot;,{zipContent:t,callback:e=>{r.fetchJSON(null,&quot;index.json&quot;).then(i)}})})):Mh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Lm(&quot;zip&quot;,{zipContent:t.file,callback:t=>{e.fetchJSON(null,&quot;index.json&quot;).then(i)}})}else if(t.base64Str){const e=Dm(t.base64Str),n=Lm(&quot;zip&quot;,{zipContent:e,callback:e=>{n.fetchJSON(null,&quot;index.json&quot;).then(i)}})}}function ZA(e){qA=!1;const t=document.querySelector(&quot;.content&quot;),n=document.querySelector(&quot;body&quot;),r=e||t||n;r!==e?(r.classList.add($A.fullScreen),n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;):(n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;);const o=document.createElement(&quot;div&quot;);o.innerHTML=`<div class=&quot;${$A.bigFileDrop}&quot;/><input type=&quot;file&quot; accept=&quot;.zip,.vtksz&quot; style=&quot;display: none;&quot;/>`,r.appendChild(o);const a=o.querySelector(&quot;input&quot;);function i(e){XA(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(&quot;.&quot;).slice(-1)[0];YA(r,{file:n[0],ext:e})}}a.addEventListener(&quot;change&quot;,i),o.addEventListener(&quot;drop&quot;,i),o.addEventListener(&quot;click&quot;,(e=>a.click())),o.addEventListener(&quot;dragover&quot;,XA)}const QA=Hv();if(QA.url||QA.fileURL){const e=document.querySelector(&quot;.content&quot;),t=document.querySelector(&quot;body&quot;),n=e||t;n&&(n.classList.add($A.fullScreen),t.style.margin=&quot;0&quot;,t.style.padding=&quot;0&quot;),qA=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>YA(n,QA)))}setTimeout((()=>{qA&&ZA()}),100),window.OfflineLocalView={initLocalFileLoader:ZA,load:YA}},793:function(e){&quot;use strict&quot;;e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=&quot;&quot;,r=void 0!==t[5];return t[4]&&(n+=&quot;@supports (&quot;.concat(t[4],&quot;) {&quot;)),t[2]&&(n+=&quot;@media &quot;.concat(t[2],&quot; {&quot;)),r&&(n+=&quot;@layer&quot;.concat(t[5].length>0?&quot; &quot;.concat(t[5]):&quot;&quot;,&quot; {&quot;)),n+=e(t),r&&(n+=&quot;}&quot;),t[2]&&(n+=&quot;}&quot;),t[4]&&(n+=&quot;}&quot;),n})).join(&quot;&quot;)},t.i=function(e,n,r,o,a){&quot;string&quot;==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]=&quot;@layer&quot;.concat(u[5].length>0?&quot; &quot;.concat(u[5]):&quot;&quot;,&quot; {&quot;).concat(u[1],&quot;}&quot;)),u[5]=a),n&&(u[2]?(u[1]=&quot;@media &quot;.concat(u[2],&quot; {&quot;).concat(u[1],&quot;}&quot;),u[2]=n):u[2]=n),o&&(u[4]?(u[1]=&quot;@supports (&quot;.concat(u[4],&quot;) {&quot;).concat(u[1],&quot;}&quot;),u[4]=o):u[4]=&quot;&quot;.concat(o)),t.push(u))}},t}},490:function(e){&quot;use strict&quot;;e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['&quot;].*['&quot;]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/[&quot;'() \\t\\n]|(%20)/.test(e)||t.needQuotes?'&quot;'.concat(e.replace(/&quot;/g,'\\\\&quot;').replace(/\\n/g,&quot;\\\\n&quot;),'&quot;'):e):e}},22:function(e){&quot;use strict&quot;;e.exports=function(e){return e[1]}},145:function(e,t,n){&quot;use strict&quot;;var r=n(426),o=&quot;function&quot;==typeof Symbol&&&quot;symbol&quot;==typeof Symbol(&quot;foo&quot;),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,&quot;x&quot;,{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||&quot;function&quot;==typeof(o=r)&&&quot;[object Function]&quot;===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){&quot;use strict&quot;;e.exports=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;var e;try{e=this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window;if(&quot;object&quot;==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){&quot;use strict&quot;;e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&&quot;object&quot;==typeof t&&&quot;object&quot;==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){&quot;use strict&quot;;&quot;undefined&quot;!=typeof self?e.exports=self:&quot;undefined&quot;!=typeof window?e.exports=window:e.exports=Function(&quot;return this&quot;)()},177:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){&quot;use strict&quot;;var r=n(491);e.exports=function(){return&quot;object&quot;==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,&quot;globalThis&quot;);t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,&quot;globalThis&quot;,{configurable:!0,enumerable:!1,value:e,writable:!0})}else&quot;object&quot;==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){&quot;use strict&quot;;var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},&quot;toString&quot;),c=s.call((function(){}),&quot;prototype&quot;),u=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if(&quot;undefined&quot;==typeof window)return!1;for(var e in window)try{if(!p[&quot;$&quot;+e]&&o.call(window,e)&&null!==window[e]&&&quot;object&quot;==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&&quot;object&quot;==typeof e,n=&quot;[object Function]&quot;===a.call(e),r=i(e),s=t&&&quot;[object String]&quot;===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError(&quot;Object.keys called on a non-object&quot;);var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&&quot;prototype&quot;===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if(&quot;undefined&quot;==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&&quot;constructor&quot;===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){&quot;use strict&quot;;var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){&quot;use strict&quot;;var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r=&quot;[object Arguments]&quot;===n;return r||(r=&quot;[object Array]&quot;!==n&&null!==e&&&quot;object&quot;==typeof e&&&quot;number&quot;==typeof e.length&&e.length>=0&&&quot;[object Function]&quot;===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(&quot; &quot;),n.s1=r(&quot; &quot;),n.s2=r(&quot; &quot;),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+=&quot;\\0&quot;,r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=&quot;&quot;+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,&quot;global&quot;in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&&quot;object&quot;==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:&quot;string&quot;==o?e:e+&quot;\\0&quot;}function v(e,t){for(var n,r=e+&quot;&quot;,o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}(&quot;undefined&quot;!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){&quot;use strict&quot;;var t=[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r=&quot;&quot;;for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join(&quot;&quot;)}function l(e){return/[\\u0080-\\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a(&quot;hello&quot;)),&quot;undefined&quot;==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff=&quot;&quot;,this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){&quot;use strict&quot;;var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,&quot;.viewer-module-fullScreen_bbk9Y {\\n  position: absolute;\\n  width: 100vw;\\n  height: 100vh;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  z-index: -1;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\n\\n.viewer-module-fullParentSize_ETopO {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n}\\n\\n.viewer-module-bigFileDrop_aqCgh {\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  background-color: white;\\n  background-image: url(&quot;+d+&quot;);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n  background-size: contain;\\n  border-radius: 10px;\\n  width: 50px;\\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\\n  cursor: pointer;\\n}\\n\\n.viewer-module-progress_cYjQJ {\\n  flex: none;\\n  font-size: 50px;\\n  color: black;\\n  z-index: 1;\\n  background: rgba(128,128,128,.5);\\n  padding: 20px;\\n  border-radius: 10px;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\n&quot;,&quot;&quot;]),u.locals={fullScreen:&quot;viewer-module-fullScreen_bbk9Y&quot;,fullParentSize:&quot;viewer-module-fullParentSize_ETopO&quot;,bigFileDrop:&quot;viewer-module-bigFileDrop_aqCgh&quot;,progress:&quot;viewer-module-progress_cYjQJ&quot;},t.Z=u},396:function(e,t,n){var r=n(13),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){&quot;use strict&quot;;var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d=&quot;&quot;.concat(c,&quot; &quot;).concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){&quot;use strict&quot;;var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error(&quot;Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.&quot;);r.appendChild(n)}},60:function(e){&quot;use strict&quot;;e.exports=function(e){var t=document.createElement(&quot;style&quot;);return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){&quot;use strict&quot;;e.exports=function(e){var t=n.nc;t&&e.setAttribute(&quot;nonce&quot;,t)}},760:function(e){&quot;use strict&quot;;e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r=&quot;&quot;;n.supports&&(r+=&quot;@supports (&quot;.concat(n.supports,&quot;) {&quot;)),n.media&&(r+=&quot;@media &quot;.concat(n.media,&quot; {&quot;));var o=void 0!==n.layer;o&&(r+=&quot;@layer&quot;.concat(n.layer.length>0?&quot; &quot;.concat(n.layer):&quot;&quot;,&quot; {&quot;)),r+=n.css,o&&(r+=&quot;}&quot;),n.media&&(r+=&quot;}&quot;),n.supports&&(r+=&quot;}&quot;);var a=n.sourceMap;a&&&quot;undefined&quot;!=typeof btoa&&(r+=&quot;\\n/*# sourceMappingURL=data:application/json;base64,&quot;.concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))),&quot; */&quot;)),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){&quot;use strict&quot;;e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){&quot;use strict&quot;;e.exports=n.p+&quot;138e7b1469f64156810a.jpg&quot;},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error(&quot;define cannot be used indirect&quot;)},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;try{return this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){&quot;undefined&quot;!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p=&quot;&quot;,n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();\n<\/script>\n<script>\nvar container = document.querySelector('.content');\nvar base64Str = &quot;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&quot;;\n\nOfflineLocalView.load(container, { base64Str });\n<\/script>\n</body>\n</html>\n\" class=\"pyvista\" style=\"width: 99%; height: 600px; border: 1px solid rgb(221,221,221);\"></iframe>"}}, "ccc90c23255246e3b80bfba2608deb56": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_d0b4823ee30f4382a63e003d20c56ddf", "style": "IPY_MODEL_fc216aa607af42ad88e4162d1606d2ba", "value": "<iframe srcdoc=\"<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;/>\n    <meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;>\n  </head>\n  <body>\n    <div class=&quot;content&quot;></div>\n<script type=&quot;text/javascript&quot;>\n!function(){var e={334:function(){const e=document.querySelector(&quot;head&quot;);e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement(&quot;link&quot;);n.setAttribute(&quot;rel&quot;,&quot;icon&quot;),n.setAttribute(&quot;href&quot;,`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute(&quot;sizes&quot;,`${t}x${t}`),n.setAttribute(&quot;type&quot;,&quot;image/png&quot;),e.appendChild(n)}))},13:function(e,t,n){&quot;use strict&quot;;n.r(t),n.d(t,{initLocalFileLoader:function(){return ZA},load:function(){return YA}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return E},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return D},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ee},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return De},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i=&quot;undefined&quot;!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],D=r[2],E=Math.hypot(R,M,D);return E<a?null:(R*=E=1/E,M*=E,D*=E,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+D*o,C=D*R*s-M*o,S=R*M*s-D*o,A=M*M*s+i,I=D*M*s+R*o,w=R*D*s+M*o,P=M*D*s-R*o,O=D*D*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),E(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,D=(1-(p+v))*C,E=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=D,e[6]=E,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+D*I+L*w),e[14]=n[2]+w-(R*A+E*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return&quot;mat4(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;, &quot;+e[9]+&quot;, &quot;+e[10]+&quot;, &quot;+e[11]+&quot;, &quot;+e[12]+&quot;, &quot;+e[13]+&quot;, &quot;+e[14]+&quot;, &quot;+e[15]+&quot;)&quot;}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],D=t[12],E=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-D)<=a*Math.max(1,Math.abs(m),Math.abs(D))&&Math.abs(h-E)<=a*Math.max(1,Math.abs(h),Math.abs(E))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return&quot;mat3(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;)&quot;}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function De(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=De,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error(&quot;Invalid VTK object&quot;),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&&quot;object&quot;==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol(&quot;void&quot;),$e={};function qe(){}[&quot;log&quot;,&quot;debug&quot;,&quot;info&quot;,&quot;warn&quot;,&quot;error&quot;,&quot;time&quot;,&quot;timeEnd&quot;,&quot;group&quot;,&quot;groupEnd&quot;].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty(&quot;log&quot;)?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st(&quot;_&quot;===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=[&quot;TB&quot;,&quot;GB&quot;,&quot;MB&quot;,&quot;KB&quot;];let o=Number(e),a=&quot;B&quot;;for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot; &quot;;const n=[];let r=e;for(;r>1e3;)n.push((&quot;000&quot;+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),&quot;classHierarchy&quot;in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He(&quot;vtkObject&quot;);function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==[&quot;mtime&quot;].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||&quot;_&quot;===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(&quot;, &quot;)}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if(&quot;object&quot;==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(&quot;string&quot;==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError(&quot;Set Enum with invalid string argument&quot;)}if(&quot;number&quot;==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError(&quot;Set Enum outside numeric range&quot;)}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError(&quot;Set Enum with invalid argument (String/Number)&quot;)}},object(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(!ke()(t[n.name],o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}return!1}}};function Ct(e){if(&quot;object&quot;==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError(&quot;No setter for field&quot;)}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{&quot;object&quot;==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et(&quot;instance deleted - cannot call any method&quot;);else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=&quot; input ports. To add more input ports, use addInputConnection()&quot;,void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et(&quot;instance deleted - cannot call any method&quot;),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):o(e,i())},e.addInputConnection=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:&quot;Scalars&quot;;for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol(&quot;Event abort&quot;);function Dt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et(&quot;instance deleted - cannot call any method&quot;);const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA(&quot;vtkObject&quot;)}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt=&quot;__root__&quot;;function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=&quot;&quot;+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,[&quot;proxyId&quot;,&quot;proxyGroup&quot;,&quot;proxyName&quot;]),At(e,t,[&quot;proxyManager&quot;]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if(&quot;application&quot;===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,&quot;application&quot;),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return&quot;detail&quot;in e&&(n=e.detail),&quot;wheelDelta&quot;in e&&(n=-e.wheelDelta/120),&quot;wheelDeltaY&quot;in e&&(n=-e.wheelDeltaY/120),&quot;wheelDeltaX&quot;in e&&(t=-e.wheelDeltaX/120),&quot;axis&quot;in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,&quot;deltaY&quot;in e&&(o=e.deltaY),&quot;deltaX&quot;in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Dt,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Et,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Dt,newInstance:Et,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push(&quot;vtkViewNode&quot;),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)r.setVisited(!0);else{const r=e.createViewNode(n);r&&(r.setParent(e),r.setVisited(!0),t._renderableChildMap.set(n,r),t.children.push(r))}},e.addMissingNodes=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r],a=t._renderableChildMap.get(o);if(void 0!==a)a.setVisited(!0);else{const n=e.createViewNode(o);n&&(n.setParent(e),n.setVisited(!0),t._renderableChildMap.set(o,n),t.children.push(n))}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];-1===t.children.indexOf(o)&&(o.setParent(e),t.children.push(o)),o.setVisited(!0)}},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t(&quot;Cannot create view nodes without my own factory&quot;),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),t._renderableChildMap=new Map,jt.get(e,t,[&quot;visited&quot;]),jt.setGet(e,t,[&quot;_parent&quot;,&quot;renderable&quot;,&quot;myFactory&quot;]),jt.getArray(e,t,[&quot;children&quot;]),jt.moveToProtected(e,t,[&quot;parent&quot;]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,&quot;vtkViewNode&quot;),extend:Yt,PASS_TYPES:[&quot;Build&quot;,&quot;Render&quot;]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push(&quot;vtkViewNodeFactory&quot;),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s},e.registerOverride=(e,n)=>{t.overrides[e]=n}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,&quot;vtkViewNodeFactory&quot;),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push(&quot;vtkOpenGLViewNodeFactory&quot;)}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,&quot;vtkOpenGLViewNodeFactory&quot;),extend:sn};function cn(e,t){t.classHierarchy.push(&quot;vtkOpenGLCamera&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,[&quot;context&quot;,&quot;keyMatrixTime&quot;]),cn(e,t)}));rn(&quot;vtkCamera&quot;,dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderer&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn(&quot;No lights are on, creating one.&quot;),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();t.context.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,[&quot;shaderCache&quot;]),At(e,t,[&quot;selector&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),fn(e,t)}),&quot;vtkOpenGLRenderer&quot;);function hn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor&quot;),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkRenderer&quot;,mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor2D&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn(&quot;vtkActor&quot;,yn);const bn={context:null,activeTextures:null};const xn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function Dn(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function En(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn(&quot;vtkActor2D&quot;,xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn=&quot;\\\\s*([+-]?\\\\d+)\\\\s*&quot;,Jn=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*&quot;,er=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*&quot;,tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\\\(${Qn},${Qn},${Qn}\\\\)$`),rr=new RegExp(`^rgb\\\\(${er},${er},${er}\\\\)$`),or=new RegExp(`^rgba\\\\(${Qn},${Qn},${Qn},${Jn}\\\\)$`),ar=new RegExp(`^rgba\\\\(${er},${er},${er},${Jn}\\\\)$`),ir=new RegExp(`^hsl\\\\(${Jn},${er},${er}\\\\)$`),sr=new RegExp(`^hsla\\\\(${Jn},${er},${er},${Jn}\\\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+&quot;&quot;).trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):&quot;transparent&quot;===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?&quot;rgb(&quot;:&quot;rgba(&quot;}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?&quot;)&quot;:`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?&quot;0&quot;:&quot;&quot;)+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?&quot;hsl(&quot;:&quot;hsla(&quot;}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?&quot;)&quot;:`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Dr=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+&quot;&quot;}}return r.gamma=e,r}(1);function Er(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+&quot;&quot;}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&&quot;object&quot;==typeof e||(e={}),null!==t&&&quot;object&quot;==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Er((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Er((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,Fr=new RegExp(_r.source,&quot;g&quot;);function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+=&quot;&quot;,t+=&quot;&quot;;(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+&quot;&quot;}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join(&quot;&quot;)})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||&quot;boolean&quot;===r?Rr(t):(&quot;number&quot;===r?Br:&quot;string&quot;===r?(n=dr(t))?(t=n,Dr):kr:t instanceof dr?Dr:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:&quot;function&quot;!=typeof t.valueOf&&&quot;function&quot;!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error(&quot;invalid format: &quot;+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?&quot; &quot;:e.fill+&quot;&quot;,this.align=void 0===e.align?&quot;>&quot;:e.align+&quot;&quot;,this.sign=void 0===e.sign?&quot;-&quot;:e.sign+&quot;&quot;,this.symbol=void 0===e.symbol?&quot;&quot;:e.symbol+&quot;&quot;,this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?&quot;&quot;:e.type+&quot;&quot;}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf(&quot;e&quot;))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1];return o<0?&quot;0.&quot;+new Array(-o).join(&quot;0&quot;)+r:r.length>o+1?r.slice(0,o+1)+&quot;.&quot;+r.slice(o+1):r+new Array(o-r.length+2).join(&quot;0&quot;)}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?&quot;0&quot;:&quot;&quot;)+(void 0===this.width?&quot;&quot;:Math.max(1,0|this.width))+(this.comma?&quot;,&quot;:&quot;&quot;)+(void 0===this.precision?&quot;&quot;:&quot;.&quot;+Math.max(0,0|this.precision))+(this.trim?&quot;~&quot;:&quot;&quot;)+this.type};var ao={&quot;%&quot;:(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+&quot;&quot;,d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString(&quot;en&quot;).replace(/,/g,&quot;&quot;):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join(&quot;0&quot;):a>0?r.slice(0,a)+&quot;.&quot;+r.slice(a):&quot;0.&quot;+new Array(1-a).join(&quot;0&quot;)+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=[&quot;y&quot;,&quot;z&quot;,&quot;a&quot;,&quot;f&quot;,&quot;p&quot;,&quot;n&quot;,&quot;\u00b5&quot;,&quot;m&quot;,&quot;&quot;,&quot;k&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;,&quot;Z&quot;,&quot;Y&quot;];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?&quot;,f&quot;:r)).type){case&quot;s&quot;:var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case&quot;&quot;:case&quot;e&quot;:case&quot;g&quot;:case&quot;p&quot;:case&quot;r&quot;:null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-(&quot;e&quot;===r.type));break;case&quot;f&quot;:case&quot;%&quot;:null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*(&quot;%&quot;===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+&quot;&quot;,function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?&quot;&quot;:e.currency[0]+&quot;&quot;,a=void 0===e.currency?&quot;&quot;:e.currency[1]+&quot;&quot;,i=void 0===e.decimal?&quot;.&quot;:e.decimal+&quot;&quot;,s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?&quot;%&quot;:e.percent+&quot;&quot;,c=void 0===e.minus?&quot;\u2212&quot;:e.minus+&quot;&quot;,u=void 0===e.nan?&quot;NaN&quot;:e.nan+&quot;&quot;;function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;&quot;n&quot;===y?(m=!0,y=&quot;g&quot;):ao[y]||(void 0===h&&(h=12),v=!0,y=&quot;g&quot;),(f||&quot;0&quot;===t&&&quot;=&quot;===n)&&(f=!0,t=&quot;0&quot;,n=&quot;=&quot;);var T=&quot;$&quot;===p?o:&quot;#&quot;===p&&/[boxX]/.test(y)?&quot;0&quot;+y.toLowerCase():&quot;&quot;,b=&quot;$&quot;===p?a:/[%p]/.test(y)?l:&quot;&quot;,x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if(&quot;c&quot;===y)S=x(e)+S,e=&quot;&quot;;else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case&quot;.&quot;:o=t=r;break;case&quot;0&quot;:0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&&quot;+&quot;!==d&&(A=!1),p=(A?&quot;(&quot;===d?d:c:&quot;-&quot;===d||&quot;(&quot;===d?&quot;&quot;:d)+p,S=(&quot;s&quot;===y?po[8+Qr/3]:&quot;&quot;)+S+(A&&&quot;(&quot;===d?&quot;)&quot;:&quot;&quot;),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):&quot;&quot;;switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=&quot;&quot;),n){case&quot;<&quot;:e=p+e+S+w;break;case&quot;=&quot;:e=p+w+e+S;break;case&quot;^&quot;:e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+&quot;&quot;},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type=&quot;f&quot;,e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:&quot;,&quot;,grouping:[3],currency:[&quot;$&quot;,&quot;&quot;]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Do,ceil:Eo,min:Vo,max:Lo}=Math;const Bo=Ao(&quot;ceilLog2&quot;),No=Ao(&quot;factorial&quot;);function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao(&quot;gaussian&quot;);function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes(&quot;e&quot;))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split(&quot;e&quot;);let r=&quot;&quot;;return+n[1]+t>0&&(r=&quot;+&quot;),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co(&quot;vtkMath::Jacobi: Error extracting eigenfunctions&quot;),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co(&quot;Unable to factor linear system&quot;),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co(&quot;Unable to factor linear system&quot;),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Da(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Ea=Ao(&quot;GetScalarTypeFittingRange&quot;),Va=Ao(&quot;GetAdjustedScalarRange&quot;);const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Do,ceil:Eo,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo(&quot;Number of columns of A must match number of rows of B.&quot;);const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co(&quot;Matrix has 0 determinant&quot;),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co(&quot;Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()&quot;),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Da,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Ea,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;#&quot;;return`${t}${e.map(Ga).join(&quot;&quot;)}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(&quot;, &quot;)})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};const Wa=1e-6,Ha=&quot;coincide&quot;,ja=&quot;disjoint&quot;;function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?&quot;x&quot;:i[1]>i[2]?&quot;y&quot;:&quot;z&quot;;const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case&quot;x&quot;:l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case&quot;y&quot;:l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case&quot;z&quot;:l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha};function Ja(e,t){t.classHierarchy.push(&quot;vtkPlane&quot;),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}const ei={normal:[0,0,1],origin:[0,0,0]};function ti(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ei,n),jt.obj(e,t),jt.setGetArray(e,t,[&quot;normal&quot;,&quot;origin&quot;],3),Ja(e,t)}var ni={newInstance:jt.newInstance(ti,&quot;vtkPlane&quot;),extend:ti,...Qa};const ri=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function oi(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ai(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ii(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function si(e){return ii(e,ri)}function li(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function ci(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)li(e,...t[n]);else for(let n=0;n<t.length;n+=3)li(e,...t.slice(n,n+3));return e}function ui(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function fi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function gi(e,t,n,r){return!!ai(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function mi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function hi(e,t){return e[2*t+1]-e[2*t]}function vi(e){return[hi(e,0),hi(e,1),hi(e,2)]}function yi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function bi(e){return e.slice(4,6)}function xi(e){const t=vi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function Ci(e){if(ai(e)){const t=vi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Si(e){return[e[0],e[2],e[4]]}function Ai(e){return[e[1],e[3],e[5]]}function Ii(e,t){return e<=0&&t>=0||e>=0&&t<=0}function wi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Pi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=wi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return si(n),ci(n,r)}function Ri(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Mi(e,t,n,r){const o=[].concat(ri),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Di(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ni.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!ai(e)||!ai(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Li(e,t){if(!ai(e)||!ai(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Bi(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Ni(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ni.evaluate(n,t,l)}let i=2;for(;i--&&!(Ii(o[r[i][0]],o[r[i][4]])&&Ii(o[r[i][1]],o[r[i][5]])&&Ii(o[r[i][2]],o[r[i][6]])&&Ii(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class _i{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ri))}getBounds(){return this.bounds}equals(e){return oi(this.bounds,e)}isValid(){return ai(this.bounds)}setBounds(e){return ii(this.bounds,e)}reset(){return si(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return li(this.bounds,...t)}addPoints(e){return ci(this.bounds,e)}addBounds(e,t,n,r,o,a){return ui(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return di(this.bounds,e,t,n)}setMaxPoint(e,t,n){return pi(this.bounds,e,t,n)}inflate(e){return fi(this.bounds,e)}scale(e,t,n){return gi(this.bounds,e,t,n)}getCenter(){return mi(this.bounds)}getLength(e){return hi(this.bounds,e)}getLengths(){return vi(this.bounds)}getMaxLength(){return xi(this.bounds)}getDiagonalLength(){return Ci(this.bounds)}getMinPoint(){return Si(this.bounds)}getMaxPoint(){return Ai(this.bounds)}getXRange(){return yi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return bi(this.bounds)}getCorners(e){return wi(this.bounds,e)}computeCornerPoints(e,t){return Pi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Mi(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Ri(this.bounds,e)}cutWithPlane(e,t){return Ni(this.bounds,e,t)}intersectBox(e,t,n,r){return Di(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Li(this.bounds,e)}containsPoint(e,t,n){return Bi(this.bounds,e,t,n)}contains(e){return Li(this.bounds,e)}}var Fi,ki={newInstance:function(e){const t=e&&e.bounds;return new _i(t)},equals:oi,isValid:ai,setBounds:ii,reset:si,addPoint:li,addPoints:ci,addBounds:ui,setMinPoint:di,setMaxPoint:pi,inflate:fi,scale:gi,scaleAboutCenter:function(e,t,n,r){if(!ai(e))return!1;const o=mi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],gi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:mi,getLength:hi,getLengths:vi,getMaxLength:xi,getDiagonalLength:Ci,getMinPoint:Si,getMaxPoint:Ai,getXRange:yi,getYRange:Ti,getZRange:bi,getCorners:wi,computeCornerPoints:Pi,computeLocalBounds:Mi,transformBounds:Oi,computeScale3:Ri,cutWithPlane:Ni,intersectBox:Di,intersectPlane:Ei,intersect:Vi,intersects:Li,containsPoint:Bi,contains:function(e,t){return!!Li(e,t)&&!!Bi(e,...Si(t))&&!!Bi(e,...Ai(t))},INIT_BOUNDS:ri};function Gi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Ui(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function zi(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function Wi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Fi=new i(4),i!=Float32Array&&(Fi[0]=0,Fi[1]=0,Fi[2]=0,Fi[3]=0);var Hi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),Ui(),Ui(),ie();var ji={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Ki}=ji;function $i(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function qi(e,t){t.classHierarchy.push(&quot;vtkProp&quot;),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=$i(&quot;pick&quot;),e.hasKey=$i(&quot;hasKey&quot;),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Ki.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Ki.DISPLAY)}const Xi={allocatedRenderTime:10,coordinateSystem:Ki.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function Yi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xi,n),jt.obj(e,t),jt.get(e,t,[&quot;estimatedRenderTime&quot;,&quot;allocatedRenderTime&quot;]),jt.setGet(e,t,[&quot;_parentProp&quot;,&quot;coordinateSystem&quot;,&quot;dragable&quot;,&quot;pickable&quot;,&quot;renderTimeMultiplier&quot;,&quot;useBounds&quot;,&quot;visibility&quot;]),jt.moveToProtected(e,t,[&quot;parentProp&quot;]),qi(e,t)}var Zi={newInstance:jt.newInstance(Yi,&quot;vtkProp&quot;),extend:Yi,...ji};function Qi(e,t){t.classHierarchy.push(&quot;vtkProp3D&quot;),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Ui();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=Ui();zi(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>ki.getCenter(t.bounds),e.getLength=()=>ki.getLength(t.bounds),e.getXRange=()=>ki.getXRange(t.bounds),e.getYRange=()=>ki.getYRange(t.bounds),e.getZRange=()=>ki.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const Ji={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Zi.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,[&quot;bounds&quot;,&quot;isIdentity&quot;]),jt.getArray(e,t,[&quot;orientation&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;position&quot;,&quot;scale&quot;],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,Qi(e,t)}var ts={newInstance:jt.newInstance(es,&quot;vtkProp3D&quot;),extend:es};const ns={FLAT:0,GOURAUD:1,PHONG:2},rs={POINTS:0,WIREFRAME:1,SURFACE:2};var os={Shading:ns,Representation:rs,Interpolation:ns};const{Representation:as,Interpolation:is}=os;function ss(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ls(e,t){t.classHierarchy.push(&quot;vtkProperty&quot;),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ss(&quot;ComputeCompositeColor&quot;),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ss(&quot;AddShaderVariable&quot;),e.setInterpolationToFlat=()=>e.setInterpolation(is.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(is.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(is.PHONG),e.getInterpolationAsString=()=>jt.enumToString(is,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(as.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(as.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(as.POINTS),e.getRepresentationAsString=()=>jt.enumToString(as,t.representation)}const cs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:is.GOURAUD,representation:as.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function us(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cs,n),jt.obj(e,t),jt.setGet(e,t,[&quot;lighting&quot;,&quot;interpolation&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;metallic&quot;,&quot;roughness&quot;,&quot;normalStrength&quot;,&quot;emission&quot;,&quot;baseIOR&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;opacity&quot;,&quot;edgeVisibility&quot;,&quot;lineWidth&quot;,&quot;pointSize&quot;,&quot;backfaceCulling&quot;,&quot;frontfaceCulling&quot;,&quot;representation&quot;,&quot;diffuseTexture&quot;,&quot;metallicTexture&quot;,&quot;roughnessTexture&quot;,&quot;normalTexture&quot;,&quot;ambientOcclusionTexture&quot;,&quot;emissionTexture&quot;]),jt.setGetArray(e,t,[&quot;ambientColor&quot;,&quot;specularColor&quot;,&quot;diffuseColor&quot;,&quot;edgeColor&quot;],3),ls(e,t)}var ds={newInstance:jt.newInstance(us,&quot;vtkProperty&quot;),extend:us,...os};const{vtkDebugMacro:ps}=jt;function fs(e,t){t.classHierarchy.push(&quot;vtkActor&quot;);const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ds.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){ps(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.concat();const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const gs={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gs,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;backfaceProperty&quot;,&quot;forceOpaque&quot;,&quot;forceTranslucent&quot;,&quot;mapper&quot;]),fs(e,t)}var hs={newInstance:jt.newInstance(ms,&quot;vtkActor&quot;),extend:ms};const vs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},ys={VOID:&quot;&quot;,CHAR:&quot;Int8Array&quot;,SIGNED_CHAR:&quot;Int8Array&quot;,UNSIGNED_CHAR:&quot;Uint8Array&quot;,SHORT:&quot;Int16Array&quot;,UNSIGNED_SHORT:&quot;Uint16Array&quot;,INT:&quot;Int32Array&quot;,UNSIGNED_INT:&quot;Uint32Array&quot;,FLOAT:&quot;Float32Array&quot;,DOUBLE:&quot;Float64Array&quot;};var Ts={DefaultDataType:ys.FLOAT,DataTypeByteSize:vs,VtkDataTypes:ys};const{vtkErrorMacro:bs}=Kt,{DefaultDataType:xs}=Ts,Cs=1e-6;function Ss(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function As(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ss(r,0,1)}return Ss(e,t<0?0:t,n)}function Is(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function ws(e){return Object.prototype.toString.call(e).slice(8,-1)}const Ps={computeRange:As,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ss,getDataType:ws,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Os(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push(&quot;vtkDataArray&quot;),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=As(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Cs;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Ds({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=ws(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||bs(&quot;numberOfComponents must match&quot;);const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Rs={name:&quot;&quot;,numberOfComponents:1,dataType:xs,rangeTuple:[0,0]};function Ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Rs,n),!t.empty&&!t.values&&!t.size)throw new TypeError(&quot;Cannot create vtkDataArray object without: size > 0, values&quot;);if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=ws(t.values)),yt(e,t),St(e,t,[&quot;name&quot;,&quot;numberOfComponents&quot;]),t.size%t.numberOfComponents!=0)throw new RangeError(&quot;model.size is not a multiple of model.numberOfComponents&quot;);Os(e,t)}const Ds=Et(Ms,&quot;vtkDataArray&quot;);var Es={newInstance:Ds,extend:Ms,...Ps,...Ts};function Vs(e,t){t.classHierarchy.push(&quot;vtkAbstractMapper&quot;),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA(&quot;vtkPlane&quot;)&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Ls={clippingPlanes:[]};var Bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ls,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),Vs(e,t)};function Ns(e,t){e.getBounds=()=>(jt.vtkErrorMacro(&quot;vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED&quot;),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=ki.isValid(n)?ki.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return ki.getDiagonalLength(t)}}const _s=e=>({bounds:[...ki.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var Fs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_s(n)),Bs(e,t,n),jt.setGet(e,t,[&quot;viewSpecificProperties&quot;]),Ns(e,t)};const{vtkErrorMacro:ks,vtkWarningMacro:Gs}=jt;function Us(e,t){t.classHierarchy.push(&quot;vtkFieldData&quot;);const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>&quot;number&quot;==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():&quot;&quot;},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else ks(&quot;Unhandled case in passData&quot;);else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Es.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Gs(&quot;Unexpected case in interpolateData&quot;)}else t.insertTuples(s.getTuples());else ks(&quot;Unhandled case in interpolateData&quot;);else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Es.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const zs={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Ws(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zs,n),jt.obj(e,t),Us(e,t)}var Hs={newInstance:jt.newInstance(Ws,&quot;vtkFieldData&quot;),extend:Ws};const js={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ks={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:js,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:&quot;vtkGhostType&quot;};const{AttributeTypes:$s,AttributeCopyOperations:qs}=Ks,{vtkWarningMacro:Xs}=jt;function Ys(e,t){const n=[&quot;Scalars&quot;,&quot;Vectors&quot;,&quot;Normals&quot;,&quot;TCoords&quot;,&quot;Tensors&quot;,&quot;GlobalIds&quot;,&quot;PedigreeIds&quot;];function r(e){let t=n.find((t=>$s[t.toUpperCase()]===e||&quot;number&quot;!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push(&quot;vtkDataSetAttributes&quot;);const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&&quot;PEDIGREEIDS&quot;===a.toUpperCase()&&!n.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if(&quot;PEDIGREEIDS&quot;!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(qs).filter((e=>&quot;ALLCOPY&quot;!==e)).forEach((e=>{t.copyAttributeFlags[qs[e]]=Object.keys($s).filter((e=>&quot;NUM_ATTRIBUTES&quot;!==e)).reduce(((e,t)=>(e[$s[t]]=!0,e)),[])})),t.copyAttributeFlags[qs.COPYTUPLE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.INTERPOLATE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.COPYTUPLE][$s.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||&quot;vtkDataArray&quot;!==t.dataArrays[n].type||e.addArray(Es.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const Zs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Qs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zs,n),Hs.extend(e,t,n),jt.setGet(e,t,[&quot;activeScalars&quot;,&quot;activeNormals&quot;,&quot;activeTCoords&quot;,&quot;activeVectors&quot;,&quot;activeTensors&quot;,&quot;activeGlobalIds&quot;,&quot;activePedigreeIds&quot;]),t.arrays||(t.arrays={}),Ys(e,t)}var Js={newInstance:jt.newInstance(Qs,&quot;vtkDataSetAttributes&quot;),extend:Qs,...Ks};const el=[&quot;pointData&quot;,&quot;cellData&quot;,&quot;fieldData&quot;];function tl(e,t){t.classHierarchy.push(&quot;vtkDataSet&quot;),el.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Js.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),el.forEach((n=>{t[n]=Js.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const nl={};function rl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nl,n),jt.obj(e,t),jt.setGet(e,t,el),tl(e,t)}var ol={newInstance:jt.newInstance(rl,&quot;vtkDataSet&quot;),extend:rl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const al={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var il={StructuredType:al};const{StructuredType:sl}=il;var ll={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?sl.EMPTY:3===t?sl.XYZ_GRID:2===t?e[0]===e[1]?sl.YZ_PLANE:e[2]===e[3]?sl.XZ_PLANE:sl.XY_PLANE:1===t?e[0]<e[1]?sl.X_LINE:e[2]<e[3]?sl.Y_LINE:sl.Z_LINE:sl.SINGLE_POINT},...il};const{vtkErrorMacro:cl}=jt;function ul(e,t){t.classHierarchy.push(&quot;vtkImageData&quot;),e.setExtent=function(){if(t.deleted)return cl(&quot;instance deleted - cannot call any method&quot;),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=ll.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)cl(&quot;instance deleted - cannot call any method&quot;);else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void cl(&quot;Bad dimension specification&quot;);n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return cl(&quot;Requesting a point from an empty image.&quot;),null;const o=new Float64Array(3);switch(t.dataDescription){case al.EMPTY:return null;case al.SINGLE_POINT:break;case al.X_LINE:o[0]=n;break;case al.Y_LINE:o[1]=n;break;case al.Z_LINE:o[2]=n;break;case al.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case al.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case al.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case al.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:cl(&quot;Invalid dataDescription&quot;)}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>ki.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>ki.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>ki.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];ki.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Da(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Da(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return cl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return cl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const dl={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:al.EMPTY};function pl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dl,n),ol.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,[&quot;indexToWorld&quot;,&quot;worldToIndex&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;spacing&quot;],3),jt.setGetArray(e,t,[&quot;direction&quot;],9),jt.getArray(e,t,[&quot;extent&quot;],6),ul(e,t)}var fl={newInstance:jt.newInstance(pl,&quot;vtkImageData&quot;),extend:pl};const gl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var ml={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:gl},hl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:vl,VectorMode:yl}=ml,{VtkDataTypes:Tl}=Es,{ColorMode:bl}=hl,{vtkErrorMacro:xl}=jt;function Cl(e){return e}function Sl(e){return Math.floor(255*e+.5)}function Al(e,t){t.classHierarchy.push(&quot;vtkScalarsToColors&quot;),e.setVectorModeToMagnitude=()=>e.setVectorMode(yl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(yl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(yl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)xl(&quot;Values and annotations do not have the same number of tuples so ignoring&quot;);else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===bl.DEFAULT&&t.getDataType()===Tl.UNSIGNED_CHAR||n===bl.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:&quot;vtkDataArray&quot;,name:&quot;temp&quot;,numberOfComponents:4,dataType:Tl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Es.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,vl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,vl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===yl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==yl.MAGNITUDE||1!==c&&1!==s||(i=yl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case yl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case yl.RGBCOLORS:break;case yl.MAGNITUDE:default:{const o=Es.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Sl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Tl.UNSIGNED_CHAR)return n;const i=Es.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Tl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=Cl;switch(n.getDataType()!==Tl.FLOAT&&n.getDataType()!==Tl.DOUBLE||(s=Sl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return xl(&quot;Cannot convert colors&quot;),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==bl.DEFAULT||n.getDataType()!==Tl.UNSIGNED_CHAR)&&r!==bl.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Il={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:yl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function wl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Il,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,[&quot;vectorSize&quot;,&quot;vectorComponent&quot;,&quot;vectorMode&quot;,&quot;alpha&quot;,&quot;indexedLookup&quot;]),jt.setArray(e,t,[&quot;mappingRange&quot;],2),jt.getArray(e,t,[&quot;mappingRange&quot;]),Al(e,t)}var Pl={newInstance:jt.newInstance(wl,&quot;vtkScalarsToColors&quot;),extend:wl,...ml};const{vtkErrorMacro:Ol}=jt;function Rl(e,t){t.classHierarchy.push(&quot;vtkLookupTable&quot;),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Ol(&quot;Expected 4 components for RGBA colors&quot;),!1;if(n.getDataType()!==ys.UNSIGNED_CHAR)return Ol(&quot;Expected unsigned char values for RGBA colors&quot;),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ml={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Dl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ml,n),Pl.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,[&quot;buildTime&quot;]),jt.setGet(e,t,[&quot;numberOfColors&quot;,&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;]),jt.setArray(e,t,[&quot;alphaRange&quot;,&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;],2),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;,&quot;alphaRange&quot;,&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),Rl(e,t)}var El={newInstance:jt.newInstance(Dl,&quot;vtkLookupTable&quot;),extend:Dl};let Vl=1,Ll=0;const Bl=[&quot;VTK_RESOLVE_OFF&quot;,&quot;VTK_RESOLVE_POLYGON_OFFSET&quot;];function Nl(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;Ll=e}var _l={getResolveCoincidentTopologyAsString:function(){return Bl[Ll]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Vl},getResolveCoincidentTopology:function(){return Ll},setResolveCoincidentTopology:Nl,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){Vl=e},setResolveCoincidentTopologyToDefault:function(){Nl(0)},setResolveCoincidentTopologyToOff:function(){Nl(0)},setResolveCoincidentTopologyToPolygonOffset:function(){Nl(1)}};function Fl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=(e,r)=>{t[n.key]={factor:e,offset:r}}}))}const kl=[&quot;Polygon&quot;,&quot;Line&quot;,&quot;Point&quot;],Gl={};Fl(Gl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},kl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Ul={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,[&quot;resolveCoincidentTopology&quot;]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(_l).forEach((t=>{e[t]=_l[t]})),Object.keys(Gl).forEach((t=>{e[t]=Gl[t]})),Fl(e,t.topologyOffset,kl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=Gl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:Gl,otherStaticMethods:_l,CATEGORIES:kl};const zl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Wl={PassTypes:zl};const{FieldAssociations:Hl}=ol,{staticOffsetAPI:jl,otherStaticMethods:Kl}=Ul,{ColorMode:$l,ScalarMode:ql,GetArray:Xl}=hl,{VectorMode:Yl}=ml,{VtkDataTypes:Zl}=Es;function Ql(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Jl(e,t){t.classHierarchy.push(&quot;vtkMapper&quot;),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString($l,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(ql,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===ql.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===ql.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===ql.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===ql.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_FIELD_DATA){const t=e.getFieldData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==a){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(n))e.mapScalarsToTexture(o,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},e.scalarToTextureCoordinate=(e,t,n)=>{let r=.5,o=1;return _a(e)||(o=.49,r=(e-t)*n,r>1e3?r=1e3:r<-1e3&&(r=-1e3)),{texCoordS:r,texCoordT:o}},e.createColorTextureCoordinates=(t,n,r,o,a,i,s,l,c)=>{const u=(i[1]-i[0])/l,d=[];d[0]=i[0]-u,d[1]=i[1]+u;const p=1/(d[1]-d[0]),f=n.getData(),g=t.getData();let m=0,h=0;if(a<0||a>=o)for(let t=0;t<r;++t){let t=0;for(let e=0;e<o;++e)t+=g[m]*g[m],m++;let n=Math.sqrt(t);c&&(n=El.applyLogScale(n,s,i));const r=e.scalarToTextureCoordinate(n,d[0],p);f[h]=r.texCoordS,f[h+1]=r.texCoordT,h+=2}else{m+=a;for(let t=0;t<r;++t){let t=g[m];c&&(t=El.applyLogScale(t,s,i));const n=e.scalarToTextureCoordinate(t,d[0],p);f[h]=n.texCoordS,f[h+1]=n.texCoordT,h+=2,m+=o}}},e.mapScalarsToTexture=(n,r)=>{const o=t.lookupTable.getRange(),a=t.lookupTable.usingLogScale();a&&El.getLogRange(o,o);const i=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==r){t.lookupTable.setAlpha(r),t.colorTextureMap=null,t.lookupTable.build();let e=t.lookupTable.getNumberOfAvailableColors();e>4094&&(e=4094),e<64&&(e=64),e+=2;const n=(o[1]-o[0])/(e-2),s=new Float64Array(2*e);for(let t=0;t<e;++t)s[t]=o[0]+t*n-n/2,a&&(s[t]=10**s[t]);for(let t=0;t<e;++t)s[t+e]=NaN;t.colorTextureMap=fl.newInstance(),t.colorTextureMap.setExtent(0,e-1,0,1,0,0);const l=Es.newInstance({numberOfComponents:1,values:s});t.colorTextureMap.getPointData().setScalars(t.lookupTable.mapScalars(l,t.colorMode,0)),t.lookupTable.setAlpha(i)}if(!t.colorCoordinates||e.getMTime()>t.colorCoordinates.getMTime()||e.getInputData(0).getMTime()>t.colorCoordinates.getMTime()||t.lookupTable.getMTime()>t.colorCoordinates.getMTime()){t.colorCoordinates=null;const r=n.getNumberOfComponents(),i=n.getNumberOfTuples();t.colorCoordinates=Es.newInstance({numberOfComponents:2,values:new Float32Array(2*i)});let s=t.lookupTable.getVectorComponent();t.lookupTable.getVectorMode()===Yl.MAGNITUDE&&n.getNumberOfComponents()>1&&(s=-1),e.createColorTextureCoordinates(n,t.colorCoordinates,i,r,s,o,t.lookupTable.getRange(),t.colorTextureMap.getPointData().getScalars().getNumberOfTuples()/2-2,a)}},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=n=>{if(!t.interpolateScalarsBeforeMapping)return!1;if(t.lookupTable&&t.lookupTable.getIndexedLookup())return!1;const r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName),o=r.scalars;return!(!o||r.cellFlag||t.colorMode===$l.DEFAULT&&o.getDataType()===Zl.UNSIGNED_CHAR||t.colorMode===$l.DIRECT_SCALARS)},e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=Ql(&quot;AcquireInvertibleLookupTable&quot;),e.valueToColor=Ql(&quot;ValueToColor&quot;),e.colorToValue=Ql(&quot;ColorToValue&quot;),e.useInvertibleColorFor=Ql(&quot;UseInvertibleColorFor&quot;),e.clearInvertibleColor=Ql(&quot;ClearInvertibleColor&quot;),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(zl.ID_LOW24),o=e.getRawPixelBuffer(zl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Hl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Hl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===zl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(zl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===zl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t],n*=256,n+=r[t+1],n*=256,n+=r[t+2];const a=s[n];e.getPixelBuffer(zl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const ec={colorMapColors:null,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function tc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ec,n),Fs(e,t,n),jt.get(e,t,[&quot;colorCoordinates&quot;,&quot;colorMapColors&quot;,&quot;colorTextureMap&quot;,&quot;selectionWebGLIdsToVTKIds&quot;]),jt.setGet(e,t,[&quot;colorByArrayName&quot;,&quot;arrayAccessMode&quot;,&quot;colorMode&quot;,&quot;fieldDataTupleId&quot;,&quot;interpolateScalarsBeforeMapping&quot;,&quot;lookupTable&quot;,&quot;populateSelectionSettings&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;useLookupTableScalarRange&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),Ul.implementCoincidentTopologyMethods(e,t),Jl(e,t)}var nc={newInstance:jt.newInstance(tc,&quot;vtkMapper&quot;),extend:tc,...jl,...Kl,...hl};function rc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function oc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const ac={extractCellSizes:rc,getNumberOfCells:oc};function ic(e,t){t.classHierarchy.push(&quot;vtkCellArray&quot;);const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=oc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=rc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function sc(e){return{empty:!0,numberOfComponents:1,dataType:ys.UNSIGNED_INT,...e}}function lc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Es.extend(e,t,sc(n)),ic(e,t)}var cc={newInstance:jt.newInstance(lc,&quot;vtkCellArray&quot;),extend:lc,...ac};const{vtkErrorMacro:uc}=jt,dc=[1,-1,1,-1,1,-1];function pc(e,t){t.classHierarchy.push(&quot;vtkPoints&quot;),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return uc(`getBounds called on an array with components of\\n        ${e.getNumberOfComponents()}`),dc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const fc={empty:!0,numberOfComponents:3,dataType:ys.FLOAT,bounds:[1,-1,1,-1,1,-1]};function gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fc,n),Es.extend(e,t,n),pc(e,t)}var mc={newInstance:jt.newInstance(gc,&quot;vtkPoints&quot;),extend:gc};function hc(e,t){t.classHierarchy.push(&quot;vtkCell&quot;),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro(&quot;vtkCell.evaluatePosition is not implemented.&quot;)}}const vc={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function yc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vc,n),jt.obj(e,t),t.points||(t.points=mc.newInstance()),jt.get(e,t,[&quot;points&quot;,&quot;pointsIds&quot;]),hc(e,t)}var Tc={newInstance:jt.newInstance(yc,&quot;vtkCell&quot;),extend:yc};function bc(e,t){t.classHierarchy.push(&quot;vtkCellLinks&quot;),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA(&quot;vtkPolyData&quot;)){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Tc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Tc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const xc={array:null,maxId:0,extend:0};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),jt.obj(e,t),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,&quot;vtkCellLinks&quot;),extend:Cc};const Ac=0,Ic=1,wc=2,Pc=3,Oc=4,Rc=5,Mc=6,Dc=7,Ec=9,Vc=21,Lc=41,Bc=42,Nc=[&quot;vtkEmptyCell&quot;,&quot;vtkVertex&quot;,&quot;vtkPolyVertex&quot;,&quot;vtkLine&quot;,&quot;vtkPolyLine&quot;,&quot;vtkTriangle&quot;,&quot;vtkTriangleStrip&quot;,&quot;vtkPolygon&quot;,&quot;vtkPixel&quot;,&quot;vtkQuad&quot;,&quot;vtkTetra&quot;,&quot;vtkVoxel&quot;,&quot;vtkHexahedron&quot;,&quot;vtkWedge&quot;,&quot;vtkPyramid&quot;,&quot;vtkPentagonalPrism&quot;,&quot;vtkHexagonalPrism&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkQuadraticEdge&quot;,&quot;vtkQuadraticTriangle&quot;,&quot;vtkQuadraticQuad&quot;,&quot;vtkQuadraticTetra&quot;,&quot;vtkQuadraticHexahedron&quot;,&quot;vtkQuadraticWedge&quot;,&quot;vtkQuadraticPyramid&quot;,&quot;vtkBiQuadraticQuad&quot;,&quot;vtkTriQuadraticHexahedron&quot;,&quot;vtkQuadraticLinearQuad&quot;,&quot;vtkQuadraticLinearWedge&quot;,&quot;vtkBiQuadraticQuadraticWedge&quot;,&quot;vtkBiQuadraticQuadraticHexahedron&quot;,&quot;vtkBiQuadraticTriangle&quot;,&quot;vtkCubicLine&quot;,&quot;vtkQuadraticPolygon&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkConvexPointSet&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkParametricCurve&quot;,&quot;vtkParametricSurface&quot;,&quot;vtkParametricTriSurface&quot;,&quot;vtkParametricQuadSurface&quot;,&quot;vtkParametricTetraRegion&quot;,&quot;vtkParametricHexRegion&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkHigherOrderEdge&quot;,&quot;vtkHigherOrderTriangle&quot;,&quot;vtkHigherOrderQuad&quot;,&quot;vtkHigherOrderPolygon&quot;,&quot;vtkHigherOrderTetrahedron&quot;,&quot;vtkHigherOrderWedge&quot;,&quot;vtkHigherOrderPyramid&quot;,&quot;vtkHigherOrderHexahedron&quot;],_c={getClassNameFromTypeId:function(e){return e<Nc.length?Nc[e]:&quot;UnknownClass&quot;},getTypeIdFromClassName:function(e){return Nc.findIndex(e)},isLinear:function(e){return e<Vc||e===Lc||e===Bc},hasSubCells:function(e){return e===Mc||e===Oc||e===wc}};function Fc(e,t){t.classHierarchy.push(&quot;vtkCellTypes&quot;),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Ac},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const kc={size:0,maxId:-1,extend:1e3};function Gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kc,n),jt.obj(e,t),jt.get(e,t,[&quot;size&quot;,&quot;maxId&quot;,&quot;extend&quot;]),jt.getArray(e,t,[&quot;typeArray&quot;,&quot;locationArray&quot;]),Fc(e,t)}var Uc={newInstance:jt.newInstance(Gc,&quot;vtkCellTypes&quot;),extend:Gc,..._c},zc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Wc}=zc;function Hc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Hc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Wc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Wc.YES_INTERSECTION:Wc.NO_INTERSECTION}const Kc={distanceToLine:Hc,intersection:jc};function $c(e,t){t.classHierarchy.push(&quot;vtkLine&quot;),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Wc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Hc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Hc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Hc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Hc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const qc={orientations:null};function Xc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qc,n),Tc.extend(e,t,n),jt.setGet(e,t,[&quot;orientations&quot;]),$c(e,t)}var Yc={newInstance:jt.newInstance(Xc,&quot;vtkLine&quot;),extend:Xc,...Kc,...zc};function Zc(e,t){t.classHierarchy.push(&quot;vtkPointSet&quot;),t.points?t.points=We(t.points):t.points=mc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=mc.newInstance(),t.points.shallowCopy(e.getPoints())}}const Qc={};function Jc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qc,n),ol.extend(e,t,n),jt.setGet(e,t,[&quot;points&quot;]),Zc(e,t)}var eu={newInstance:jt.newInstance(Jc,&quot;vtkPointSet&quot;),extend:Jc};function tu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function nu(e,t,n,r){tu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const ru={computeNormalDirection:tu,computeNormal:nu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];nu(e,t,n,d),nu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,D=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ni.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ni.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(D=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[D],P[D]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function ou(e,t){t.classHierarchy.push(&quot;vtkTriangle&quot;),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(nu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ni.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=Yc.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),tu(l,c,u,d),ni.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=Yc.distanceToLine(e,c,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Yc.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Yc.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Yc.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const au={};function iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,au,n),Tc.extend(e,t,n),ou(e,t)}var su={newInstance:jt.newInstance(iu,&quot;vtkTriangle&quot;),extend:iu,...ru};const lu=[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;],{vtkWarningMacro:cu}=jt,uu={[Pc]:Yc,[Oc]:Yc,[Rc]:su};function du(e,t){t.classHierarchy.push(&quot;vtkPolyData&quot;),lu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\\w|[A-Z]|\\b\\w)/g,(e=>e.toUpperCase())).replace(/\\s+/g,&quot;&quot;)}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=cc.newInstance()})),e.getNumberOfCells=()=>lu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),lu.forEach((n=>{t[n]=cc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?wc:Ic,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Oc:Pc,1===t&&cu(&quot;Building VTK_LINE &quot;,n,&quot; with only one point, but VTK_LINE needs at least two points. Check the input.&quot;),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=Rc;break;case 4:l[n]=Ec;break;default:l[n]=Dc}t<3&&cu(&quot;Building VTK_TRIANGLE &quot;,n,&quot; with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.&quot;),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Mc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Uc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Sc.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Ic:case wc:o=t.verts;break;case Pc:case Oc:o=t.lines;break;case Rc:case Ec:case Dc:o=t.polys;break;case Mc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||uu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const pu={};function fu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pu,n),eu.extend(e,t,n),jt.get(e,t,[&quot;cells&quot;,&quot;links&quot;]),jt.setGet(e,t,[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;]),du(e,t)}var gu={newInstance:jt.newInstance(fu,&quot;vtkPolyData&quot;),extend:fu};function mu(e,t){t.classHierarchy.push(&quot;vtkTexture&quot;),e.imageLoaded=()=>{t.image.removeEventListener(&quot;load&quot;,e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener(&quot;load&quot;,e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext(&quot;2d&quot;).getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement(&quot;canvas&quot;);e.width=t.image.width,e.height=t.image.height;const n=e.getContext(&quot;2d&quot;);return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const hu={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hu,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,[&quot;canvas&quot;,&quot;image&quot;,&quot;jsImageData&quot;,&quot;imageLoaded&quot;,&quot;resizable&quot;]),jt.setGet(e,t,[&quot;repeat&quot;,&quot;edgeClamp&quot;,&quot;interpolate&quot;,&quot;mipLevel&quot;]),mu(e,t)}const yu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Tu={newInstance:jt.newInstance(vu,&quot;vtkTexture&quot;),extend:vu,...yu};const bu=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],xu=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Cu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Su=[0,1,0,1,0,1,0,1,2,2,2,2],Au=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Iu=new Float64Array(3),wu=new Float64Array(3),Pu=new Float64Array(3),Ou=new Float64Array(3),Ru=new Float64Array(3),Mu=new Float64Array(3),Du=new Float64Array(16);function Eu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Vu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],Vn(Pu,Iu,r),Pu[0]+=.1,Vn(wu,Pu,o),Pn(Ru,wu,Iu),Pu[0]-=.1,Pu[1]+=.1,Vn(wu,Pu,o),Pn(Mu,wu,Iu);for(let e=0;e<3;e++)Ru[e]/=.05*u[0],Mu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],a[0]<-.5?On(Pu,Ru,a[0]*i-l.width):a[0]>.5?On(Pu,Ru,a[0]*i):On(Pu,Ru,a[0]*i-l.width/2),wn(Iu,Iu,Pu),On(Pu,Mu,a[1]*i-l.height/2),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Pu,Ru,l.width),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Pu,Mu,l.height),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Pu,Ru,l.width),Pn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(Du,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Iu[0]=f[3*u],Iu[1]=f[3*u+1],Iu[2]=f[3*u+2],Vn(Pu,Iu,n),Iu[0]=f[3*u+3],Iu[1]=f[3*u+4],Iu[2]=f[3*u+5],Vn(Ou,Iu,n),Pn(Pu,Pu,Ou);const r=[Pu[0],Pu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Lu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,[&quot;renderable&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;tmActor&quot;,&quot;ticks&quot;]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],Vu(e,t)}),&quot;vtkCubeAxesActorHelper&quot;);function Bu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActor&quot;),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=ki.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Iu[s]=t.dataBounds[a]-.1*r*bu[a][s],Iu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Iu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Pu,Iu,e),Iu[s]=t.dataBounds[a],Vn(Ou,Iu,e),Pn(Pu,Ou,Pu),Mn(Pu,Pu),i=Pu[2]>o,t.camera.getParallelProjection()||(Mn(Ou,Ou),i=Dn(Ou,Pu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Au[t][0]].length+2*r[Au[t][1]].length,a+=r[Au[t][0]].length+r[Au[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Cu[e][0],l[3*u+2]=Cu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Au[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Au[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Su[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=xu[a][e];if(1===n[d]){const e=Su[d],n=3*Cu[d][0],p=3*Cu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Au[a][0]]=.5*(t.dataBounds[2*Au[a][0]]+t.dataBounds[2*Au[a][0]+1]),s[3*l+Au[a][1]]=.5*(t.dataBounds[2*Au[a][1]]+t.dataBounds[2*Au[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[xu[e][t]]++;const a=[],i=[];for(let e=0;e<3;e++){const n=go().domain([t.dataBounds[2*e],t.dataBounds[2*e+1]]);a[e]=n.ticks(5);const r=n.tickFormat(5);i[e]=a[e].map(r)}e.updatePolyData(r,n,a),e.updateTextData(r,n,a,i),(o||t.forceUpdate)&&e.updateTextureAtlas(i)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Eu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Eu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Eu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),ki.setBounds(t.bounds,t.gridActor.getBounds()),ki.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function Nu(e){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...ki.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:12,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},...e}}function _u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nu(n)),hs.extend(e,t,n),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=[&quot;X-Axis&quot;,&quot;Y-Axis&quot;,&quot;Z-Axis&quot;],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.tmTexture=Tu.newInstance(),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=nc.newInstance(),t.polyData=gu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=hs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=gu.newInstance(),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;boundsScaleFactor&quot;,&quot;faceVisibilityAngle&quot;,&quot;gridLines&quot;,&quot;tickLabelPixelOffset&quot;]),jt.setGetArray(e,t,[&quot;dataBounds&quot;],6),jt.setGetArray(e,t,[&quot;axisLabels&quot;],3),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;camera&quot;,&quot;tmTexture&quot;,&quot;textValues&quot;,&quot;textPolyData&quot;,&quot;tickCounts&quot;,&quot;gridActor&quot;]),Bu(e,t)}var Fu={newInstance:jt.newInstance(_u,&quot;vtkCubeAxesActor&quot;),extend:_u,newCubeAxesActorHelper:Lu};function ku(e,t){t.classHierarchy.push(&quot;vtkOpenGLCubeAxesActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gu={};const Uu=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=Fu.newCubeAxesActorHelper(),ku(e,t)}),&quot;vtkOpenGLCubeAxesActor&quot;);rn(&quot;vtkCubeAxesActor&quot;,Uu);const zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Wu={ObjectType:zu};const{ObjectType:Hu}=Wu;function ju(e,t){function n(e){switch(e){case Hu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Hu.TEXTURE_BUFFER:if(&quot;TEXTURE_BUFFER&quot;in t.context)return t.context.TEXTURE_BUFFER;case Hu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push(&quot;vtkOpenGLBufferObject&quot;);let r=null,o=null,a=!0,i=&quot;&quot;;e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i=&quot;Trying to upload array buffer to incompatible buffer.&quot;,!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const Ku={objectType:Hu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function $u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ku,n),jt.obj(e,t),jt.get(e,t,[&quot;_openGLRenderWindow&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),ju(e,t)}var qu={newInstance:jt.newInstance($u),extend:$u,...Wu};const{vtkErrorMacro:Xu}=jt;function Yu(e,t){t.classHierarchy.push(&quot;vtkOpenGLCellArrayBufferObject&quot;),e.setType(zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=qu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n){for(let r=0;r<e;++r)f(t[n+r])},linesToWireframe(e,t,n){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1])},polysToWireframe(e,t,n){if(e>2)for(let r=0;r<e;++r)f(t[n+r]),f(t[n+(r+1)%e])},stripsToWireframe(e,t,n){if(e>2){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1]);for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+2])}},polysToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+0]),f(t[n+r+1]),f(t[n+r+2])},stripsToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+1+r%2]),f(t[n+r+1+(r+1)%2])}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===rs.POINTS||&quot;verts&quot;===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===rs.WIREFRAME||&quot;lines&quot;===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,D=0,E=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];D+=n*n;const r=.5*(t[1]+t[0]);E+=r*r}const V=D>0&&(Math.abs(E)/D>1e6||Math.abs(Math.log10(D))>3||0===D&&E>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;)C(A[e],A,e+1),e+=A[e]+1,T++;return t.elementCount=w,e.upload(O,zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,Ui(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):Xu(&quot;Wrong type for coordScale, expected vec3 or null&quot;):Xu(&quot;Wrong type for coordShift, expected vec3 or null&quot;)}}const Zu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function Qu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zu,n),qu.extend(e,t,n),jt.setGet(e,t,[&quot;colorBO&quot;,&quot;elementCount&quot;,&quot;stride&quot;,&quot;colorBOStride&quot;,&quot;vertexOffset&quot;,&quot;normalOffset&quot;,&quot;tCoordOffset&quot;,&quot;tCoordComponents&quot;,&quot;colorOffset&quot;,&quot;colorComponents&quot;,&quot;customData&quot;]),jt.get(e,t,[&quot;coordShift&quot;,&quot;coordScale&quot;,&quot;coordShiftAndScaleEnabled&quot;,&quot;inverseShiftAndScaleMatrix&quot;]),Yu(e,t)}var Ju={newInstance:jt.newInstance(Qu),extend:Qu};const{vtkErrorMacro:ed}=jt;function td(e,t){t.classHierarchy.push(&quot;vtkShader&quot;),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||&quot;Unknown&quot;===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e=&quot;Fragment&quot;===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return ed(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const nd={shaderType:&quot;Unknown&quot;,source:&quot;&quot;,error:&quot;&quot;,handle:0,dirty:!1,context:null};function rd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nd,n),jt.obj(e,t),jt.setGet(e,t,[&quot;shaderType&quot;,&quot;source&quot;,&quot;error&quot;,&quot;handle&quot;,&quot;context&quot;]),td(e,t)}var od={newInstance:jt.newInstance(rd,&quot;vtkShader&quot;),extend:rd};const{vtkErrorMacro:ad}=jt;function id(e,t){t.classHierarchy.push(&quot;vtkShaderProgram&quot;),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(ad(`Links failed: ${t.error}`),0):(ad(t.error),0):(ad(t.fragmentShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.fragmentShader.getError()),0):(ad(t.vertexShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.vertexShader.getError()),0),e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error=&quot;Program has not been initialized, and/or does not have shaders.&quot;,!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return ad(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error=&quot;Shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===n.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error=&quot;Could not create shader program.&quot;,!1;t.handle=e,t.linked=!1}return&quot;Vertex&quot;===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),&quot;Fragment&quot;===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error=&quot;shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===e.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;switch(0===t.handle&&(t.error=&quot;This shader program has not been initialized yet.&quot;),e.getShaderType()){case&quot;Vertex&quot;:return t.vertexShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case&quot;Fragment&quot;:return t.fragmentShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const sd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:&quot;&quot;,handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=od.newInstance(),t.vertexShader.setShaderType(&quot;Vertex&quot;),t.fragmentShader=od.newInstance(),t.fragmentShader.setShaderType(&quot;Fragment&quot;),t.geometryShader=od.newInstance(),t.geometryShader.setShaderType(&quot;Geometry&quot;),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;error&quot;,&quot;handle&quot;,&quot;compiled&quot;,&quot;bound&quot;,&quot;md5Hash&quot;,&quot;vertexShader&quot;,&quot;fragmentShader&quot;,&quot;geometryShader&quot;,&quot;linked&quot;]),id(e,t)}var cd={newInstance:jt.newInstance(ld,&quot;vtkShaderProgram&quot;),extend:ld,substitute:function(e,t,n,r){const o=&quot;string&quot;==typeof n?n:n.join(&quot;\\n&quot;),a=!1===r?t:new RegExp(t,&quot;g&quot;),i=e.replace(a,o);return{replace:i!==o,result:i}}};function ud(e,t){t.classHierarchy.push(&quot;vtkOpenGLVertexArrayObject&quot;),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;)),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension(&quot;OES_vertex_array_object&quot;),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const dd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,[&quot;supported&quot;]),jt.setGet(e,t,[&quot;forceEmulation&quot;]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,&quot;vtkOpenGLVertexArrayObject&quot;),extend:pd};const gd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function md(e,t){t.classHierarchy.push(&quot;vtkOpenGLHelper&quot;),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===rs.POINTS||n===gd.Points?t.context.POINTS:e===rs.WIREFRAME||n===gd.Lines||n===gd.TrisEdges||n===gd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f(&quot;viewportSize&quot;,o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf(&quot;lineWidthStepSize&quot;,t/Math.ceil(t)),e.getProgram().setUniformf(&quot;halfLineWidth&quot;,n)}t.primitiveType===gd.Points||r.getProperty().getRepresentation()===rs.POINTS?e.getProgram().setUniformf(&quot;pointSize&quot;,r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf(&quot;pointSize&quot;,e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform float pointSize;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot;  gl_PointSize = pointSize;&quot;],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform vec2 viewportSize;&quot;,&quot;uniform float lineWidthStepSize;&quot;,&quot;uniform float halfLineWidth;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot; if (halfLineWidth > 0.0)&quot;,&quot;   {&quot;,&quot;   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;&quot;,&quot;   vec4 tmpPos = gl_Position;&quot;,&quot;   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;&quot;,&quot;   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];&quot;,&quot;   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];&quot;,&quot;   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);&quot;,&quot;   }&quot;]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===gd.Points?2:t.primitiveType===gd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const hd={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,[&quot;program&quot;,&quot;shaderSourceTime&quot;,&quot;VAO&quot;,&quot;attributeUpdateTime&quot;,&quot;CABO&quot;,&quot;primitiveType&quot;,&quot;pointPicking&quot;]),t.program=cd.newInstance(),t.VAO=fd.newInstance(),t.CABO=Ju.newInstance(),md(e,t)}var yd={newInstance:jt.newInstance(vd),extend:vd,primTypes:gd};const Td={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},bd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var xd={Wrap:Td,Filter:bd};const Cd=new Float32Array(1),Sd=new Int32Array(Cd.buffer);var Ad={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Cd[0]=e;const t=Sd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};const{Wrap:Id,Filter:wd}=xd,{VtkDataTypes:Pd}=Es,{vtkDebugMacro:Od,vtkErrorMacro:Rd,vtkWarningMacro:Md}=Kt,{toHalf:Dd}=Ad;function Ed(e,t){function n(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==Pd.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==Pd.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Dd(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o}function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension(&quot;OES_texture_half_float&quot;),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Ad.toHalf(Ad.fromHalf(e[u][l+s+t])*h*(1-v)+Ad.fromHalf(e[u][l+p+t])*h*v+Ad.fromHalf(e[u][c+s+t])*m*(1-v)+Ad.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&t.oglNorm16Ext)||e!==Pd.UNSIGNED_SHORT&&e!==Pd.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}const s=i&&(function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a);t.useHalfFloat=s}(a,c.offset,c.scale,r),t.useHalfFloat||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}t.classHierarchy.push(&quot;vtkOpenGLTexture&quot;),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent()),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(wd.LINEAR),e.setMagnificationFilter(wd.LINEAR)):(e.setMinificationFilter(wd.NEAREST),e.setMagnificationFilter(wd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Id.REPEAT),e.setWrapS(Id.REPEAT),e.setWrapT(Id.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()},e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Md(&quot;impossible case&quot;),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Od(`Unable to find suitable internal format for T=${n} NC= ${r}`),t.internalFormat),e.getDefaultInternalFormat=(e,n)=>{let r=0;return r=t._openGLRenderWindow.getDefaultTextureInternalFormat(e,n,t.oglNorm16Ext,t.useHalfFloat),r||(r||(Od(&quot;Unsupported internal texture type!&quot;),Od(`Unable to find suitable internal format for T=${e} NC= ${n}`)),r)},e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=e=>{if(t._openGLRenderWindow.getWebgl2())switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.SHORT:return t.context.SHORT;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case t.useHalfFloat&&Pd.SHORT:case t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case Pd.FLOAT:case Pd.VOID:default:return t.context.FLOAT}switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case Pd.FLOAT:case Pd.VOID:default:if(t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))return t.context.FLOAT;{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);if(e&&t.context.getExtension(&quot;OES_texture_half_float_linear&quot;))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case wd.NEAREST:return t.context.NEAREST;case wd.LINEAR:return t.context.LINEAR;case wd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case wd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case wd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case wd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Id.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Id.REPEAT:return t.context.REPEAT;case Id.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=n(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(n(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createDepthFromRaw=(n,r,a,i)=>(e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===Pd.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=r,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0):(Rd(&quot;Failed to determine texture parameters.&quot;),!1)),e.create2DFromImage=n=>{if(e.getOpenGLDataType(Pd.UNSIGNED_CHAR),e.getInternalFormat(Pd.UNSIGNED_CHAR,4),e.getFormat(Pd.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const r=!(t._openGLRenderWindow.getWebgl2()||Fo(n.width)&&Fo(n.height)),a=document.createElement(&quot;canvas&quot;);a.width=r?_o(n.width):n.width,a.height=r?_o(n.height):n.height,t.width=a.width,t.height=a.height;const i=a.getContext(&quot;2d&quot;);i.translate(0,a.height),i.scale(1,-1),i.drawImage(n,0,0,n.width,n.height,0,0,a.width,a.height);const s=a;return o(Pd.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Pd.UNSIGNED_CHAR,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Es.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.create3DFromRaw=(a,i,s,l,c,u)=>{if(e.getOpenGLDataType(c),e.getInternalFormat(c,l),e.getFormat(c,l),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=r(n(c,[u],!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(c)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=d[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,d[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,d[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(c,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Es.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=n*r*i,g=[],m=[];for(let e=0;e<c;++e)g[e]=0,m[e]=1;t.volumeInfo={scale:m,offset:g,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i};const h=structuredClone(p);if(t._openGLRenderWindow.getWebgl2()){if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=32767;return e.create3DFromRaw(n,r,i,c,u,d)}if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.UNSIGNED_SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=65535;return e.create3DFromRaw(n,r,i,c,u,d)}if(u===Pd.FLOAT||t.useHalfFloat&&(u===Pd.SHORT||u===Pd.UNSIGNED_SHORT))return e.create3DFromRaw(n,r,i,c,u,d);if(u===Pd.UNSIGNED_CHAR){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=255;return e.create3DFromRaw(n,r,i,c,u,d)}const o=new Float32Array(f*c);t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;let a=0;const s=h.scale.map((e=>1/e));for(let e=0;e<f;e++)for(let e=0;e<c;e++)o[a]=(d[a]-h.offset[e])*s[e],a++;return e.create3DFromRaw(n,r,i,c,Pd.FLOAT,o)}let v=(e,t,n,r,o)=>{e[t]=n},y=Pd.UNSIGNED_CHAR;if(u===Pd.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)?(y=Pd.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=Pd.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===Pd.FLOAT||c>=3)&&(T=4096);let b=1,x=1;f>T*T&&(b=Math.ceil(Math.sqrt(f/(T*T))),x=b);let C=Math.sqrt(f)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===Pd.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1}const Vd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Id.CLAMP_TO_EDGE,wrapT:Id.CLAMP_TO_EDGE,wrapR:Id.CLAMP_TO_EDGE,minificationFilter:wd.NEAREST,magnificationFilter:wd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,useHalfFloat:!0,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0};function Ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,[&quot;format&quot;,&quot;openGLDataType&quot;]),At(e,t,[&quot;keyMatrixTime&quot;,&quot;minificationFilter&quot;,&quot;magnificationFilter&quot;,&quot;wrapS&quot;,&quot;wrapT&quot;,&quot;wrapR&quot;,&quot;generateMipmap&quot;,&quot;oglNorm16Ext&quot;]),bt(e,t,[&quot;width&quot;,&quot;height&quot;,&quot;volumeInfo&quot;,&quot;components&quot;,&quot;handle&quot;,&quot;target&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),Ed(e,t)}const Bd=Et(Ld,&quot;vtkOpenGLTexture&quot;);var Nd={newInstance:Bd,extend:Ld,...xd};rn(&quot;vtkTexture&quot;,Bd);var _d=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexMC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\nvoid main()\\n{\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::PrimID::Impl\\n\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,Fd=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the polydata mappers fragment shader\\n\\nuniform int PrimitiveIDOffset;\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// optional color passed in from the vertex shader, vertexColor\\n//VTK::Color::Dec\\n\\n// optional surface normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// Depth Peeling Support\\n//VTK::DepthPeeling::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// label outline \\n//VTK::LabelOutline::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n//VTK::LabelOutlineHelperFunction\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::Color::Impl\\n\\n  // Generate the normal if we are not passed in one\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Light::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,kd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::Coincident::Dec&quot;,[&quot;uniform float cfactor;&quot;,&quot;uniform float coffset;&quot;]).result,t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;&quot;).result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;&quot;).result),n.Fragment=e}}},Gd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=cd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&&quot;&quot;!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&&quot;&quot;!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Ud}=ol,{primTypes:zd}=yd,{Representation:Wd,Shading:Hd}=ds,{ScalarMode:jd}=nc,{Filter:Kd,Wrap:$d}=Nd,{vtkErrorMacro:qd}=Kt,Xd={type:&quot;StartEvent&quot;},Yd={type:&quot;EndEvent&quot;},{CoordinateSystem:Zd}=Zi;function Qd(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType(&quot;vtkOpenGLActor&quot;),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=zd.Start;e<zd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let l=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;,&quot;uniform vec3 ambientColorUniform;&quot;,&quot;uniform vec3 diffuseColorUniform;&quot;];s&&(l=l.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let c=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];s&&(c=c.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),c=c.concat([&quot;  ambientColor = ambientColorUniform;&quot;,&quot;  diffuseColor = diffuseColorUniform;&quot;,&quot;  opacity = opacityUniform;&quot;]),s&&(c=c.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 scalarColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput =  scalarColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?t.renderable.getInterpolateScalarsBeforeMapping()&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);&quot;,&quot;  diffuseColor = texColor.rgb;&quot;,&quot;  ambientColor = texColor.rgb;&quot;,&quot;  opacity = opacity*texColor.a;&quot;])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat([&quot;uniform float opacityUniformBF; // the fragment opacity&quot;,&quot;uniform float ambientIntensityBF; // the material ambient&quot;,&quot;uniform float diffuseIntensityBF; // the material diffuse&quot;,&quot;uniform vec3 ambientColorUniformBF; // ambient material color&quot;,&quot;uniform vec3 diffuseColorUniformBF; // diffuse material color&quot;]),s?(l=l.concat([&quot;uniform float specularIntensityBF; // the material specular intensity&quot;,&quot;uniform vec3 specularColorUniformBF; // intensity weighted color&quot;,&quot;uniform float specularPowerUniformBF;&quot;]),c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  specularColor = specularIntensityBF * specularColorUniformBF;&quot;,&quot;  specularPower = specularPowerUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])):c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat([&quot;uniform samplerBuffer texture1;&quot;])),i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c).result):i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),i=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);let s=[];switch(a){case 0:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 1:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  float df = max(0.0, normalVCVSOutput.z);&quot;,&quot;  float sf = pow(df, specularPower);&quot;,&quot;  vec3 diffuseL = df * diffuseColor;&quot;,&quot;  vec3 specularL = sf * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,&quot;    {&quot;,`    float sf = sign(df)*pow(max(1e-5,\\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\\n                                                  normalize(-vertexVC.xyz))),\\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  vec3 vertLightDirectionVC;&quot;,&quot;  float attenuation;&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([&quot;  attenuation = 1.0;&quot;,`  if (lightPositional${e} == 0)`,&quot;    {&quot;,`      vertLightDirectionVC = lightDirectionVC${e};`,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,&quot;    float distanceVC = length(vertLightDirectionVC);&quot;,&quot;    vertLightDirectionVC = normalize(vertLightDirectionVC);&quot;,&quot;    attenuation = 1.0 /&quot;,`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,&quot;    // per OpenGL standard cone angle is 90 or less for a spot light&quot;,`    if (lightConeAngle${e} <= 90.0)`,&quot;      {&quot;,`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,&quot;      // if inside the cone&quot;,`      if (coneDot >= cos(radians(lightConeAngle${e})))`,&quot;        {&quot;,`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,&quot;        }&quot;,&quot;      else&quot;,&quot;        {&quot;,&quot;        attenuation = 0.0;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));&quot;,`    diffuseL += ((df) * lightColor${e});`,&quot;    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)&quot;,&quot;      {&quot;,`      float sf = sign(df)*attenuation*pow(max(1e-5,\\n                                                           dot(reflect(lightDirectionVC${e},\\n                                                                       normalVCVSOutput),\\n                                                               normalize(-vertexVC.xyz))),\\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;default:qd(&quot;bad light complexity&quot;)}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * normalMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Dec&quot;,[&quot;in vec3 normalVCVSOutput[];&quot;,&quot;out vec3 normalVCGSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCGSOutput = normalVCVSOutput[i];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;varying vec3 normalVCVSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalVCVSOutput);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.haveCellNormals?(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform mat3 normalMatrix;&quot;,&quot;uniform samplerBuffer textureN;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalMatrix *&quot;,&quot;    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput;&quot;,&quot;  if (abs(fdx.x) > 0.0)&quot;,&quot;    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }&quot;,&quot;  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}&quot;]).result):(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;&quot;]).result,a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;  fdx = normalize(fdx);&quot;,&quot;  fdy = normalize(fdy);&quot;,&quot;  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));&quot;,&quot;  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;,&quot;  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(o=cd.substitute(o,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCVSOutput = MCVCMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;in vec4 vertexVCVSOutput[];&quot;,&quot;out vec4 vertexVCGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCGSOutput = vertexVCVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;&quot;]).result):(o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,a&&a.length>=1)switch(i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}}else switch(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec3 tcoordVCVSOutput[];&quot;,&quot;out vec3 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec3 tcoordVCVSOutput;&quot;,&quot;uniform samplerCube texture1;&quot;]).result,i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`varying float clipDistancesVSOutput[${e}];`]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()||o.getEdgeVisibility()&&o.getRepresentation()===Wd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===zd.Points||o.getRepresentation()===Wd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===zd.Lines||o.getRepresentation()===Wd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==zd.Tris&&e!==zd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==zd.TrisEdges&&e!==zd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform int picking;&quot;,&quot;//VTK::Picking::Dec&quot;]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==zl.ID_LOW24&&t.lastSelectionState!==zl.ID_HIGH24||(a=cd.substitute(a,&quot;//VTK::Picking::Dec&quot;,[&quot;flat out int vertexIDVSOutput;\\n&quot;,&quot;uniform int VertexIDOffset;\\n&quot;]).result,a=cd.substitute(a,&quot;//VTK::Picking::Impl&quot;,&quot;  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;flat in int vertexIDVSOutput;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,[&quot;  int idx = vertexIDVSOutput;&quot;,&quot;//VTK::Picking::Impl&quot;]).result),t.lastSelectionState){case zl.ID_LOW24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);&quot;).result;break;case zl.ID_HIGH24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);&quot;).result;break;default:o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;uniform vec3 mapperIndex;&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===Hd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),h=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&n.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),n.getProgram().isUniformUsed(&quot;VertexIDOffset&quot;)&&n.getProgram().setUniformi(&quot;VertexIDOffset&quot;,t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;normalMC&quot;)&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;normalMC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting normalMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;normalMC&quot;),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||qd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||qd(&quot;Error setting tcoordMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),n.getProgram().isAttributeUsed(&quot;scalarColor&quot;)&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),&quot;scalarColor&quot;,n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||qd(&quot;Error setting scalarColor in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;scalarColor&quot;),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,r)}t.internalColorTexture&&n.getProgram().isUniformUsed(&quot;texture1&quot;)&&n.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi(&quot;picking&quot;,i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===Zd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4)}else s.setUniformMatrix(&quot;MCPCMatrix&quot;,n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed(&quot;MCVCMatrix&quot;)&&s.setUniformMatrix(&quot;MCVCMatrix&quot;,n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed(&quot;normalMatrix&quot;)&&s.setUniformMatrix3x3(&quot;normalMatrix&quot;,n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf(&quot;opacityUniform&quot;,i),o.setUniform3fArray(&quot;ambientColorUniform&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniform&quot;,l),o.setUniformf(&quot;ambient&quot;,c),o.setUniformf(&quot;diffuse&quot;,u);const f=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray(&quot;specularColorUniform&quot;,g),o.setUniformf(&quot;specularPowerUniform&quot;,p),o.setUniformf(&quot;specular&quot;,d),o.isUniformUsed(&quot;ambientIntensityBF&quot;)){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf(&quot;ambientIntensityBF&quot;,c),o.setUniformf(&quot;diffuseIntensityBF&quot;,u),o.setUniformf(&quot;opacityUniformBF&quot;,i),o.setUniform3fArray(&quot;ambientColorUniformBF&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniformBF&quot;,l),f<1)return;o.setUniformf(&quot;specularIntensityBF&quot;,d),o.setUniform3fArray(&quot;specularColorUniformBF&quot;,g),o.setUniformf(&quot;specularPowerUniformBF&quot;,p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():zl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Wd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===zl.ID_LOW24||t.lastSelectionState===zl.ID_HIGH24);for(let i=zd.Start;i<zd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===zd.TrisEdges||i===zd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(Xd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Yd),!t.currentInput)return void qd(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(null===o)return;t.renderable.mapScalars(o,1);const a=t.renderable.getColorMapColors();t.haveCellScalars=!1;const i=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(i!==jd.USE_CELL_DATA&&i!==jd.USE_CELL_FIELD_DATA&&i!==jd.USE_FIELD_DATA&&o.getPointData().getScalars()||i===jd.USE_POINT_FIELD_DATA||!a||(t.haveCellScalars=!0));let s=r.getProperty().getInterpolation()!==Hd.FLAT?o.getPointData().getNormals():null;null===s&&o.getCellData().getNormals()&&(t.haveCellNormals=!0,s=o.getCellData().getNormals());const l=r.getProperty().getRepresentation();let c=o.getPointData().getTCoords();if(t.openGLActor.getActiveTextures()||(c=null),t.renderable.getColorCoordinates()){c=t.renderable.getColorCoordinates(),t.internalColorTexture||(t.internalColorTexture=Nd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Kd.NEAREST),e.setMagnificationFilter(Kd.NEAREST),e.setWrapS($d.CLAMP_TO_EDGE),e.setWrapT($d.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${o.getMTime()}A${l}B${o.getMTime()}C${s?s.getMTime():1}D${a?a.getMTime():1}E${r.getProperty().getEdgeVisibility()}F${c?c.getMTime():1}`;if(t.VBOBuildString!==u){const n={points:o.getPoints(),normals:s,tcoords:c,colors:a,cellOffset:0,vertexOffset:0,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>o.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const i=[{inRep:&quot;verts&quot;,cells:o.getVerts()},{inRep:&quot;lines&quot;,cells:o.getLines()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()}],d=r.getProperty().getEdgeVisibility()&&l===Wd.SURFACE;for(let e=zd.Start;e<zd.End;e++)e!==zd.TrisEdges&&e!==zd.TriStripsEdges?(n.cellOffset+=t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,l,n,t.selectionWebGLIdsToVTKIds),n.vertexOffset+=t.primitives[e].getCABO().getElementCount()):d?t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,Wd.WIREFRAME,{...n,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[e].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&(t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),e.updateMaximumPointCellIds()),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Jd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:zl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function ep(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jd,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=zd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=zd.Start;e<zd.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),Qd(e,t)}const tp=Et(ep,&quot;vtkOpenGLPolyDataMapper&quot;);var np={newInstance:tp,extend:ep};rn(&quot;vtkMapper&quot;,tp);const{ColorMode:rp,ScalarMode:op,GetArray:ap}=hl;function ip(e,t){t.classHierarchy.push(&quot;vtkMapper2D&quot;),e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString(rp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(op,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===op.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===op.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===op.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===op.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_FIELD_DATA){const t=e.getFieldData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const sp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function lp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sp,n),Bs(e,t,n),jt.get(e,t,[&quot;colorMapColors&quot;]),jt.setGet(e,t,[&quot;arrayAccessMode&quot;,&quot;colorByArrayName&quot;,&quot;colorMode&quot;,&quot;lookupTable&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;transformCoordinate&quot;,&quot;useLookupTableScalarRange&quot;,&quot;viewSpecificProperties&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),ip(e,t)}var cp={newInstance:jt.newInstance(lp,&quot;vtkMapper2D&quot;),extend:lp};const up=1,{primTypes:dp}=yd,{ScalarMode:pp}=cp,{vtkErrorMacro:fp}=Kt,gp={type:&quot;StartEvent&quot;},mp={type:&quot;EndEvent&quot;};function hp(e,t){t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper2D&quot;),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType(&quot;vtkOpenGLActor2D&quot;),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model Coordinates\\n// WC - WC world coordinates\\n// VC - View Coordinates\\n// DC - Display Coordinates\\n\\nin vec4 vertexWC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nuniform mat4 WCVCMatrix;  // World to view matrix\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  gl_Position = WCVCMatrix*vertexWC;\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::PositionVC::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nuniform int PrimitiveIDOffset;\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Scalar coloring\\n//VTK::Color::Dec\\n\\n// Depth Peeling\\n//VTK::DepthPeeling::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Color::Impl\\n  //VTK::TCoord::Impl\\n\\n  //VTK::DepthPeeling::Impl\\n  //VTK::Picking::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=dp.Start;e<dp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(gp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(mp),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):fp(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==pp.USE_CELL_DATA&&a!==pp.USE_CELL_FIELD_DATA&&a!==pp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===pp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=mc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[dp.Points].getCABO().createVBO(r.getVerts(),&quot;verts&quot;,i,a),a.cellOffset+=t.primitives[dp.Lines].getCABO().createVBO(r.getLines(),&quot;lines&quot;,i,a),a.cellOffset+=t.primitives[dp.Tris].getCABO().createVBO(r.getPolys(),&quot;polys&quot;,i,a),a.cellOffset+=t.primitives[dp.TriStrips].getCABO().createVBO(r.getStrips(),&quot;strips&quot;,i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=dp.Start;a<dp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform samplerBuffer texture1;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);&quot;]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 diffuseColor;&quot;,&quot;out vec4 fcolorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorVSOutput = diffuseColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput[];\\n&quot;,&quot;out vec4 fcolorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorGSOutput = fcolorVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = fcolorVSOutput;&quot;]).result):(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform vec4 diffuseColor;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = diffuseColor;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordMC;&quot;,&quot;out float tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput[];\\n&quot;,&quot;out float tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,[&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));&quot;]).result):2===a&&(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordMC;&quot;,&quot;out vec2 tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];\\n&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);&quot;]).result),t.haveCellScalars&&(r=cd.substitute(r,&quot;//VTK::PrimID::Impl&quot;,[&quot;gl_PrimitiveID = gl_PrimitiveIDIn;&quot;]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=cd.substitute(r,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&e.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),e.getProgram().isAttributeUsed(&quot;vertexWC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;vertexWC&quot;,e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||fp(&quot;Error setting vertexWC in shader VAO.&quot;)),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||fp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;tcoordMC&quot;,e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||fp(&quot;Error setting tcoordMC in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),t.internalColorTexture&&e.getProgram().isUniformUsed(&quot;texture1&quot;)&&e.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi(&quot;picking&quot;,a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f(&quot;diffuseColor&quot;,i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===up?-1:1,x[15]=1,m(x,x),a.setUniformMatrix(&quot;WCVCMatrix&quot;,(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const vp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const yp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=dp,t.tmpMat4=g(new Float64Array(16));for(let e=dp.Start;e<dp.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),hp(e,t)}),&quot;vtkOpenGLPolyDataMapper2D&quot;);rn(&quot;vtkMapper2D&quot;,yp);const{VectorMode:Tp}=Pl;function bp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function xp(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Cp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Sp(e,t){t.classHierarchy.push(&quot;vtkScalarBarActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;;const n={},r=new Map;let o=0,a=1;bp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,bp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),&quot;NaN&quot;,&quot;Below&quot;,&quot;Above&quot;];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{bp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s(&quot;NaN&quot;,[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s(&quot;Below&quot;,[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s(&quot;ticks&quot;,t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s(&quot;Above&quot;,[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p=&quot;vertical&quot;===a?[1,0]:[0,1];&quot;vertical&quot;===a?(d[0]=l.width,d[1]=-l.height,&quot;middle&quot;===o[0]?n[1]-=l.width/2:&quot;right&quot;===o[0]&&(n[1]-=l.width),&quot;middle&quot;===o[1]?n[0]+=l.height/2:&quot;top&quot;===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,&quot;middle&quot;===o[0]?n[0]-=l.width/2:&quot;right&quot;===o[0]&&(n[0]-=l.width),&quot;middle&quot;===o[1]?n[1]-=l.height/2:&quot;top&quot;===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?[&quot;right&quot;,&quot;middle&quot;]:[&quot;middle&quot;,&quot;bottom&quot;];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;top&quot;],&quot;vertical&quot;,[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];&quot;ticks&quot;===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,&quot;horizontal&quot;,g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,&quot;horizontal&quot;,g,c)}const b=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Tp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Es.newInstance({numberOfComponents:i,values:c,name:&quot;Scalars&quot;});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Ap=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;tickLabelPixelOffset&quot;,&quot;renderable&quot;,&quot;topTitle&quot;,&quot;ticks&quot;,&quot;tickStrings&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;lastTickBounds&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;barActor&quot;,&quot;tmActor&quot;]),jt.getArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.barMapper=nc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=gu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=hs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Tu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Sp(e,t)}),&quot;vtkScalarBarActorHelper&quot;);function Ip(e,t){t.classHierarchy.push(&quot;vtkScalarBarActor&quot;),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(xp(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Cp())}}function wp(e){return{automated:!0,autoLayout:null,axisLabel:&quot;Scalar Value&quot;,barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:14,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function Pp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wp(n)),t.autoLayout||(t.autoLayout=xp(0,t)),t.generateTicks||(t.generateTicks=Cp()),hs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,[&quot;automated&quot;,&quot;autoLayout&quot;,&quot;axisTitlePixelOffset&quot;,&quot;axisLabel&quot;,&quot;scalarsToColors&quot;,&quot;tickLabelPixelOffset&quot;,&quot;generateTicks&quot;,&quot;drawNanAnnotation&quot;,&quot;drawBelowRangeSwatch&quot;,&quot;drawAboveRangeSwatch&quot;]),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;]),jt.getArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;],2),Ip(e,t)}var Op={newInstance:jt.newInstance(Pp,&quot;vtkScalarBarActor&quot;),extend:Pp,newScalarBarActorHelper:Ap};function Rp(e,t){t.classHierarchy.push(&quot;vtkOpenGLScalarBarActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Mp={};const Dp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Op.newScalarBarActorHelper(),Rp(e,t)}),&quot;vtkOpenGLScalarBarActor&quot;);rn(&quot;vtkScalarBarActor&quot;,Dp);const{vtkErrorMacro:Ep}=Kt;function Vp(e,t){t.classHierarchy.push(&quot;vtkOpenGLSkybox&quot;),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi(&quot;sbtexture&quot;,n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix(&quot;IMCPCMatrix&quot;,a),&quot;box&quot;===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f(&quot;camPos&quot;,e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Es.newInstance({numberOfComponents:3,values:e});n.setName(&quot;points&quot;);const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),&quot;box&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec3 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = wpos.xyz/wpos.w;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec3 TexCoords;\\n             uniform samplerCube sbtexture;\\n             uniform vec3 camPos;\\n             void main () {\\n               // skybox looks from inside out\\n               // which means we have to adjust\\n               // our tcoords. Otherwise text would\\n               // be flipped\\n               vec3 tc = normalize(TexCoords - camPos);\\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\\n               {\\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\\n               }\\n               else\\n               {\\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\\n               }\\n               gl_FragData[0] = textureCube(sbtexture, tc);\\n             }&quot;,&quot;&quot;)),&quot;background&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec2 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec2 TexCoords;\\n             uniform sampler2D sbtexture;\\n             void main () {\\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\\n             }&quot;,&quot;&quot;)),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),&quot;vertexMC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Ep(&quot;Error setting vertexMC in shader VAO.&quot;));const e=t.renderable.getTextures();e.length||Ep(&quot;vtkSkybox requires a texture map&quot;),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Lp={context:null};const Bp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lp,n),Zt.extend(e,t,n),t.openGLTexture=Nd.newInstance(),t.tris=yd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Vp(e,t)}));rn(&quot;vtkSkybox&quot;,Bp);const{FieldAssociations:Np}=ol;function _p(e,t){t.classHierarchy.push(&quot;vtkHardwareSelector&quot;),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const Fp={fieldAssociation:Np.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function kp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fp,n),jt.obj(e,t),jt.setGet(e,t,[&quot;fieldAssociation&quot;,&quot;captureZValues&quot;]),_p(e,t)}var Gp={newInstance:jt.newInstance(kp,&quot;vtkHardwareSelector&quot;),extend:kp};function Up(e,t){t.classHierarchy.push(&quot;vtkFramebuffer&quot;),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling saveCurrentBindings&quot;);const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling restorePreviousBindings&quot;);const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et(&quot;you must set the OpenGLRenderWindow before calling create&quot;)},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et(&quot;you must set the OpenGLRenderWindow before calling setColorBuffer&quot;);let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et(&quot;you must set the OpenGLRenderWindow before calling removeColorBuffer&quot;);let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et(&quot;Attaching depth buffer textures to fbo requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling setDepthBuffer&quot;)},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et(&quot;Attaching depth buffer textures to framebuffers requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling removeDepthBuffer&quot;)},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>{const e=[0,0];return null!==t.glFramebuffer&&(e[0]=t.glFramebuffer.width,e[1]=t.glFramebuffer.height),e},e.populateFramebuffer=()=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling populateFrameBuffer&quot;);e.bind();const n=t.context,r=Nd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(bd.LINEAR),r.setMagnificationFilter(bd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,ys.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const zp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Wp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zp,n),yt(e,t),t.colorBuffers&&et(&quot;you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.&quot;),t.colorBuffers=[],It(e,t,[&quot;colorBuffers&quot;]),Up(e,t)}var Hp={newInstance:Et(Wp,&quot;vtkFramebuffer&quot;),extend:Wp};function jp(e,t){t.classHierarchy.push(&quot;vtkSelectionNode&quot;),e.getBounds=()=>t.points.getBounds()}const Kp={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function $p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kp,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,[&quot;contentType&quot;,&quot;fieldType&quot;,&quot;properties&quot;,&quot;selectionList&quot;]),jp(e,t)}var qp={newInstance:jt.newInstance($p,&quot;vtkSelectionNode&quot;),extend:$p,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Xp}=Wl,{SelectionContent:Yp,SelectionField:Zp}=qp,{FieldAssociations:Qp}=ol,{vtkErrorMacro:Jp}=jt;function ef(e){return`${e.propID} ${e.compositeID}`}function tf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function nf(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function rf(e,t){let n=t;return n<<=24,n|=e,n}function of(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=nf(n[0],n[1],e.pixBuffer[Xp.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=nf(n[0],n[1],e.pixBuffer[Xp.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Xp.ID_LOW24]&&0===tf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area))return a;const s=nf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area),l=nf(n[0],n[1],e.pixBuffer[Xp.ID_HIGH24],e.area);return a.attributeID=rf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=of(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=of(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=of(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function af(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=qp.newInstance();switch(l.setContentType(Yp.INDICES),e){case Qp.FIELD_ASSOCIATION_CELLS:l.setFieldType(Zp.CELL);break;case Qp.FIELD_ASSOCIATION_POINTS:l.setFieldType(Zp.POINT);break;default:Jp(&quot;Unknown field association&quot;)}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function sf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=of(e,[n,t],0,u);if(r&&r.valid){const t=ef(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return af(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function lf(e,t){t.classHierarchy.push(&quot;vtkOpenGLHardwareSelector&quot;),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e[0]!==n[0]||e[1]!==n[1]?(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer()):t.framebuffer.bind()}else t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return sf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return Jp(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:&quot;StartEvent&quot;}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();for(e.beginSelection(),t.currentPass=Xp.MIN_KNOWN_PASS;t.currentPass<=Xp.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Xp.ACTOR_PASS&&&quot;function&quot;==typeof n[0].requestDepth&&&quot;function&quot;==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),e.processPixelBuffers());return e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:&quot;EndEvent&quot;}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Xp.ID_HIGH24){if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Xp.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if(&quot;function&quot;==typeof e[0].requestDepth&&&quot;function&quot;==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=nf(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Xp.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Xp.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(Xp,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=nf(e[0],e[1],t.pixBuffer[Xp.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=nf(e[0],e[1],t.pixBuffer[Xp.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Xp.ID_LOW24]&&0===tf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area))return a;const s=nf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area),l=nf(e[0],e[1],t.pixBuffer[Xp.ID_HIGH24],t.area);return a.attributeID=rf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=ef(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return af(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const cf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cf,n),Gp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,[&quot;area&quot;],4),jt.setGet(e,t,[&quot;_renderer&quot;,&quot;currentPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;maximumPointId&quot;,&quot;maximumCellId&quot;]),jt.setGetArray(e,t,[&quot;propColorValue&quot;],3),jt.moveToProtected(e,t,[&quot;renderer&quot;,&quot;openGLRenderWindow&quot;]),jt.event(e,t,&quot;event&quot;),lf(e,t)}var df={newInstance:jt.newInstance(uf,&quot;vtkOpenGLHardwareSelector&quot;),extend:uf,...Wl};const{vtkErrorMacro:pf}=Kt,{Representation:ff}=ds,{ObjectType:gf}=qu,{PassTypes:mf}=df,hf={type:&quot;StartEvent&quot;},vf={type:&quot;EndEvent&quot;};function yf(e,t){t.classHierarchy.push(&quot;vtkOpenGLGlyph3DMapper&quot;);const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(hf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(vf),!t.currentInput)return void pf(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;attribute mat3 gNormal;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * gNormal * normalMC;&quot;]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;];a&&(i=i.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let s=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];a&&(s=s.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),s=s.concat([&quot;  opacity = opacityUniform;&quot;]),a&&(s=s.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),t.drawingEdges||(i=i.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),n=cd.substitute(n,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 gColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput = gColor;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result,s=s.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])),o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,s).result,o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;vertexVCVSOutput = MCVCMatrix * gVertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result):(n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;]).result,n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=cd.substitute(n,&quot;//VTK::Picking::Dec&quot;,[&quot;attribute vec3 mapperIndexVS;&quot;,&quot;varying vec3 mapperIndexVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Picking::Impl&quot;,&quot;  mapperIndexVSOutput = mapperIndexVS;&quot;).result,e.Vertex=n,t=cd.substitute(t,&quot;//VTK::Picking::Dec&quot;,[&quot;varying vec3 mapperIndexVSOutput;&quot;,&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,t=cd.substitute(t,&quot;//VTK::Picking::Impl&quot;,[&quot;  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);&quot;,&quot;  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];&quot;]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3(&quot;normalMatrix&quot;,t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix(&quot;MCVCMatrix&quot;,t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray(&quot;ambientColorUniform&quot;,t.tmpColor),u.setUniform3fArray(&quot;diffuseColorUniform&quot;,t.tmpColor)}c&&u.setUniform3fArray(&quot;mapperIndex&quot;,c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===ff.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===mf.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed(&quot;normalMatrix&quot;),v=g.isUniformUsed(&quot;MCVCMatrix&quot;);if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed(&quot;gMatrix&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,&quot;gMatrix&quot;,0,64,t.context.FLOAT,4,!1,1)||pf(&quot;Error setting gMatrix in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gMatrix&quot;),e.getProgram().isAttributeUsed(&quot;gNormal&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,&quot;gNormal&quot;,0,36,t.context.FLOAT,3,!1,1)||pf(&quot;Error setting gNormal in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gNormal&quot;),e.getProgram().isAttributeUsed(&quot;gColor&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,&quot;gColor&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting gColor in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gColor&quot;),e.getProgram().isAttributeUsed(&quot;mapperIndexVS&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,&quot;mapperIndexVS&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting mapperIndexVS in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;mapperIndexVS&quot;),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=qu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=qu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=qu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=qu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,gf.ARRAY_BUFFER),t.normalBuffer.upload(n,gf.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),gf.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,gf.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Tf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const bf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),np.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),yf(e,t)}),&quot;vtkOpenGLGlyph3DMapper&quot;);rn(&quot;vtkGlyph3DMapper&quot;,bf);const{vtkErrorMacro:xf}=jt;class Cf{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Sf(e,t){t.classHierarchy.push(&quot;vtkClosedPolyLineToSurfaceFilter&quot;),e.requestData=(e,t)=>{const n=e[0];if(!n)return void xf(&quot;Invalid or missing input&quot;);const r=gu.newInstance();r.shallowCopy(n);const o=new Cf,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(cc.newInstance({values:c,name:&quot;faces&quot;})),t[0]=r}}const Af={};function If(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Af,n),jt.obj(e,t),jt.algo(e,t,1,1),Sf(e,t)}var wf={newInstance:jt.newInstance(If,&quot;vtkClosedPolyLineToSurfaceFilter&quot;),extend:If};const{vtkErrorMacro:Pf}=Kt;function Of(e,t){t.classHierarchy.push(&quot;vtkCutter&quot;);const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Pf(&quot;Invalid or missing input&quot;);if(!t.cutFunction)return void Pf(&quot;Missing cut function&quot;);const o=gu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error(&quot;Iterator is done&quot;);r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const Rf={cutFunction:null,cutScalars:null,cutValue:0};function Mf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),yt(e,t),Rt(e,t,1,1),At(e,t,[&quot;cutFunction&quot;,&quot;cutValue&quot;]),Of(e,t)}var Df={newInstance:Et(Mf,&quot;vtkCutter&quot;),extend:Mf};const Ef=e=>e,Vf=1e-6;class Lf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Ef}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=Dn(n,r);return a>=1||(En(this.tmp,n,r),Sn(this.tmp)<Vf&&(En(this.tmp,[1,0,0],e),Sn(this.tmp)<Vf&&En(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Bf=function(){return new Lf(!0)},Nf=function(){return new Lf(!1)};const _f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],Ff=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function kf(e,t){t.classHierarchy.push(&quot;vtkCubeSource&quot;),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=gu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Es.newInstance({name:&quot;Normals&quot;,values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Es.newInstance({name:&quot;TextureCoordinates&quot;,values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Bf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Nf().translate(...t.center).apply(o),t.matrix){Nf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Nf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Gf={xLength:1,yLength:1,zLength:1,pointType:&quot;Float64Array&quot;,generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;xLength&quot;,&quot;yLength&quot;,&quot;zLength&quot;,&quot;generate3DTextureCoordinates&quot;,&quot;generateFaces&quot;,&quot;generateLines&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;rotations&quot;],3),jt.setGetArray(e,t,[&quot;matrix&quot;],16),t._polys=cc.newInstance({values:Uint16Array.from(Ff)}),t._lineCells=cc.newInstance({values:Uint16Array.from(_f)}),jt.moveToProtected(e,t,[&quot;polys&quot;,&quot;lineCells&quot;]),jt.algo(e,t,0,1),kf(e,t)}var zf={newInstance:jt.newInstance(Uf,&quot;vtkCubeSource&quot;),extend:Uf};const{vtkErrorMacro:Wf}=jt;function Hf(e,t){t.classHierarchy.push(&quot;vtkImageDataOutlineFilter&quot;);const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA(&quot;vtkImageData&quot;))return void Wf(&quot;Invalid or missing input&quot;);const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Wf(&quot;Unable to fetch spatial extents of input image.&quot;)},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const jf={};function Kf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jf,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=zf.newInstance(),jt.moveToProtected(e,t,[&quot;cubeSource&quot;,&quot;tmpOut&quot;]),Hf(e,t)}var $f={newInstance:jt.newInstance(Kf,&quot;vtkImageDataOutlineFilter&quot;),extend:Kf};let qf;function Xf(e,t){t.classHierarchy.push(&quot;vtkAbstractTransform&quot;,&quot;vtkHomogeneousTransform&quot;,&quot;vtkTransform&quot;),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>qf({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const Yf={preMultiplyFlag:!1,matrix:[...vo]};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;preMultiplyFlag&quot;]),jt.setGetArray(e,t,[&quot;matrix&quot;],16),Xf(e,t)}qf=jt.newInstance(Zf,&quot;vtkTransform&quot;);var Qf={newInstance:qf,extend:Zf};const Jf={NEAREST:0,LINEAR:1};var eg={InterpolationType:Jf};const{vtkErrorMacro:tg}=Kt;function ng(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function rg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function og(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageResliceMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:&quot;EndEvent&quot;})):tg(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Jf.NEAREST?(t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.openGLTexture.setMinificationFilter(bd.LINEAR),t.openGLTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime(),e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(!r)return;const o=r.getPointData()?.getScalars();if(!o)return;t._scalars!==o&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=o);const a=o.getNumberOfComponents();let i=`${r.getMTime()}A${o.getMTime()}`;const s=t._openGLRenderWindow.getGraphicsResourceForObject(o);if(s?.vtkObj&&s?.hash===i&&t.openGLTextureString===i)t.openGLTexture=s.vtkObj,t.openGLTextureString=s.hash;else{t.openGLTexture||(t.openGLTexture=Nd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const e=r.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],o),t.openGLTextureString=i,o&&t._openGLRenderWindow.setGraphicsResourceForObject(o,t.openGLTexture,t.openGLTextureString)}const l=n.getProperty(),c=l.getIndependentComponents(),u=c?a:1,d=c?2*u:1,p=l.getRGBTransferFunction();i=ng(l,p,u);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===i&&t.colorTextureString===i)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(e*d*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),p){const r=new Float32Array(3*e);for(let t=0;t<u;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),c)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=i,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}const g=l.getPiecewiseFunction();i=ng(l,g,u);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(m?.vtkObj&&m?.hash===i&&t.pwfTextureString===i)t.pwfTexture=m.vtkObj,t.pwfTextureString=m.hash;else{const e=1024,n=e*d,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),g){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<u;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=i,g&&t._openGLRenderWindow.setGraphicsResourceForObject(g,t.pwfTexture,t.pwfTextureString)}const h=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==h){const e=Es.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName(&quot;points&quot;);const n=Es.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:tg(&quot;Slab mode requested without normals&quot;)}t.tris.getCABO().createVBO(n,&quot;polys&quot;,rs.SURFACE,r)}t.VBOBuildString=h,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed(&quot;texture1&quot;)&&a.setUniformi(&quot;texture1&quot;,t.openGLTexture.getTextureUnit()),a.isAttributeUsed(&quot;vertexWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexWC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting vertexWC in shader VAO.&quot;)),a.isAttributeUsed(&quot;normalWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;normalWC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting normalWC in shader VAO.&quot;)),a.isUniformUsed(&quot;slabThickness&quot;)&&a.setUniformf(&quot;slabThickness&quot;,t.renderable.getSlabThickness()),a.isUniformUsed(&quot;spacing&quot;)&&a.setUniform3fv(&quot;spacing&quot;,t.currentInput.getSpacing()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabTrapezoid&quot;)&&a.setUniformi(&quot;slabTrapezoid&quot;,t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed(&quot;WCTCMatrix&quot;)){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix(&quot;WCTCMatrix&quot;,t.tmpMat4)}a.isUniformUsed(&quot;vboScaling&quot;)&&a.setUniform3fv(&quot;vboScaling&quot;,n.getCABO().getCoordScale()),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed(&quot;MCPCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCPCMatrix&quot;,rg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed(&quot;MCVCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCVCMatrix&quot;,rg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d),o.setUniform4fv(&quot;backgroundColor&quot;,t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model coordinates\\n// WC - World coordinates\\n// VC - View coordinates\\n// DC - Display coordinates\\n// TC - Texture coordinates\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvoid main()\\n{\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the gpu image mapper fragment shader\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  //VTK::TCoord::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform mat4 WCTCMatrix;&quot;,&quot;out vec3 fragTexCoord;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;fragTexCoord = (WCTCMatrix * vertexWC).xyz;&quot;]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=[&quot;in vec3 fragTexCoord;&quot;,&quot;uniform highp sampler3D texture1;&quot;,&quot;uniform mat4 WCTCMatrix;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}s>0&&(u=u.concat([&quot;uniform vec3 spacing;&quot;,&quot;uniform float slabThickness;&quot;,&quot;uniform int slabType;&quot;,&quot;uniform int slabTrapezoid;&quot;,&quot;uniform vec3 vboScaling;&quot;]),u=u.concat([&quot;vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)&quot;,&quot;{&quot;,&quot;  vec4 retVal = vec4(1.0);&quot;,&quot;  if (slabType == 0) // min&quot;,&quot;  {&quot;,&quot;    retVal = min(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 1) // max&quot;,&quot;  {&quot;,&quot;    retVal = max(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 3) // sum&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  else // mean&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  return retVal;&quot;,&quot;}&quot;])),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,u).result;let d=[&quot;if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(texture1, fragTexCoord);&quot;];if(s>0&&(d=d.concat([&quot;// Get the first and last samples&quot;,&quot;int numSlices = 1;&quot;,&quot;float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;&quot;,&quot;vec3 normalxspacing = scaling * normalWCVSOutput;&quot;,&quot;float distTraveled = length(normalxspacing);&quot;,&quot;int trapezoid = 0;&quot;,&quot;while (distTraveled < slabThickness * 0.5)&quot;,&quot;{&quot;,&quot;  distTraveled += length(normalxspacing);&quot;,&quot;  float fnumSlices = float(numSlices);&quot;,&quot;  if (distTraveled > slabThickness * 0.5)&quot;,&quot;  {&quot;,&quot;    // Before stepping outside the slab, sample at the boundaries&quot;,&quot;    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;&quot;,&quot;    trapezoid = slabTrapezoid;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordNeg);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordPos);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;}&quot;,&quot;// Finally, if slab type is *mean*, divide the sum by the numSlices&quot;,&quot;if (slabType == 2)&quot;,&quot;{&quot;,&quot;  tvalue = tvalue / float(numSlices);&quot;,&quot;}&quot;])),c){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(l){case 1:d=d.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:d=d.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=[&quot;attribute vec4 vertexWC;&quot;];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat([&quot;attribute vec3 normalWC;&quot;,&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,c).result;let u=[&quot;gl_Position = MCPCMatrix * vertexWC;&quot;];l>0&&(u=u.concat([&quot;normalWCVSOutput = normalWC;&quot;,&quot;vertexWCVSOutput = vertexWC;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,u).result,a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result;let d=[];l>0&&(d=d.concat([&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),s=cd.substitute(s,&quot;//VTK::PositionVC::Dec&quot;,d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e=&quot;&quot;;const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`));const t=ue(n?.getDirection());ge(t,t);const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999||o>.999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ni.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getDimensions(),l=[0,i[0]-1,0,i[1]-1,0,i[2]-1];let c=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[c+a]=r[a],e[c+o[0]]=l[2*o[0]+n],e[c+o[1]]=l[2*o[1]+t],c+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const u=new Uint16Array(8);u[0]=3,u[1]=0,u[2]=1,u[3]=3,u[4]=3,u[5]=0,u[6]=3,u[7]=2;const d=s.getNormal();za.normalize(d);const p=new Float32Array(12);for(let e=0;e<4;++e)p[3*e]=d[0],p[3*e+1]=d[1],p[3*e+2]=d[2];t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(u,1);const f=Es.newInstance({numberOfComponents:3,values:p,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(f)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=gu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Es.newInstance({numberOfComponents:3,values:a,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(i)}else tg(&quot;Something went wrong.&quot;,&quot;A default slice plane should have been created in the beginning of&quot;,&quot;updateResliceGeometry.&quot;);t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)}}const ag={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,openGLTextureString:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1,_scalars:null};const ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ag,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=$f.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=gu.newInstance(),t.cutter=Df.newInstance(),t.lineToSurfaceFilter=wf.newInstance(),t.transform=Qf.newInstance(),bt(e,t,[&quot;openGLTexture&quot;]),og(e,t)}),&quot;vtkOpenGLImageResliceMapper&quot;);rn(&quot;vtkImageResliceMapper&quot;,ig);var sg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:lg}=Kt,{SlicingMode:cg}=sg;function ug(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function dg(e){const t=e.split(&quot;\\n&quot;),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function pg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t.renderable.isA(&quot;vtkImageMapper&quot;)&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(n.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,a=cd.substitute(a,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result,a=cd.substitute(a,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform sampler2D labelOutlineTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform float outlineOpacity;&quot;];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}}if(i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,c).result,!0===o.getProperty().getUseLabelOutline()&&(i=cd.substitute(i,&quot;//VTK::LabelOutline::Dec&quot;,[&quot;uniform int outlineThickness;&quot;,&quot;uniform float vpWidth;&quot;,&quot;uniform float vpHeight;&quot;,&quot;uniform float vpOffsetX;&quot;,&quot;uniform float vpOffsetY;&quot;,&quot;uniform mat4 PCWCMatrix;&quot;,&quot;uniform mat4 vWCtoIDX;&quot;,&quot;uniform ivec3 imageDimensions;&quot;]).result,i=cd.substitute(i,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result,i=cd.substitute(i,&quot;//VTK::LabelOutlineHelperFunction&quot;,[&quot;#ifdef vtkImageLabelOutlineOn&quot;,&quot;vec3 fragCoordToIndexSpace(vec4 fragCoord) {&quot;,&quot;  vec4 pcPos = vec4(&quot;,&quot;    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,&quot;,&quot;    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,&quot;,&quot;    (fragCoord.z - 0.5) * 2.0,&quot;,&quot;    1.0);&quot;,&quot;&quot;,&quot;  vec4 worldCoord = PCWCMatrix * pcPos;&quot;,&quot;  vec4 vertex = (worldCoord/worldCoord.w);&quot;,&quot;&quot;,&quot;  vec3 index = (vWCtoIDX * vertex).xyz;&quot;,&quot;&quot;,&quot;  // half voxel fix for labelmapOutline&quot;,&quot;  return (index + vec3(0.5)) / vec3(imageDimensions);&quot;,&quot;}&quot;,&quot;#endif&quot;]).result),l){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];let t=[&quot;vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);&quot;];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, opacity);&quot;]);break;case 2:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,t).result}else switch(s){case 1:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[...dg(&quot;\\n                #ifdef vtkImageLabelOutlineOn\\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); \\n                  float centerValue = texture2D(texture1, centerPosIS.xy).r;\\n                  bool pixelOnBorder = false;\\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\\n                  float opacityToUse = scalarOpacity * opacity;\\n                  int segmentIndex = int(centerValue * 255.0);\\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\\n                  int actualThickness = int(textureValue * 255.0);\\n\\n                  if (actualThickness == 0) {\\n                    gl_FragData[0] = vec4(0.0, 0.0, 1.0, 1.0);\\n                    return;\\n                  }\\n                  if (opacityToUse > 0.01) {\\n                    for (int i = -actualThickness; i <= actualThickness; i++) {\\n                      for (int j = -actualThickness; j <= actualThickness; j++) {\\n                        if (i == 0 || j == 0) {\\n                          continue;\\n                        }\\n                        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n                          gl_FragCoord.y + float(j),\\n                          gl_FragCoord.z, gl_FragCoord.w);\\n                        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n                        float value = texture2D(texture1, neighborPosIS.xy).r;\\n                        if (value != centerValue) {\\n                          pixelOnBorder = true;\\n                          break;\\n                        }\\n                      }\\n                      if (pixelOnBorder == true) {\\n                        break;\\n                      }\\n                    }\\n                    if (pixelOnBorder == true) {\\n                      gl_FragData[0] = vec4(tColor, outlineOpacity);\\n                    }\\n                    else {\\n                      gl_FragData[0] = vec4(tColor, opacityToUse);\\n                    }\\n                  }\\n                #else\\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\\n                #endif\\n                &quot;)]).result;break;case 2:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;float intensity = tcolor.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);&quot;]).result;break;case 3:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]).result;break;default:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;]).result}t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||lg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||lg(&quot;Error setting tcoordMC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi(&quot;texture1&quot;,a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi(&quot;colorTexture1&quot;,c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi(&quot;pwfTexture1&quot;,u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;labelOutlineTexture1&quot;,p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf(&quot;outlineOpacity&quot;,e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();a.setUniform3i(&quot;imageDimensions&quot;,o[0],o[1],1),a.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const i=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,i.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const l=e.getRenderTargetSize();a.setUniformf(&quot;vpWidth&quot;,l[0]),a.setUniformf(&quot;vpHeight&quot;,l[1]);const c=e.getRenderTargetOffset();a.setUniformf(&quot;vpOffsetX&quot;,c[0]/l[0]),a.setUniformf(&quot;vpOffsetY&quot;,c[1]/l[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf(&quot;opacity&quot;,o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):lg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=ug(l,f,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.vtkObj&&m?.hash===g&&t.colorTextureString===g)t.colorTexture=m.vtkObj,t.colorTextureString=m.hash;else{const e=1024,n=new Uint8Array(e*p*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST)):(t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR)),f){const r=new Float32Array(3*e);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),u)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,p,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=g,f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,t.colorTextureString)}const h=l.getPiecewiseFunction(),v=ug(l,h,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.vtkObj&&y?.hash===v&&t.pwfTextureString===v)t.pwfTexture=y.vtkObj,t.pwfTextureString=y.hash;else{const e=1024,n=e*p,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),h){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<d;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),u)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,p,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=v,h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,t.pwfTextureString)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA(&quot;vtkImageArrayMapper&quot;)?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===cg.I&&(S=x-C[0]),T===cg.J&&(S=x-C[2]),T!==cg.K&&T!==cg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Nd.newInstance({resizable:!0}),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(new Set([1,3,4]).has(s)&&i===ys.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.NEAREST)):t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST)):(4!==s||i!==ys.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(bd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(bd.LINEAR)),t.openGLTexture.setWrapS(Td.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Td.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[cg.X,cg.Y,cg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===cg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===cg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===cg.K||T===cg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):lg(&quot;Reformat slicing not yet supported.&quot;);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);m?.vtkObj?(t.openGLTexture=m.vtkObj,t.VBOBuildString=m.hash):(t._scalars!==g&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=g),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t._openGLRenderWindow.setGraphicsResourceForObject(g,t.openGLTexture,t.VBOBuildString)),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Es.newInstance({numberOfComponents:3,values:r});h.setName(&quot;points&quot;);const v=Es.newInstance({numberOfComponents:2,values:l});v.setName(&quot;tcoords&quot;);const y=new Uint16Array(8);y[0]=3,y[1]=0,y[2]=1,y[3]=3,y[4]=3,y[5]=0,y[6]=3,y[7]=2;const C=Es.newInstance({numberOfComponents:1,values:y});t.tris.getCABO().createVBO(C,&quot;polys&quot;,rs.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=e=>{t.labelOutlineThicknessTexture||(t.labelOutlineThicknessTexture=Nd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]}}const fg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,_scalars:null};const gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fg,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),pg(e,t)}),&quot;vtkOpenGLImageMapper&quot;);rn(&quot;vtkAbstractImageMapper&quot;,gg);const{vtkErrorMacro:mg}=jt;function hg(e,t,n){if(t.apply(e)){const t=e.getIndependentComponents();return`${e.getMTime()}-${t}-${n}`}return&quot;0&quot;}function vg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageCPRMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow))},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentImageDataInput,o=t.currentCenterlineInput;n.getProperty().getInterpolationType()===Jf.NEAREST?(t.volumeTexture.setMinificationFilter(bd.NEAREST),t.volumeTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.volumeTexture.setMinificationFilter(bd.LINEAR),t.volumeTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR));const a=r.getMTime();if(t.volumeTextureTime!==a){const e=r.getDimensions(),n=r.getPointData().getScalars();if(!n)return;t.volumeTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.volumeTexture.releaseGraphicsResources(t._openGLRenderWindow),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromRaw(e[0],e[1],e[2],n.getNumberOfComponents(),n.getDataType(),n.getData(),t.renderable.getPreferSizeOverAccuracy()),t.volumeTextureTime=a}const i=r.getPointData()&&r.getPointData().getScalars();if(!i)return;const s=i.getNumberOfComponents(),l=n.getProperty(),c=l.getIndependentComponents(),u=c?s:1,d=c?2*u:1,p=hg(l,l.getRGBTransferFunction,u);if(t.colorTextureString!==p){const e=1024,n=new Uint8Array(e*d*3);let r=l.getRGBTransferFunction();if(r){const o=new Float32Array(3*e);for(let t=0;t<u;t++){r=l.getRGBTransferFunction(t);const a=r.getRange();if(r.getTable(a[0],a[1],e,o,1),c)for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r],n[t*e*6+r+3*e]=255*o[r];else for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=p}const f=hg(l,l.getPiecewiseFunction,u);if(t.pwfTextureString!==f){const e=1024,n=e*d,r=new Uint8Array(n);let o=l.getPiecewiseFunction();if(t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),o){const r=new Float32Array(n),a=new Float32Array(e);for(let t=0;t<u;++t)if(o=l.getPiecewiseFunction(t),null===o)r.fill(1);else{const n=o.getRange();if(o.getTable(n[0],n[1],e,a,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=a[n],r[t*e*2+n+e]=a[n];else for(let n=0;n<e;n++)r[t*e*2+n]=a[n]}t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=f}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<o.getMTime()){const e=o.getNumberOfPoints(),n=e<=1?0:e-1,r=o.getDistancesToFirstPoint(),a=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,a-r[e],0],t),t+=3,s.set([l,a-r[e],0],t),t+=3,s.set([l,a-r[e+1],0],t),t+=3,s.set([0,a-r[e+1],0],t),t+=3;const c=Es.newInstance({numberOfComponents:3,values:s});c.setName(&quot;points&quot;);const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Es.newInstance({numberOfComponents:1,values:u}),p=o.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Es.newInstance({numberOfComponents:3,values:f,name:&quot;centerlinePosition&quot;}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Es.newInstance({numberOfComponents:1,values:v,name:&quot;quadIndex&quot;})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getCenterlineTangentDirections(),r=new Float32Array(3*i),o=new Float32Array(3*i);for(let t=0,a=0;t<n;++t){const n=3*t;for(let t=0;t<4;++t)r[a+0]=e[n+0],r[a+1]=e[n+1],r[a+2]=e[n+2],o[a+0]=e[n+3],o[a+1]=e[n+4],o[a+2]=e[n+5],a+=3}const a=Es.newInstance({numberOfComponents:3,values:r,name:&quot;centerlineTopDirection&quot;}),s=Es.newInstance({numberOfComponents:3,values:o,name:&quot;centerlineBotDirection&quot;});y.push(a,s)}t.tris.getCABO().createVBO(d,&quot;polys&quot;,rs.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result;const s=[&quot;attribute vec3 centerlinePosition;&quot;,&quot;attribute float quadIndex;&quot;,&quot;uniform float width;&quot;,&quot;out vec2 quadOffsetVSOutput;&quot;,&quot;out vec3 centerlinePosVSOutput;&quot;],l=t.renderable.getUseUniformOrientation();l?s.push(&quot;out vec3 centerlineDirVSOutput;&quot;,&quot;uniform vec3 centerlineDirection;&quot;):s.push(&quot;out vec3 centerlineTopDirVSOutput;&quot;,&quot;out vec3 centerlineBotDirVSOutput;&quot;,&quot;out float centerlineAngleVSOutput;&quot;,&quot;attribute vec3 centerlineTopDirection;&quot;,&quot;attribute vec3 centerlineBotDirection;&quot;),a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,s).result;const c=[&quot;quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);&quot;,&quot;centerlinePosVSOutput = centerlinePosition;&quot;];l?c.push(&quot;centerlineDirVSOutput = centerlineDirection;&quot;):c.push(&quot;vec3 sumVec = centerlineTopDirection + centerlineBotDirection;&quot;,&quot;float sumLen2 = dot(sumVec, sumVec);&quot;,&quot;float diffLen2 = 4.0 - sumLen2;&quot;,&quot;if (diffLen2 < 0.001) {&quot;,&quot;  // vectors are too close to each other, use lerp&quot;,&quot;  centerlineAngleVSOutput = -1.0; // use negative angle as a flag for lerp&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection;&quot;,&quot;} else if (sumLen2 == 0.0) {&quot;,&quot;  // vector are opposite to each other, don't make a choice for the user&quot;,&quot;  // use slerp without direction, it will display the centerline color on each row of pixel&quot;,&quot;  centerlineAngleVSOutput = 0.0;&quot;,&quot;  centerlineTopDirVSOutput = vec3(0.0);&quot;,&quot;  centerlineBotDirVSOutput = vec3(0.0);&quot;,&quot;} else {&quot;,&quot;  // use slerp&quot;,&quot;  centerlineAngleVSOutput = 2.0 * atan(sqrt(diffLen2/sumLen2));&quot;,&quot;  float sinAngle = sin(centerlineAngleVSOutput);&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection / sinAngle;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection / sinAngle;&quot;,&quot;}&quot;),a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,c).result;const u=t.volumeTexture.getComponents(),d=o.getProperty().getIndependentComponents();let p=[&quot;uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates&quot;,&quot;in vec2 quadOffsetVSOutput;&quot;,&quot;in vec3 centerlinePosVSOutput;&quot;,&quot;uniform highp sampler3D volumeTexture;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;];l?p.push(&quot;in vec3 centerlineDirVSOutput;&quot;):p.push(&quot;in vec3 centerlineTopDirVSOutput;&quot;,&quot;in vec3 centerlineBotDirVSOutput;&quot;,&quot;in float centerlineAngleVSOutput;&quot;);const f=t.renderable.getCenterPoint();if(f&&p.push(&quot;uniform vec3 globalCenterPoint;&quot;),d){for(let e=1;e<u;e++)p=p.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(u){case 1:p=p.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,p).result;let g=[];if(l?g.push(&quot;vec3 interpolatedCenterlineDir = centerlineDirVSOutput;&quot;):g.push(&quot;vec3 interpolatedCenterlineDir;&quot;,&quot;if (centerlineAngleVSOutput < 0.0) {&quot;,&quot;  // Lerp&quot;,&quot;  interpolatedCenterlineDir = quadOffsetVSOutput.y * centerlineTopDirVSOutput + (1.0 - quadOffsetVSOutput.y) * centerlineBotDirVSOutput;&quot;,&quot;} else {&quot;,&quot;  // Slerp&quot;,&quot;  float topInterpolationAngle = quadOffsetVSOutput.y * centerlineAngleVSOutput;&quot;,&quot;  float botInterpolationAngle = centerlineAngleVSOutput - topInterpolationAngle;&quot;,&quot;  interpolatedCenterlineDir = sin(topInterpolationAngle) * centerlineTopDirVSOutput + sin(botInterpolationAngle) * centerlineBotDirVSOutput;&quot;,&quot;}&quot;,&quot;// Slerp should give a normalized vector but when sin(angle) is small, rounding error occurs&quot;,&quot;// Normalize for both lerp and slerp&quot;,&quot;interpolatedCenterlineDir = normalize(interpolatedCenterlineDir);&quot;),f?g.push(&quot;float baseOffset = dot(interpolatedCenterlineDir, globalCenterPoint - centerlinePosVSOutput);&quot;,&quot;float horizontalOffset = quadOffsetVSOutput.x + baseOffset;&quot;):g.push(&quot;float horizontalOffset = quadOffsetVSOutput.x;&quot;),g.push(&quot;vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * interpolatedCenterlineDir;&quot;,&quot;vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;&quot;,&quot;if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(volumeTexture, volumePosTC);&quot;),d){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<u;++t)g=g.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(u){case 1:g=g.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(u){case 1:g=g.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:g=g.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,g).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||mg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getCABO().getCustomData().forEach((e=>{e&&n.getProgram().isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),e.name,e.offset,n.getCABO().getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&mg(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const a=t.volumeTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;volumeTexture&quot;,a),n.getProgram().setUniformf(&quot;width&quot;,t.renderable.getWidth()),n.getProgram().setUniform4f(&quot;backgroundColor&quot;,...t.renderable.getBackgroundColor()),n.getProgram().isUniformUsed(&quot;centerlineDirection&quot;)){const e=t.renderable.getUniformDirection();n.getProgram().setUniform3fArray(&quot;centerlineDirection&quot;,e)}if(n.getProgram().isUniformUsed(&quot;globalCenterPoint&quot;)){const e=t.renderable.getCenterPoint();n.getProgram().setUniform3fArray(&quot;globalCenterPoint&quot;,e)}const i=t.currentImageDataInput,s=i.getWorldToIndex(),l=P(new Float32Array(16),Rn([],i.getDimensions())),c=oe(l,l,s);if(n.getProgram().setUniformMatrix(&quot;MCTCMatrix&quot;,c),t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)}}const yg={currentRenderPass:null,volumeTexture:null,volumeTextureTime:0,colorTexture:null,colorTextureString:null,pwfTexture:null,pwfTextureString:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Tg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yg,n),Zt.extend(e,t,n),kd(e,t,n),jt.algo(e,t,2,0),t.tris=yd.newInstance(),t.volumeTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.pwfTexture=Nd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),vg(e,t)}),&quot;vtkOpenGLImageCPRMapper&quot;);function bg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageSlice&quot;),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkImageCPRMapper&quot;,Tg);const xg={context:null,keyMatrixTime:null,keyMatrices:null};const Cg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bg(e,t)}),&quot;vtkOpenGLImageSlice&quot;);function Sg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolume&quot;),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn(&quot;vtkImageSlice&quot;,Cg);const Ag={};const Ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ag,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,[&quot;context&quot;]),Sg(e,t)}),&quot;vtkOpenGLVolume&quot;);rn(&quot;vtkVolume&quot;,Ig);const wg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},Pg={FRACTIONAL:0,PROPORTIONAL:1};var Og={InterpolationType:wg,OpacityMode:Pg};const Rg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5};var Mg={BlendMode:Rg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Dg,vtkErrorMacro:Eg}=Kt;function Vg(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function Lg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolumeMapper&quot;),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType(&quot;vtkOpenGLVolume&quot;);const n=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const r=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera()),e.renderPiece(r,n)}},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\n\\nvarying vec3 vertexVCVSOutput;\\nuniform mat4 PCVCMatrix;\\n\\nuniform float dcxmin;\\nuniform float dcxmax;\\nuniform float dcymin;\\nuniform float dcymax;\\n\\nvoid main()\\n{\\n  // dcsmall is the device coords reduced to the\\n  // x y area covered by the volume\\n  vec4 dcsmall = vec4(\\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\\n    vertexDC.z,\\n    vertexDC.w);\\n  vec4 vcpos = PCVCMatrix * dcsmall;\\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\\n  gl_Position = dcsmall;\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkVolumeFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the volume mappers fragment shader\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvarying vec3 vertexVCVSOutput;\\n\\n// first declare the settings from the mapper\\n// that impact the code paths in here\\n\\n// always set vtkNumComponents 1,2,3,4\\n//VTK::NumComponents\\n\\n// possibly define vtkTrilinearOn\\n//VTK::TrilinearOn\\n\\n// possibly define vtkIndependentComponents\\n//VTK::IndependentComponentsOn\\n\\n// possibly define any \\&quot;proportional\\&quot; components\\n//VTK::vtkProportionalComponents\\n\\n// Define the blend mode to use\\n#define vtkBlendMode //VTK::BlendMode\\n\\n// Possibly define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n#ifdef vtkImageLabelOutlineOn\\n\\nuniform float outlineOpacity;\\nuniform float vpWidth;\\nuniform float vpHeight;\\nuniform float vpOffsetX;\\nuniform float vpOffsetY;\\nuniform mat4 PCWCMatrix;\\nuniform mat4 vWCtoIDX;\\n#endif\\n\\n// define vtkLightComplexity\\n//VTK::LightComplexity\\n#if vtkLightComplexity > 0\\nuniform float vSpecularPower;\\nuniform float vAmbient;\\nuniform float vDiffuse;\\nuniform float vSpecular;\\n//VTK::Light::Dec\\n#endif\\n\\n//VTK::VolumeShadowOn\\n//VTK::SurfaceShadowOn\\n//VTK::localAmbientOcclusionOn\\n//VTK::LAO::Dec\\n//VTK::VolumeShadow::Dec\\n\\n// define vtkComputeNormalFromOpacity\\n//VTK::vtkComputeNormalFromOpacity\\n\\n// possibly define vtkGradientOpacityOn\\n//VTK::GradientOpacityOn\\n#ifdef vtkGradientOpacityOn\\nuniform float goscale0;\\nuniform float goshift0;\\nuniform float gomin0;\\nuniform float gomax0;\\n#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\nuniform float goscale1;\\nuniform float goshift1;\\nuniform float gomin1;\\nuniform float gomax1;\\n#if vtkNumComponents >= 3\\nuniform float goscale2;\\nuniform float goshift2;\\nuniform float gomin2;\\nuniform float gomax2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float goscale3;\\nuniform float goshift3;\\nuniform float gomin3;\\nuniform float gomax3;\\n#endif\\n#endif\\n#endif\\n\\n// if you want to see the raw tiled\\n// data in webgl1 uncomment the following line\\n// #define debugtile\\n\\n// camera values\\nuniform float camThick;\\nuniform float camNear;\\nuniform float camFar;\\nuniform int cameraParallel;\\n\\n// values describing the volume geometry\\nuniform vec3 vOriginVC;\\nuniform vec3 vSpacing;\\nuniform ivec3 volumeDimensions; // 3d texture dimensions\\nuniform vec3 vPlaneNormal0;\\nuniform float vPlaneDistance0;\\nuniform vec3 vPlaneNormal1;\\nuniform float vPlaneDistance1;\\nuniform vec3 vPlaneNormal2;\\nuniform float vPlaneDistance2;\\nuniform vec3 vPlaneNormal3;\\nuniform float vPlaneDistance3;\\nuniform vec3 vPlaneNormal4;\\nuniform float vPlaneDistance4;\\nuniform vec3 vPlaneNormal5;\\nuniform float vPlaneDistance5;\\n\\n//VTK::ClipPlane::Dec\\n\\n// opacity and color textures\\nuniform sampler2D otexture;\\nuniform float oshift0;\\nuniform float oscale0;\\nuniform sampler2D ctexture;\\nuniform float cshift0;\\nuniform float cscale0;\\n\\n// jitter texture\\nuniform sampler2D jtexture;\\nuniform sampler2D ttexture;\\n\\n\\n// some 3D texture values\\nuniform float sampleDistance;\\nuniform vec3 vVCToIJK;\\n\\n// the heights defined below are the locations\\n// for the up to four components of the tfuns\\n// the tfuns have a height of 2XnumComps pixels so the\\n// values are computed to hit the middle of the two rows\\n// for that component\\n#ifdef vtkIndependentComponentsOn\\n#if vtkNumComponents == 2\\nuniform float mix0;\\nuniform float mix1;\\n#define height0 0.25\\n#define height1 0.75\\n#endif\\n#if vtkNumComponents == 3\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\n#define height0 0.17\\n#define height1 0.5\\n#define height2 0.83\\n#endif\\n#if vtkNumComponents == 4\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\nuniform float mix3;\\n#define height0 0.125\\n#define height1 0.375\\n#define height2 0.625\\n#define height3 0.875\\n#endif\\n#endif\\n\\n#if vtkNumComponents >= 2\\nuniform float oshift1;\\nuniform float oscale1;\\nuniform float cshift1;\\nuniform float cscale1;\\n#endif\\n#if vtkNumComponents >= 3\\nuniform float oshift2;\\nuniform float oscale2;\\nuniform float cshift2;\\nuniform float cscale2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float oshift3;\\nuniform float oscale3;\\nuniform float cshift3;\\nuniform float cscale3;\\n#endif\\n\\nuniform vec4 ipScalarRangeMin;\\nuniform vec4 ipScalarRangeMax;\\n\\n// declaration for intermixed geometry\\n//VTK::ZBuffer::Dec\\n\\n//=======================================================================\\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\\nvec3 rayDirVC;\\nfloat sampleDistanceISVS;\\nfloat sampleDistanceIS;\\n\\n#define SQRT3    1.7321\\n#define INV4PI   0.0796\\n#define EPSILON  0.001\\n#define PI       3.1415\\n#define PI2      9.8696\\n\\n//=======================================================================\\n// Webgl2 specific version of functions\\n#if __VERSION__ == 300\\n\\nuniform highp sampler3D texture1;\\n\\nvec4 getTextureValue(vec3 pos)\\n{\\n  vec4 tmp = texture(texture1, pos);\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.a = tmp.g;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n  return tmp;\\n}\\n\\n//=======================================================================\\n// WebGL1 specific version of functions\\n#else\\n\\nuniform sampler2D texture1;\\n\\nuniform float texWidth;\\nuniform float texHeight;\\nuniform int xreps;\\nuniform int xstride;\\nuniform int ystride;\\n\\n// if computing trilinear values from multiple z slices\\n#ifdef vtkTrilinearOn\\nvec4 getTextureValue(vec3 ijk)\\n{\\n  float zoff = 1.0/float(volumeDimensions.z);\\n  vec4 val1 = getOneTextureValue(ijk);\\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\\n\\n  float indexZ = float(volumeDimensions)*ijk.z;\\n  float zmix =  indexZ - floor(indexZ);\\n\\n  return mix(val1, val2, zmix);\\n}\\n\\nvec4 getOneTextureValue(vec3 ijk)\\n#else // nearest or fast linear\\nvec4 getTextureValue(vec3 ijk)\\n#endif\\n{\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n#ifdef debugtile\\n  vec2 tpos = vec2(ijk.x, ijk.y);\\n  vec4 tmp = texture2D(texture1, tpos);\\n  tmp.a = 1.0;\\n\\n#else\\n  int z = int(ijk.z * tdims.z);\\n  int yz = z / xreps;\\n  int xz = z - yz*xreps;\\n\\n  int tileWidth = volumeDimensions.x/xstride;\\n  int tileHeight = volumeDimensions.y/ystride;\\n\\n  xz *= tileWidth;\\n  yz *= tileHeight;\\n\\n  float ni = float(xz) + (ijk.x*float(tileWidth));\\n  float nj = float(yz) + (ijk.y*float(tileHeight));\\n\\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\\n\\n  vec4 tmp = texture2D(texture1, tpos);\\n\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.g = tmp.a;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n#endif\\n\\n  return tmp;\\n}\\n\\n// End of Webgl1 specific code\\n//=======================================================================\\n#endif\\n\\n//=======================================================================\\n// transformation between VC and IS space\\n\\n// convert vector position from idx to vc\\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\\nvec3 IStoVC(vec3 posIS){\\n  vec3 posVC = posIS / vVCToIJK;\\n  return posVC.x * vPlaneNormal0 +\\n         posVC.y * vPlaneNormal2 +\\n         posVC.z * vPlaneNormal4 +\\n         vOriginVC;\\n}\\n\\n// convert vector position from vc to idx\\nvec3 VCtoIS(vec3 posVC){\\n  posVC = posVC - vOriginVC;\\n  posVC = vec3(\\n    dot(posVC, vPlaneNormal0),\\n    dot(posVC, vPlaneNormal2),\\n    dot(posVC, vPlaneNormal4));\\n  return posVC * vVCToIJK;\\n}\\n#endif\\n\\n//Rotate vector to view coordinate\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\nvoid rotateToViewCoord(inout vec3 dirIS){\\n  dirIS.xyz =\\n    dirIS.x * vPlaneNormal0 +\\n    dirIS.y * vPlaneNormal2 +\\n    dirIS.z * vPlaneNormal4;\\n}\\n\\n//Rotate vector to idx coordinate\\nvec3 rotateToIDX(vec3 dirVC){\\n  vec3 dirIS;\\n  dirIS.xyz = vec3(\\n    dot(dirVC, vPlaneNormal0),\\n    dot(dirVC, vPlaneNormal2),\\n    dot(dirVC, vPlaneNormal4));\\n  return dirIS;\\n}\\n#endif\\n\\n//=======================================================================\\n// Given a normal compute the gradient opacity factors\\nfloat computeGradientOpacityFactor(\\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\\n{\\n#if defined(vtkGradientOpacityOn)\\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\\n#else\\n  return 1.0;\\n#endif\\n}\\n\\n//=======================================================================\\n// compute the normal and gradient magnitude for a position, uses forward difference\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\n#ifdef vtkClippingPlanesOn\\n  void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\\n  {\\n    vec3 g1VC[3];\\n    for (int i = 0; i < 3; ++i)\\n    {\\n      g1VC[i] = IStoVC(texPos[i]);\\n    }\\n    vec3 posVC = IStoVC(pos);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      for (int j = 0; j < 3; ++j)\\n      {\\n        if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\\n        {\\n          g1[j] = 0.0;\\n        }\\n      }\\n    }\\n  }\\n#endif\\n\\n  #ifdef vtkComputeNormalFromOpacity\\n    #ifdef vtkGradientOpacityOn\\n      vec4 computeDensityNormal(float gradientMag, vec3 scalarInterp[2])\\n      {\\n    #else\\n      //if gradient opacity not on but using density gradient\\n      vec4 computeDensityNormal(vec3 scalarInterp[2])\\n      {\\n    #endif\\n        vec3 opacityG1, opacityG2;\\n        opacityG1.x = texture2D(otexture, vec2(scalarInterp[0].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.y = texture2D(otexture, vec2(scalarInterp[0].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.z = texture2D(otexture, vec2(scalarInterp[0].z * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.x = texture2D(otexture, vec2(scalarInterp[1].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.y = texture2D(otexture, vec2(scalarInterp[1].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.z = texture2D(otexture, vec2(scalarInterp[1].z * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n        float gradOpacityFactor = 1.0f;\\n        if (gradientMag >= 0.0){\\n          gradOpacityFactor = computeGradientOpacityFactor(gradientMag, goscale0, goshift0, gomin0, gomax0);\\n        }\\n        opacityG1.xyz *= gradOpacityFactor;\\n        opacityG2.xyz *= gradOpacityFactor;\\n    #endif\\n\\n        vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\\n        // divide by spacing\\n        opacityG.xyz /= vSpacing;\\n        opacityG.w = length(opacityG.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(opacityG.xyz);\\n        if (length(opacityG.xyz) > 0.0) {\\n          return vec4(normalize(opacityG.xyz),opacityG.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n\\n      vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2])\\n      {\\n        vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n        vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n        vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n        vec3 texPosPVec[3];\\n        texPosPVec[0] = pos + xvec;\\n        texPosPVec[1] = pos + yvec;\\n        texPosPVec[2] = pos + zvec;\\n        vec3 texPosNVec[3];\\n        texPosNVec[0] = pos - xvec;\\n        texPosNVec[1] = pos - yvec;\\n        texPosNVec[2] = pos - zvec;\\n        vec3 g1, g2;\\n\\n        scalarInterp[0].x = getTextureValue(texPosPVec[0]).a;\\n        scalarInterp[0].y = getTextureValue(texPosPVec[1]).a;\\n        scalarInterp[0].z = getTextureValue(texPosPVec[2]).a;\\n        scalarInterp[1].x = getTextureValue(texPosNVec[0]).a;\\n        scalarInterp[1].y = getTextureValue(texPosNVec[1]).a;\\n        scalarInterp[1].z = getTextureValue(texPosNVec[2]).a;\\n\\n        #ifdef vtkClippingPlanesOn\\n          adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\\n          adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\\n        #endif\\n        vec4 result;\\n        result.x = scalarInterp[0].x - scalarInterp[1].x;\\n        result.y = scalarInterp[0].y - scalarInterp[1].y;\\n        result.z = scalarInterp[0].z - scalarInterp[1].z;\\n        // divide by spacing\\n        result.xyz /= vSpacing;\\n        result.w = length(result.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(result.xyz);\\n        if (length(result.xyz) > 0.0) {\\n          return vec4(normalize(result.xyz),result.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n  #endif\\n\\n  vec4 computeNormal(vec3 pos, vec3 tstep)\\n  {\\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n    vec3 texPosPVec[3];\\n    texPosPVec[0] = pos + xvec;\\n    texPosPVec[1] = pos + yvec;\\n    texPosPVec[2] = pos + zvec;\\n    vec3 texPosNVec[3];\\n    texPosNVec[0] = pos - xvec;\\n    texPosNVec[1] = pos - yvec;\\n    texPosNVec[2] = pos - zvec;\\n    vec3 g1, g2;\\n    g1.x = getTextureValue(texPosPVec[0]).a;\\n    g1.y = getTextureValue(texPosPVec[1]).a;\\n    g1.z = getTextureValue(texPosPVec[2]).a;\\n    g2.x = getTextureValue(texPosNVec[0]).a;\\n    g2.y = getTextureValue(texPosNVec[1]).a;\\n    g2.z = getTextureValue(texPosNVec[2]).a;\\n    #ifdef vtkClippingPlanesOn\\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\\n    #endif\\n    vec4 result;\\n    result = vec4(g1 - g2, -1.0);\\n    // divide by spacing\\n    result.xyz /= vSpacing;\\n    result.w = length(result.xyz);\\n    if (result.w > 0.0){\\n      // rotate to View Coords\\n      rotateToViewCoord(result.xyz);\\n      return vec4(normalize(result.xyz),result.w);\\n    } else {\\n      return vec4(0.0);\\n    }\\n  }\\n#endif\\n\\n#ifdef vtkImageLabelOutlineOn\\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\\n  vec4 pcPos = vec4(\\n    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\\n    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\\n    (fragCoord.z - 0.5) * 2.0,\\n    1.0);\\n\\n  vec4 worldCoord = PCWCMatrix * pcPos;\\n  vec4 vertex = (worldCoord/worldCoord.w);\\n\\n  vec3 index = (vWCtoIDX * vertex).xyz;\\n\\n  // half voxel fix for labelmapOutline\\n  return (index + vec3(0.5)) / vec3(volumeDimensions);\\n}\\n#endif\\n\\n//=======================================================================\\n// compute the normals and gradient magnitudes for a position\\n// for independent components\\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\\n{\\n  mat4 result;\\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\\n\\n  // divide by spacing\\n  distX /= vSpacing.x;\\n  distY /= vSpacing.y;\\n  distZ /= vSpacing.z;\\n\\n  mat3 rot;\\n  rot[0] = vPlaneNormal0;\\n  rot[1] = vPlaneNormal2;\\n  rot[2] = vPlaneNormal4;\\n\\n#if !defined(vtkComponent0Proportional)\\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\\n  result[0].a = length(result[0].xyz);\\n  result[0].xyz *= rot;\\n  if (result[0].w > 0.0)\\n  {\\n    result[0].xyz /= result[0].w;\\n  }\\n#endif\\n\\n// optionally compute the 2nd component\\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\\n  result[1].a = length(result[1].xyz);\\n  result[1].xyz *= rot;\\n  if (result[1].w > 0.0)\\n  {\\n    result[1].xyz /= result[1].w;\\n  }\\n#endif\\n\\n// optionally compute the 3rd component\\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\\n  result[2].a = length(result[2].xyz);\\n  result[2].xyz *= rot;\\n  if (result[2].w > 0.0)\\n  {\\n    result[2].xyz /= result[2].w;\\n  }\\n#endif\\n\\n// optionally compute the 4th component\\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\\n  result[3].a = length(result[3].xyz);\\n  result[3].xyz *= rot;\\n  if (result[3].w > 0.0)\\n  {\\n    result[3].xyz /= result[3].w;\\n  }\\n#endif\\n\\n  return result;\\n}\\n\\n//=======================================================================\\n// global shadow - secondary ray\\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\\nfloat random()\\n{\\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\\n  uint pcg_state = floatBitsToUint(jitter);\\n  uint state = pcg_state;\\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\\n}\\n#endif\\n\\n#ifdef VolumeShadowOn\\n// henyey greenstein phase function\\nfloat phase_function(float cos_angle)\\n{\\n  // divide by 2.0 instead of 4pi to increase intensity\\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\\n}\\n\\n// Computes the intersection between a ray and a box\\nstruct Hit\\n{\\n  float tmin;\\n  float tmax;\\n};\\n\\nstruct Ray\\n{\\n  vec3 origin;\\n  vec3 dir;\\n  vec3 invDir;\\n};\\n\\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\\n{\\n  vec3 tbot = r.invDir * (boundMin - r.origin);\\n  vec3 ttop = r.invDir * (boundMax - r.origin);\\n  vec3 tmin = min(ttop, tbot);\\n  vec3 tmax = max(ttop, tbot);\\n  vec2 t = max(tmin.xx, tmin.yz);\\n  float t0 = max(t.x, t.y);\\n  t = min(tmax.xx, tmax.yz);\\n  float t1 = min(t.x, t.y);\\n  hit.tmin = t0;\\n  hit.tmax = t1;\\n  return t1 > max(t0,0.0);\\n}\\n\\n// As BBoxIntersect requires the inverse of the ray coords,\\n// this function is used to avoid numerical issues\\nvoid safe_0_vector(inout Ray ray)\\n{\\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\\n}\\n\\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\\n{\\n  float shadow = 1.0;\\n  float opacity = 0.0;\\n\\n  // modify sample distance with a random number between 1.5 and 3.0\\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\\n\\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\\n\\n  // compute the start and end points for the ray\\n  Ray ray;\\n  Hit hit;\\n  ray.origin = posIS;\\n  ray.dir = lightDirNormIS;\\n  safe_0_vector(ray);\\n  ray.invDir = 1.0/ray.dir;\\n\\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\\n  {\\n    return 1.0;\\n  }\\n  float maxdist = hit.tmax;\\n\\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\\n  maxdist = min(maxdist,maxgi);\\n  if(maxdist < EPSILON) {\\n    return 1.0;\\n  }\\n\\n  // support gradient opacity\\n  #ifdef vtkGradientOpacityOn\\n    vec4 normal;\\n  #endif\\n\\n  float current_dist = 0.0;\\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\\n  float clamped_step = 0.0;\\n\\n  vec4 scalar = vec4(0.0);\\n  while(current_dist < maxdist)\\n  {\\n#ifdef vtkClippingPlanesOn\\n    vec3 posVC = IStoVC(posIS);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\\n      {\\n        current_dist = maxdist;\\n      }\\n    }\\n#endif\\n    scalar = getTextureValue(posIS);\\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n      normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    shadow *= 1.0 - opacity;\\n\\n    // optimization: early termination\\n    if (shadow < EPSILON){\\n      return 0.0;\\n    }\\n\\n    clamped_step = min(maxdist - current_dist, current_step);\\n    posIS += clamped_step * lightDirNormIS;\\n    current_dist += current_step;\\n  }\\n\\n  return shadow;\\n}\\n\\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\\n{\\n  vec3 vertLight = vec3(0.0);\\n  vec3 secondary_contrib = vec3(0.0);\\n  // here we assume only positional light, no effect of cones\\n  for (int i = 0; i < lightNum; i++)\\n  {\\n    #if(vtkLightComplexity==3)\\n      if (lightPositional[i] == 1){\\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\\n      }else{\\n        vertLight = - lightDirectionVC[i];\\n      }\\n    #else\\n      vertLight = - lightDirectionVC[i];\\n    #endif\\n    // here we assume achromatic light, only intensity\\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\\n    float phase_attenuation = 0.5;\\n    if (abs(anisotropy) > EPSILON){\\n      phase_attenuation = phase_function(dDotL);\\n    }\\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\\n    secondary_contrib += tColor * vAmbient;\\n  }\\n  return secondary_contrib;\\n}\\n#endif\\n\\n//=======================================================================\\n// local ambient occlusion\\n#ifdef localAmbientOcclusionOn\\nvec3 sample_direction_uniform(int i)\\n{\\n  float rand = random() * 0.5;\\n  float theta = PI2 * (kernelSample[i][0] + rand);\\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\\n}\\n\\n// return a matrix that transform startDir into z axis; startDir should be normalized\\nmat3 zBaseRotationalMatrix(vec3 startDir){\\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\\n  float cosA = startDir.z;\\n  float k = 1.0 / (1.0 + cosA);\\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\\n  return matrix;\\n}\\n\\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\\n  // apply LAO only at selected locations, otherwise return full brightness\\n  if (normal.w > 0.0 && op > 0.05){\\n    float total_transmittance = 0.0;\\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\\n    vec3 currPos, randomDirStep;\\n    float weight, transmittance, opacity;\\n    for (int i = 0; i < kernelSize; i++)\\n    {\\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\\n      currPos = posIS;\\n      transmittance = 1.0;\\n      for (int j = 0; j < kernelRadius ; j++){\\n        currPos += randomDirStep;\\n        // check if it's at clipping plane, if so return full brightness\\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\\n          #ifdef vtkGradientOpacityOn\\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n          #endif\\n          transmittance *= 1.0 - opacity;\\n        }\\n        else{\\n          break;\\n        }\\n      }\\n      total_transmittance += transmittance / float(kernelRadius) * weight;\\n\\n      // early termination if fully translucent\\n      if (total_transmittance > 1.0 - EPSILON){\\n        return 1.0;\\n      }\\n    }\\n    // average transmittance and reduce variance\\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\\n  } else {\\n    return 1.0;\\n  }\\n}\\n#endif\\n\\n//=======================================================================\\n// surface light contribution\\n#if vtkLightComplexity > 0\\n  void applyLighting(inout vec3 tColor, vec4 normal)\\n  {\\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\\n    vec3 specular = vec3(0.0, 0.0, 0.0);\\n    float df, sf = 0.0;\\n    for (int i = 0; i < lightNum; i++){\\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\\n        diffuse += df * lightColor[i];\\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\\n        specular += sf * lightColor[i];\\n    }\\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\\n  }\\n  #ifdef SurfaceShadowOn\\n  #if vtkLightComplexity < 3\\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float ndotL,vdotR;\\n        vertLightDirection = lightDirectionVC[i];\\n        ndotL = dot(normal.xyz, vertLightDirection);\\n        if (ndotL < 0.0 && twoSidedLighting)\\n        {\\n          ndotL = -ndotL;\\n        }\\n        if (ndotL > 0.0)\\n        {\\n          diffuse += ndotL * lightColor[i];\\n          //specular\\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n          if (vdotR > 0.0)\\n          {\\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n          }\\n        }\\n        #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n        #endif\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #else\\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float distance,attenuation,ndotL,vdotR;\\n        vec3 lightDir;\\n        if (lightPositional[i] == 1){\\n          lightDir = lightDirectionVC[i];\\n          vertLightDirection = posVC - lightPositionVC[i];\\n          distance = length(vertLightDirection);\\n          vertLightDirection = normalize(vertLightDirection);\\n          attenuation = 1.0 / (lightAttenuation[i].x\\n                              + lightAttenuation[i].y * distance\\n                              + lightAttenuation[i].z * distance * distance);\\n          // per OpenGL standard cone angle is 90 or less for a spot light\\n          if (lightConeAngle[i] <= 90.0){\\n            float coneDot = dot(vertLightDirection, lightDir);\\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\\n            }\\n            else {\\n              attenuation = 0.0;\\n            }\\n          }\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * attenuation * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        } else {\\n          vertLightDirection = lightDirectionVC[i];\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        }\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #endif\\n  #endif\\n#endif\\n\\n//=======================================================================\\n// Given a texture value compute the color and opacity\\n//\\nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\\n{\\n#ifdef vtkImageLabelOutlineOn\\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\\n  vec4 centerValue = getTextureValue(centerPosIS);\\n  bool pixelOnBorder = false;\\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\\n\\n  // Get alpha of segment from opacity function.\\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n  int segmentIndex = int(centerValue.r * 255.0);\\n  \\n  // Use texture sampling for outlineThickness\\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\\n\\n  int actualThickness = int(textureValue * 255.0);\\n\\n  if (actualThickness == 0) {\\n    return vec4(0, 0, 1, 1);\\n  }\\n\\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\\n  // Saves a bunch of needless checks on the background.\\n  // TODO define epsilon when building shader?\\n  if (float(tColor.a) > 0.01) {\\n    for (int i = -actualThickness; i <= actualThickness; i++) {\\n      for (int j = -actualThickness; j <= actualThickness; j++) {\\n        if (i == 0 || j == 0) {\\n          continue;\\n        }\\n\\n        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n          gl_FragCoord.y + float(j),\\n          gl_FragCoord.z, gl_FragCoord.w);\\n\\n        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n        vec4 value = getTextureValue(neighborPosIS);\\n\\n        // If any of my neighbours are not the same value as I\\n        // am, this means I am on the border of the segment.\\n        // We can break the loops\\n        if (any(notEqual(value, centerValue))) {\\n          pixelOnBorder = true;\\n          break;\\n        }\\n      }\\n\\n      if (pixelOnBorder == true) {\\n        break;\\n      }\\n    }\\n\\n    // If I am on the border, I am displayed at full opacity\\n    if (pixelOnBorder == true) {\\n      tColor.a = outlineOpacity;\\n    }\\n  }\\n\\n#else\\n  // compute the normal and gradient magnitude if needed\\n  // We compute it as a vec4 if possible otherwise a mat4\\n  //\\n  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);\\n\\n  // compute the normal vectors as needed\\n  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\\n      #if !defined(vtkComponent0Proportional)\\n        vec4 normal0 = normalMat[0];\\n      #endif\\n      #if !defined(vtkComponent1Proportional)\\n        vec4 normal1 = normalMat[1];\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          vec4 normal2 = normalMat[2];\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            vec4 normal3 = normalMat[3];\\n          #endif\\n        #endif\\n      #endif\\n    #else\\n      vec4 normalLight;\\n      #ifdef vtkComputeNormalFromOpacity\\n        vec3 scalarInterp[2];\\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp);\\n        if (length(normal0)>0.0){\\n          #ifdef vtkGradientOpacityOn\\n            normalLight = computeDensityNormal(normal0.w, scalarInterp);\\n          #else\\n            normalLight = computeDensityNormal(scalarInterp);\\n          #endif\\n          if (length(normalLight) == 0.0){\\n            normalLight = normal0;\\n          }\\n        }\\n      #else\\n        vec4 normal0 = computeNormal(posIS, tstep);\\n        normalLight = normal0;\\n      #endif\\n    #endif\\n  #endif\\n\\n  // compute gradient opacity factors as needed\\n  #if defined(vtkGradientOpacityOn)\\n    #if !defined(vtkComponent0Proportional)\\n      goFactor.x =\\n        computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      #if !defined(vtkComponent1Proportional)\\n        goFactor.y =\\n          computeGradientOpacityFactor(normal1.a, goscale1, goshift1, gomin1, gomax1);\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          goFactor.z =\\n            computeGradientOpacityFactor(normal2.a, goscale2, goshift2, gomin2, gomax2);\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            goFactor.w =\\n              computeGradientOpacityFactor(normal3.a, goscale3, goshift3, gomin3, gomax3);\\n          #endif\\n        #endif\\n      #endif\\n    #endif\\n  #endif\\n\\n  // single component is always independent\\n  #if vtkNumComponents == 1\\n    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n    if (tColor.a < EPSILON){\\n      return vec4(0.0);\\n    }\\n  #endif\\n\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));\\n    #if !defined(vtkComponent0Proportional)\\n      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n      tColor *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));\\n    #endif\\n\\n    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\\n    #if !defined(vtkComponent1Proportional)\\n      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n      tColor1 *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));\\n    #endif\\n\\n    #if vtkNumComponents >= 3\\n      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\\n      #if !defined(vtkComponent2Proportional)\\n        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n      #else\\n        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n        tColor2 *= pwfValue;\\n        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));\\n      #endif\\n\\n      #if vtkNumComponents >= 4\\n        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\\n        #if !defined(vtkComponent3Proportional)\\n          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n        #else\\n          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n          tColor3 *= pwfValue;\\n          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));\\n        #endif\\n      #endif\\n    #endif\\n  #else // then not independent\\n\\n  #if vtkNumComponents == 2\\n    float lum = tValue.r * cscale0 + cshift0;\\n    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\\n    vec4 tColor = vec4(lum, lum, lum, alpha);\\n  #endif\\n  #if vtkNumComponents == 3\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\\n  #endif\\n  #if vtkNumComponents == 4\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\\n  #endif\\n  #endif // dependent\\n\\n  // apply lighting if requested as appropriate\\n  #if vtkLightComplexity > 0\\n    #if !defined(vtkComponent0Proportional)\\n      #if vtkNumComponents == 1\\n        #ifdef SurfaceShadowOn\\n            #if vtkLightComplexity < 3\\n                vec3 tColorS = applyLightingDirectional(posIS, tColor, normalLight);\\n            #else\\n                vec3 tColorS = applyLightingPositional(posIS, tColor, normalLight, IStoVC(posIS));\\n            #endif\\n        #endif\\n\\n        #ifdef VolumeShadowOn\\n          vec3 tColorVS = applyShadowRay(tColor.rgb, posIS, rayDirVC);\\n          #ifdef SurfaceShadowOn\\n            float vol_coef = volumetricScatteringBlending * (1.0 - tColor.a / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\\n            tColor.rgb = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\\n          #else\\n            tColor.rgb = tColorVS;\\n          #endif\\n        #else\\n            tColor.rgb = tColorS;\\n        #endif\\n\\n      #else\\n        applyLighting(tColor.rgb, normal0);\\n      #endif\\n    #endif\\n\\n    #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n      #if !defined(vtkComponent1Proportional)\\n        applyLighting(tColor1, normal1);\\n      #endif\\n    #if vtkNumComponents >= 3\\n      #if !defined(vtkComponent2Proportional)\\n        applyLighting(tColor2, normal2);\\n      #endif\\n    #if vtkNumComponents >= 4\\n      #if !defined(vtkComponent3Proportional)\\n        applyLighting(tColor3, normal3);\\n      #endif\\n    #endif\\n    #endif\\n    #endif\\n  #endif\\n\\n// perform final independent blend as needed\\n#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n  tColor.rgb += tColor1;\\n#if vtkNumComponents >= 3\\n  tColor.rgb += tColor2;\\n#if vtkNumComponents >= 4\\n  tColor.rgb += tColor3;\\n#endif\\n#endif\\n#endif\\n\\n#endif\\nreturn tColor;\\n}\\n\\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\\n  bool withinRange = false;\\n  #if vtkNumComponents == 1\\n    if (val.r >= min.r && val.r <= max.r) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2\\n     if (val.r >= min.r && val.r <= max.r &&\\n        val.g >= min.g && val.g <= max.g) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3\\n    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\\n        all(lessThanEqual(val, ipScalarRangeMax))) {\\n      withinRange = true;\\n    }\\n  #endif\\n  return withinRange;\\n}\\n\\n//=======================================================================\\n// Apply the specified blend mode operation along the ray's path.\\n//\\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\\n{\\n  vec3 tstep = 1.0/tdims;\\n\\n  // start slightly inside and apply some jitter\\n  vec3 delta = endIS - posIS;\\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\\n  float raySteps = length(delta)/sampleDistanceIS;\\n\\n  // avoid 0.0 jitter\\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\\n  float stepsTraveled = jitter;\\n\\n  // local vars for the loop\\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\\n  vec4 tValue;\\n  vec4 tColor;\\n\\n  // if we have less than one step then pick the middle point\\n  // as our value\\n  // if (raySteps <= 1.0)\\n  // {\\n  //   posIS = (posIS + endIS)*0.5;\\n  // }\\n\\n  // Perform initial step at the volume boundary\\n  // compute the scalar\\n  tValue = getTextureValue(posIS);\\n\\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\\n    // now map through opacity and color\\n    tColor = getColorForValue(tValue, posIS, tstep);\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\\n      gl_FragData[0] = tColor;\\n      return;\\n    }\\n\\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n\\n      float mix = (1.0 - color.a);\\n\\n      // this line should not be needed but nvidia seems to not handle\\n      // the break correctly on windows/chrome 58 angle\\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\\n\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n      stepsTraveled++;\\n      posIS += stepIS;\\n      if (color.a > 0.99) { color.a = 1.0; break; }\\n    }\\n\\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\\n    {\\n      posIS = endIS;\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\\n\\n      float mix = (1.0 - color.a);\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n    }\\n\\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\\n  #endif\\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\\n    // Find maximum/minimum intensity along the ray.\\n\\n    // Define the operation we will use (min or max)\\n    #if vtkBlendMode == 1\\n    #define OP max\\n    #else\\n    #define OP min\\n    #endif\\n\\n    // If the clipping range is shorter than the sample distance\\n    // we can skip the sampling loop along the ray.\\n    if (raySteps <= 1.0)\\n    {\\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\\n      return;\\n    }\\n\\n    vec4 value = tValue;\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // Update the maximum value if necessary\\n      value = OP(tValue, value);\\n\\n      // Otherwise, continue along the ray\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n    tValue = getTextureValue(posIS);\\n    value = OP(tValue, value);\\n\\n    // Now map through opacity and color\\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\\n    vec4 sum = vec4(0.);\\n\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n    }\\n\\n    if (raySteps <= 1.0) {\\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\\n      // Notes:\\n      // - We are comparing all values in the texture to see if any of them\\n      //   are outside of the scalar range. In the future we might want to allow\\n      //   scalar ranges for each component.\\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n        // Sum the values across each step in the path\\n        sum += tValue;\\n      }\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n\\n    // compute the scalar\\n    tValue = getTextureValue(posIS);\\n\\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n\\n      stepsTraveled++;\\n    }\\n\\n    #if vtkBlendMode == 3 // Average\\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\\n    #endif\\n\\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 5 // RADON\\n    float normalizedRayIntensity = 1.0;\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tValue = getTextureValue(posIS);\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar value\\n      tValue = getTextureValue(posIS);\\n\\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n      posIS += stepIS;\\n      stepsTraveled++;\\n    }\\n\\n    // map normalizedRayIntensity to color\\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\\n\\n  #endif\\n}\\n\\n//=======================================================================\\n// Compute a new start and end point for a given ray based\\n// on the provided bounded clipping plane (aka a rectangle)\\nvoid getRayPointIntersectionBounds(\\n  vec3 rayPos, vec3 rayDir,\\n  vec3 planeDir, float planeDist,\\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\\n  float vSize1, float vSize2)\\n{\\n  float result = dot(rayDir, planeDir);\\n  if (abs(result) < 1e-6)\\n  {\\n    return;\\n  }\\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\\n  vec3 xposVC = rayPos + rayDir*result;\\n  vec3 vxpos = xposVC - vOriginVC;\\n  vec2 vpos = vec2(\\n    dot(vxpos, vPlaneX),\\n    dot(vxpos, vPlaneY));\\n\\n  // on some apple nvidia systems this does not work\\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\\n  //     vpos.y < 0.0 || vpos.y > vSize2)\\n  // even just\\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\\n  // fails\\n  // so instead we compute a value that represents in and out\\n  //and then compute the return using this value\\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\\n\\n  tbounds = mix(\\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\\n   tbounds, // out value\\n   check);  // 0 in 1 out\\n}\\n\\n//=======================================================================\\n// given a\\n// - ray direction (rayDir)\\n// - starting point (vertexVCVSOutput)\\n// - bounding planes of the volume\\n// - optionally depth buffer values\\n// - far clipping plane\\n// compute the start/end distances of the ray we need to cast\\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\\n{\\n  vec2 dists = vec2(100.0*camFar, -1.0);\\n\\n  vec3 vSize = vSpacing*tdims;\\n\\n  // all this is in View Coordinates\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n\\n  //VTK::ClipPlane::Impl\\n\\n  // do not go behind front clipping plane\\n  dists.x = max(0.0,dists.x);\\n\\n  // do not go PAST far clipping plane\\n  float farDist = -camThick/rayDir.z;\\n  dists.y = min(farDist,dists.y);\\n\\n  // Do not go past the zbuffer value if set\\n  // This is used for intermixing opaque geometry\\n  //VTK::ZBuffer::Impl\\n\\n  return dists;\\n}\\n\\n//=======================================================================\\n// Compute the index space starting position (pos) and end\\n// position\\n//\\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\\n{\\n  // compute starting and ending values in volume space\\n  pos = vertexVCVSOutput + dists.x*rayDir;\\n  pos = pos - vOriginVC;\\n  // convert to volume basis and origin\\n  pos = vec3(\\n    dot(pos, vPlaneNormal0),\\n    dot(pos, vPlaneNormal2),\\n    dot(pos, vPlaneNormal4));\\n\\n  endPos = vertexVCVSOutput + dists.y*rayDir;\\n  endPos = endPos - vOriginVC;\\n  endPos = vec3(\\n    dot(endPos, vPlaneNormal0),\\n    dot(endPos, vPlaneNormal2),\\n    dot(endPos, vPlaneNormal4));\\n\\n  float delta = length(endPos - pos);\\n\\n  pos *= vVCToIJK;\\n  endPos *= vVCToIJK;\\n\\n  float delta2 = length(endPos - pos);\\n  sampleDistanceIS = sampleDistance*delta2/delta;\\n  #ifdef VolumeShadowOn\\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\\n  #endif\\n}\\n\\nvoid main()\\n{\\n\\n  if (cameraParallel == 1)\\n  {\\n    // Camera is parallel, so the rayDir is just the direction of the camera.\\n    rayDirVC = vec3(0.0, 0.0, -1.0);\\n  } else {\\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\\n    rayDirVC = normalize(vertexVCVSOutput);\\n  }\\n\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n  // compute the start and end points for the ray\\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\\n\\n  // do we need to composite? aka does the ray have any length\\n  // If not, bail out early\\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\\n  {\\n    discard;\\n  }\\n\\n  // IS = Index Space\\n  vec3 posIS;\\n  vec3 endIS;\\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\\n\\n  // Perform the blending operation along the ray\\n  applyBlend(posIS, endIS, tdims);\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Fragment;o.getProperty().getInterpolationType()===wg.LINEAR&&(a=cd.substitute(a,&quot;//VTK::TrilinearOn&quot;,&quot;#define vtkTrilinearOn&quot;).result),!0===o.getProperty().getUseLabelOutline()&&(a=cd.substitute(a,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result);const i=t.scalarTexture.getComponents();a=cd.substitute(a,&quot;//VTK::NumComponents&quot;,`#define vtkNumComponents ${i}`).result;const s=o.getProperty().getIndependentComponents();if(s){a=cd.substitute(a,&quot;//VTK::IndependentComponentsOn&quot;,&quot;#define vtkIndependentComponentsOn&quot;).result;const e=[];for(let t=0;t<i;t++)o.getProperty().getOpacityMode(t)===Pg.PROPORTIONAL&&e.push(`#define vtkComponent${t}Proportional`);e.length>0&&(a=cd.substitute(a,&quot;//VTK::vtkProportionalComponents&quot;,e.join(&quot;\\n&quot;)).result)}const l=t.currentInput.getSpatialExtent(),c=t.currentInput.getSpacing(),u=new Float64Array(3);In(u,(l[1]-l[0])*c[0],(l[3]-l[2])*c[1],(l[5]-l[4])*c[2]);const d=Sn(u)/e.getCurrentSampleDistance(r);a=cd.substitute(a,&quot;//VTK::MaximumSamplesValue&quot;,`${Math.ceil(d)}`).result,a=cd.substitute(a,&quot;//VTK::LightComplexity&quot;,`#define vtkLightComplexity ${t.lastLightComplexity}`).result,t.lastLightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(a=cd.substitute(a,&quot;//VTK::VolumeShadowOn&quot;,&quot;#define VolumeShadowOn&quot;).result),t.renderable.getVolumetricScatteringBlending()<1&&(a=cd.substitute(a,&quot;//VTK::SurfaceShadowOn&quot;,&quot;#define SurfaceShadowOn&quot;).result),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0&&(a=cd.substitute(a,&quot;//VTK::localAmbientOcclusionOn&quot;,&quot;#define localAmbientOcclusionOn&quot;).result)),t.gopacity=o.getProperty().getUseGradientOpacity(0);for(let e=1;s&&!t.gopacity&&e<i;++e)o.getProperty().getUseGradientOpacity(e)&&(t.gopacity=!0);t.gopacity&&(a=cd.substitute(a,&quot;//VTK::GradientOpacityOn&quot;,&quot;#define vtkGradientOpacityOn&quot;).result),t.renderable.getComputeNormalFromOpacity()&&(a=cd.substitute(a,&quot;//VTK::vtkComputeNormalFromOpacity&quot;,&quot;#define vtkComputeNormalFromOpacity&quot;).result),null!==t.zBufferTexture&&(a=cd.substitute(a,&quot;//VTK::ZBuffer::Dec&quot;,[&quot;uniform sampler2D zBufferTexture;&quot;,&quot;uniform float vpZWidth;&quot;,&quot;uniform float vpZHeight;&quot;]).result,a=cd.substitute(a,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));&quot;,&quot;float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;&quot;,&quot;zdepth = zdepth * 2.0 - 1.0;&quot;,&quot;if (cameraParallel == 0) {&quot;,&quot;zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}&quot;,&quot;else {&quot;,&quot;zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\\n&quot;,&quot;zdepth = -zdepth/rayDir.z;&quot;,&quot;dists.y = min(zdepth,dists.y);&quot;]).result),a=cd.substitute(a,&quot;//VTK::BlendMode&quot;,`${t.renderable.getBlendMode()}`).result,n.Fragment=a,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lastLightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[&quot;uniform int lightNum;&quot;,&quot;uniform bool twoSidedLighting;&quot;,`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,&quot;//VTK::Light::Dec&quot;],!1).result,3===t.lastLightComplexity&&(o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=cd.substitute(o,&quot;//VTK::VolumeShadow::Dec&quot;,[&quot;uniform float volumetricScatteringBlending;&quot;,&quot;uniform float giReach;&quot;,&quot;uniform float volumeShadowSamplingDistFactor;&quot;,&quot;uniform float anisotropy;&quot;,&quot;uniform float anisotropy2;&quot;],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=cd.substitute(o,&quot;//VTK::LAO::Dec&quot;,[&quot;uniform int kernelRadius;&quot;,`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,&quot;uniform int kernelSize;&quot;],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=cd.substitute(o,&quot;//VTK::ClipPlane::Dec&quot;,[&quot;uniform vec3 vClipPlaneNormals[6];&quot;,&quot;uniform float vClipPlaneDistances[6];&quot;,&quot;uniform vec3 vClipPlaneOrigins[6];&quot;,&quot;uniform int clip_numPlanes;&quot;,&quot;//VTK::ClipPlane::Dec&quot;,&quot;#define vtkClippingPlanesOn&quot;],!1).result,o=cd.substitute(o,&quot;//VTK::ClipPlane::Impl&quot;,[`for(int i = 0; i < ${e}; i++) {`,&quot;  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);&quot;,&quot;  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];&quot;,&quot;  if (rayDirRatio == 0.0)&quot;,&quot;  {&quot;,&quot;    if (equationResult < 0.0) dists.x = dists.y;&quot;,&quot;    continue;&quot;,&quot;  }&quot;,&quot;  float result = -1.0 * equationResult / rayDirRatio;&quot;,&quot;  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);&quot;,&quot;  else dists.x = max(dists.x, result);&quot;,&quot;}&quot;,&quot;//VTK::ClipPlane::Impl&quot;],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{let a=0;o.getProperty().getShade()&&t.renderable.getBlendMode()===Rg.COMPOSITE_BLEND&&(a=0,t.numberOfLights=0,r.getLights().forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===a&&(a=1)),1===a&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(a=2),a<3&&e.getPositional()&&(a=3)})));let i=!1;t.lastLightComplexity!==a&&(t.lastLightComplexity=a,i=!0);const s=t.scalarTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=!1;const u=[];if(l){for(let e=0;e<s;e++)u.push(o.getProperty().getOpacityMode(e));u.length>0&&(c=!0)}const d=t.currentInput.getSpatialExtent(),p=t.currentInput.getSpacing(),f=new Float64Array(3);In(f,(d[1]-d[0])*p[0],(d[3]-d[2])*p[1],(d[5]-d[4])*p[2]);const g=Sn(f)/e.getCurrentSampleDistance(r),m={interpolationType:o.getProperty().getInterpolationType(),useLabelOutline:o.getProperty().getUseLabelOutline(),numComp:s,usesProportionalComponents:c,iComps:l,maxSamples:g,useGradientOpacity:o.getProperty().getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),proportionalComponents:u};return t.previousState&&t.previousState.interpolationType===m.interpolationType&&t.previousState.useLabelOutline===m.useLabelOutline&&t.previousState.numComp===m.numComp&&t.previousState.usesProportionalComponents===m.usesProportionalComponents&&t.previousState.iComps===m.iComps&&t.previousState.maxSamples===m.maxSamples&&t.previousState.useGradientOpacity===m.useGradientOpacity&&t.previousState.blendMode===m.blendMode&&function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(t.previousState.proportionalComponents,m.proportionalComponents)?!!(0===n.getProgram()?.getHandle()||i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||!!t.lastZBufferTexture!=!!t.zBufferTexture||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime())&&(t.lastZBufferTexture=t.zBufferTexture,!0):(t.previousState={...m},!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed(&quot;vertexDC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexDC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified()),a.setUniformi(&quot;texture1&quot;,t.scalarTexture.getTextureUnit()),a.setUniformf(&quot;sampleDistance&quot;,e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange(),l=[],c=[];for(let e=0;e<4;e++)l[e]=s[0]*i.dataComputedScale[e]+i.dataComputedOffset[e],c[e]=s[1]*i.dataComputedScale[e]+i.dataComputedOffset[e],l[e]=(l[e]-i.offset[e])/i.scale[e],c[e]=(c[e]-i.offset[e])/i.scale[e];if(a.setUniform4f(&quot;ipScalarRangeMin&quot;,l[0],l[1],l[2],l[3]),a.setUniform4f(&quot;ipScalarRangeMax&quot;,c[0],c[1],c[2],c[3]),null!==t.zBufferTexture){a.setUniformi(&quot;zBufferTexture&quot;,t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf(&quot;vpZWidth&quot;,e[0]),a.setUniformf(&quot;vpZHeight&quot;,e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf(&quot;camThick&quot;,c[1]-c[0]),s.setUniformf(&quot;camNear&quot;,c[0]),s.setUniformf(&quot;camFar&quot;,c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf(&quot;dcxmin&quot;,g),s.setUniformf(&quot;dcxmax&quot;,m),s.setUniformf(&quot;dcymin&quot;,v),s.setUniformf(&quot;dcymax&quot;,y),s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f(&quot;vSpacing&quot;,x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f(&quot;vOriginVC&quot;,p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Dg(`The number of steps required ${Math.ceil(A)} is larger than the\\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\\n        Please either change the\\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f(&quot;vVCToIJK&quot;,I[0],I[1],I[2]),s.setUniform3i(&quot;volumeDimensions&quot;,d[0],d[1],d[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf(&quot;texWidth&quot;,t.scalarTexture.getWidth()),s.setUniformf(&quot;texHeight&quot;,t.scalarTexture.getHeight()),s.setUniformi(&quot;xreps&quot;,e.xreps),s.setUniformi(&quot;xstride&quot;,e.xstride),s.setUniformi(&quot;ystride&quot;,e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*Dn(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(o.getProperty().getUseLabelOutline()){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf(&quot;vpWidth&quot;,u[0]),s.setUniformf(&quot;vpHeight&quot;,u[1]);const d=e.getRenderTargetOffset();s.setUniformf(&quot;vpOffsetX&quot;,d[0]/u[0]),s.setUniformf(&quot;vpOffsetY&quot;,d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix(&quot;PCVCMatrix&quot;,t.projectionToView),0===t.lastLightComplexity)return;let O=0;const R=[],M=[],D=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],D[0+3*O]=-.5*w[0],D[1+3*O]=-.5*w[1],D[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi(&quot;twoSidedLighting&quot;,r.getTwoSidedLighting()),s.setUniformi(&quot;lightNum&quot;,O),s.setUniform3fv(&quot;lightColor&quot;,R),s.setUniform3fv(&quot;lightDirectionVC&quot;,M),s.setUniform3fv(&quot;lightHalfAngleVC&quot;,D),3===t.lastLightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv(&quot;lightPositionVC&quot;,e),s.setUniform3fv(&quot;lightAttenuation&quot;,n),s.setUniformfv(&quot;lightConeAngle&quot;,o),s.setUniformfv(&quot;lightExponent&quot;,a),s.setUniformiv(&quot;lightPositional&quot;,i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf(&quot;giReach&quot;,t.renderable.getGlobalIlluminationReach()),s.setUniformf(&quot;volumetricScatteringBlending&quot;,t.renderable.getVolumetricScatteringBlending()),s.setUniformf(&quot;volumeShadowSamplingDistFactor&quot;,t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf(&quot;anisotropy&quot;,t.renderable.getAnisotropy()),s.setUniformf(&quot;anisotropy2&quot;,t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi(&quot;kernelSize&quot;,e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv(&quot;kernelSample&quot;,n),s.setUniformi(&quot;kernelRadius&quot;,t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi(&quot;ctexture&quot;,t.colorTexture.getTextureUnit()),o.setUniformi(&quot;otexture&quot;,t.opacityTexture.getTextureUnit()),o.setUniformi(&quot;jtexture&quot;,t.jitterTexture.getTextureUnit()),o.setUniformi(&quot;ttexture&quot;,t.labelOutlineThicknessTexture.getTextureUnit());const a=t.scalarTexture.getVolumeInfo(),i=r.getProperty(),s=t.scalarTexture.getComponents(),l=r.getProperty().getIndependentComponents();if(l&&s>=2)for(let e=0;e<s;e++)o.setUniformf(`mix${e}`,r.getProperty().getComponentWeight(e));for(let e=0;e<s;e++){const t=l?e:0,n=a.scale[e],r=i.getScalarOpacity(t).getRange(),s=n/(r[1]-r[0]),c=(a.offset[e]-r[0])/(r[1]-r[0]);o.setUniformf(`oshift${e}`,c),o.setUniformf(`oscale${e}`,s);const u=i.getRGBTransferFunction(t).getRange(),d=(a.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);o.setUniformf(`cshift${e}`,d),o.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(l)for(let e=0;e<s;++e){const t=a.scale[e];if(i.getUseGradientOpacity(e)){const n=i.getGradientOpacityMinimumOpacity(e),r=i.getGradientOpacityMaximumOpacity(e);o.setUniformf(`gomin${e}`,n),o.setUniformf(`gomax${e}`,r);const a=[i.getGradientOpacityMinimumValue(e),i.getGradientOpacityMaximumValue(e)];o.setUniformf(`goscale${e}`,t*(r-n)/(a[1]-a[0])),o.setUniformf(`goshift${e}`,-a[0]*(r-n)/(a[1]-a[0])+n)}else o.setUniformf(`gomin${e}`,1),o.setUniformf(`gomax${e}`,1),o.setUniformf(`goscale${e}`,0),o.setUniformf(`goshift${e}`,1)}else{const e=a.scale[s-1],t=i.getGradientOpacityMinimumOpacity(0),n=i.getGradientOpacityMaximumOpacity(0);o.setUniformf(&quot;gomin0&quot;,t),o.setUniformf(&quot;gomax0&quot;,n);const r=[i.getGradientOpacityMinimumValue(0),i.getGradientOpacityMaximumValue(0)];o.setUniformf(&quot;goscale0&quot;,e*(n-t)/(r[1]-r[0])),o.setUniformf(&quot;goshift0&quot;,-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===r.getProperty().getUseLabelOutline()){const e=r.getProperty().getLabelOutlineOpacity();o.setUniformf(&quot;outlineOpacity&quot;,e)}t.lastLightComplexity>0&&(o.setUniformf(&quot;vAmbient&quot;,i.getAmbient()),o.setUniformf(&quot;vDiffuse&quot;,i.getDiffuse()),o.setUniformf(&quot;vSpecular&quot;,i.getSpecular()),o.setUniformf(&quot;vSpecularPower&quot;,i.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*Dn(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv(&quot;vClipPlaneNormals&quot;,o),c.setUniformfv(&quot;vClipPlaneDistances&quot;,a),c.setUniform3fv(&quot;vClipPlaneOrigins&quot;,i),c.setUniformi(&quot;clip_numPlanes&quot;,l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===wg.NEAREST?(t.scalarTexture.setMinificationFilter(bd.NEAREST),t.scalarTexture.setMagnificationFilter(bd.NEAREST)):(t.scalarTexture.setMinificationFilter(bd.LINEAR),t.scalarTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null,null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;uniform vec2 tfactor;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),[&quot;//VTK::System::Dec&quot;,&quot;//VTK::Output::Dec&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { gl_FragData[0] = texture2D(texture1,tcoord); }&quot;].join(&quot;\\n&quot;),&quot;&quot;);const e=t.copyShader;t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in copy shader VAO.&quot;)}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi(&quot;texture&quot;,n.getTextureUnit()),t.copyShader.setUniform2f(&quot;tfactor&quot;,t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Eg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;t._scalars!==a&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=a);const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(bd.LINEAR),t.jitterTexture.setMagnificationFilter(bd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,ys.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=i.getIndependentComponents()?s:1,c=i.getScalarOpacity(),u=t._openGLRenderWindow.getGraphicsResourceForObject(c);let d=Vg(i,c,l);if(u.vtkObj&&u.hash===d&&t.opacityTextureString===d)t.opacityTexture=u.vtkObj,t.opacityTextureString=u.hash;else{const r=1024,o=2*r*l,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<l;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.releaseGraphicsResources(t._openGLRenderWindow),t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(bd.LINEAR),t.opacityTexture.setMagnificationFilter(bd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))t.opacityTexture.create2DFromRaw(r,2*l,1,ys.FLOAT,a);else{const e=new Uint8Array(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*l,1,ys.UNSIGNED_CHAR,e)}t.opacityTextureString=d,c&&t._openGLRenderWindow.setGraphicsResourceForObject(c,t.opacityTexture,t.opacityTextureString)}const p=i.getRGBTransferFunction();d=Vg(i,p,l);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===d&&t.colorTextureString===d)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(2*e*l*3),r=new Float32Array(3*e);for(let t=0;t<l;++t){const o=i.getRGBTransferFunction(t),a=o.getRange();o.getTable(a[0],a[1],e,r,1);for(let o=0;o<3*e;++o)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.create2DFromRaw(e,2*l,3,ys.UNSIGNED_CHAR,n),t.colorTextureString=d,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}e.updateLabelOutlineThicknessTexture(r);const g=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(d=`${o.getMTime()}A${a.getMTime()}`,g?.vtkObj&&g?.hash===d&&t.scalarTextureString===d)t.scalarTexture=g.vtkObj,t.scalarTextureString=g.hash;else{const e=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.scalarTexture.releaseGraphicsResources(t._openGLRenderWindow),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],a,t.renderable.getPreferSizeOverAccuracy()),t.scalarTextureString=d,a&&t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,t.scalarTextureString)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Es.newInstance({numberOfComponents:3,values:e});r.setName(&quot;points&quot;);const o=Es.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=e=>{const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}}}const Bg={context:null,VBOBuildTime:null,scalarTexture:null,scalarTextureString:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lastLightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0,_scalars:null};const Ng=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bg,n),Zt.extend(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),t.scalarTexture=Nd.newInstance(),t.opacityTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.jitterTexture=Nd.newInstance(),t.jitterTexture.setWrapS(Td.REPEAT),t.jitterTexture.setWrapT(Td.REPEAT),t.labelOutlineThicknessTexture=Nd.newInstance(),t.framebuffer=Hp.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,[&quot;context&quot;]),Lg(e,t)}),&quot;vtkOpenGLVolumeMapper&quot;);rn(&quot;vtkVolumeMapper&quot;,Ng);const{vtkDebugMacro:_g}=Kt;function Fg(e,t){t.classHierarchy.push(&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent();const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():_g(&quot;No framebuffer to save/restore&quot;);const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const kg={};const Gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kg,n),Zt.extend(e,t,n),Fg(e,t)}),&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;);rn(&quot;vtkPixelSpaceCallbackMapper&quot;,Gg);var Ug=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtktextureObjectVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\nattribute vec2 tcoordDC;\\nvarying vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  tcoordVC = tcoordDC;\\n  gl_Position = vertexDC;\\n}\\n&quot;;const{Representation:zg}=ds;function Wg(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Nd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,&quot;Float32Array&quot;,null),s.activate(),s.sendParameters(),s.deactivate(),s}function Hg(e,t){return Wg(e,t,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE)}function jg(e,t){t.classHierarchy.push(&quot;vtkLICPingPongBufferManager&quot;),t._openGLRenderWindow?(t.quad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,zg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=Hg(t._openGLRenderWindow,t.size),t.seedTexture0=Hg(t._openGLRenderWindow,t.size),t.licTexture1=Hg(t._openGLRenderWindow,t.size),t.seedTexture1=Hg(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?Wg(t._openGLRenderWindow,t.size,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return Wg(e,t,Nd.Filter.LINEAR,Nd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error(&quot;Pass renderwindow to ping pong manager&quot;)}const Kg={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function $g(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kg,n),jt.obj(e,t),jt.get(e,t,[&quot;readIndex&quot;]),jt.setGet(e,t,[&quot;doEEPass&quot;,&quot;doVTPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;vectorTexture&quot;,&quot;maskVectorTexture&quot;,&quot;noiseTexture&quot;,&quot;framebuffer&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),jg(e,t)}var qg={newInstance:jt.newInstance($g,&quot;vtkLICPingPongBufferManager&quot;),extend:$g};const Xg=0,Yg=1,Zg=2,Qg=3,Jg=1;function em(e,t){function n(e,t){e.setUniformi(&quot;texLIC&quot;,t.getLICTextureUnit()),e.setUniformi(&quot;texSeedPts&quot;,t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push(&quot;vtkLineIntegralConvolution2D&quot;),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Hp.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t=&quot;xyzw&quot;;return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n/**\\nThis shader initializes the convolution for the LIC computation.\\n*/\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texMaskVectors;\\nuniform sampler2D texNoise;\\nuniform sampler2D texLIC;\\n\\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the *whole* domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value. this\\n// depends on the pass number.\\nvec2 getNoiseTC(vec2 vectc)\\n{\\n  // in pass 1 : convert from vector tc to noise tc\\n  // in pass 2 : use vector tc\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(vectc);\\n    }\\n  else\\n    {\\n    return vectc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the\\n// need to convert to noise texture coordinates.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 vectc = tcoordVC.st;\\n\\n  // lic => (convolution, mask, 0, step count)\\n  if (uStepNo == 0)\\n    {\\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\\n    float maskFlag;\\n    if (maskCriteria <= uMaskThreshold)\\n      {\\n      maskFlag = 1.0;\\n      }\\n    else\\n      {\\n      maskFlag = 0.0;\\n      }\\n    float noise = getNoise(vectc);\\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = texture2D(texLIC, vectc);\\n    }\\n\\n  // initial seed\\n  SeedOutput = vec4(vectc, 0.0, 1.0);\\n}\\n&quot;);const n=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// move vector field to normalized image space\\n// pre-processing for vtkLineIntegralConvolution2D\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Fragment shader used by the gaussian blur filter render pass.\\n\\nuniform sampler2D texVectors; // input texture\\nuniform vec2      uTexSize;   // size of texture\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  //VTK::LICComponentSelection::Impl\\n  V = V/uTexSize;\\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\\n}\\n&quot;,&quot;//VTK::LICComponentSelection::Impl&quot;,`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D  texVectors;\\nuniform sampler2D  texNoise;\\nuniform sampler2D  texLIC;\\nuniform sampler2D  texSeedPts;\\n\\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\\nuniform float uStepSize;        // step size in parametric space\\n\\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n//VTK::LICVectorLookup::Impl\\n\\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\\n// are very poorly supported in webgl\\nvec2 clampToBorder(vec2 uv){\\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\\n  {\\n    return vec2(0.0, 0.0);\\n  }\\n  return getVector(uv);\\n}\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the whole domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value.\\n// in pass 1 repeatedly tile the noise texture across\\n// the computational domain.\\nvec2 getNoiseTC(vec2 tc)\\n{\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(tc);\\n    }\\n  else\\n    {\\n    return tc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the need\\n// to convert to either noise or lic texture coordinates in\\n// pass 1 and 2 respectively.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\n// fourth-order Runge-Kutta streamline integration\\n// no bounds checks are made, therefore it's essential\\n// to have the entire texture initialized to 0\\n// and set clamp to border and have border color 0\\n// an integer is set if the step was taken, keeping\\n// an accurate step count is necessary to prevent\\n// boundary artifacts. Don't count the step if\\n// all vector lookups are identically 0. This is\\n// a proxy for \\&quot;stepped outside valid domain\\&quot;\\nvec2 rk4(vec2 pt0, float dt, out bool count)\\n{\\n  count=true;\\n  float dtHalf = dt * 0.5;\\n  vec2 pt1;\\n\\n  vec2 v0 = clampToBorder(pt0);\\n  pt1 = pt0 + v0 * dtHalf;\\n\\n  vec2 v1 = clampToBorder(pt1);\\n  pt1 = pt0 + v1 * dtHalf;\\n\\n  vec2 v2 = clampToBorder(pt1);\\n  pt1 = pt0 + v2 * dt;\\n\\n  vec2 v3 = clampToBorder(pt1);\\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\\n\\n  if (vSum == vec2(0.0, 0.0))\\n    {\\n      count = false;\\n    }\\n\\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\\n\\n return pt1;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic = texture2D(texLIC, lictc);\\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\\n\\n  bool count;\\n  vec2 pt1 = rk4(pt0, uStepSize, count);\\n\\n  if (count)\\n    {\\n    // accumulate lic step\\n    // (lic, mask, 0, step count)\\n    float noise = getNoise(pt1);\\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\\n    SeedOutput = vec4(pt1, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    // keep existing values\\n    LICOutput = lic;\\n    SeedOutput = vec4(pt0, 0.0, 1.0);\\n    }\\n}\\n&quot;,&quot;//VTK::LICVectorLookup::Impl&quot;,function(){const e=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      vec2 V = texture2D( texVectors, vectc ).xy;\\n\\n      // normalize if |V| not 0\\n\\n      float lenV = length( V );\\n\\n      if ( lenV > 1.0e-8 )\\n\\n        {\\n\\n        return V/lenV;\\n\\n        }\\n\\n      else\\n\\n        {\\n\\n        return vec2( 0.0, 0.0 );\\n\\n        }\\n\\n      }\\n\\n    &quot;,t=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      return texture2D( texVectors, vectc ).xy;\\n\\n      }\\n\\n    &quot;;return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(&quot; //VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n/**\\nThis shader finalizes the convolution for the LIC computation\\napplying the normalization. eg. if box kernel is used the this\\nis the number of steps taken.\\n*/\\n\\nuniform sampler2D texLIC;\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\\n  conv.r = conv.r/conv.a;\\n  // lic => (convolution, mask, 0, 1)\\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.CEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// gray scale contrast enhance stage implemented via histogram stretching\\n// if the min and max are tweaked it can generate out-of-range values\\n// these will be clamped in 0 to 1\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n\\nuniform sampler2D texLIC;  // most recent lic pass\\nuniform float uMin;        // min gray scale color value\\nuniform float uMaxMinDiff; // max-min\\n\\nin vec2 tcoordVC;\\n\\nvoid main( void )\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g!=0.0)\\n    {\\n    LICOutput = lic;\\n    }\\n  else\\n    {\\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\\n    LICOutput = vec4(CElic, lic.gb, 1.0);\\n    }\\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.EEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\\n// noise for pass2.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 EEOutput;\\n\\nuniform sampler2D texLIC; // most recent lic pass\\nuniform float     uDx;    // fragment size\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// kernel for simple laplace edge enhancement.\\n// p=Laplace(p)+p\\nfloat K[9] = float[9](\\n  -1.0, -1.0, -1.0,\\n  -1.0,  9.0, -1.0,\\n  -1.0, -1.0, -1.0\\n  );\\n\\n// determine if the fragment was masked\\nbool Masked(float val) { return val != 0.0; }\\n\\nvoid main(void)\\n{\\n  // tex coord neighbor offsets\\n  vec2 fragDx[9] = vec2[9](\\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\\n    );\\n\\n  vec2 lictc = tcoordVC.st;\\n\\n  // compute the convolution but don't use convovled values if\\n  // any masked fragments on the stencil. Fragments outside\\n  // the valid domain are masked during initialization, and\\n  // texture wrap parameters are clamp to border with border\\n  // color that contains masked flag\\n  float conv = 0.0;\\n  bool dontUse = false;\\n  for (int i=0; i<9; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    vec4 lic = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic.g);\\n    conv = conv + K[i] * lic.r;\\n    }\\n\\n  if (dontUse)\\n    {\\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    conv = clamp(conv, 0.0, 1.0);\\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\\n    }\\n\\n}\\n&quot;),t.AAHProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// horizontal pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDx;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.AAVProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// vertical pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\\n\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDy[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;)},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;f&&o[0]===f.getSize()[0]&&o[1]===f.getSize()[1]||(f=Hp.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=qg.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const g=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],m=1/o[0],h=1/o[1],v=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;v.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f(&quot;uTexSize&quot;,...o),e.setUniformi(&quot;texVectors&quot;,t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,0),y.setUniformf(&quot;uMaskThreshold&quot;,t.maskThreshold),y.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),y.setUniformi(&quot;texMaskVectors&quot;,t.bufs.getMaskVectorTextureUnit()),y.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:T}=t;v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,0),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),T.setUniformi(&quot;texVectors&quot;,t.bufs.getImageVectorTextureUnit()),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:b}=t;if(v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),r(t.bufs,o,b),t.enhancedLIC){t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDx&quot;,m),a.setUniformf(&quot;uDy&quot;,h),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,1),n(y,t.bufs),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,1),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),b.setUniformi(&quot;texSeedPts&quot;,t.bufs.getSeedTextureUnit()),r(t.bufs,o,b)}if(t.antiAlias){const e=t.AAHProgram;v.readyShaderProgram(e),e.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),e.setUniformf(&quot;uDx&quot;,m);const a=t.AAVProgram;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDy&quot;,h);for(let i=0;i<t.antiAlias;++i)v.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),v.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error(&quot;Invalid color range: &quot;,i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),c.setUniformf(&quot;uMin&quot;,i),c.setUniformf(&quot;uMaxMinDiff&quot;,l),r(t.bufs,o,c)}}const tm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function nm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tm,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;nuberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;componentIds&quot;,&quot;isComposite&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),em(e,t)}var rm={newInstance:jt.newInstance(nm,&quot;vtkLineIntegralConvolution2D&quot;),extend:nm};function om(e,t){t.classHierarchy.push(&quot;vtkSurfaceLICInterface&quot;)}const am={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Xg,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:Jg,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function im(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,am,n),jt.obj(e,t),jt.setGet(e,t,[&quot;enableLIC&quot;,&quot;numberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;transformVectors&quot;,&quot;maskOnSurface&quot;,&quot;maskThreshold&quot;,&quot;maskColor&quot;,&quot;maskIntensity&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;noiseTextureSize&quot;,&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;noiseGeneratorSeed&quot;,&quot;viewPortScale&quot;,&quot;rebuildNoiseTexture&quot;]),om(0,t)}var sm={newInstance:jt.newInstance(im,&quot;vtkSurfaceLICInterface&quot;),extend:im};const{Representation:lm}=ds;function cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICInterface&quot;),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get(&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;);n=r===Jg?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Nd.newInstance({wrapS:Nd.Wrap.REPEAT,wrapT:Nd.Wrap.REPEAT,minificationFilter:Nd.Filter.NEAREST,magnificationFilter:Nd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,&quot;Float32Array&quot;,d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.allocateTextures=()=>{const n=Nd.Filter.NEAREST,r=Nd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Nd.newInstance({wrapS:Nd.Wrap.CLAMP_TO_EDGE,wrapT:Nd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,&quot;Float32Array&quot;,null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Nd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,&quot;Float32Array&quot;,null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=Hp.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader combines surface geometry, LIC, and  scalar colors.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 RGBOutput;\\nlayout(location = 1) out vec4 HSLOutput;\\n\\nuniform sampler2D texVectors;       // vectors, depth\\nuniform sampler2D texGeomColors;    // scalar colors + lighting\\nuniform sampler2D texLIC;           // image lic\\nuniform int       uScalarColorMode; // select between blend, and map shader\\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\\nuniform float     uMaskIntensity;   // blending factor for mask color\\nuniform vec3      uMaskColor;       // color for the masked out fragments\\n\\nin vec2 tcoordVC;\\n\\n/**\\nConvert from RGB color space into HSL colorspace.\\n*/\\nvec3 RGBToHSL(vec3 RGB)\\n{\\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\\n\\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\\n  float RGBMaxMinDiff = RGBMax - RGBMin;\\n\\n  HSL.z = (RGBMax + RGBMin) / 2.0;\\n\\n  if (RGBMaxMinDiff == 0.0)\\n    {\\n    // Gray scale\\n    HSL.x = 0.0;\\n    HSL.y = 0.0;\\n    }\\n  else\\n    {\\n    // Color\\n    if (HSL.z < 0.5)\\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\\n    else\\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\\n\\n    float dR\\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dG\\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dB\\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n\\n    if (RGB.r == RGBMax)\\n      HSL.x = dB - dG;\\n    else\\n    if (RGB.g == RGBMax)\\n      HSL.x = (1.0 / 3.0) + dR - dB;\\n    else\\n    if (RGB.b == RGBMax)\\n      HSL.x = (2.0 / 3.0) + dG - dR;\\n\\n    if (HSL.x < 0.0)\\n      HSL.x += 1.0;\\n\\n    if (HSL.x > 1.0)\\n      HSL.x -= 1.0;\\n    }\\n\\n  return HSL;\\n}\\n\\n/**\\nHelper for HSL to RGB conversion.\\n*/\\nfloat Util(float v1, float v2, float vH)\\n{\\n  if (vH < 0.0)\\n    vH += 1.0;\\n\\n  if (vH > 1.0)\\n     vH -= 1.0;\\n\\n  if ((6.0 * vH) < 1.0)\\n    return (v1 + (v2 - v1) * 6.0 * vH);\\n\\n  if ((2.0 * vH) < 1.0)\\n    return (v2);\\n\\n  if ((3.0 * vH) < 2.0)\\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\\n\\n  return v1;\\n}\\n\\n/**\\nConvert from HSL space into RGB space.\\n*/\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  if (HSL.y == 0.0)\\n    {\\n    // Gray\\n    RGB.r = HSL.z;\\n    RGB.g = HSL.z;\\n    RGB.b = HSL.z;\\n    }\\n  else\\n    {\\n    // Chromatic\\n    float v2;\\n    if (HSL.z < 0.5)\\n      v2 = HSL.z * (1.0 + HSL.y);\\n    else\\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\\n\\n    float v1 = 2.0 * HSL.z - v2;\\n\\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\\n    RGB.g = Util(v1, v2, HSL.x);\\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\\n    }\\n\\n  return RGB.rgb;\\n}\\n\\nvoid main()\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n\\n  // depth is used to determine which fragment belong to us\\n  // and we can change\\n  float depth = texture2D(texVectors, tcoordVC.st).a;\\n\\n  vec3 fragColorRGB;\\n  float valid;\\n  if (depth > 1.0e-3)\\n    {\\n    // we own it\\n    // shade LIC'ed geometry, or apply mask\\n    if (lic.g!=0.0)\\n      {\\n      // it's masked\\n      // apply fragment mask\\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\\n      valid = 0.0;\\n      }\\n    else\\n      {\\n      if (uScalarColorMode==0)\\n        {\\n        // blend with scalars\\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\\n        }\\n      else\\n        {\\n        // multiply with scalars\\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\\n        }\\n      if (lic.b != 0.0)\\n        {\\n        // didn't have the required guard pixels\\n        // don't consider it in min max estimation\\n        // for histpgram stretching\\n        valid = 0.0;\\n        }\\n      else\\n        {\\n        // ok to use in min/max estimates for histogram\\n        // stretching\\n        valid = 1.0;\\n        }\\n      }\\n    }\\n  else\\n    {\\n    // we don't own it\\n    // pass through scalars\\n    fragColorRGB = geomColor.rgb;\\n    valid = 0.0;\\n    }\\n\\n  // if no further stages this texture is\\n  // copied to the screen\\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\\n\\n  // if further stages, move to hsl space for contrast\\n  // enhancement. encoding validity saves moving a texture to the cpu\\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\\n  HSLOutput = vec4(fragColorHSL, valid);\\n}\\n&quot;),t.licCopyPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader copies fragments and depths to the output buffer\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texDepth;     // z values from vertex shader\\nuniform sampler2D texRGBColors; // final rgb LIC colors\\n\\nin vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\\n\\n  // since we render a screen aligned quad\\n  // we're going to be writing fragments\\n  // not touched by the original geometry\\n  // it's critical not to modify those\\n  // fragments.\\n  if (gl_FragDepth == 1.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;),t.enhanceContrastPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// color contrast enhance stage implemented via histogram stretching\\n// on lightness channel. if the min and max are tweaked it can generate\\n// out-of-range values these will be clamped in 0 to 1\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texGeomColors; // scalars + lighting\\nuniform sampler2D texLIC;        // image lic, mask\\nuniform sampler2D texHSLColors;  // hsla colors\\n\\nuniform float     uLMin;         // min lightness over all fragments\\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\\n\\nin vec2 tcoordVC;\\n\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  float v;\\n  float h = HSL.x;\\n  float sl = HSL.y;\\n  float l = HSL.z;\\n\\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\\n  if (v <= 0.0) {\\n    RGB = vec3(0.0,0.0,0.0);\\n  } else {\\n    float m;\\n    int sextant;\\n    float fract, vsf, mid1, mid2;\\n\\n    m = l + l - v;\\n    h *= 6.0;\\n    sextant = int(h);\\n    fract = h - float(sextant);\\n\\n    vsf = (v - m) * fract;\\n    mid1 = m + vsf;\\n    mid2 = v - vsf;\\n    switch (sextant) {\\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\\n    }\\n  }\\n  return RGB;\\n}\\n\\nvoid main()\\n{\\n  // lookup hsl color , mask\\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\\n\\n  // don't modify masked fragments (masked => lic.g==1)\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g==0.0)\\n    {\\n    // normalize lightness channel\\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\\n    }\\n\\n  // back into rgb space\\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\\n\\n  // add alpha\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n  fragColor.a = geomColor.a;\\n\\n  gl_FragData[0] = fragColor;\\n}\\n&quot;),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,lm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=rm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi(&quot;texDepth&quot;,t.depthTexture.getTextureUnit()),r.setUniformi(&quot;texRGBColors&quot;,t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi(&quot;texVectors&quot;,t.vectorImage.getTextureUnit()),o.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get(&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;maskIntensity&quot;,&quot;maskColor&quot;,&quot;enhanceContrast&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;);if(o.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),o.setUniformi(&quot;uScalarColorMode&quot;,a),o.setUniformf(&quot;uLICIntensity&quot;,i),o.setUniformf(&quot;uMapBias&quot;,s),o.setUniformf(&quot;uMaskIntensity&quot;,l),o.setUniform3f(&quot;uMaskColor&quot;,...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===Zg||u===Qg){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit()),s.setUniformi(&quot;texHSLColors&quot;,t.HSLColorImage.getTextureUnit()),s.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),s.setUniformf(&quot;uLMin&quot;,o),s.setUniformf(&quot;uLMaxMinDiff&quot;,i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get(&quot;stepSize&quot;,&quot;numberOfSteps&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;transformVectors&quot;),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error(&quot;Failed to compute image LIC&quot;),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const um={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function dm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,um,n),sm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;reallocateTextures&quot;,&quot;licInterface&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cm(e,t)}var pm={newInstance:jt.newInstance(dm,&quot;vtkSurfaceLICInterface&quot;),extend:dm};const{vtkErrorMacro:fm}=Kt;function gm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICMapper&quot;);const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=cd.substitute(s,&quot;//VTK::Output::Dec&quot;,[&quot;//VTK::Output::Dec&quot;,&quot;layout(location = 2) out vec4 vectorTexture;&quot;,&quot;layout(location = 3) out vec4 maskVectorTexture;&quot;]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,[`attribute vec3 ${n};`,&quot;out vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[`licOutput = ${n};`,&quot;//VTK::TCoord::Impl&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform int uMaskOnSurface;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;in vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Impl&quot;,[&quot;// projected vectors&quot;,&quot;  vec3 tcoordLIC = normalMatrix * licOutput;&quot;,&quot;  vec3 normN = normalize(normalVCVSOutput);&quot;,&quot;  float k = dot(tcoordLIC, normN);&quot;,&quot;  vec3 projected = (tcoordLIC - k*normN);&quot;,&quot;  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;// vectors for fragment masking&quot;,&quot;  if (uMaskOnSurface == 0)&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(licOutput, 1.0);&quot;,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;    }&quot;,&quot;//VTK::TCoord::Impl&quot;],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi(&quot;uMaskOnSurface&quot;,t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(fm(&quot;SurfaceLICMapper Requires WebGL 2&quot;),a=!1),t.context.getExtension(&quot;EXT_color_buffer_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)||(fm(&quot;SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions.&quot;),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(fm(&quot;No input&quot;),a=!1);let i=t.renderable.getLicInterface();i||(i=sm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=pm.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(fm(&quot;No vector input array&quot;),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const mm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const hm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mm,n),np.extend(e,t,n),gm(e,t),At(e,t,[&quot;openGLLicInterface&quot;])}),&quot;vtkOpenGLSurfaceLICMapper&quot;);rn(&quot;vtkSurfaceLICMapper&quot;,hm);const{vtkErrorMacro:vm}=Kt;function ym(e,t){t.classHierarchy.push(&quot;vtkOpenGLSphereMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkSphereMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Spheres\\n\\nattribute vec4 vertexMC;\\nattribute vec2 offsetMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\n\\nuniform int cameraParallel;\\nuniform float scaleFactor;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  // compute the projected vertex position\\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\\n\\n  // make the triangle face the camera\\n  if (cameraParallel == 0)\\n    {\\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\\n    vec3 base1 = cross(base2,dir);\\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\\n    }\\n  else\\n    {\\n    // add in the offset\\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\\n    }\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;\\n&quot;]).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform float invertedDepth;\\n&quot;,&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float b = 2.0*dot(EyePos,EyeDir);\\n&quot;,&quot;  float c = dot(EyePos,EyePos) - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t = (-b - invertedDepth*sqrt(d))*0.5;\\n&quot;,&quot;    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\\n&quot;,&quot;    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;offsetMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||vm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isUniformUsed(&quot;invertedDepth&quot;)&&e.getProgram().setUniformf(&quot;invertedDepth&quot;,t.invert?-1:1),e.getProgram().isUniformUsed(&quot;scaleFactor&quot;)){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf(&quot;scaleFactor&quot;,t.renderable.getScaleFactor()):e.getProgram().setUniformf(&quot;scaleFactor&quot;,1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),o.isUniformUsed(&quot;MCVCMatrix&quot;))if(r.getIsIdentity())o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,n)}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Tm={};const bm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tm,n),np.extend(e,t,n),ym(e,t)}),&quot;vtkOpenGLSphereMapper&quot;);rn(&quot;vtkSphereMapper&quot;,bm);const{vtkErrorMacro:xm}=Kt;function Cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLStickMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkStickMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Sticks\\n\\nattribute vec4 vertexMC;\\nattribute vec3 orientMC;\\nattribute vec4 offsetMC;\\nattribute float radiusMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying float lengthVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\nvarying vec3 orientVCVSOutput;\\n\\nuniform int cameraParallel;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = radiusMC;\\n  lengthVCVSOutput = length(orientMC);\\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\\n\\n  // make sure it is pointing out of the screen\\n  if (orientVCVSOutput.z < 0.0)\\n    {\\n    orientVCVSOutput = -orientVCVSOutput;\\n    }\\n\\n  // make the basis\\n  vec3 xbase;\\n  vec3 ybase;\\n  vec3 dir = vec3(0.0,0.0,1.0);\\n  if (cameraParallel == 0)\\n    {\\n    dir = normalize(-vertexVCVSOutput.xyz);\\n    }\\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\\n    {\\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\\n    ybase = cross(xbase,orientVCVSOutput);\\n    }\\n  else\\n    {\\n    xbase = normalize(cross(orientVCVSOutput,dir));\\n    ybase = cross(orientVCVSOutput,xbase);\\n    }\\n\\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\\n    radiusVCVSOutput*offsets.x*xbase +\\n    radiusVCVSOutput*offsets.y*ybase +\\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,&quot;varying vec4 vertexVCVSOutput;&quot;).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,&quot;  vec4 vertexVC = vertexVCVSOutput;\\n&quot;).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 orientVCVSOutput;\\n&quot;,&quot;varying float lengthVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  vec3 base1;\\n&quot;,&quot;  if (abs(orientVCVSOutput.z) < 0.99) {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\\n&quot;,&quot;  vec3 base2 = cross(orientVCVSOutput,base1);\\n&quot;,&quot;  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\\n&quot;,&quot;  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n&quot;,&quot;  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n&quot;,&quot;  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*a*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t =  (-b - sqrt(d))/(2.0*a);\\n&quot;,&quot;    float tz = EyePos.z + t*EyeDir.z;\\n&quot;,&quot;    vec3 iPoint = EyePos + t*EyeDir;\\n&quot;,&quot;    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\\n&quot;,&quot;      float t2 = (-b + sqrt(d))/(2.0*a);\\n&quot;,&quot;      float tz2 = EyePos.z + t2*EyeDir.z;\\n&quot;,&quot;      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\\n&quot;,&quot;      else {\\n&quot;,&quot;        normalVCVSOutput = orientVCVSOutput;\\n&quot;,&quot;        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\\n&quot;,&quot;        iPoint = EyePos + t3*EyeDir;\\n&quot;,&quot;        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;        }\\n&quot;,&quot;      }\\n&quot;,&quot;    else {\\n&quot;,&quot;      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\\n&quot;,&quot;      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;      }\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed(&quot;orientMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;orientMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||xm(&quot;Error setting 'orientMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),&quot;offsetMC&quot;,0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||xm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;radiusMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;radiusMC&quot;,24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||xm(&quot;Error setting 'radiusMC' in shader VAO.&quot;))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),r.getIsIdentity())o.isUniformUsed(&quot;MCVCMatrix&quot;)&&o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc),o.isUniformUsed(&quot;normalMatrix&quot;)&&o.setUniformMatrix3x3(&quot;normalMatrix&quot;,i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed(&quot;MCVCMatrix&quot;)){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,t)}if(o.isUniformUsed(&quot;normalMatrix&quot;)){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3(&quot;normalMatrix&quot;,t)}}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():xm([&quot;Error setting orientationArray.\\n&quot;,&quot;You have to specify the stick orientation&quot;]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,zu.ARRAY_BUFFER),a.getColorBO().upload(g,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Sm={};const Am=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sm,n),np.extend(e,t,n),Cm(e,t)}),&quot;vtkOpenGLStickMapper&quot;);rn(&quot;vtkStickMapper&quot;,Am);const Im=[];Im[&quot;-&quot;.charCodeAt(0)]=62,Im[&quot;_&quot;.charCodeAt(0)]=63;const wm=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;for(let e=0;e<wm.length;e++)Im[wm.charCodeAt(e)]=e;function Pm(e){return void 0!==Im[e.charCodeAt(0)]}function Om(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<18;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<12;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<6;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<10;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<4;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<2;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error(&quot;BASE64: remain 1 should not happen&quot;)}return u}function Rm(e,t,n){const r=(e<<16)+(t<<8)+n;return wm[r>>18]+wm[r>>12&63]+wm[r>>6&63]+wm[63&r]}function Mm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Rm(t[n],t[n+1],t[n+2])}if(n>0){const e=Rm(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join(&quot;&quot;)}var Dm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)Pm(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):&quot;=&quot;===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Om(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Em={};function Vm(e,t){Em[e]=t}var Lm=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;http&quot;,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Em[e](t)},Bm=Uint8Array,Nm=Uint16Array,_m=Uint32Array,Fm=new Bm([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),km=new Bm([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Gm=new Bm([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Um=function(e,t){for(var n=new Nm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new _m(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},zm=Um(Fm,2),Wm=zm[0],Hm=zm[1];Wm[28]=258,Hm[258]=28;for(var jm=Um(km,0),Km=jm[0],$m=(jm[1],new Nm(32768)),qm=0;qm<32768;++qm){var Xm=(43690&qm)>>>1|(21845&qm)<<1;Xm=(61680&(Xm=(52428&Xm)>>>2|(13107&Xm)<<2))>>>4|(3855&Xm)<<4,$m[qm]=((65280&Xm)>>>8|(255&Xm)<<8)>>>1}var Ym=function(e,t,n){for(var r=e.length,o=0,a=new Nm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Nm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Nm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[$m[d]>>>l]=c}else for(i=new Nm(r),o=0;o<r;++o)e[o]&&(i[o]=$m[s[e[o]-1]++]>>>15-e[o]);return i},Zm=new Bm(288);for(qm=0;qm<144;++qm)Zm[qm]=8;for(qm=144;qm<256;++qm)Zm[qm]=9;for(qm=256;qm<280;++qm)Zm[qm]=7;for(qm=280;qm<288;++qm)Zm[qm]=8;var Qm=new Bm(32);for(qm=0;qm<32;++qm)Qm[qm]=5;var Jm=Ym(Zm,9,1),eh=Ym(Qm,5,1),th=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},nh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},rh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},oh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Nm:4==e.BYTES_PER_ELEMENT?_m:Bm)(n-t);return r.set(e.subarray(t,n)),r},ah=[&quot;unexpected EOF&quot;,&quot;invalid block type&quot;,&quot;invalid length/literal&quot;,&quot;invalid distance&quot;,&quot;stream finished&quot;,&quot;no stream handler&quot;,,&quot;no callback&quot;,&quot;invalid UTF-8 data&quot;,&quot;extra field too long&quot;,&quot;date not in range 1980-2099&quot;,&quot;filename too long&quot;,&quot;stream finishing&quot;,&quot;invalid zip data&quot;],ih=function(e,t,n){var r=new Error(t||ah[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,ih),!n)throw r;return r},sh=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new Bm(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new Bm(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new Bm(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=nh(e,c,1);var h=nh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&ih(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=Jm,p=eh,f=9,g=5;else if(2==h){var T=nh(e,c,31)+257,b=nh(e,c+10,15)+4,x=T+nh(e,c+5,31)+1;c+=14;for(var C=new Bm(x),S=new Bm(19),A=0;A<b;++A)S[Gm[A]]=nh(e,c+3*A,7);c+=3*b;var I=th(S),w=(1<<I)-1,P=Ym(S,I,1);for(A=0;A<x;){var O,R=P[nh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,D=0;for(16==O?(D=3+nh(e,c,3),c+=2,M=C[A-1]):17==O?(D=3+nh(e,c,7),c+=3):18==O&&(D=11+nh(e,c,127),c+=7);D--;)C[A++]=M}}var E=C.subarray(0,T),V=C.subarray(T);f=th(E),g=th(V),d=Ym(E,f,1),p=Ym(V,g,1)}else ih(1);if(c>m){a&&ih(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[rh(e,c)&L])>>>4;if((c+=15&M)>m){a&&ih(0);break}if(M||ih(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Fm[A=_-257];F=nh(e,c,(1<<k)-1)+Wm[A],c+=k}var G=p[rh(e,c)&B],U=G>>>4;if(G||ih(3),c+=15&G,V=Km[U],U>3&&(k=km[U],V+=rh(e,c)&(1<<k)-1,c+=k),c>m){a&&ih(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:oh(t,0,u)},lh=new Bm(0),ch=function(e,t){return e[t]|e[t+1]<<8},uh=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},dh=function(e,t){return uh(e,t)+4294967296*uh(e,t+4)};function ph(e,t){return sh(e,t)}function fh(e,t){return sh(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||ih(6,&quot;invalid gzip data&quot;);var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new Bm((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function gh(e,t){return sh(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&ih(6,&quot;invalid zlib data&quot;),32&n[1]&&ih(6,&quot;invalid zlib data: preset dictionaries not supported&quot;),e.subarray(2,-4)),t);var n}function mh(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?fh(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?ph(e,t):gh(e,t)}var hh=&quot;undefined&quot;!=typeof TextEncoder&&new TextEncoder,vh=&quot;undefined&quot;!=typeof TextDecoder&&new TextDecoder;try{vh.decode(lh,{stream:!0})}catch(e){}function yh(e,t){if(t){for(var n=&quot;&quot;,r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(vh)return vh.decode(e);var o=function(e){for(var t=&quot;&quot;,n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,oh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&ih(8),a}var Th=function(e,t){return t+30+ch(e,t+26)+ch(e,t+28)},bh=function(e,t,n){var r=ch(e,t+28),o=yh(e.subarray(t+46,t+46+r),!(2048&ch(e,t+8))),a=t+46+r,i=uh(e,t+20),s=n&&4294967295==i?xh(e,a):[i,uh(e,t+24),uh(e,t+42)],l=s[0],c=s[1],u=s[2];return[ch(e,t+10),l,c,o,a+ch(e,t+30)+ch(e,t+32),u]},xh=function(e,t){for(;1!=ch(e,t);t+=4+ch(e,t+2));return[dh(e,t+12),dh(e,t+4),dh(e,t+20)]};function Ch(e,t){for(var n={},r=e.length-22;101010256!=uh(e,r);--r)(!r||e.length-r>65558)&&ih(13);var o=ch(e,r+8);if(!o)return{};var a=uh(e,r+16),i=4294967295==a;i&&(r=uh(e,r-12),101075792!=uh(e,r)&&ih(13),o=uh(e,r+32),a=uh(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=bh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Th(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=ph(e.subarray(h,h+d),new Bm(p)):ih(14,&quot;unknown compression type &quot;+u):n[f]=oh(e,h,h+d))}return n}function Sh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?&quot;LittleEndian&quot;:2712847316===n[0]?&quot;BigEndian&quot;:null}&quot;function&quot;==typeof queueMicrotask?queueMicrotask:&quot;function&quot;==typeof setTimeout&&setTimeout;var Ah=Sh(),Ih=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:wh,vtkDebugMacro:Ph}=jt;let Oh=0;function Rh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener(&quot;progress&quot;,n.progressCallback),r}const Mh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;);const s=Rh(&quot;GET&quot;,i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(Ph(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&wh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||&quot;string&quot;!==n.dataType?&quot;arraybuffer&quot;:&quot;text&quot;,s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(yh(mh(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&&quot;gz&quot;!==n.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(yh(mh(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&&quot;gz&quot;!==t.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Rh(&quot;GET&quot;,e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(mh(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType=&quot;arraybuffer&quot;,o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};Vm(&quot;http&quot;,(e=>Mh));const{vtkDebugMacro:Dh}=jt;function Eh(e,t){t.classHierarchy.push(&quot;vtkCamera&quot;);const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;);const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Gi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Gi(o,[...t.position,1],n),Gi(a,[...t.focalPoint,1],n),Gi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=Hi(e[0],e[1],e[2],e[3]),n=Ui(),r=Hi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],Wi(r,t,r),Wi(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error(&quot;Off-Axis projection is not supported at this time&quot;);{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=Ui();zi(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const Vh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Lh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vh,n),jt.obj(e,t),jt.get(e,t,[&quot;distance&quot;]),jt.setGet(e,t,[&quot;parallelProjection&quot;,&quot;useHorizontalViewAngle&quot;,&quot;viewAngle&quot;,&quot;parallelScale&quot;,&quot;useOffAxisProjection&quot;,&quot;freezeFocalPoint&quot;,&quot;physicalScale&quot;]),jt.getArray(e,t,[&quot;directionOfProjection&quot;,&quot;viewPlaneNormal&quot;,&quot;position&quot;,&quot;focalPoint&quot;]),jt.setGetArray(e,t,[&quot;clippingRange&quot;,&quot;windowCenter&quot;],2),jt.setGetArray(e,t,[&quot;viewUp&quot;,&quot;screenBottomLeft&quot;,&quot;screenBottomRight&quot;,&quot;screenTopRight&quot;,&quot;physicalTranslation&quot;,&quot;physicalViewUp&quot;,&quot;physicalViewNorth&quot;],3),Eh(e,t)}var Bh={newInstance:jt.newInstance(Lh,&quot;vtkCamera&quot;),extend:Lh};function Nh(e,t){t.classHierarchy.push(&quot;vtkLight&quot;);const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType(&quot;HeadLight&quot;)},e.setLightTypeToCameraLight=()=>{e.setLightType(&quot;CameraLight&quot;)},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType(&quot;SceneLight&quot;)},e.lightTypeIsHeadLight=()=>&quot;HeadLight&quot;===t.lightType,e.lightTypeIsSceneLight=()=>&quot;SceneLight&quot;===t.lightType,e.lightTypeIsCameraLight=()=>&quot;CameraLight&quot;===t.lightType}const _h={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:&quot;SceneLight&quot;,shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_h,n),jt.obj(e,t),jt.setGet(e,t,[&quot;intensity&quot;,&quot;switch&quot;,&quot;positional&quot;,&quot;exponent&quot;,&quot;coneAngle&quot;,&quot;coneFalloff&quot;,&quot;transformMatrix&quot;,&quot;lightType&quot;,&quot;shadowAttenuation&quot;,&quot;attenuationValues&quot;]),jt.setGetArray(e,t,[&quot;color&quot;,&quot;position&quot;,&quot;focalPoint&quot;,&quot;attenuationValues&quot;],3),Nh(e,t)}var kh={newInstance:jt.newInstance(Fh,&quot;vtkLight&quot;),extend:Fh,LIGHT_TYPES:[&quot;HeadLight&quot;,&quot;CameraLight&quot;,&quot;SceneLight&quot;]};const{vtkErrorMacro:Gh}=jt;function Uh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push(&quot;vtkViewport&quot;),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Gh(&quot;call displayToView on your view instead&quot;),e.viewToDisplay=()=>Gh(&quot;callviewtodisplay on your view instead&quot;),e.getSize=()=>Gh(&quot;call getSize on your View instead&quot;),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=(&quot;PickPropFrom&quot;,()=>Gh(&quot;vtkViewport::PickPropFrom - NOT IMPLEMENTED&quot;))}const zh={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function Wh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zh,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),jt.setGetArray(e,t,[&quot;viewport&quot;],4),jt.setGetArray(e,t,[&quot;background&quot;,&quot;background2&quot;],3),Uh(e,t)}var Hh={newInstance:jt.newInstance(Wh,&quot;vtkViewport&quot;),extend:Wh};const{vtkDebugMacro:jh,vtkErrorMacro:Kh,vtkWarningMacro:$h}=Kt;function qh(e){return()=>Kh(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function Xh(e,t){t.classHierarchy.push(&quot;vtkRenderer&quot;);const n={type:&quot;ComputeVisiblePropBoundsEvent&quot;,renderer:e},r={type:&quot;ResetCameraClippingRangeEvent&quot;,renderer:e},o={type:&quot;ResetCameraEvent&quot;,renderer:e};e.updateCamera=()=>(t.activeCamera||(jh(&quot;No cameras are on, creating one.&quot;),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Kh(&quot;light has unknown light type&quot;,e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=qh(&quot;allocateTime&quot;),e.updateGeometry=qh(&quot;updateGeometry&quot;),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{jh(e.getClassName(),e,&quot;setting Layer to &quot;,n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:&quot;ActiveCameraEvent&quot;,camera:n}),!0),e.makeCamera=()=>{const t=Bh.newInstance();return e.invokeEvent({type:&quot;CreateCameraEvent&quot;,camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=kh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;WorldToView: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=ki.INIT_BOUNDS[0],t.allBounds[1]=ki.INIT_BOUNDS[1],t.allBounds[2]=ki.INIT_BOUNDS[2],t.allBounds[3]=ki.INIT_BOUNDS[3],t.allBounds[4]=ki.INIT_BOUNDS[4],t.allBounds[5]=ki.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),jh(&quot;Can't compute bounds, no 3D props are visible&quot;)),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return jh(&quot;Cannot reset camera!&quot;),!1;let i=null;if(!e.getActiveCamera())return Kh(&quot;Trying to reset non-existent camera&quot;),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&($h(&quot;Resetting view-up since view plane normal is parallel&quot;),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return jh(&quot;Cannot reset camera clipping range!&quot;),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Kh(&quot;Trying to reset clipping range of non-existent camera&quot;),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const Yh={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Zh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Yh,n),Hh.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,[&quot;_renderWindow&quot;,&quot;allocatedRenderTime&quot;,&quot;timeFactor&quot;,&quot;lastRenderTimeInSeconds&quot;,&quot;numberOfPropsRendered&quot;,&quot;lastRenderingUsedDepthPeeling&quot;,&quot;selector&quot;]),At(e,t,[&quot;twoSidedLighting&quot;,&quot;lightFollowCamera&quot;,&quot;automaticLightCreation&quot;,&quot;erase&quot;,&quot;draw&quot;,&quot;nearClippingPlaneTolerance&quot;,&quot;clippingRangeExpansion&quot;,&quot;backingStore&quot;,&quot;interactive&quot;,&quot;layer&quot;,&quot;preserveColorBuffer&quot;,&quot;preserveDepthBuffer&quot;,&quot;useDepthPeeling&quot;,&quot;occlusionRatio&quot;,&quot;maximumNumberOfPeels&quot;,&quot;delegate&quot;,&quot;backgroundTexture&quot;,&quot;texturedBackground&quot;,&quot;environmentTexture&quot;,&quot;environmentTextureDiffuseStrength&quot;,&quot;environmentTextureSpecularStrength&quot;,&quot;useEnvironmentTextureAsBackground&quot;,&quot;useShadows&quot;,&quot;pass&quot;]),It(e,t,[&quot;actors&quot;,&quot;volumes&quot;,&quot;lights&quot;]),Pt(e,t,[&quot;background&quot;],4,1),Ot(0,t,[&quot;renderWindow&quot;]),Xh(e,t)}var Qh={newInstance:Et(Zh,&quot;vtkRenderer&quot;),extend:Zh};const Jh=Object.create(null);function ev(e,t){Jh[e]=t}function tv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Jh[e]&&Jh[e](t)}function nv(e,t){t.classHierarchy.push(&quot;vtkRenderWindow&quot;),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return tv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6;const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join(&quot;\\n&quot;),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))}}const rv={defaultViewAPI:&quot;WebGL&quot;,renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1};function ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rv,n),jt.obj(e,t),jt.setGet(e,t,[&quot;interactor&quot;,&quot;numberOfLayers&quot;,&quot;_views&quot;,&quot;defaultViewAPI&quot;]),jt.get(e,t,[&quot;neverRendered&quot;]),jt.getArray(e,t,[&quot;renderers&quot;]),jt.moveToProtected(e,t,[&quot;views&quot;]),jt.event(e,t,&quot;completion&quot;),nv(e,t)}var av={newInstance:jt.newInstance(ov,&quot;vtkRenderWindow&quot;),extend:ov,registerViewConstructor:ev,listViewAPIs:function(){return Object.keys(Jh)},newAPISpecificView:tv};const iv={Unknown:0,LeftController:1,RightController:2},sv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var lv={Device:iv,Input:sv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:cv,Input:uv}=lv,{vtkWarningMacro:dv,vtkErrorMacro:pv,normalizeWheel:fv,vtkOnceErrorMacro:gv}=jt,mv={ctrlKey:!1,altKey:!1,shiftKey:!1},hv={&quot;xr-standard&quot;:[uv.Trigger,uv.Grip,uv.TrackPad,uv.Thumbstick,uv.A,uv.B]},vv=[&quot;StartAnimation&quot;,&quot;Animation&quot;,&quot;EndAnimation&quot;,&quot;PointerEnter&quot;,&quot;PointerLeave&quot;,&quot;MouseEnter&quot;,&quot;MouseLeave&quot;,&quot;StartMouseMove&quot;,&quot;MouseMove&quot;,&quot;EndMouseMove&quot;,&quot;LeftButtonPress&quot;,&quot;LeftButtonRelease&quot;,&quot;MiddleButtonPress&quot;,&quot;MiddleButtonRelease&quot;,&quot;RightButtonPress&quot;,&quot;RightButtonRelease&quot;,&quot;KeyPress&quot;,&quot;KeyDown&quot;,&quot;KeyUp&quot;,&quot;StartMouseWheel&quot;,&quot;MouseWheel&quot;,&quot;EndMouseWheel&quot;,&quot;StartPinch&quot;,&quot;Pinch&quot;,&quot;EndPinch&quot;,&quot;StartPan&quot;,&quot;Pan&quot;,&quot;EndPan&quot;,&quot;StartRotate&quot;,&quot;Rotate&quot;,&quot;EndRotate&quot;,&quot;Button3D&quot;,&quot;Move3D&quot;,&quot;StartPointerLock&quot;,&quot;EndPointerLock&quot;,&quot;StartInteraction&quot;,&quot;Interaction&quot;,&quot;EndInteraction&quot;,&quot;AnimationFrameRateUpdate&quot;];function yv(e){e.cancelable&&e.preventDefault()}function Tv(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function bv(e,t){t.classHierarchy.push(&quot;vtkRenderWindowInteractor&quot;);const n=new Set,r=new Map;let o=1;function a(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{pv(&quot;you want to call setView(view) instead of setRenderWindow on a vtk.js interactor&quot;)},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>dv(&quot;empty event loop&quot;),e.getCurrentRenderer=()=>(t.currentRenderer||a(0,0),t.currentRenderer);const i=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),o=n.getBoundingClientRect(),i=n.width/o.width,s=n.height/o.height,l={x:i*(e.clientX-o.left),y:s*(o.height-e.clientY+o.top),z:0};return(r.size<=1||!t.currentRenderer)&&a(l.x,l.y),l};function s(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function l(e){const t=s(e);return{key:e.key,keyCode:e.charCode,...t}}function c(e){return e.pointerType||&quot;&quot;}function u(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.bindEvents=n=>{t.container=n,n.addEventListener(&quot;contextmenu&quot;,yv),n.addEventListener(&quot;wheel&quot;,e.handleWheel),n.addEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.addEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.addEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.addEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.addEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.addEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.addEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.addEventListener(&quot;keypress&quot;,e.handleKeyPress),document.addEventListener(&quot;keydown&quot;,e.handleKeyDown),document.addEventListener(&quot;keyup&quot;,e.handleKeyUp),document.addEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),n.style.touchAction=&quot;none&quot;,n.style.userSelect=&quot;none&quot;,n.style.webkitTapHighlightColor=&quot;rgba(0,0,0,0)&quot;},e.unbindEvents=()=>{const{container:n}=t;n.removeEventListener(&quot;contextmenu&quot;,yv),n.removeEventListener(&quot;wheel&quot;,e.handleWheel),n.removeEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.removeEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.removeEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.removeEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.removeEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.removeEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.removeEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.removeEventListener(&quot;keypress&quot;,e.handleKeyPress),document.removeEventListener(&quot;keydown&quot;,e.handleKeyDown),document.removeEventListener(&quot;keyup&quot;,e.handleKeyUp),document.removeEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),t.container=null,r.clear()},e.handleKeyPress=t=>{const n=l(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=l(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=l(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerEnterEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerLeaveEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&yv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),r.has(n.pointerId)&&dv(&quot;[RenderWindowInteractor] duplicate pointerId detected&quot;),r.set(n.pointerId,{pointerId:n.pointerId,position:i(n)}),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(r.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&yv(n),r.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(r.has(t.pointerId))switch(r.delete(t.pointerId),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(r.has(t.pointerId)&&(r.get(t.pointerId).position=i(t)),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:pv(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=r=>{void 0!==r?n.has(r)?dv(&quot;requester is already registered for animating&quot;):(n.add(r),t.animationRequest||1!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):pv(&quot;undefined requester, can not start animating&quot;)},e.extendAnimation=r=>{const o=Date.now()+r;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(r){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.has(r))n.delete(r),t.animationRequest&&0===n.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=r&&r.getClassName?r.getClassName():r;dv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==n.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=n.gamepad,s=n.handedness;if(i){i.index in t.lastGamepadValues||(t.lastGamepadValues[i.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<i.buttons.length;++r)r in t.lastGamepadValues[i.index][s].buttons||(t.lastGamepadValues[i.index][s].buttons[r]=!1),t.lastGamepadValues[i.index][s].buttons[r]!==i.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,pressed:i.buttons[r].pressed,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController,input:hv[i.mapping]&&hv[i.mapping][r]?hv[i.mapping][r]:uv.Trigger}),t.lastGamepadValues[i.index][s].buttons[r]=i.buttons[r].pressed),t.lastGamepadValues[i.index][s].buttons[r]&&null!=a&&e.move3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController})}}))},e.handleMouseMove=n=>{const r={...s(n),position:i(n),deviceType:c(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const r=Date.now();t._animationFrameCount++,r-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(r-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=r,t._animationFrameCount=1),e.animationEvent(),u(),n.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{yv(n);const r={...fv(n),...s(n),position:i(n),deviceType:c(n)};0===t.wheelTimeoutID&&(o=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=o,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:pv(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);if(2===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture(&quot;TouchStart&quot;,t)}else if(1===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const o=[...r.values()];if(t.recognizeGestures)if(0===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonReleaseEvent(t)}else if(1===o.length){const t=Tv(r);e.recognizeGesture(&quot;TouchEnd&quot;,t);const a={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonPressEvent(a)}else{const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||u()},vv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void gv(&quot;\\n          Can not forward events without a current renderer on the interactor.\\n        &quot;);const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),&quot;TouchStart&quot;===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture=&quot;Start&quot;);if(&quot;TouchEnd&quot;===n)return&quot;Pinch&quot;===t.currentGesture&&(e.render(),e.endPinchEvent()),&quot;Rotate&quot;===t.currentGesture&&(e.render(),e.endRotateEvent()),&quot;Pan&quot;===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture=&quot;Start&quot;,void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,&quot;TouchMove&quot;===n)if(&quot;Start&quot;===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture=&quot;Pinch&quot;;const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture=&quot;Rotate&quot;;const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture=&quot;Pan&quot;;const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if(&quot;Rotate&quot;===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if(&quot;Pinch&quot;===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if(&quot;Pan&quot;===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e};const d=e.delete;e.delete=()=>{for(;n.size;)e.cancelAnimation(n.values().next().value);void 0!==document.hidden&&document.removeEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange),t.container&&e.unbindEvents(),d()},void 0!==document.hidden&&document.addEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange,!1)}const xv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:&quot;Start&quot;,animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,&quot;RenderEvent&quot;),vv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,[&quot;initialized&quot;,&quot;container&quot;,&quot;interactorStyle&quot;,&quot;lastFrameTime&quot;,&quot;recentAnimationFrameRate&quot;,&quot;_view&quot;]),jt.setGet(e,t,[&quot;lightFollowCamera&quot;,&quot;enabled&quot;,&quot;enableRender&quot;,&quot;recognizeGestures&quot;,&quot;desiredUpdateRate&quot;,&quot;stillUpdateRate&quot;,&quot;picker&quot;,&quot;preventDefaultOnPointerDown&quot;,&quot;preventDefaultOnPointerUp&quot;,&quot;mouseScrollDebounceByPass&quot;]),jt.moveToProtected(e,t,[&quot;view&quot;]),bv(e,t)}var Sv={newInstance:jt.newInstance(Cv,&quot;vtkRenderWindowInteractor&quot;),extend:Cv,handledEvents:vv,...lv};const{vtkErrorMacro:Av,VOID:Iv}=jt;function wv(e,t){t.classHierarchy.push(&quot;vtkInteractorObserver&quot;);const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Sv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):Iv),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Av(&quot;\\n          The interactor must be set before subscribing to events\\n        &quot;)),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const Pv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pv,n),jt.obj(e,t),jt.event(e,t,&quot;InteractionEvent&quot;),jt.event(e,t,&quot;StartInteractionEvent&quot;),jt.event(e,t,&quot;EndInteractionEvent&quot;),jt.get(e,t,[&quot;_interactor&quot;,&quot;enabled&quot;]),jt.setGet(e,t,[&quot;priority&quot;,&quot;processEvents&quot;]),jt.moveToProtected(e,t,[&quot;interactor&quot;]),wv(e,t)}var Rv={newInstance:jt.newInstance(Ov,&quot;vtkInteractorObserver&quot;),extend:Ov,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},Mv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Dv}=Mv,Ev={Rotate:Dv.IS_ROTATE,Pan:Dv.IS_PAN,Spin:Dv.IS_SPIN,Dolly:Dv.IS_DOLLY,CameraPose:Dv.IS_CAMERA_POSE,WindowLevel:Dv.IS_WINDOW_LEVEL,Slice:Dv.IS_SLICE};function Vv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyle&quot;),Object.keys(Ev).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Dv.IS_NONE&&(t.state=Ev[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:&quot;StartInteractionEvent&quot;}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Ev[n]&&(t.state=Dv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:&quot;EndInteractionEvent&quot;}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case&quot;r&quot;:case&quot;R&quot;:e.pokedRenderer.resetCamera(),n.render();break;case&quot;w&quot;:case&quot;W&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case&quot;s&quot;:case&quot;S&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case&quot;v&quot;:case&quot;V&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Lv={state:Dv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function Bv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lv,n),Rv.extend(e,t,n),Vv(e,t)}var Nv={newInstance:jt.newInstance(Bv,&quot;vtkInteractorStyle&quot;),extend:Bv,...Mv};const{States:_v}=Mv;function Fv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyleTrackballCamera&quot;),e.handleMouseMove=n=>{const r=n.position,o=n.pokedRenderer;switch(t.state){case _v.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad?!n||n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad||t.state!==_v.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===_v.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const t=e.pokedRenderer.getActiveCamera(),n=t.getPhysicalTranslation(),r=.025*t.getPhysicalScale(),o=t.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);t.setPhysicalTranslation(n[0]+o[0]*r,n[1]+o[1]*r,n[2]+o[2]*r)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case _v.IS_DOLLY:e.endDolly();break;case _v.IS_PAN:e.endPan();break;case _v.IS_SPIN:e.endSpin();break;case _v.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(n.pokedRenderer,n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=n.pokedRenderer.getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(n.pokedRenderer,o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(n.pokedRenderer,o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(n.pokedRenderer,o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&n.pokedRenderer.updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=e.pokedRenderer.getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(n.pokedRenderer,r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const kv={motionFactor:10,zoomFactor:10};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Nv.extend(e,t,n),jt.setGet(e,t,[&quot;motionFactor&quot;,&quot;zoomFactor&quot;]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,&quot;vtkInteractorStyleTrackballCamera&quot;),extend:Gv};function zv(e){return e}function Wv(e){return null===e||&quot;null&quot;===e?null:&quot;true&quot;===e||&quot;false&quot;!==e&&(void 0!==e&&&quot;undefined&quot;!==e?&quot;[&quot;===e[0]&&&quot;]&quot;===e[e.length-1]?e.substring(1,e.length-1).split(&quot;,&quot;).map((e=>Wv(e.trim()))):&quot;&quot;===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var Hv=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?Wv:zv,o=(t||&quot;&quot;).replace(/#.*/,&quot;&quot;).replace(&quot;?&quot;,&quot;&quot;).split(&quot;&&quot;);return o.forEach((e=>{const[t,o]=e.split(&quot;=&quot;).map((e=>decodeURIComponent(e)));t&&(n[t]=!o||r(o))})),n};function jv(e,t){t.classHierarchy.push(&quot;vtkRenderPass&quot;),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const Kv={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),jt.obj(e,t),jt.get(e,t,[&quot;currentOperation&quot;]),jt.setGet(e,t,[&quot;delegates&quot;,&quot;_currentParent&quot;,&quot;preDelegateOperations&quot;,&quot;postDelegateOperations&quot;]),jt.moveToProtected(e,t,[&quot;currentParent&quot;]),jv(e,t)}var qv={newInstance:jt.newInstance($v,&quot;vtkRenderPass&quot;),extend:$v};const{Representation:Xv}=ds,{vtkErrorMacro:Yv}=jt;function Zv(e){const t=cd.substitute(e.Fragment,&quot;//VTK::RenderPassFragmentShader::Impl&quot;,&quot;\\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\\n      gl_FragData[1].r = weight;\\n    &quot;,!1);e.Fragment=t.result}function Qv(e,t){t.classHierarchy.push(&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Es.newInstance({numberOfComponents:3,values:e});o.setName(&quot;points&quot;);const a=Es.newInstance({numberOfComponents:2,values:n});a.setName(&quot;tcoords&quot;);const i=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,&quot;polys&quot;,Xv.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Nd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,&quot;Float32Array&quot;,null),t.translucentRTexture=Nd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,&quot;Float32Array&quot;,null),t.translucentZTexture=Nd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],&quot;Float32Array&quot;,null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;attribute vec2 tcoordTC;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = tcoordTC; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),&quot;//VTK::System::Dec\\n\\nin vec2 tcoord;\\n\\nuniform sampler2D translucentRTexture;\\nuniform sampler2D translucentRGBATexture;\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\\n  float t2Color = texture(translucentRTexture, tcoord).r;\\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\\n}\\n&quot;,&quot;&quot;)},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;tcoordTC&quot;,t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;)},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension(&quot;EXT_color_buffer_half_float&quot;)&&!i.getExtension(&quot;EXT_color_buffer_float&quot;))return e.setCurrentOperation(&quot;translucentPass&quot;),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation(&quot;opaqueZBufferPass&quot;),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation(&quot;translucentPass&quot;),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi(&quot;translucentRGBATexture&quot;,t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi(&quot;translucentRTexture&quot;,t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate()},e.getShaderReplacement=()=>t._supported?Zv:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const Jv={framebuffer:null,copyShader:null,tris:null};function ey(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jv,n),qv.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),jt.get(e,t,[&quot;framebuffer&quot;]),Qv(e,t)}var ty={newInstance:jt.newInstance(ey,&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),extend:ey};function ny(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];if(s.getDraw()&&s.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=Hp.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation(&quot;zBufferPass&quot;),i.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation(&quot;opaquePass&quot;),i.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=ty.newInstance()),t.translucentPass.traverse(n,i,e)),t.volumeCount>0&&(e.setCurrentOperation(&quot;volumePass&quot;),i.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation(&quot;overlayPass&quot;),i.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const ry={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ry,n),qv.extend(e,t,n),jt.get(e,t,[&quot;framebuffer&quot;,&quot;opaqueActorCount&quot;,&quot;translucentActorCount&quot;,&quot;volumeCount&quot;]),ny(e,t)}var ay={newInstance:jt.newInstance(oy,&quot;vtkForwardPass&quot;),extend:oy},iy=n(594),sy=n.n(iy);const ly=[&quot;lastShaderProgramBound&quot;,&quot;context&quot;,&quot;_openGLRenderWindow&quot;];function cy(e,t){t.classHierarchy.push(&quot;vtkShaderCache&quot;),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=cd.substitute(o,&quot;VSOut&quot;,&quot;GSOut&quot;).result);const a=t._openGLRenderWindow.getWebgl2();let i=&quot;\\n&quot;,s=&quot;#version 100\\n&quot;;a?s=&quot;#version 300 es\\n#define attribute in\\n#define textureCube texture\\n#define texture2D texture\\n#define textureCubeLod textureLod\\n#define texture2DLod textureLod\\n&quot;:(t.context.getExtension(&quot;OES_standard_derivatives&quot;),t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(i=&quot;#extension GL_EXT_frag_depth : enable\\n&quot;),t.context.getExtension(&quot;EXT_shader_texture_lod&quot;)&&(i+=&quot;#extension GL_EXT_shader_texture_lod : enable\\n#define textureCubeLod textureCubeLodEXT\\n#define texture2DLod texture2DLodEXT&quot;)),o=cd.substitute(o,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,a?&quot;&quot;:&quot;#extension GL_OES_standard_derivatives : enable\\n&quot;,i,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;let l=cd.substitute(e,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;if(a){l=cd.substitute(l,&quot;varying&quot;,&quot;out&quot;).result,o=cd.substitute(o,&quot;varying&quot;,&quot;in&quot;).result;let e=&quot;&quot;,t=0;for(;o.includes(`gl_FragData[${t}]`);)o=cd.substitute(o,`gl_FragData\\\\[${t}\\\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\\n`,t++;o=cd.substitute(o,&quot;//VTK::Output::Dec&quot;,e).result}return{VSSource:l,FSSource:o,GSSource:cd.substitute(r,&quot;//VTK::System::Dec&quot;,s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=sy().hash(o);if(!(a in t.shaderPrograms)){const o=cd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const uy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,ly),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cy(e,t)}var py={newInstance:jt.newInstance(dy,&quot;vtkShaderCache&quot;),extend:dy};const{vtkErrorMacro:fy}=jt;function gy(e,t){t.classHierarchy.push(&quot;vtkOpenGLTextureUnitManager&quot;),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&fy(&quot;some texture units  were not properly released&quot;);t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const my={context:null,numberOfTextureUnits:0,textureUnits:0};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,[&quot;numberOfTextureUnits&quot;]),jt.setGet(e,t,[&quot;context&quot;]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,&quot;vtkOpenGLTextureUnitManager&quot;),extend:hy};function yy(e,t){t.classHierarchy.push(&quot;vtkRenderWindowViewNode&quot;),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.createSelector=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)}}const Ty={size:void 0,selector:void 0};function by(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ty,n),t.size||(t.size=[300,300]),jt.getArray(e,t,[&quot;size&quot;],2),jt.get(e,t,[&quot;selector&quot;]),Zt.extend(e,t,n),yy(e,t)}var xy={newInstance:jt.newInstance(by,&quot;vtkRenderWindowViewNode&quot;),extend:by};const{vtkDebugMacro:Cy,vtkErrorMacro:Sy}=jt,Ay={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Iy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let wy=0;const Py=[];function Oy(){wy++,Py.forEach((e=>e(wy)))}function Ry(){wy--,Py.forEach((e=>e(wy)))}function My(e){e.preventDefault()}function Dy(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderWindow&quot;);const n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if(&quot;__getUnderlyingContext&quot;===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}();e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener(&quot;webglcontextlost&quot;,My,!1),t.canvas.addEventListener(&quot;webglcontextrestored&quot;,e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow(e)}))}},e.initialize=()=>{if(!t.initialized){t.context=e.get3DContext(),t.textureUnitManager=vy.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND),t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Sy(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.activeFramebuffer?t.activeFramebuffer.getSize():t.size,e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:&quot;high-performance&quot;},r=null;const o=&quot;undefined&quot;!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext(&quot;webgl2&quot;,e),r&&(t.webgl2=!0,Cy(&quot;using webgl2&quot;))),r||(Cy(&quot;using webgl1&quot;),r=t.canvas.getContext(&quot;webgl&quot;,e)||t.canvas.getContext(&quot;experimental-webgl&quot;,e)),new Proxy(r,n)},e.restoreContext=()=>{const t=qv.newInstance();t.setCurrentOperation(&quot;Release&quot;),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?Sy(&quot;Hardware does not support the number of textures defined.&quot;):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case ys.CHAR:case ys.SIGNED_CHAR:case ys.UNSIGNED_CHAR:return 1;case n:case r:case ys.UNSIGNED_SHORT:case ys.SHORT:case ys.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case ys.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&ys.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&ys.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return t.context.R16F;case 2:return t.context.RG16F;case 3:return t.context.RGB16F;default:return t.context.RGBA16F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Ay,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension(&quot;OES_texture_float&quot;),o=n.getExtension(&quot;OES_texture_half_float&quot;),a=n.getExtension(&quot;WEBGL_debug_renderer_info&quot;),i=n.getExtension(&quot;WEBGL_draw_buffers&quot;),s=n.getExtension(&quot;EXT_texture_filter_anisotropic&quot;)||n.getExtension(&quot;WEBKIT_EXT_texture_filter_anisotropic&quot;),l=[[&quot;Max Vertex Attributes&quot;,&quot;MAX_VERTEX_ATTRIBS&quot;,n.getParameter(n.MAX_VERTEX_ATTRIBS)],[&quot;Max Varying Vectors&quot;,&quot;MAX_VARYING_VECTORS&quot;,n.getParameter(n.MAX_VARYING_VECTORS)],[&quot;Max Vertex Uniform Vectors&quot;,&quot;MAX_VERTEX_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],[&quot;Max Fragment Uniform Vectors&quot;,&quot;MAX_FRAGMENT_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],[&quot;Max Fragment Texture Image Units&quot;,&quot;MAX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],[&quot;Max Vertex Texture Image Units&quot;,&quot;MAX_VERTEX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],[&quot;Max Combined Texture Image Units&quot;,&quot;MAX_COMBINED_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],[&quot;Max 2D Texture Size&quot;,&quot;MAX_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_TEXTURE_SIZE)],[&quot;Max Cube Texture Size&quot;,&quot;MAX_CUBE_MAP_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],[&quot;Max Texture Anisotropy&quot;,&quot;MAX_TEXTURE_MAX_ANISOTROPY_EXT&quot;,s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],[&quot;Point Size Range&quot;,&quot;ALIASED_POINT_SIZE_RANGE&quot;,n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(&quot; - &quot;)],[&quot;Line Width Range&quot;,&quot;ALIASED_LINE_WIDTH_RANGE&quot;,n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(&quot; - &quot;)],[&quot;Max Viewport Dimensions&quot;,&quot;MAX_VIEWPORT_DIMS&quot;,n.getParameter(n.MAX_VIEWPORT_DIMS).join(&quot; - &quot;)],[&quot;Max Renderbuffer Size&quot;,&quot;MAX_RENDERBUFFER_SIZE&quot;,n.getParameter(n.MAX_RENDERBUFFER_SIZE)],[&quot;Framebuffer Red Bits&quot;,&quot;RED_BITS&quot;,n.getParameter(n.RED_BITS)],[&quot;Framebuffer Green Bits&quot;,&quot;GREEN_BITS&quot;,n.getParameter(n.GREEN_BITS)],[&quot;Framebuffer Blue Bits&quot;,&quot;BLUE_BITS&quot;,n.getParameter(n.BLUE_BITS)],[&quot;Framebuffer Alpha Bits&quot;,&quot;ALPHA_BITS&quot;,n.getParameter(n.ALPHA_BITS)],[&quot;Framebuffer Depth Bits&quot;,&quot;DEPTH_BITS&quot;,n.getParameter(n.DEPTH_BITS)],[&quot;Framebuffer Stencil Bits&quot;,&quot;STENCIL_BITS&quot;,n.getParameter(n.STENCIL_BITS)],[&quot;Framebuffer Subpixel Bits&quot;,&quot;SUBPIXEL_BITS&quot;,n.getParameter(n.SUBPIXEL_BITS)],[&quot;MSAA Samples&quot;,&quot;SAMPLES&quot;,n.getParameter(n.SAMPLES)],[&quot;MSAA Sample Buffers&quot;,&quot;SAMPLE_BUFFERS&quot;,n.getParameter(n.SAMPLE_BUFFERS)],[&quot;Supported Formats for UByte Render Targets     &quot;,&quot;UNSIGNED_BYTE RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.UNSIGNED_BYTE)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.UNSIGNED_BYTE)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.UNSIGNED_BYTE)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Half Float Render Targets&quot;,&quot;HALF FLOAT RENDER TARGET FORMATS&quot;,[o&&Iy(n,n.RGBA,o.HALF_FLOAT_OES)?&quot;RGBA&quot;:&quot;&quot;,o&&Iy(n,n.RGB,o.HALF_FLOAT_OES)?&quot;RGB&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?&quot;LUMINANCE&quot;:&quot;&quot;,o&&Iy(n,n.ALPHA,o.HALF_FLOAT_OES)?&quot;ALPHA&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Full Float Render Targets&quot;,&quot;FLOAT RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.FLOAT)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.FLOAT)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.FLOAT)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.FLOAT)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.FLOAT)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Max Multiple Render Targets Buffers&quot;,&quot;MAX_DRAW_BUFFERS_WEBGL&quot;,i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],[&quot;High Float Precision in Vertex Shader&quot;,&quot;HIGH_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Vertex Shader&quot;,&quot;MEDIUM_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Vertex Shader&quot;,&quot;LOW_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Float Precision in Fragment Shader&quot;,&quot;HIGH_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Fragment Shader&quot;,&quot;MEDIUM_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Fragment Shader&quot;,&quot;LOW_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Vertex Shader&quot;,&quot;HIGH_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Vertex Shader&quot;,&quot;MEDIUM_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Vertex Shader&quot;,&quot;LOW_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Fragment Shader&quot;,&quot;HIGH_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Fragment Shader&quot;,&quot;MEDIUM_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Fragment Shader&quot;,&quot;LOW_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Supported Extensions&quot;,&quot;EXTENSIONS&quot;,n.getSupportedExtensions().join(&quot;<br/>\\t\\t\\t\\t\\t    &quot;)],[&quot;WebGL Renderer&quot;,&quot;RENDERER&quot;,n.getParameter(n.RENDERER)],[&quot;WebGL Vendor&quot;,&quot;VENDOR&quot;,n.getParameter(n.VENDOR)],[&quot;WebGL Version&quot;,&quot;VERSION&quot;,n.getParameter(n.VERSION)],[&quot;Shading Language Version&quot;,&quot;SHADING_LANGUAGE_VERSION&quot;,n.getParameter(n.SHADING_LANGUAGE_VERSION)],[&quot;Unmasked Renderer&quot;,&quot;UNMASKED_RENDERER&quot;,a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],[&quot;Unmasked Vendor&quot;,&quot;UNMASKED_VENDOR&quot;,a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],[&quot;WebGL Version&quot;,&quot;WEBGL_VERSION&quot;,t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}()},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=df.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((function(){t.canvas.removeEventListener(&quot;webglcontextlost&quot;,My),t.canvas.removeEventListener(&quot;webglcontextrestored&quot;,e.restoreContext)}),e.delete,e.setViewStream,Ry),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.getGraphicsResourceForObject=e=>e?{vtkObj:t._graphicsResources.get(e),hash:t._graphicsResourceHash.get(e)}:null,e.setGraphicsResourceForObject=(e,n,r)=>{e&&(t._graphicsResources.set(e,n),t._graphicsResourceHash.set(e,r))},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach(((t,n)=>{e+=t.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResourcesForObject=n=>!!n&&(t._graphicsResources.get(n)?.releaseGraphicsResources(e),t._graphicsResources.delete(n)&&t._graphicsResourceHash.delete(n)),e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach(((t,n)=>{t.releaseGraphicsResources(e)})),t._graphicsResources.clear(),t._graphicsResourceHash.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))}}const Ey={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1};const Vy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),xy.extend(e,t,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,Oy(),t.selector||(t.selector=df.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,t._textureResourceIds=new Map,t._graphicsResources=new Map,t._graphicsResourceHash=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Vy),t.shaderCache=py.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=ay.newInstance(),jt.event(e,t,&quot;imageReady&quot;),jt.get(e,t,[&quot;shaderCache&quot;,&quot;textureUnitManager&quot;,&quot;webgl2&quot;,&quot;useBackgroundImage&quot;,&quot;activeFramebuffer&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;defaultToWebgl2&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Dy(e,t)}),&quot;vtkOpenGLRenderWindow&quot;);function Ly(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderModule&quot;),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}ev(&quot;WebGL&quot;,Vy);const By={device:null,handle:null};function Ny(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,By,n),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;handle&quot;]),Ly(e,t)}var _y={newInstance:jt.newInstance(Ny,&quot;vtkWebGPUShaderModule&quot;),extend:Ny};function Fy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderCache&quot;),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=_y.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const ky={shaderModules:null,device:null,window:null};function Gy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ky,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;,&quot;window&quot;]),Fy(e,t)}var Uy={newInstance:jt.newInstance(Gy,&quot;vtkWebGPUShaderCache&quot;),extend:Gy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join(&quot;\\n&quot;):n;let a=!1;-1!==e.search(t)&&(a=!0);let i=&quot;&quot;;r&&(i=&quot;g&quot;);const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function zy(e,t){t.classHierarchy.push(&quot;vtkWebGPUBindGroup&quot;),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join(&quot;\\n&quot;)}}const Wy={device:null,handle:null,label:null};function Hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;label&quot;,&quot;device&quot;,&quot;arrayInformation&quot;]),zy(e,t)}var jy={newInstance:jt.newInstance(Hy),extend:Hy};function Ky(e,t){t.classHierarchy.push(&quot;vtkWebGPUPipeline&quot;),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);&quot;vertex&quot;===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint=&quot;main&quot;),&quot;fragment&quot;===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint=&quot;main&quot;)}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const $y={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$y,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,[&quot;handle&quot;,&quot;pipelineDescription&quot;]),At(e,t,[&quot;device&quot;,&quot;renderEncoder&quot;,&quot;topology&quot;,&quot;vertexState&quot;]),Ky(e,t)}var Xy={newInstance:Et(qy,&quot;vtkWebGPUPipeline&quot;),extend:qy};function Yy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderDescription&quot;),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push(&quot;};&quot;),o=n,r[r.length-1]+=&quot;,&quot;,r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Input&quot;,r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push(&quot;};&quot;),o=o.concat(e),t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Output&quot;,[`-> ${t.type}Output`]).result}t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Dec&quot;,o).result}}const Zy={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function Qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zy,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,[&quot;type&quot;,&quot;hash&quot;,&quot;code&quot;]),jt.getArray(e,t,[&quot;outputTypes&quot;,&quot;outputNames&quot;,&quot;outputInterpolations&quot;]),Yy(e,t)}var Jy={newInstance:jt.newInstance(Qy,&quot;vtkWebGPUShaderDescription&quot;),extend:Qy};const eT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;sint&quot;},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;uint&quot;},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:&quot;sint&quot;},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:&quot;float&quot;},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;uint&quot;},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;sint&quot;},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:&quot;uint&quot;},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:&quot;sint&quot;},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:&quot;uint&quot;},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:&quot;sint&quot;},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:&quot;float&quot;},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;rgba8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;uint&quot;},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;sint&quot;},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;bgra8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:&quot;float&quot;},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:&quot;uint&quot;},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:&quot;sint&quot;},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:&quot;uint&quot;},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:&quot;sint&quot;},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:&quot;float&quot;},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:&quot;uint&quot;},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:&quot;sint&quot;},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:&quot;unfilterable-float&quot;},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;depth&quot;},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:&quot;depth&quot;},&quot;depth24plus-stencil8&quot;:{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:&quot;mixed&quot;},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;depth&quot;}};var tT=function(e){return!e||e.length<6?0:e in eT==1?eT[e]:(et(`unknown format ${e}`),null)},nT=function(e){if(!e||e.length<5)return 0;let t=1;&quot;x&quot;===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},rT=function(e){if(!e||e.length<5)return 0;let t;if(&quot;f&quot;===e[0])t=&quot;Float&quot;;else if(&quot;s&quot;===e[0])t=&quot;Int&quot;;else{if(&quot;u&quot;!==e[0])return void et(`unknown format ${e}`);t=&quot;Uint&quot;}const n=e.split(&quot;x&quot;)[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+=&quot;Array&quot;,t;et(`unknown format ${e}`)},oT=function(e){let t;if(&quot;f&quot;===e[0]||&quot;n&quot;===e[1])t=&quot;f32&quot;;else if(&quot;s&quot;===e[0]&&&quot;i&quot;===e[1])t=&quot;i32&quot;;else{if(&quot;u&quot;!==e[0]||&quot;i&quot;!==e[1])return void et(`unknown format ${e}`);t=&quot;u32&quot;}let n=1;return&quot;x&quot;===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},aT=function(e){if(!e)return 0;let t=1;return&quot;vec&quot;===e.substring(0,3)?t=Number(e[3]):&quot;mat&quot;===e.substring(0,3)&&(t=e[3]*e[5]),4*t},iT=function(e){if(e)return e.includes(&quot;f32&quot;)?&quot;Float32Array&quot;:e.includes(&quot;i32&quot;)?&quot;Int32Array&quot;:e.includes(&quot;u32&quot;)?&quot;Uint32Array&quot;:void et(`unknown format ${e}`)};function sT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function lT(e,t){t.classHierarchy.push(&quot;vtkWebGPUVertexInput&quot;),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:&quot;vertex&quot;,o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(sT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e=&quot;&quot;,n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=oT(a.format);n>0&&(e+=&quot;,\\n&quot;),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const cT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function uT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,[&quot;created&quot;,&quot;device&quot;,&quot;handle&quot;,&quot;indexBuffer&quot;]),lT(e,t)}var dT={newInstance:Et(uT,&quot;vtkWebGPUVertexInput&quot;),extend:uT};const pT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  // var vertex: vec4<f32> = vertexBC;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n&quot;,fT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function gT(e,t){t.classHierarchy.push(&quot;vtkWebGPUSimpleMapper&quot;),e.generateShaderDescriptions=(n,r,o)=>{const a=Jy.newInstance({type:&quot;vertex&quot;,hash:n,code:t.vertexShaderTemplate}),i=Jy.newInstance({type:&quot;fragment&quot;,hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp(&quot;//VTK::[^:]*::&quot;,&quot;g&quot;),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];&quot;replaceShaderIOStructs&quot;!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.replaceShaderCode(null,n),t.getShaderDescription(&quot;fragment&quot;).replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set(&quot;replaceShaderRenderEncoder&quot;,e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderRenderer&quot;,e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);s.addBuiltinInput(&quot;bool&quot;,&quot;@builtin(front_facing) frontFacing&quot;),i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderMapper&quot;,e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;    output.Position = rendererUBO.SCPCMatrix*vertexBC;&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription(&quot;vertex&quot;).addOutput(&quot;vec2<f32>&quot;,&quot;tcoordVS&quot;)},t.shaderReplacements.set(&quot;replaceShaderTCoord&quot;,e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=Xy.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const mT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:&quot;triangle-list&quot;,UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function hT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=dT.newInstance(),t.bindGroup=jy.newInstance({label:&quot;mapperBG&quot;}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||fT,t.vertexShaderTemplate=t.vertexShaderTemplate||pT,t.shaderReplacements=new Map,jt.get(e,t,[&quot;pipeline&quot;,&quot;vertexInput&quot;]),jt.setGet(e,t,[&quot;additionalBindables&quot;,&quot;device&quot;,&quot;fragmentShaderTemplate&quot;,&quot;interpolate&quot;,&quot;numberOfInstances&quot;,&quot;numberOfVertices&quot;,&quot;pipelineHash&quot;,&quot;shaderReplacements&quot;,&quot;SSBO&quot;,&quot;textureViews&quot;,&quot;topology&quot;,&quot;UBO&quot;,&quot;vertexShaderTemplate&quot;,&quot;WebGPURenderer&quot;]),gT(e,t)}var vT={newInstance:jt.newInstance(hT,&quot;vtkWebGPUSimpleMapper&quot;),extend:hT};function yT(e,t){t.classHierarchy.push(&quot;vtkWebGPUFullScreenQuad&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;),r.addOutput(&quot;vec4<f32>&quot;,&quot;vertexVC&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;,&quot;output.vertexVC = vec4<f32>(vertexBC, 1);&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,[&quot;vertexBC&quot;]),t.numberOfVertices=6}}const TT={};function bT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,TT,n),vT.extend(e,t,n),yT(e,t)}var xT={newInstance:jt.newInstance(bT,&quot;vtkWebGPUFullScreenQuad&quot;),extend:bT};const CT=[&quot;setBindGroup&quot;,&quot;setIndexBuffer&quot;,&quot;setVertexBuffer&quot;,&quot;draw&quot;,&quot;drawIndexed&quot;];function ST(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderEncoder&quot;),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!(&quot;depthStencil&quot;in n))console.log(&quot;mismatched depth attachments&quot;),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\\n${o}\\n versus pipeline\\n${a}\\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<CT.length;n++)e[CT[n]]=function(){return t.handle[CT[n]](...arguments)}}const AT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function IT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}],depthStencilAttachment:{view:void 0,depthLoadOp:&quot;clear&quot;,depthClearValue:0,depthStoreOp:&quot;store&quot;}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = computedColor;&quot;]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater-equal&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}},t.colorTextureViews=[],bt(e,t,[&quot;boundPipeline&quot;,&quot;colorTextureViews&quot;]),At(e,t,[&quot;depthTextureView&quot;,&quot;description&quot;,&quot;handle&quot;,&quot;label&quot;,&quot;pipelineHash&quot;,&quot;pipelineSettings&quot;,&quot;replaceShaderCodeFunction&quot;]),ST(e,t)}var wT={newInstance:Et(IT,&quot;vtkWebGPURenderEncoder&quot;),extend:IT},PT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const OT=[&quot;getMappedRange&quot;,&quot;mapAsync&quot;,&quot;unmap&quot;];function RT(e,t){t.classHierarchy.push(&quot;vtkWebGPUBuffer&quot;),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<OT.length;n++)e[OT[n]]=function(){return t.handle[OT[n]](...arguments)}}const MT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;strideInBytes&quot;,&quot;device&quot;,&quot;arrayInformation&quot;,&quot;label&quot;,&quot;sourceTime&quot;]),RT(e,t)}var ET={newInstance:jt.newInstance(DT),extend:DT,...PT};const{Representation:VT}=ds,{PrimitiveTypes:LT}=PT;class BT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function NT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function _T(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=NT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=NT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=NT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=NT(n,o,t),n.ibo[n.iboId++]=a}function FT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let kT;const GT=new Uint32Array(1),UT=new Uint32Array(2),zT=new Uint32Array(3),WT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)GT[0]=t[n+a],kT(GT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)UT[0]=t[n+a],UT[1]=t[n+(a+1)%e],kT(UT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o);for(let a=0;a<e-2;a++)UT[0]=t[n+a],UT[1]=t[n+a+2],kT(UT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n],zT[1]=t[n+a+1],zT[2]=t[n+a+2],kT(zT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n+a],zT[1]=t[n+a+1+a%2],zT[2]=t[n+a+1+(a+1)%2],kT(zT,r,o)}};function HT(e,t){t.classHierarchy.push(&quot;vtkWebGPUIndexBuffer&quot;),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case LT.Points:return&quot;points&quot;;case LT.Lines:return&quot;lines&quot;;case LT.Triangles:case LT.TriangleEdges:return&quot;polys&quot;;case LT.TriangleStripEdges:case LT.TriangleStrips:return&quot;strips&quot;;default:return&quot;&quot;}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new BT};let d=null;d=o===VT.POINTS||r===LT.Points?WT.anythingToPoints:o===VT.WIREFRAME||r===LT.Lines?WT[`${l}ToWireframe`]:WT[`${l}ToSurface`],kT=FT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format=&quot;uint16&quot;):(u.ibo=new Uint32Array(u.iboSize),e.format=&quot;uint32&quot;),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),kT=_T,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const jT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function KT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jT,n),ET.extend(e,t,n),jt.setGet(e,t,[&quot;flatIdToPointId&quot;,&quot;flatIdToCellId&quot;,&quot;flatSize&quot;,&quot;indexCount&quot;]),HT(e,t)}var $T={newInstance:jt.newInstance(KT),extend:KT,...PT};const{BufferUsage:qT}=PT,{vtkErrorMacro:XT}=Kt,{VtkDataTypes:YT}=Es;function ZT(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,&quot;packExtra&quot;)&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function QT(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function JT(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===qT.Index&&(n=$T.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=ET.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===qT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===qT.PointArray){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=ZT(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?&quot;flat&quot;:&quot;perspective&quot;}])}if(e.usage===qT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=QT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=ZT(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:&quot;flat&quot;}])}return e.usage===qT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push(&quot;vtkWebGPUBufferManager&quot;),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case YT.UNSIGNED_CHAR:t=&quot;uint8&quot;;break;case YT.FLOAT:t=&quot;float32&quot;;break;case YT.UNSIGNED_INT:t=&quot;uint32&quot;;break;case YT.INT:t=&quot;sint32&quot;;break;case YT.DOUBLE:t=&quot;float32&quot;;break;case YT.UNSIGNED_SHORT:t=&quot;uint16&quot;;break;case YT.SHORT:t=&quot;sin16&quot;;break;default:t=&quot;float32&quot;}switch(e.getNumberOfComponents()){case 2:t+=&quot;x2&quot;;break;case 3:t.includes(&quot;32&quot;)||XT(`unsupported x3 type for ${t}`),t+=&quot;x3&quot;;break;case 4:t+=&quot;x4&quot;}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:qT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=ET.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:&quot;float32x3&quot;}]),t.fullScreenQuadBuffer}}const eb={device:null,fullScreenQuadBuffer:null};function tb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eb,n),yt(e,t),At(e,t,[&quot;device&quot;]),JT(e,t)}var nb={newInstance:Et(tb),extend:tb,...PT};function rb(e,t){t.classHierarchy.push(&quot;vtkWebGPUSampler&quot;),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:&quot;clamp-to-edge&quot;,t.options.addressModeV=n.addressModeV?n.addressModeV:&quot;clamp-to-edge&quot;,t.options.addressModeW=n.addressModeW?n.addressModeW:&quot;clamp-to-edge&quot;,t.options.magFilter=n.magFilter?n.magFilter:&quot;nearest&quot;,t.options.minFilter=n.minFilter?n.minFilter:&quot;nearest&quot;,t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:&quot;nearest&quot;,t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const ob={device:null,handle:null,label:null,options:null};function ab(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ob,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;options&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;]),rb(e,t)}var ib={newInstance:jt.newInstance(ab),extend:ab};function sb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTextureView&quot;),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r=&quot;f32&quot;;&quot;sint&quot;===t.bindGroupLayoutEntry.texture.sampleType?r=&quot;i32&quot;:&quot;uint&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(r=&quot;u32&quot;);let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return&quot;depth&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=ib.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const lb={texture:null,handle:null,sampler:null,label:null};function cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:&quot;float&quot;,viewDimension:&quot;2d&quot;}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;texture&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;sampler&quot;]),sb(e,t)}var ub={newInstance:jt.newInstance(cb),extend:cb};const{BufferUsage:db}=nb;function pb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTexture&quot;),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?&quot;2d&quot;:&quot;3d&quot;;t.format=n.format?n.format:&quot;rgba8unorm&quot;,t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:&quot;rgba8unorm&quot;,t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format=&quot;rgba8unorm&quot;,n.flip=!0,n.nativeArray=n.jsImageData.data);const o=tT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&&quot;float&quot;===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?&quot;Uint16Array&quot;:i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Ad.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement(&quot;canvas&quot;);e.width=n.image.width,e.height=n.image.height;const t=e.getContext(&quot;2d&quot;);t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Tu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:db.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:db.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=tT(t.format);return 2===e.elementSize&&&quot;float&quot;===e.sampleType?1:255},e.getNumberOfComponents=()=>tT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?&quot;2d&quot;:&quot;3d&quot;);const o=ub.newInstance({label:n});return o.create(e,r),o}}const fb={device:null,handle:null,buffer:null,ready:!1,label:null};function gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fb,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;ready&quot;,&quot;width&quot;,&quot;height&quot;,&quot;depth&quot;,&quot;format&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;label&quot;]),pb(e,t)}var mb={newInstance:jt.newInstance(gb),extend:gb};function hb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOpaquePass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;opaquePassColor&quot;}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView(&quot;opaquePassColorTexture&quot;);t.renderEncoder.setColorTextureView(0,n),t.depthFormat=&quot;depth32float&quot;,t.depthTexture=mb.newInstance({label:&quot;opaquePassDepth&quot;}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;opaquePassDepthTexture&quot;);t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;opaquePass&quot;),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=wT.newInstance({label:&quot;OpaquePass&quot;}),t.renderEncoder.setPipelineHash(&quot;op&quot;)}}const vb={renderEncoder:null,colorTexture:null,depthTexture:null};function yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vb,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),hb(e,t)}var Tb={newInstance:jt.newInstance(yb,&quot;vtkWebGPUOpaquePass&quot;),extend:yb};function bb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=mb.newInstance({label:&quot;translucentPassColor&quot;}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView(&quot;oitpColorTexture&quot;);t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=mb.newInstance({label:&quot;translucentPassAccumulate&quot;}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView(&quot;oitpAccumTexture&quot;);t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=xT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash(&quot;oitpfsq&quot;),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\\n  if (reveal == 1.0) { discard; }\\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\\n  var total: f32 = max(tcolor.a, 0.01);\\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;)}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;translucentPass&quot;),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=wT.newInstance({label:&quot;translucentRender&quot;});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:void 0,clearValue:[1,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}],e.depthStencilAttachment={view:void 0,depthLoadOp:&quot;load&quot;,depthStoreOp:&quot;store&quot;},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addOutput(&quot;f32&quot;,&quot;outAccum&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);&quot;,&quot;output.outColor = vec4<f32>(computedColor.rgb*w, w);&quot;,&quot;output.outAccum = computedColor.a;&quot;]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash(&quot;oitpr&quot;),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!1,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;zero&quot;,dstFactor:&quot;one-minus-src&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=wT.newInstance({label:&quot;translucentFinal&quot;}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash(&quot;oitpf&quot;),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})}}const xb={colorTextureView:null,depthTextureView:null};function Cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),bb(e,t)}var Sb={newInstance:jt.newInstance(Cb,&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),extend:Cb};const{BufferUsage:Ab}=nb,{vtkErrorMacro:Ib}=jt;function wb(e,t){t.classHierarchy.push(&quot;vtkWebGPUUniformBuffer&quot;),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Ib(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:aT(n),offset:-1,nativeType:iT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Ab.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join(&quot;\\n&quot;)}}const Pb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function Ob(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;uniform&quot;}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,[&quot;binding&quot;,&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;,&quot;sizeInBytes&quot;]),wb(e,t)}var Rb={newInstance:jt.newInstance(Ob,&quot;vtkWebGPUUniformBuffer&quot;),extend:Ob};const{BufferUsage:Mb}=nb,{vtkErrorMacro:Db}=jt;function Eb(e,t){t.classHierarchy.push(&quot;vtkWebGPUStorageBuffer&quot;),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void Db(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=aT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:iT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Mb.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\\n};\\nstruct ${t.label}Struct\\n{\\n  values: array<${t.label}StructEntry>,\\n};\\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\\n`),r.join(&quot;\\n&quot;)},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Vb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function Lb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;read-only-storage&quot;}},jt.get(e,t,[&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;numberOfInstances&quot;,&quot;sizeInBytes&quot;]),Eb(e,t)}var Bb={newInstance:jt.newInstance(Lb,&quot;vtkWebGPUStorageBuffer&quot;),extend:Lb};const Nb=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Volume::TraverseDec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\\n{\\n  // todo multicomponent support\\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\\n}\\n\\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\\n{\\n  var result: vec4<f32>;\\n\\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\\n  result.w = 0.0;\\n\\n  // divide by spacing as that is our delta\\n  result = result / volumeSSBO.values[vNum].spacing;\\n  // now we have a gradient in unit tcoords\\n\\n  var grad: f32 = length(result.xyz);\\n  if (grad > 0.0)\\n  {\\n    // rotate to View Coords, needed for lighting and shading\\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\\n    result = nMat * result;\\n    result = result / length(result);\\n  }\\n\\n  // store gradient magnitude in .w\\n  result.w = grad;\\n\\n  return result;\\n}\\n\\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\\n{\\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n\\n  // convert to tcoords and reject if outside the volume\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\\n\\n  var scalar: f32 = getTextureValue(vTex, tpos);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n\\n  var gofactor: f32 = 1.0;\\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    normal = getGradient(vTex, tpos, vNum, scalar);\\n    if (componentSSBO.values[cNum].gomin <  1.0)\\n    {\\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\\n    }\\n  }\\n\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n\\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    color = color*abs(normal.z);\\n  }\\n\\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\\n\\n  return outColor;\\n}\\n\\n// adjust the start and end point of a raycast such that it intersects the unit cube.\\n// This function is used to take a raycast starting point and step vector\\n// and numSteps and return the startijng and ending steps for intersecting the\\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\\n// and bound it to intersecting the texture.\\n//\\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\\n{\\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\\n\\n  // move tpos to the start of the volume\\n  var adjust: f32 =\\n    min(\\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\\n      min(\\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\\n  if (adjust < 0.0)\\n  {\\n    result.x = result.x - adjust;\\n  }\\n\\n  // adjust length to the end\\n  adjust =\\n    max(\\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\\n      max(\\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\\n  if (adjust > 0.0)\\n  {\\n    result.y = result.y - adjust;\\n  }\\n\\n  return result;\\n}\\n\\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\\n{\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n  return vec4<f32>(color.rgb, opacity);\\n}\\n\\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var maxVal: f32 = -1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar > maxVal)\\n    {\\n      maxVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\\n}\\n\\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var minVal: f32 = 1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar < minVal)\\n    {\\n      minVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\\n}\\n\\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var avgVal: f32 = 0.0;\\n  var sampleCount: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      avgVal = avgVal + sample;\\n      sampleCount = sampleCount + 1.0;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  if (sampleCount <= 0.0)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\\n}\\n\\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var sumVal: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      sumVal = sumVal + sample;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\\n}\\n\\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\\n{\\n  // initial ray position is at the beginning\\n  var rayPosSC: vec4<f32> = minPosSC;\\n\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var curDist: f32 = 0.0;\\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n  var sampleColor: vec4<f32>;\\n//VTK::Volume::TraverseCalls\\n\\n  loop\\n  {\\n    // for each volume, sample and accumulate color\\n//VTK::Volume::CompositeCalls\\n\\n    // increment position\\n    curDist = curDist + mapperUBO.SampleDistance;\\n    rayPosSC = rayPosSC + rayStepSC;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayLengthSC) { break; }\\n    if (computedColor.a > 0.98) { break; }\\n  }\\n  return computedColor;\\n}\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\\n\\n  // discard empty rays\\n  if (rayMax <= rayMin) { discard; }\\n  else\\n  {\\n    // compute start and end ray positions in view coordinates\\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\\n\\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\\n    rayStepSC.w = 0.0;\\n\\n    var computedColor: vec4<f32>;\\n\\n//VTK::Volume::Loop\\n\\n//VTK::RenderEncoder::Impl\\n  }\\n\\n  return output;\\n}\\n&quot;,_b=new Float64Array(16),Fb=new Float64Array(16);function kb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePassFSQ&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;]).result,r.setCode(o),t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription(&quot;fragment&quot;);let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===Rg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push(&quot;    computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;)):(s.push(`  sampleColor = traverseVals[${e}];`),s.push(&quot;  computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;));a=Uy.substitute(a,&quot;//VTK::Volume::CompositeCalls&quot;,i).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseCalls&quot;,s).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseDec&quot;,[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===Rg.COMPOSITE_BLEND?l=!0:n===Rg.MAXIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.MINIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.AVERAGE_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.ADDITIVE_INTENSITY_BLEND&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result)}l&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[&quot;    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);&quot;]).result),o.setCode(a)},t.shaderReplacements.set(&quot;replaceShaderVolume&quot;,e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8Array(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;rgba8unorm&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;tfunTexture&quot;);t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;r16float&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;ofunTexture&quot;);t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(_b),b(_b,_b,o);const p=n.getMatrix();m(Fb,p),h(Fb,Fb),T(_b,Fb,_b);const f=d.getWorldToIndex();T(_b,f,_b);const v=d.getDimensions();g(Fb),x(Fb,Fb,[1/v[0],1/v[1],1/v[2]]),T(_b,Fb,_b);for(let t=0;t<16;t++)a[16*e+t]=_b[t];h(_b,_b);for(let t=0;t<4;t++)i[16*e+4*t]=_b[4*t],i[16*e+4*t+1]=_b[4*t+1],i[16*e+4*t+2]=_b[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry(&quot;SCTCMatrix&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;planeNormals&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;shade&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;tstep&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;spacing&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;ipScalarRange&quot;,&quot;vec4<f32>&quot;),t.SSBO.setAllInstancesFromArray(&quot;SCTCMatrix&quot;,a),t.SSBO.setAllInstancesFromArray(&quot;planeNormals&quot;,i),t.SSBO.setAllInstancesFromArray(&quot;shade&quot;,l),t.SSBO.setAllInstancesFromArray(&quot;tstep&quot;,s),t.SSBO.setAllInstancesFromArray(&quot;spacing&quot;,c),t.SSBO.setAllInstancesFromArray(&quot;ipScalarRange&quot;,u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=tT(l),u={scale:[255],offset:[0]};2===c.elementSize&&&quot;float&quot;===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry(&quot;cScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;cShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomin&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomax&quot;,&quot;f32&quot;),t.componentSSBO.setAllInstancesFromArray(&quot;cScale&quot;,d),t.componentSSBO.setAllInstancesFromArray(&quot;cShift&quot;,p),t.componentSSBO.setAllInstancesFromArray(&quot;oScale&quot;,f),t.componentSSBO.setAllInstancesFromArray(&quot;oShift&quot;,v),t.componentSSBO.setAllInstancesFromArray(&quot;goScale&quot;,A),t.componentSSBO.setAllInstancesFromArray(&quot;goShift&quot;,S),t.componentSSBO.setAllInstancesFromArray(&quot;gomin&quot;,y),t.componentSSBO.setAllInstancesFromArray(&quot;gomax&quot;,C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue(&quot;SampleDistance&quot;,r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=ib.newInstance({label:&quot;clampSampler&quot;}),t.clampSampler.create(t.device,{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}))},e.computePipelineHash=()=>{t.pipelineHash=&quot;volfsq&quot;;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Gb={volumes:null,rowLength:1024,lastVolumeLength:0};function Ub(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gb,n),xT.extend(e,t,n),t.fragmentShaderTemplate=Nb,t.UBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t.UBO.addEntry(&quot;SampleDistance&quot;,&quot;f32&quot;),t.SSBO=Bb.newInstance({label:&quot;volumeSSBO&quot;}),t.componentSSBO=Bb.newInstance({label:&quot;componentSSBO&quot;}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),kb(e,t)}var zb={newInstance:jt.newInstance(Ub,&quot;vtkWebGPUVolumePassFSQ&quot;),extend:Ub};const{Representation:Wb}=ds,{BufferUsage:Hb,PrimitiveTypes:jb}=nb,Kb=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],$b=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::VolumePass::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::VolumePass::Impl\\n\\n  // use the maximum (closest) of the current value and the zbuffer\\n  // the blend func will then take the min to find the farthest stop value\\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function qb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePass&quot;),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=zb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=xT.newInstance(),t._volumeCopyQuad.setPipelineHash(&quot;volpassfsq&quot;),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._copyUBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t._copyUBO.addEntry(&quot;tscale&quot;,&quot;vec2<f32>&quot;),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray(&quot;tscale&quot;,[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray(&quot;tscale&quot;,[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:Hb.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:jb.Triangles,representation:Wb.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:Hb.PointArray,format:&quot;float32x4&quot;,hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,[&quot;vertexBC&quot;]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+Kb[e][0],l[n++]=r+Kb[e][1],l[n++]=r+Kb[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation(&quot;volumeDepthRangePass&quot;),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=wT.newInstance({label:&quot;VolumePass DepthRange&quot;}),t._depthRangeEncoder.setPipelineHash(&quot;volr&quot;),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor1&quot;),t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor2&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);&quot;,&quot;output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);&quot;]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:null,clearValue:[1,1,1,1],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;}}}]}}),t._depthRangeTexture=mb.newInstance({label:&quot;volumePassMaxDepth&quot;}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView(&quot;maxTexture&quot;);t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=mb.newInstance({label:&quot;volumePassDepthMin&quot;}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView(&quot;minTexture&quot;);t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=mb.newInstance({label:&quot;volumePassColor&quot;}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;bgra8unorm&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView(&quot;volumePassColorTexture&quot;),t._colorTextureView.addSampler(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._clearEncoder=wT.newInstance({label:&quot;VolumePass Clear&quot;}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._clearEncoder.setPipelineHash(&quot;volpf&quot;),t._clearEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=wT.newInstance({label:&quot;volumePassCopy&quot;}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._copyEncoder.setPipelineHash(&quot;volcopypf&quot;),t._copyEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=wT.newInstance({label:&quot;volumePassMerge&quot;}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash(&quot;volpf&quot;),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const Xb={colorTextureView:null,depthTextureView:null,volumes:null};function Yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xb,n),qv.extend(e,t,n),t._mapper=vT.newInstance(),t._mapper.setFragmentShaderTemplate($b),t._mapper.getShaderReplacements().set(&quot;replaceShaderVolumePass&quot;,((e,t,n)=>{t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)})),t._boundsPoly=gu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),qb(e,t)}var Zb={newInstance:jt.newInstance(Yb,&quot;vtkWebGPUVolumePass&quot;),extend:Yb};function Qb(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e),t.opaquePass||(t.opaquePass=Tb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Sb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=Zb.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=wT.newInstance({label:&quot;forwardPassBlit&quot;}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._finalBlitEncoder.setPipelineHash(&quot;fpf&quot;),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}}),t._fsqSampler=ib.newInstance({label:&quot;finalPassSampler&quot;}),t._fsqSampler.create(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._fullScreenQuad=xT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash(&quot;fpfsq&quot;),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0),vec4<f32>(0.0),vec4<f32>(1.0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._finalBlitOutputTextureView=ub.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const Jb={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;opaquePass&quot;,&quot;translucentPass&quot;,&quot;volumePass&quot;]),Qb(e,t)}var tx={newInstance:jt.newInstance(ex,&quot;vtkForwardPass&quot;),extend:ex};const{VtkDataTypes:nx}=Es;function rx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format=&quot;r&quot;;break;case 2:e.format=&quot;rg&quot;;break;default:e.format=&quot;rgba&quot;}switch(e.dataArray.getDataType()){case nx.UNSIGNED_CHAR:e.format+=&quot;8unorm&quot;;break;case nx.FLOAT:case nx.UNSIGNED_INT:case nx.INT:case nx.DOUBLE:case nx.UNSIGNED_SHORT:case nx.SHORT:default:e.format+=&quot;16float&quot;}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format=&quot;rgba8unorm&quot;),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=mb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push(&quot;vtkWebGPUTextureManager&quot;),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const ox={handle:null,device:null};function ax(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ox,n),jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;]),rx(e,t)}var ix={newInstance:jt.newInstance(ax),extend:ax};class sx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&&quot;object&quot;==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function lx(e,t){t.classHierarchy.push(&quot;vtkWebGPUDevice&quot;),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro(&quot;layout not found&quot;),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro(&quot;attempt to cache an object without a hash&quot;),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const cx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cx,n),yt(e,t),At(e,t,[&quot;handle&quot;]),bt(e,t,[&quot;bufferManager&quot;,&quot;shaderCache&quot;,&quot;textureManager&quot;]),t.objectCache=new sx,t.shaderCache=Uy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=nb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=ix.newInstance(),t.textureManager.setDevice(e),t.pipelines={},lx(e,t)}var dx={newInstance:Et(ux,&quot;vtkWebGPUDevice&quot;),extend:ux};function px(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelectionPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;hardwareSelectorColor&quot;}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;rgba32uint&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView(&quot;hardwareSelectColorTexture&quot;);t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=mb.newInstance({label:&quot;hardwareSelectorDepth&quot;}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;depth32float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;hardwareSelectDepthTexture&quot;);t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation(&quot;cameraPass&quot;),r.traverse(e),e.setCurrentOperation(&quot;opaquePass&quot;),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=wT.newInstance({label:&quot;HardwareSelectionPass&quot;}),t.selectionRenderEncoder.setPipelineHash(&quot;sel&quot;),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<u32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);&quot;]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba32uint&quot;,blend:void 0}]}})}}const fx={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function gx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fx,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),px(e,t)}var mx={newInstance:jt.newInstance(gx,&quot;vtkWebGPUHardwareSelectionPass&quot;),extend:gx};const{SelectionContent:hx,SelectionField:vx}=qp,{FieldAssociations:yx}=ol,{vtkErrorMacro:Tx}=jt;function bx(e){return`${e.propID} ${e.compositeID}`}function xx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Cx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=xx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=xx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Cx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Cx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Cx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Cx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Cx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Sx(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelector&quot;),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Tx(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=ET.newInstance({label:&quot;hardwareSelectColorBuffer&quot;});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=ET.newInstance({label:&quot;hardwareSelectDepthBuffer&quot;}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:&quot;depth-only&quot;},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Cx(e,[n,t],0,u);if(r){const t=bx(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=qp.newInstance();switch(i.setContentType(hx.INDICES),e){case yx.FIELD_ASSOCIATION_CELLS:i.setFieldType(vx.CELL);break;case yx.FIELD_ASSOCIATION_POINTS:i.setFieldType(vx.POINT);break;default:Tx(&quot;Unknown field association&quot;)}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Ax={};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),Gp.extend(e,t,n),t._selectionPass=mx.newInstance(),jt.setGet(e,t,[&quot;_WebGPURenderWindow&quot;]),jt.moveToProtected(e,t,[&quot;WebGPURenderWindow&quot;]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,&quot;vtkWebGPUHardwareSelector&quot;),extend:Ix};const Px=Object.create(null);function Ox(e,t){t.classHierarchy.push(&quot;vtkWebGPUViewNodeFactory&quot;)}const Rx={};function Mx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rx,n),t.overrides=Px,tn.extend(e,t,n),Ox(0,t)}var Dx={newInstance:jt.newInstance(Mx,&quot;vtkWebGPUViewNodeFactory&quot;),extend:Mx};const{vtkErrorMacro:Ex}=jt,Vx={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Lx(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderWindow&quot;),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:&quot;premultiplied&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Ex(&quot;WebGPU is not enabled.&quot;);e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Ex(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:&quot;high-performance&quot;}),t.deleted||(t.device=dx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext(&quot;webgpu&quot;))},e.releaseGraphicsResources=()=>{const n=qv.newInstance();n.setCurrentOperation(&quot;Release&quot;),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Vx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=ET.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Ad.fromHalf(r.colorValues[o]),s[n+1]=255*Ad.fromHalf(r.colorValues[o+1]),s[n+2]=255*Ad.fromHalf(r.colorValues[o+2]),s[n+3]=255*Ad.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=wx.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Bx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Nx=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,xy.extend(e,t,n),t.myFactory=Dx.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Nx),t.renderPasses[0]=tx.newInstance(),t.selector||(t.selector=wx.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,&quot;imageReady&quot;),jt.event(e,t,&quot;initialized&quot;),jt.get(e,t,[&quot;commandEncoder&quot;,&quot;device&quot;,&quot;presentationFormat&quot;,&quot;useBackgroundImage&quot;,&quot;xrSupported&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;device&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Lx(e,t)}),&quot;vtkWebGPURenderWindow&quot;);ev(&quot;WebGPU&quot;,Nx);const _x=Hv(),Fx={margin:&quot;0&quot;,padding:&quot;0&quot;,position:&quot;absolute&quot;,top:&quot;0&quot;,left:&quot;0&quot;,width:&quot;100%&quot;,height:&quot;100%&quot;,overflow:&quot;hidden&quot;},kx={position:&quot;absolute&quot;,left:&quot;25px&quot;,top:&quot;25px&quot;,backgroundColor:&quot;white&quot;,borderRadius:&quot;5px&quot;,listStyle:&quot;none&quot;,padding:&quot;5px 10px&quot;,margin:&quot;0&quot;,display:&quot;block&quot;,border:&quot;solid 1px black&quot;,maxWidth:&quot;calc(100% - 70px)&quot;,maxHeight:&quot;calc(100% - 60px)&quot;,overflow:&quot;auto&quot;};function Gx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Ux(e,t){t.classHierarchy.push(&quot;vtkFullScreenRenderWindow&quot;);const n=document.querySelector(&quot;body&quot;);t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement(&quot;div&quot;),Gx(t.container,t.containerStyle||Fx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height=&quot;100%&quot;,n.style.height=&quot;100%&quot;,n.style.padding=&quot;0&quot;,n.style.margin=&quot;0&quot;),t.renderWindow=av.newInstance(),t.renderer=Qh.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(_x.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Sv.newInstance(),t.interactor.setInteractorStyle(Uv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?&quot;block&quot;:&quot;none&quot;)},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement(&quot;div&quot;),Gx(t.controlContainer,t.controlPanelStyle||kx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener(&quot;keypress&quot;,(t=>{&quot;c&quot;===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}))},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener(&quot;resize&quot;,e.resize),e.resize()}const zx={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Wx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zx,n),jt.obj(e,t),jt.get(e,t,[&quot;renderWindow&quot;,&quot;renderer&quot;,&quot;apiSpecificRenderWindow&quot;,&quot;interactor&quot;,&quot;rootContainer&quot;,&quot;container&quot;,&quot;controlContainer&quot;]),Ux(e,t)}var Hx={newInstance:jt.newInstance(Wx),extend:Wx},jx={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:Kx,Scale:$x}=jx,{ScalarMappingTarget:qx}=Pl,{vtkDebugMacro:Xx,vtkErrorMacro:Yx,vtkWarningMacro:Zx}=jt;function Qx(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Jx(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function eC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];Qx(o,i),Qx(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Jx(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Jx(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function tC(e,t){t.classHierarchy.push(&quot;vtkColorTransferFunction&quot;),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Yx(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(s<0||s>1)return Yx(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===$x.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Do(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===Kx.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===Kx.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;,t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===Kx.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===Kx.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;);for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Yx(&quot;Attempting to lookup a value with no points in the function&quot;),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Yx(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Yx(&quot;Index out of range!&quot;),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>t.indexedLookup&&e.getSize()?e.getSize():t.tableSize?t.tableSize:16777216,e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void Yx(&quot;attempt to set zero width color range&quot;);const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):Xx(&quot;Transfer Function Has No Points!&quot;)},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void Zx(&quot;Transfer Function Has No Points!&quot;);const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===qx.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===qx.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===qx.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===qx.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=Kx[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Yx(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=Kx.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const nC={clamping:!0,colorSpace:Kx.RGB,hSVWrap:!0,scale:$x.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function rC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nC,n),Pl.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,[&quot;buildTime&quot;,&quot;mappingRange&quot;]),jt.setGet(e,t,[&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;,&quot;colorSpace&quot;,&quot;discretize&quot;,&quot;numberOfValues&quot;]),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),tC(e,t)}var oC={newInstance:jt.newInstance(rC,&quot;vtkColorTransferFunction&quot;),extend:rC,...jx},aC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:iC,ScaleModes:sC}=aC,{vtkErrorMacro:lC}=jt;function cC(e,t){t.classHierarchy.push(&quot;vtkGlyph3DMapper&quot;),e.getOrientationModeAsString=()=>jt.enumToString(iC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(iC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(iC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(iC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(sC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(sC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(sC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(sC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===sC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(lC(&quot;Cannot scale by components since scale array does not have 3 components.&quot;),a=null);const l=r.getBounds(),c=[];ki.getCorners(l,c),t.bounds[0]=ki.INIT_BOUNDS[0],t.bounds[1]=ki.INIT_BOUNDS[1],t.bounds[2]=ki.INIT_BOUNDS[2],t.bounds[3]=ki.INIT_BOUNDS[3],t.bounds[4]=ki.INIT_BOUNDS[4],t.bounds[5]=ki.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case iC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case iC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case iC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case sC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case sC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case sC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const uC={orient:!0,orientationMode:iC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:sC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function dC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uC,n),nc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,[&quot;orient&quot;,&quot;orientationMode&quot;,&quot;orientationArray&quot;,&quot;scaleArray&quot;,&quot;scaleFactor&quot;,&quot;scaleMode&quot;,&quot;scaling&quot;]),jt.get(e,t,[&quot;colorArray&quot;,&quot;matrixArray&quot;,&quot;normalArray&quot;,&quot;buildTime&quot;]),cC(e,t)}var pC={newInstance:jt.newInstance(dC,&quot;vtkGlyph3DMapper&quot;),extend:dC,...aC};const{vtkErrorMacro:fC}=jt;function gC(e,t){t.classHierarchy.push(&quot;vtkPiecewiseFunction&quot;),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return&quot;Constant&quot;;case 1:return&quot;NonDecreasing&quot;;case 2:return&quot;NonIncreasing&quot;;default:return&quot;Varied&quot;}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(fC(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return fC(&quot;Index out of range!&quot;),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return fC(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(a<0||a>1)return fC(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const mC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function hC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,[&quot;allowDuplicateScalars&quot;,&quot;clamping&quot;]),jt.setArray(e,t,[&quot;range&quot;],2),jt.getArray(e,t,[&quot;range&quot;]),gC(e,t)}var vC={newInstance:jt.newInstance(hC,&quot;vtkPiecewiseFunction&quot;),extend:hC};const{InterpolationType:yC,OpacityMode:TC}=Og,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push(&quot;vtkVolumeProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(bC(&quot;Bad index - must be between 0 and 3&quot;),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=vC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=oC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=vC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return bC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(bC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(yC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(yC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(yC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(yC,t.interpolationType),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const CC={independentComponents:!0,interpolationType:yC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,CC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:TC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;shade&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,&quot;vtkVolumeProperty&quot;),extend:SC,...Og};const{vtkDebugMacro:IC}=jt;function wC(e,t){t.classHierarchy.push(&quot;vtkVolume&quot;),e.getVolumes=()=>e,e.makeProperty=AC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){IC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e));const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const PC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),wC(e,t)}var RC={newInstance:jt.newInstance(OC,&quot;vtkVolume&quot;),extend:OC};const{BlendMode:MC,FilterMode:DC}=Mg,EC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=vC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function VC(e,t){t.classHierarchy.push(&quot;vtkVolumeMapper&quot;);const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(MC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(MC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(MC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(MC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(MC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(MC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(MC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn(&quot;setAverageIPScalarRange is deprecated use setIpScalarRange&quot;),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(DC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(DC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(DC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(DC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Do(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const LC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:MC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:DC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LC,n),Bs(e,t,n),jt.setGet(e,t,[&quot;sampleDistance&quot;,&quot;imageSampleDistance&quot;,&quot;maximumSamplesPerRay&quot;,&quot;autoAdjustSampleDistances&quot;,&quot;initialInteractionScale&quot;,&quot;interactionSampleDistanceFactor&quot;,&quot;blendMode&quot;,&quot;filterMode&quot;,&quot;preferSizeOverAccuracy&quot;,&quot;computeNormalFromOpacity&quot;,&quot;volumetricScatteringBlending&quot;,&quot;globalIlluminationReach&quot;,&quot;volumeShadowSamplingDistFactor&quot;,&quot;anisotropy&quot;,&quot;localAmbientOcclusion&quot;,&quot;LAOKernelSize&quot;,&quot;LAOKernelRadius&quot;]),jt.setGetArray(e,t,[&quot;ipScalarRange&quot;],2),jt.event(e,t,&quot;lightingActivated&quot;),VC(e,t)}var NC={newInstance:jt.newInstance(BC,&quot;vtkVolumeMapper&quot;),extend:BC,...EC};const{InterpolationType:_C}=eg,{vtkErrorMacro:FC}=jt;function kC(e,t){t.classHierarchy.push(&quot;vtkImageProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return FC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(FC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(_C.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(_C.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(_C,t.interpolationType)}const GC={independentComponents:!1,interpolationType:_C.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function UC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,GC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;colorWindow&quot;,&quot;colorLevel&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;opacity&quot;,&quot;useLookupTableScalarRange&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),kC(e,t)}var zC={newInstance:jt.newInstance(UC,&quot;vtkImageProperty&quot;),extend:UC};const{vtkDebugMacro:WC}=jt;function HC(e,t){t.classHierarchy.push(&quot;vtkImageSlice&quot;),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=zC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){WC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),ki.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!ki.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),ki.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const jC={mapper:null,property:null,bounds:[...ki.INIT_BOUNDS]};function KC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),HC(e,t)}var $C={newInstance:jt.newInstance(KC,&quot;vtkImageSlice&quot;),extend:KC};function qC(e,t){t.classHierarchy.push(&quot;vtkAbstractImageMapper&quot;),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro(&quot;vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED&quot;),Fa())}const XC={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var YC=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,XC,n),Fs(e,t,n),jt.setGet(e,t,[&quot;slice&quot;,&quot;useCustomExtents&quot;]),jt.setGetArray(e,t,[&quot;customDisplayExtent&quot;],6),jt.setGetArray(e,t,[&quot;backgroundColor&quot;],4),qC(e,t)};function ZC(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA(&quot;vtkImageArrayMapper&quot;)?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ni.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:QC,otherStaticMethods:JC}=Ul,{SlicingMode:eS}=sg;function tS(e,t){function n(){let n;switch(t.slicingMode){case eS.X:n=0;break;case eS.Y:n=1;break;case eS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push(&quot;vtkImageMapper&quot;),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case eS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case eS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case eS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case eS.I:l=Ma(a[0],i[0],i[1]);break;case eS.J:l=Ma(a[1],i[2],i[3]);break;case eS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case eS.I:case eS.J:case eS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case eS.X:e.setSlice(r[0]);break;case eS.Y:e.setSlice(r[1]);break;case eS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(eS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(eS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(eS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(eS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(eS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(eS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case eS.X:n[0]=1;break;case eS.Y:n[1]=1;break;case eS.Z:n[2]=1;break;case eS.I:ea(r,[1,0,0],n);break;case eS.J:ea(r,[0,1,0],n);break;case eS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==eS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case eS.I:r[0]=a,r[1]=a;break;case eS.J:r[2]=a,r[3]=a;break;case eS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case eS.I:a[0]=s-r,a[1]=s+r;break;case eS.J:a[2]=s-r,a[3]=s+r;break;case eS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const nS={slicingMode:eS.NONE,closestIJKAxis:{ijkMode:eS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function rS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nS,n),YC(e,t,n),jt.get(e,t,[&quot;slicingMode&quot;]),jt.setGet(e,t,[&quot;closestIJKAxis&quot;,&quot;renderToRectangle&quot;,&quot;sliceAtFocalPoint&quot;,&quot;preferSizeOverAccuracy&quot;]),Ul.implementCoincidentTopologyMethods(e,t),tS(e,t)}var oS={newInstance:jt.newInstance(rS,&quot;vtkImageMapper&quot;),extend:rS,...QC,...JC,...sg};const{vtkErrorMacro:aS}=jt;function iS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function sS(e,t){t.classHierarchy.push(&quot;vtkAppendPolyData&quot;),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void aS(&quot;No input specified.&quot;);if(1===o)return void(r[0]=n[0]);const a=gu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===js.SINGLE?s=ys.FLOAT:t.outputPointsPrecision===js.DOUBLE&&(s=ys.DOUBLE);const v=mc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Es.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Es.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Es.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),iS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),iS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),iS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),iS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const lS={outputPointsPrecision:js.DEFAULT};function cS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lS,n),jt.setGet(e,t,[&quot;outputPointsPrecision&quot;]),jt.obj(e,t),jt.algo(e,t,1,1),sS(e,t)}var uS={newInstance:jt.newInstance(cS,&quot;vtkAppendPolyData&quot;),extend:cS};function dS(e,t){t.classHierarchy.push(&quot;vtkConeSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Nf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=gu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const pS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:&quot;Float64Array&quot;};function fS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),dS(e,t)}var gS={newInstance:jt.newInstance(fS,&quot;vtkConeSource&quot;),extend:fS};function mS(e,t){t.classHierarchy.push(&quot;vtkCylinderSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Es.newInstance({numberOfComponents:3,values:u,name:&quot;Normals&quot;}),p=new Float32Array(2*a),f=Es.newInstance({numberOfComponents:2,values:p,name:&quot;TCoords&quot;}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Nf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=gu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const hS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:&quot;Float64Array&quot;};function vS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;initAngle&quot;,&quot;otherRadius&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),mS(e,t)}var yS={newInstance:jt.newInstance(vS,&quot;vtkCylinderSource&quot;),extend:vS};function TS(e,t){t.classHierarchy.push(&quot;vtkArrowSource&quot;),e.requestData=function(e,n){if(t.deleted)return;const r=yS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Bf().rotateZ(-90).apply(a).apply(i);const s=gS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Nf().translate(1-.5*t.tipLength,0,0).apply(c);const u=uS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Nf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Nf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Nf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const bS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:&quot;Float64Array&quot;};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;tipResolution&quot;,&quot;tipRadius&quot;,&quot;tipLength&quot;,&quot;shaftResolution&quot;,&quot;shaftRadius&quot;,&quot;invert&quot;]),jt.setGetArray(e,t,[&quot;direction&quot;],3),jt.algo(e,t,0,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,&quot;vtkArrowSource&quot;),extend:xS};function SS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Bf().translate(...n).apply(e.getPoints().getData())}function AS(e,t){const n=e.getPoints().getBounds(),r=[0,0,0];r[t]=-n[2*t],Bf().translate(...r).apply(e.getPoints().getData())}function IS(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8Array(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Es.newInstance({name:&quot;color&quot;,numberOfComponents:3,values:a}))}function wS(e,t){t.classHierarchy.push(&quot;vtkAxesActor&quot;);const n=nc.newInstance();e.setMapper(n),e.update=()=>{const e=CS.newInstance({direction:[1,0,0],...t.config}).getOutputData();t.config.recenter?SS(e):AS(e,0),IS(e,...t.xAxisColor);const r=CS.newInstance({direction:[0,1,0],...t.config}).getOutputData();t.config.recenter?SS(r):AS(r,1),IS(r,...t.yAxisColor);const o=CS.newInstance({direction:[0,0,1],...t.config}).getOutputData();t.config.recenter?SS(o):AS(o,2),IS(o,...t.zAxisColor);const a=uS.newInstance();a.setInputData(e),a.addInputData(r),a.addInputData(o),n.setInputConnection(a.getOutputPort())},e.update();const r=jt.debounce(e.update,0),{setConfig:o,setXAxisColor:a,setYAxisColor:i,setZAxisColor:s}=e;e.setConfig=e=>!!o(e)&&(r(),!0),e.setXAxisColor=e=>!!a(e)&&(r(),!0),e.setYAxisColor=e=>!!i(e)&&(r(),!0),e.setZAxisColor=e=>!!s(e)&&(r(),!0)}const PS={config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1},xAxisColor:[255,0,0],yAxisColor:[255,255,0],zAxisColor:[0,128,0]};function OS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PS,n),hs.extend(e,t,n),jt.setGet(e,t,[&quot;config&quot;]),jt.setGetArray(e,t,[&quot;xAxisColor&quot;,&quot;yAxisColor&quot;,&quot;zAxisColor&quot;],3,255),wS(e,t)}var RS={newInstance:jt.newInstance(OS,&quot;vtkAxesActor&quot;),extend:OS};const MS=&quot;resetcamera&quot;,DS=&quot;orientation&quot;,ES={MODE_RESET_CAMERA:MS,MODE_ORIENTATION:DS,MODE_SAME:&quot;same&quot;};function VS(e,t){t.classHierarchy.push(&quot;vtkCameraSynchronizer&quot;);const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName(&quot;position&quot;),s=e.getReferenceByName(&quot;focalPoint&quot;),l=e.getReferenceByName(&quot;viewUp&quot;),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===DS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===MS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const LS={mode:DS,focalPoint:[0,0,0],distance:6.8,active:!0};function BS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LS,n),yt(e,t),At(e,t,[&quot;mode&quot;,&quot;active&quot;,&quot;srcRenderer&quot;,&quot;dstRenderer&quot;,&quot;distance&quot;]),Pt(e,t,[&quot;focalPoint&quot;],3,0),VS(e,t)}var NS={newInstance:Et(BS,&quot;vtkCameraSynchronizer&quot;),extend:BS,SynchronizationMode:ES};const _S={},FS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=NS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:NS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var kS=function(e,t,n){const r=e.get(&quot;synchronizedViewId&quot;).synchronizedViewId;if(!t.behaviors||!r)return;_S[r]||(_S[r]={});const o=_S[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=NS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];FS[e.type]?o[r]=new FS[e.type](n,e):console.log(&quot;No mapping for&quot;,e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const GS={},US=/instance:\\${([^}]+)}/,zS={},WS=[],HS={},jS={vtkPoints:mc,vtkCellArray:cc,vtkDataArray:Es};function KS(e){return e.map((e=>US.exec(e))).filter((e=>e)).map((e=>e[1]))}function $S(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),$S(e,t)})),t}function qS(e,t,n,r){if(!t)return Promise.reject(new Error(&quot;No instance provided.&quot;));const o=GS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function XS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=GS[e];return n&&n.build?n.build(t):(console.log(&quot;No builder for&quot;,e),null)}function YS(){Object.keys(GS).forEach((e=>{delete GS[e]}))}function ZS(){Object.keys(zS).forEach((e=>{delete zS[e]}))}function QS(e){if(1===e[1].length)return-1===WS.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===WS.indexOf(e[1][n]);return t}function JS(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(HS[r]){const{key:n,value:o}=HS[r];if(!n||e.properties[n]===o)return void WS.push((e=>`instance:\\${${e}}`)(t))}let o=n.getInstance(t);o||(o=XS(r,{managedInstanceId:t}),n.registerInstance(t,o)),qS(r,o,e,n)})),t.calls&&t.calls.filter(QS).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=US.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:&quot;addArray&quot;,a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:&quot;vtkDataArray&quot;,l=jS[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log(&quot;Error fetching array&quot;,JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error(&quot;Error in array handling for state&quot;,JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function eA(e,t,n){zS[t.id]||JS(e,t,n),zS[t.id]=!0}function tA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function nA(e){const t=e.name?`_${e.name}`:&quot;&quot;;return`${e.hash}_${e.dataType}${t}`}function rA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=nA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=nA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),tA(t.getPointData(),i.pointData),tA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=JS(t,s,r);return r.end(),l}}const oA=rA([&quot;points&quot;,&quot;polys&quot;,&quot;verts&quot;,&quot;lines&quot;,&quot;strips&quot;]),aA=rA([]);function iA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:JS;XS||qS?GS[e]={build:t,update:n}:delete GS[e]}const sA={vtkMapper:[&quot;vtkOpenGLPolyDataMapper&quot;,&quot;vtkCompositePolyDataMapper2&quot;,&quot;vtkDataSetMapper&quot;],vtkProperty:[&quot;vtkOpenGLProperty&quot;],vtkRenderer:[&quot;vtkOpenGLRenderer&quot;],vtkCamera:[&quot;vtkOpenGLCamera&quot;],vtkColorTransferFunction:[&quot;vtkPVDiscretizableColorTransferFunction&quot;],vtkActor:[&quot;vtkOpenGLActor&quot;,&quot;vtkPVLODActor&quot;],vtkLight:[&quot;vtkOpenGLLight&quot;,&quot;vtkPVLight&quot;],vtkTexture:[&quot;vtkOpenGLTexture&quot;],vtkImageMapper:[&quot;vtkOpenGLImageSliceMapper&quot;],vtkVolumeMapper:[&quot;vtkFixedPointVolumeRayCastMapper&quot;]},lA={vtkAxesActor:{build:RS.newInstance,update:JS},vtkRenderWindow:{build:av.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(QS).filter((e=>&quot;removeRenderer&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),JS(e,t,n),kS(e,t,n)}},vtkRenderer:{build:Qh.newInstance,update:function(e,t,n){JS(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=$S(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(QS).filter((e=>&quot;removeViewProp&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{const t=n.getInstance(e).get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:El.newInstance,update:JS},vtkCamera:{build:Bh.newInstance,update:eA},vtkPolyData:{build:gu.newInstance,update:oA},vtkImageData:{build:fl.newInstance,update:aA},vtkMapper:{build:nc.newInstance,update:JS},vtkGlyph3DMapper:{build:pC.newInstance,update:JS},vtkProperty:{build:ds.newInstance,update:JS},vtkActor:{build:hs.newInstance,update:JS},vtkLight:{build:kh.newInstance,update:JS},vtkColorTransferFunction:{build:oC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Tu.newInstance,update:JS},vtkVolume:{build:RC.newInstance,update:JS},vtkVolumeMapper:{build:NC.newInstance,update:JS},vtkVolumeProperty:{build:AC.newInstance,update:JS},vtkImageSlice:{build:$C.newInstance,update:JS},vtkImageMapper:{build:oS.newInstance,update:JS},vtkImageProperty:{build:zC.newInstance,update:JS},vtkPiecewiseFunction:{build:vC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:Fu.newInstance,update:JS},vtkScalarBarActor:{build:Op.newInstance,update:JS}};function cA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&YS(),Object.keys(lA).forEach((e=>{const t=lA[e];iA(e,t.build,t.update)}))}function uA(){Object.keys(sA).forEach((e=>{sA[e].forEach((t=>{GS[t]=GS[e]}))}))}cA(),uA(),HS.vtkPVLight={};var dA={build:XS,update:qS,genericUpdater:JS,oneTimeGenericUpdater:eA,setTypeMapping:iA,clearTypeMapping:YS,getSupportedTypes:function(){return Object.keys(GS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return ZS();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete zS[e]})),r},updateRenderWindow:function(e,t,n){return qS(&quot;vtkRenderWindow&quot;,e,t,n)},excludeInstance:function(e,t,n){HS[e]={key:t,value:n}},setDefaultMapping:cA,applyDefaultAliases:uA,alwaysUpdateCamera:function(){iA(&quot;vtkCamera&quot;,Bh.newInstance),uA()}};const pA={};function fA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if(&quot;string&quot;==typeof t&&(i=Dm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log(&quot;Error getting data array:&quot;),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use &quot;setArrayFetcher&quot; to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function gA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function mA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Dt(t,n,&quot;progressEvent&quot;),Dt(t,n,&quot;progressDone&quot;),t}function hA(){const e={};let t=&quot;default&quot;;return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function vA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;default&quot;,t=pA[e];return t||(t={...fA(),...gA(),...mA(),...hA()},pA[e]=t),t}function yA(e,t){let n=-1,r=100;const o=e=>e.get(&quot;managedInstanceId&quot;).managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get(&quot;synchronizedViewId&quot;).synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),dA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){dA.clearOneTimeUpdaters(a())}}}function TA(e,t){t.classHierarchy.push(&quot;vtkSynchronizableRenderWindow&quot;),t.synchronizerContext||(t.synchronizerContext=vA(t.synchronizerContextName));const n=yA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const bA={synchronizerContextName:&quot;default&quot;,synchronizerContext:null,synchronizedViewId:null};function xA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bA,n),av.extend(e,t),bt(e,t,[&quot;synchronizerContext&quot;]),TA(e,t)}var CA={newInstance:Et(xA,&quot;vtkSynchronizableRenderWindow&quot;),extend:xA,getSynchronizerContext:vA,setSynchronizerContext:function(e,t){pA[e]=t},clearSynchronizerContext:function(e){if(e&&pA[e]&&delete pA[e],!e){const e=Object.keys(pA);for(let t=0;t<e.length;t++)delete pA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;default&quot;;const n=yA(e,vA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:gA,createArrayHandler:fA,createProgressHandler:mA,createSceneMtimeHandler:hA,vtkObjectManager:dA};const{vtkErrorMacro:SA,vtkDebugMacro:AA}=jt;let IA=0;function wA(e){const t=document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`);return t?t.innerHTML:null}function PA(e){return&quot;/&quot;===e[0]?e.substr(1):e}const OA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=wA(PA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=wA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=PA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;)),s=wA(i);if(null===s)a(new Error(`No such array ${i}`));else{if(&quot;string&quot;===n.dataType){let e=atob(s);r.compression&&(e=yh(mh(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Dm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(AA(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&SA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--IA&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};Vm(&quot;html&quot;,(e=>OA));const{vtkErrorMacro:RA,vtkDebugMacro:MA}=jt;function DA(e){return function(e){return&quot;/&quot;===e[0]?e.substr(1):e}(function(e){return new URL(e,&quot;http://any&quot;).pathname}(e))}const EA=function(e){let t=!1,n=0,r=null,o=&quot;&quot;;var a;return(a=e.zipContent,new Promise(((e,t)=>{&quot;string&quot;==typeof a?e(function(e,t){if(t){for(var n=new Bm(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(hh)return hh.encode(e);var o=e.length,a=new Bm(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new Bm(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return oh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error(&quot;Invalid datatype to unpack.&quot;))}))).then((n=>{r=Ch(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith(&quot;index.json&quot;)&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\\.json$/,&quot;&quot;),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||RA(&quot;ERROR!!! zip not ready...&quot;);const u=DA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join(&quot;/&quot;));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if(&quot;string&quot;!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&(&quot;string&quot;===e.dataType||&quot;JSON&quot;===e.dataType?e.buffer=yh(mh(new Uint8Array(e.buffer))):e.buffer=mh(new Uint8Array(e.buffer)).buffer),&quot;JSON&quot;===e.ref.encode?e.values=JSON.parse(e.buffer):(Ah!==e.ref.encode&&Ah&&(MA(`Swap bytes of ${e.name}`),Ih(e.buffer,vs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&RA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(yh(mh(r))):JSON.parse(r),n()}}(i,s.compression,d);e(yh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];if(a.compression){if(&quot;gz&quot;===a.compression){const e=yh(mh(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error(&quot;Invalid compression&quot;))}return Promise.resolve(JSON.parse(yh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(yh(Ch(s))):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(yh(s))},fetchImage(e,n){const a=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=Mm(i.buffer);n.src=`data:image/${function(e){const t=e.split(&quot;.&quot;).pop().toLowerCase();return&quot;jpg&quot;===t?&quot;jpeg&quot;:t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(mh(s).buffer):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(s.buffer)}}};Vm(&quot;zip&quot;,(e=>EA(e)));var VA=n(892),LA=n.n(VA),BA=n(760),NA=n.n(BA),_A=n(311),FA=n.n(_A),kA=n(192),GA=n.n(kA),UA=n(60),zA=n.n(UA),WA=n(865),HA=n.n(WA),jA=n(34),KA={};KA.styleTagTransform=HA(),KA.setAttributes=GA(),KA.insert=FA().bind(null,&quot;head&quot;),KA.domAPI=NA(),KA.insertStyleElement=zA(),LA()(jA.Z,KA);var $A=jA.Z&&jA.Z.locals?jA.Z.locals:void 0;let qA=!0;function XA(e){e.preventDefault(),e.stopPropagation()}function YA(e,t){qA=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=Hx.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:&quot;100%&quot;,width:&quot;100%&quot;,position:&quot;absolute&quot;}}).getRenderWindow(),o=CA.getSynchronizerContext(),a=CA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement(&quot;div&quot;);n.setAttribute(&quot;class&quot;,$A.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?Mh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Lm(&quot;zip&quot;,{zipContent:t,callback:e=>{r.fetchJSON(null,&quot;index.json&quot;).then(i)}})})):Mh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Lm(&quot;zip&quot;,{zipContent:t.file,callback:t=>{e.fetchJSON(null,&quot;index.json&quot;).then(i)}})}else if(t.base64Str){const e=Dm(t.base64Str),n=Lm(&quot;zip&quot;,{zipContent:e,callback:e=>{n.fetchJSON(null,&quot;index.json&quot;).then(i)}})}}function ZA(e){qA=!1;const t=document.querySelector(&quot;.content&quot;),n=document.querySelector(&quot;body&quot;),r=e||t||n;r!==e?(r.classList.add($A.fullScreen),n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;):(n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;);const o=document.createElement(&quot;div&quot;);o.innerHTML=`<div class=&quot;${$A.bigFileDrop}&quot;/><input type=&quot;file&quot; accept=&quot;.zip,.vtksz&quot; style=&quot;display: none;&quot;/>`,r.appendChild(o);const a=o.querySelector(&quot;input&quot;);function i(e){XA(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(&quot;.&quot;).slice(-1)[0];YA(r,{file:n[0],ext:e})}}a.addEventListener(&quot;change&quot;,i),o.addEventListener(&quot;drop&quot;,i),o.addEventListener(&quot;click&quot;,(e=>a.click())),o.addEventListener(&quot;dragover&quot;,XA)}const QA=Hv();if(QA.url||QA.fileURL){const e=document.querySelector(&quot;.content&quot;),t=document.querySelector(&quot;body&quot;),n=e||t;n&&(n.classList.add($A.fullScreen),t.style.margin=&quot;0&quot;,t.style.padding=&quot;0&quot;),qA=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>YA(n,QA)))}setTimeout((()=>{qA&&ZA()}),100),window.OfflineLocalView={initLocalFileLoader:ZA,load:YA}},793:function(e){&quot;use strict&quot;;e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=&quot;&quot;,r=void 0!==t[5];return t[4]&&(n+=&quot;@supports (&quot;.concat(t[4],&quot;) {&quot;)),t[2]&&(n+=&quot;@media &quot;.concat(t[2],&quot; {&quot;)),r&&(n+=&quot;@layer&quot;.concat(t[5].length>0?&quot; &quot;.concat(t[5]):&quot;&quot;,&quot; {&quot;)),n+=e(t),r&&(n+=&quot;}&quot;),t[2]&&(n+=&quot;}&quot;),t[4]&&(n+=&quot;}&quot;),n})).join(&quot;&quot;)},t.i=function(e,n,r,o,a){&quot;string&quot;==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]=&quot;@layer&quot;.concat(u[5].length>0?&quot; &quot;.concat(u[5]):&quot;&quot;,&quot; {&quot;).concat(u[1],&quot;}&quot;)),u[5]=a),n&&(u[2]?(u[1]=&quot;@media &quot;.concat(u[2],&quot; {&quot;).concat(u[1],&quot;}&quot;),u[2]=n):u[2]=n),o&&(u[4]?(u[1]=&quot;@supports (&quot;.concat(u[4],&quot;) {&quot;).concat(u[1],&quot;}&quot;),u[4]=o):u[4]=&quot;&quot;.concat(o)),t.push(u))}},t}},490:function(e){&quot;use strict&quot;;e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['&quot;].*['&quot;]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/[&quot;'() \\t\\n]|(%20)/.test(e)||t.needQuotes?'&quot;'.concat(e.replace(/&quot;/g,'\\\\&quot;').replace(/\\n/g,&quot;\\\\n&quot;),'&quot;'):e):e}},22:function(e){&quot;use strict&quot;;e.exports=function(e){return e[1]}},145:function(e,t,n){&quot;use strict&quot;;var r=n(426),o=&quot;function&quot;==typeof Symbol&&&quot;symbol&quot;==typeof Symbol(&quot;foo&quot;),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,&quot;x&quot;,{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||&quot;function&quot;==typeof(o=r)&&&quot;[object Function]&quot;===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){&quot;use strict&quot;;e.exports=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;var e;try{e=this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window;if(&quot;object&quot;==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){&quot;use strict&quot;;e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&&quot;object&quot;==typeof t&&&quot;object&quot;==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){&quot;use strict&quot;;&quot;undefined&quot;!=typeof self?e.exports=self:&quot;undefined&quot;!=typeof window?e.exports=window:e.exports=Function(&quot;return this&quot;)()},177:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){&quot;use strict&quot;;var r=n(491);e.exports=function(){return&quot;object&quot;==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,&quot;globalThis&quot;);t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,&quot;globalThis&quot;,{configurable:!0,enumerable:!1,value:e,writable:!0})}else&quot;object&quot;==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){&quot;use strict&quot;;var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},&quot;toString&quot;),c=s.call((function(){}),&quot;prototype&quot;),u=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if(&quot;undefined&quot;==typeof window)return!1;for(var e in window)try{if(!p[&quot;$&quot;+e]&&o.call(window,e)&&null!==window[e]&&&quot;object&quot;==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&&quot;object&quot;==typeof e,n=&quot;[object Function]&quot;===a.call(e),r=i(e),s=t&&&quot;[object String]&quot;===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError(&quot;Object.keys called on a non-object&quot;);var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&&quot;prototype&quot;===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if(&quot;undefined&quot;==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&&quot;constructor&quot;===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){&quot;use strict&quot;;var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){&quot;use strict&quot;;var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r=&quot;[object Arguments]&quot;===n;return r||(r=&quot;[object Array]&quot;!==n&&null!==e&&&quot;object&quot;==typeof e&&&quot;number&quot;==typeof e.length&&e.length>=0&&&quot;[object Function]&quot;===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(&quot; &quot;),n.s1=r(&quot; &quot;),n.s2=r(&quot; &quot;),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+=&quot;\\0&quot;,r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=&quot;&quot;+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,&quot;global&quot;in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&&quot;object&quot;==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:&quot;string&quot;==o?e:e+&quot;\\0&quot;}function v(e,t){for(var n,r=e+&quot;&quot;,o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}(&quot;undefined&quot;!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){&quot;use strict&quot;;var t=[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r=&quot;&quot;;for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join(&quot;&quot;)}function l(e){return/[\\u0080-\\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a(&quot;hello&quot;)),&quot;undefined&quot;==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff=&quot;&quot;,this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){&quot;use strict&quot;;var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,&quot;.viewer-module-fullScreen_bbk9Y {\\n  position: absolute;\\n  width: 100vw;\\n  height: 100vh;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  z-index: -1;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\n\\n.viewer-module-fullParentSize_ETopO {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n}\\n\\n.viewer-module-bigFileDrop_aqCgh {\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  background-color: white;\\n  background-image: url(&quot;+d+&quot;);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n  background-size: contain;\\n  border-radius: 10px;\\n  width: 50px;\\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\\n  cursor: pointer;\\n}\\n\\n.viewer-module-progress_cYjQJ {\\n  flex: none;\\n  font-size: 50px;\\n  color: black;\\n  z-index: 1;\\n  background: rgba(128,128,128,.5);\\n  padding: 20px;\\n  border-radius: 10px;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\n&quot;,&quot;&quot;]),u.locals={fullScreen:&quot;viewer-module-fullScreen_bbk9Y&quot;,fullParentSize:&quot;viewer-module-fullParentSize_ETopO&quot;,bigFileDrop:&quot;viewer-module-bigFileDrop_aqCgh&quot;,progress:&quot;viewer-module-progress_cYjQJ&quot;},t.Z=u},396:function(e,t,n){var r=n(13),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){&quot;use strict&quot;;var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d=&quot;&quot;.concat(c,&quot; &quot;).concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){&quot;use strict&quot;;var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error(&quot;Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.&quot;);r.appendChild(n)}},60:function(e){&quot;use strict&quot;;e.exports=function(e){var t=document.createElement(&quot;style&quot;);return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){&quot;use strict&quot;;e.exports=function(e){var t=n.nc;t&&e.setAttribute(&quot;nonce&quot;,t)}},760:function(e){&quot;use strict&quot;;e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r=&quot;&quot;;n.supports&&(r+=&quot;@supports (&quot;.concat(n.supports,&quot;) {&quot;)),n.media&&(r+=&quot;@media &quot;.concat(n.media,&quot; {&quot;));var o=void 0!==n.layer;o&&(r+=&quot;@layer&quot;.concat(n.layer.length>0?&quot; &quot;.concat(n.layer):&quot;&quot;,&quot; {&quot;)),r+=n.css,o&&(r+=&quot;}&quot;),n.media&&(r+=&quot;}&quot;),n.supports&&(r+=&quot;}&quot;);var a=n.sourceMap;a&&&quot;undefined&quot;!=typeof btoa&&(r+=&quot;\\n/*# sourceMappingURL=data:application/json;base64,&quot;.concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))),&quot; */&quot;)),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){&quot;use strict&quot;;e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){&quot;use strict&quot;;e.exports=n.p+&quot;138e7b1469f64156810a.jpg&quot;},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error(&quot;define cannot be used indirect&quot;)},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;try{return this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){&quot;undefined&quot;!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p=&quot;&quot;,n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();\n<\/script>\n<script>\nvar container = document.querySelector('.content');\nvar base64Str = &quot;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&quot;;\n\nOfflineLocalView.load(container, { base64Str });\n<\/script>\n</body>\n</html>\n\" class=\"pyvista\" style=\"width: 99%; height: 600px; border: 1px solid rgb(221,221,221);\"></iframe>"}}, "d0b4823ee30f4382a63e003d20c56ddf": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {}}, "fc216aa607af42ad88e4162d1606d2ba": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}}, "version_major": 2, "version_minor": 0}
</script></section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="TEAM_13_geometry.html" class="btn btn-neutral float-left" title="Creating the 3D geometry for TEAM problem 13" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="magnetostatics.html" class="btn btn-neutral float-right" title="Magnetostatics solution" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>
   
  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   
</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>