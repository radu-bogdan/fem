

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Computing the current density j in the coil &mdash; FEM  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
      <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
      <script src="../_static/jquery.js"></script>
      <script src="../_static/underscore.js"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script src="../_static/doctools.js"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../_static/iframe_stuff.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Magnetostatics solution" href="magnetostatics.html" />
    <link rel="prev" title="Creating the 3D geometry for TEAM problem 13" href="TEAM_13_geometry.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            FEM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">TEAM 13</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="TEAM_13_geometry.html">Creating the 3D geometry for TEAM problem 13</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Computing the current density j in the coil</a></li>
<li class="toctree-l1"><a class="reference internal" href="magnetostatics.html">Magnetostatics solution</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">FEM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Computing the current density j in the coil</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/notebooks/current_density.ipynb" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Computing-the-current-density-j-in-the-coil">
<h1>Computing the current density j in the coil<a class="headerlink" href="#Computing-the-current-density-j-in-the-coil" title="Permalink to this heading">¶</a></h1>
<p><span class="math notranslate nohighlight">\(\def\curl{\operatorname{curl}}\def\Curl{\operatorname{Curl}}\def\div{\operatorname{div}}\)</span> Before we solve the non-linear magnetostatic problem, we first need to find the current <span class="math notranslate nohighlight">\(j\)</span> flowing inside the coil <span class="math notranslate nohighlight">\(\Omega_c\)</span>.</p>
<p>The first property is that <span class="math notranslate nohighlight">\(j\)</span> is solenoidal, i.e. <span class="math notranslate nohighlight">\(\div(j)=0\)</span>. Further, we presume the existence of a potential <span class="math notranslate nohighlight">\(\phi\)</span> with <span class="math notranslate nohighlight">\(j=-\sigma\nabla\phi\)</span>, where <span class="math notranslate nohighlight">\(\sigma\)</span> denotes the connectivity. As for the boundary conditions, we prescribe <span class="math notranslate nohighlight">\(n\cdot j = -\sigma\partial_n\phi=0\)</span> on the exterior boundary <span class="math notranslate nohighlight">\(\Gamma_{ex}\)</span>, and <span class="math notranslate nohighlight">\(\phi=1\)</span> and <span class="math notranslate nohighlight">\(\phi=0\)</span> on the inflow <span class="math notranslate nohighlight">\(\Gamma_{in}\)</span> and outflow boundary <span class="math notranslate nohighlight">\(\Gamma_{out}\)</span>, respectively. Altogether, we
have</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
j + \sigma\nabla\phi &amp;= 0 \qquad\text{on }\Omega_c \\
\div j &amp;=0  \qquad\text{on }\Omega_c \\
n\cdot j = \sigma\partial_n\phi &amp;= 0 \qquad\text{on }\Gamma_{ex} \\
j &amp;= 0 \qquad\text{on }\Gamma_{out} \\
j &amp;= 1 \qquad\text{on }\Gamma_{in}
\end{align}\end{split}\]</div>
<p>However, in our case, the coil is a loop with no inflow or outflow boundary. This is where the face “coil_cut_1” we defined in the geometry comes into play. For this purpose, we have to introduce “fictitious” points and introduce a clone of the face “coil_cut_1” in order to be able to prescribe the necessary boundary conditions.</p>
<p>We begin by loading the geometry and the mesh generated in the previous document</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%capture</span>
<span class="o">%</span><span class="n">run</span> <span class="n">TEAM_13_geometry</span><span class="o">.</span><span class="n">ipynb</span>
</pre></div>
</div>
</div>
<p>Create the MESH object from the mesh generated by netgen</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;../../../&#39;</span><span class="p">)</span> <span class="c1"># adds parent directory</span>
<span class="kn">import</span> <span class="nn">pde</span>
<span class="n">MESH</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">mesh3</span><span class="o">.</span><span class="n">netgen</span><span class="p">(</span><span class="n">geoOCCmesh</span><span class="p">)</span>
<span class="n">MESH</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
np:4132, nt:23369, nf:3059, ne:720, nf_all:46966, ne_all:27728
</pre></div></div>
</div>
<p>The piece of code below duplicates the face, as described above, and generates a new MESH object.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1">##############################################################################</span>

<span class="n">face_index</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">getIndices</span><span class="p">(</span><span class="n">MESH</span><span class="o">.</span><span class="n">regions_2d</span><span class="p">,</span><span class="s1">&#39;coil_cut_1&#39;</span><span class="p">)</span>
<span class="n">faces</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">MESH</span><span class="o">.</span><span class="n">BoundaryFaces_Region</span> <span class="o">==</span> <span class="n">face_index</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">new_faces</span> <span class="o">=</span> <span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">points_to_duplicate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
<span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">MESH</span><span class="o">.</span><span class="n">np</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">np</span><span class="o">+</span><span class="n">points_to_duplicate</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

<span class="n">actual_points</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">points_to_duplicate</span><span class="p">,:]</span>

<span class="n">t_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">t</span><span class="p">[:,:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">p_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">f_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">pnt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points_to_duplicate</span><span class="p">):</span>

    <span class="c1"># append point to list</span>
    <span class="n">p_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">p_new</span><span class="p">,</span><span class="n">p_new</span><span class="p">[</span><span class="n">pnt</span><span class="p">,:]])</span>

    <span class="c1"># finding tets coordinates containing the ith point to duplicate</span>
    <span class="n">tets_containing_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">t_new</span><span class="p">[:,:</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="n">pnt</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tets_containing_points</span><span class="p">):</span>
        <span class="c1">#check if tet is left</span>
        <span class="k">if</span> <span class="n">MESH</span><span class="o">.</span><span class="n">mp_tet</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">t_new</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">t_new</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">==</span><span class="n">pnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">np</span> <span class="o">+</span> <span class="n">i</span>

<span class="n">t_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">t_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">t</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">faces</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
    <span class="n">new_faces</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_points</span><span class="p">[</span><span class="n">points_to_duplicate</span><span class="o">==</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="n">new_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">new_faces</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">f_new</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,(</span><span class="n">new_faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))]</span>
<span class="n">f_new</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">f_new</span><span class="p">,</span><span class="n">new_faces</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

<span class="n">regions_2d_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">regions_2d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">regions_2d_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;new&#39;</span><span class="p">)</span>

<span class="n">identifications</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">points_to_duplicate</span><span class="p">,</span><span class="n">new_points</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="c1"># stop</span>
<span class="n">MESH</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">mesh3</span><span class="p">(</span><span class="n">p_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">e</span><span class="p">,</span><span class="n">f_new</span><span class="p">,</span><span class="n">t_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">regions_3d</span><span class="p">,</span><span class="n">regions_2d_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">regions_1d</span><span class="p">,</span><span class="n">identifications</span> <span class="o">=</span> <span class="n">identifications</span><span class="p">)</span>
<span class="n">MESH</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
np:4149, nt:23369, nf:3076, ne:720, nf_all:47028, ne_all:27806
</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">DB</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assembleB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">N1</span><span class="p">,</span><span class="n">N2</span><span class="p">,</span><span class="n">N3</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assembleN3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">unit_coil</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluate3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">regions</span> <span class="o">=</span> <span class="s1">&#39;coil&#39;</span><span class="p">)</span>

<span class="n">face_in_1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluateB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;coil_cut_1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">face_in_2</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluateB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">0</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;coil_cut_1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">face_in_3</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluateB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">0</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;coil_cut_1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

<span class="c1">###########################################################################</span>

<span class="n">phi_H1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">dphix_H1</span><span class="p">,</span> <span class="n">dphiy_H1</span><span class="p">,</span> <span class="n">dphiz_H1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">phiB_H1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assembleB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">phi_H1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>

<span class="n">R0</span><span class="p">,</span> <span class="n">RS0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assembleR3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;new,coil_cut_1&#39;</span><span class="p">)</span>
<span class="n">R1</span><span class="p">,</span> <span class="n">RS1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assembleR3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;coil_cut_1&#39;</span><span class="p">)</span>

<span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">face_in_1</span><span class="o">*</span><span class="n">N1</span> <span class="o">+</span> <span class="n">face_in_2</span><span class="o">*</span><span class="n">N2</span> <span class="o">+</span> <span class="n">face_in_3</span><span class="o">*</span><span class="n">N3</span><span class="p">)</span> <span class="o">@</span> <span class="n">DB</span> <span class="o">@</span> <span class="n">phiB_H1</span><span class="o">.</span><span class="n">T</span>

<span class="n">M</span> <span class="o">=</span> <span class="n">phi_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">phi_H1</span><span class="o">.</span><span class="n">T</span>

<span class="n">K</span> <span class="o">=</span> <span class="n">dphix_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">dphix_H1</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>\
    <span class="n">dphiy_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">dphiy_H1</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>\
    <span class="n">dphiz_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">dphiz_H1</span><span class="o">.</span><span class="n">T</span>

<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">RS0</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">R1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">R1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">RS0</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">RS0</span><span class="o">.</span><span class="n">T</span>


<span class="n">RZ</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">removeZeros</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">RZ</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">RZ</span><span class="o">.</span><span class="n">T</span>

<span class="c1"># M = RS0 @ M @ RS0.T</span>
<span class="c1"># M = RZ @ M @ RZ.T</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">RZ</span> <span class="o">@</span> <span class="n">r</span>

<span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span><span class="c1">#58.7e6</span>
<span class="kn">from</span> <span class="nn">sksparse.cholmod</span> <span class="kn">import</span> <span class="n">cholesky</span> <span class="k">as</span> <span class="n">chol</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">chol</span><span class="p">(</span><span class="n">sigma</span><span class="o">*</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">solve_A</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">RS0</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">RZ</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">x</span> <span class="o">+</span> <span class="n">R1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">R1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="c1"># MESH.pdesurf(x, faces = &#39;coil_face&#39;)</span>

<span class="n">dx_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">dphix_H1</span><span class="o">.</span><span class="n">T</span><span class="nd">@x</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">dy_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">dphiy_H1</span><span class="o">.</span><span class="n">T</span><span class="nd">@x</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">dz_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">dphiz_H1</span><span class="o">.</span><span class="n">T</span><span class="nd">@x</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

<span class="n">dphix_H1_P0</span><span class="p">,</span> <span class="n">dphiy_H1_P0</span><span class="p">,</span> <span class="n">dphiz_H1_P0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">unit_coil_P0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluate3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">regions</span> <span class="o">=</span> <span class="s1">&#39;coil&#39;</span><span class="p">)</span>
<span class="n">dx_x_P0</span> <span class="o">=</span> <span class="p">(</span><span class="n">dphix_H1_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@x</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">dy_x_P0</span> <span class="o">=</span> <span class="p">(</span><span class="n">dphiy_H1_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@x</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">dz_x_P0</span> <span class="o">=</span> <span class="p">(</span><span class="n">dphiz_H1_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@x</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<br/></pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">createVTK</span><span class="p">(</span><span class="n">MESH</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">add_H1_Scalar</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">add_L2_Vector</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">dx_x_P0</span><span class="p">,</span><span class="n">dy_x_P0</span><span class="p">,</span><span class="n">dz_x_P0</span><span class="p">,</span><span class="s1">&#39;grad_J&#39;</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">writeVTK</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="s1">&#39;current_density.vtu&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(4149,)
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;current_density.vtu&#39;</span><span class="p">)</span>
<span class="n">mesh</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<table style='width: 100%;'><tr><th>Header</th><th>Data Arrays</th></tr><tr><td>
<table style='width: 100%;'>
<tr><th>UnstructuredGrid</th><th>Information</th></tr>
<tr><td>N Cells</td><td>23369</td></tr>
<tr><td>N Points</td><td>4149</td></tr>
<tr><td>X Bounds</td><td>-2.000e+02, 2.000e+02</td></tr>
<tr><td>Y Bounds</td><td>-2.000e+02, 2.000e+02</td></tr>
<tr><td>Z Bounds</td><td>-1.000e+02, 1.000e+02</td></tr>
<tr><td>N Arrays</td><td>3</td></tr>
</table>

</td><td>
<table style='width: 100%;'>
<tr><th>Name</th><th>Field</th><th>Type</th><th>N Comp</th><th>Min</th><th>Max</th></tr>
<tr><td>J</td><td>Points</td><td>float32</td><td>1</td><td>0.000e+00</td><td>1.000e+00</td></tr>
<tr><td><b>Scalars_</b></td><td>Cells</td><td>float64</td><td>1</td><td>0.000e+00</td><td>5.000e+00</td></tr>
<tr><td>grad_J</td><td>Cells</td><td>float32</td><td>3</td><td>-2.123e-03</td><td>2.110e-03</td></tr>
</table>

</td></tr> </table></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># mesh.plot(jupyter_backend=&#39;html&#39;)</span>
<span class="c1"># mesh.export_html(&#39;kek.html&#39;)</span>
<span class="c1"># p.add_mesh(mesh, style=&#39;wireframe&#39;, color=&#39;blue&#39;, label=None)</span>
<span class="c1"># p.add_mesh(mesh, label=&#39;Clipped&#39;)</span>
<span class="c1"># clipped = mesh.clip_scalar(scalars=&quot;Scalars_&quot;, value=1, invert=True)</span>





<span class="c1"># sample_function(</span>
<span class="c1">#     noise, [0, 1.0, -0, 1.0, 0, 1.0], dim=(20, 20, 20)</span>

<span class="c1"># clipped = mesh.threshold(value=1)</span>
<span class="c1"># # p.add_legend()</span>




<span class="c1"># plotter = pv.Plotter()</span>
<span class="c1"># plotter.add_mesh(mesh.clip_scalar(scalars=&quot;Scalars_&quot;, value=100, invert=True), opacity=0.8)</span>
<span class="c1"># # plotter.show_axes()</span>
<span class="c1"># plotter.show(jupyter_backend=&#39;html&#39;)</span>

<span class="c1"># p.add_mesh(clipped, label=&#39;Clipped&#39;)</span>
<span class="c1"># p.add_legend()</span>
<span class="c1"># p.camera_position = [(0.24, 0.32, 0.7), (0.02, 0.03, -0.02), (-0.12, 0.93, -0.34)]</span>

<span class="c1"># threshed.plot(jupyter_backend=&#39;html&#39;,show_edges=True,color=&quot;w&quot;)</span>

<span class="c1"># mesh[&quot;grad_J&quot;] = mesh[&quot;grad_J&quot;]</span>

<span class="n">mesh</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;Scalars_&quot;</span><span class="p">)</span>
<span class="n">threshed</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">threshold</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
<span class="n">threshed</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;J&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">threshed</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;surface&#39;</span><span class="p">,</span> <span class="n">opacity</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="n">threshed</span><span class="o">.</span><span class="n">set_active_vectors</span><span class="p">(</span><span class="s2">&quot;grad_J&quot;</span><span class="p">)</span>
<span class="n">arrows</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">glyph</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="s2">&quot;grad_J&quot;</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">9500.0</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">arrows</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">camera_position</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">600</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="n">p</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">jupyter_backend</span><span class="o">=</span><span class="s1">&#39;html&#39;</span><span class="p">)</span>
<br/><br/><br/><br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "c870b6facb9643f5b0cde43bf00a6e91", "version_major": 2, "version_minor": 0}</script></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
<script type="application/vnd.jupyter.widget-state+json">
{"state": {"2679a50822ca4d5b9b2f57b39177c15c": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {}}, "4a57ef32fb2b46ddb4829193a0063348": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_2679a50822ca4d5b9b2f57b39177c15c", "style": "IPY_MODEL_cf66e838c0ab4227b4bd9e5defb3e8c9", "value": "<iframe srcdoc=\"<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;/>\n    <meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;>\n  </head>\n  <body>\n    <div class=&quot;content&quot;></div>\n<script type=&quot;text/javascript&quot;>\n!function(){var e={334:function(){const e=document.querySelector(&quot;head&quot;);e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement(&quot;link&quot;);n.setAttribute(&quot;rel&quot;,&quot;icon&quot;),n.setAttribute(&quot;href&quot;,`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute(&quot;sizes&quot;,`${t}x${t}`),n.setAttribute(&quot;type&quot;,&quot;image/png&quot;),e.appendChild(n)}))},13:function(e,t,n){&quot;use strict&quot;;n.r(t),n.d(t,{initLocalFileLoader:function(){return ZA},load:function(){return YA}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return E},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return D},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ee},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return De},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i=&quot;undefined&quot;!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],D=r[2],E=Math.hypot(R,M,D);return E<a?null:(R*=E=1/E,M*=E,D*=E,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+D*o,C=D*R*s-M*o,S=R*M*s-D*o,A=M*M*s+i,I=D*M*s+R*o,w=R*D*s+M*o,P=M*D*s-R*o,O=D*D*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),E(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,D=(1-(p+v))*C,E=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=D,e[6]=E,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+D*I+L*w),e[14]=n[2]+w-(R*A+E*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return&quot;mat4(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;, &quot;+e[9]+&quot;, &quot;+e[10]+&quot;, &quot;+e[11]+&quot;, &quot;+e[12]+&quot;, &quot;+e[13]+&quot;, &quot;+e[14]+&quot;, &quot;+e[15]+&quot;)&quot;}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],D=t[12],E=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-D)<=a*Math.max(1,Math.abs(m),Math.abs(D))&&Math.abs(h-E)<=a*Math.max(1,Math.abs(h),Math.abs(E))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return&quot;mat3(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;)&quot;}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function De(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=De,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error(&quot;Invalid VTK object&quot;),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&&quot;object&quot;==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol(&quot;void&quot;),$e={};function qe(){}[&quot;log&quot;,&quot;debug&quot;,&quot;info&quot;,&quot;warn&quot;,&quot;error&quot;,&quot;time&quot;,&quot;timeEnd&quot;,&quot;group&quot;,&quot;groupEnd&quot;].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty(&quot;log&quot;)?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st(&quot;_&quot;===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=[&quot;TB&quot;,&quot;GB&quot;,&quot;MB&quot;,&quot;KB&quot;];let o=Number(e),a=&quot;B&quot;;for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot; &quot;;const n=[];let r=e;for(;r>1e3;)n.push((&quot;000&quot;+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),&quot;classHierarchy&quot;in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He(&quot;vtkObject&quot;);function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==[&quot;mtime&quot;].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||&quot;_&quot;===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(&quot;, &quot;)}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if(&quot;object&quot;==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(&quot;string&quot;==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError(&quot;Set Enum with invalid string argument&quot;)}if(&quot;number&quot;==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError(&quot;Set Enum outside numeric range&quot;)}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError(&quot;Set Enum with invalid argument (String/Number)&quot;)}},object(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(!ke()(t[n.name],o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}return!1}}};function Ct(e){if(&quot;object&quot;==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError(&quot;No setter for field&quot;)}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{&quot;object&quot;==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et(&quot;instance deleted - cannot call any method&quot;);else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=&quot; input ports. To add more input ports, use addInputConnection()&quot;,void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et(&quot;instance deleted - cannot call any method&quot;),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):o(e,i())},e.addInputConnection=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:&quot;Scalars&quot;;for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol(&quot;Event abort&quot;);function Dt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et(&quot;instance deleted - cannot call any method&quot;);const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA(&quot;vtkObject&quot;)}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt=&quot;__root__&quot;;function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=&quot;&quot;+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,[&quot;proxyId&quot;,&quot;proxyGroup&quot;,&quot;proxyName&quot;]),At(e,t,[&quot;proxyManager&quot;]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if(&quot;application&quot;===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,&quot;application&quot;),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return&quot;detail&quot;in e&&(n=e.detail),&quot;wheelDelta&quot;in e&&(n=-e.wheelDelta/120),&quot;wheelDeltaY&quot;in e&&(n=-e.wheelDeltaY/120),&quot;wheelDeltaX&quot;in e&&(t=-e.wheelDeltaX/120),&quot;axis&quot;in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,&quot;deltaY&quot;in e&&(o=e.deltaY),&quot;deltaX&quot;in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Dt,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Et,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Dt,newInstance:Et,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push(&quot;vtkViewNode&quot;),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)r.setVisited(!0);else{const r=e.createViewNode(n);r&&(r.setParent(e),r.setVisited(!0),t._renderableChildMap.set(n,r),t.children.push(r))}},e.addMissingNodes=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r],a=t._renderableChildMap.get(o);if(void 0!==a)a.setVisited(!0);else{const n=e.createViewNode(o);n&&(n.setParent(e),n.setVisited(!0),t._renderableChildMap.set(o,n),t.children.push(n))}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];-1===t.children.indexOf(o)&&(o.setParent(e),t.children.push(o)),o.setVisited(!0)}},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t(&quot;Cannot create view nodes without my own factory&quot;),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),t._renderableChildMap=new Map,jt.get(e,t,[&quot;visited&quot;]),jt.setGet(e,t,[&quot;_parent&quot;,&quot;renderable&quot;,&quot;myFactory&quot;]),jt.getArray(e,t,[&quot;children&quot;]),jt.moveToProtected(e,t,[&quot;parent&quot;]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,&quot;vtkViewNode&quot;),extend:Yt,PASS_TYPES:[&quot;Build&quot;,&quot;Render&quot;]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push(&quot;vtkViewNodeFactory&quot;),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s},e.registerOverride=(e,n)=>{t.overrides[e]=n}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,&quot;vtkViewNodeFactory&quot;),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push(&quot;vtkOpenGLViewNodeFactory&quot;)}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,&quot;vtkOpenGLViewNodeFactory&quot;),extend:sn};function cn(e,t){t.classHierarchy.push(&quot;vtkOpenGLCamera&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,[&quot;context&quot;,&quot;keyMatrixTime&quot;]),cn(e,t)}));rn(&quot;vtkCamera&quot;,dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderer&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn(&quot;No lights are on, creating one.&quot;),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();t.context.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,[&quot;shaderCache&quot;]),At(e,t,[&quot;selector&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),fn(e,t)}),&quot;vtkOpenGLRenderer&quot;);function hn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor&quot;),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkRenderer&quot;,mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor2D&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn(&quot;vtkActor&quot;,yn);const bn={context:null,activeTextures:null};const xn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function Dn(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function En(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn(&quot;vtkActor2D&quot;,xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn=&quot;\\\\s*([+-]?\\\\d+)\\\\s*&quot;,Jn=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*&quot;,er=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*&quot;,tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\\\(${Qn},${Qn},${Qn}\\\\)$`),rr=new RegExp(`^rgb\\\\(${er},${er},${er}\\\\)$`),or=new RegExp(`^rgba\\\\(${Qn},${Qn},${Qn},${Jn}\\\\)$`),ar=new RegExp(`^rgba\\\\(${er},${er},${er},${Jn}\\\\)$`),ir=new RegExp(`^hsl\\\\(${Jn},${er},${er}\\\\)$`),sr=new RegExp(`^hsla\\\\(${Jn},${er},${er},${Jn}\\\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+&quot;&quot;).trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):&quot;transparent&quot;===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?&quot;rgb(&quot;:&quot;rgba(&quot;}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?&quot;)&quot;:`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?&quot;0&quot;:&quot;&quot;)+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?&quot;hsl(&quot;:&quot;hsla(&quot;}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?&quot;)&quot;:`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Dr=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+&quot;&quot;}}return r.gamma=e,r}(1);function Er(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+&quot;&quot;}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&&quot;object&quot;==typeof e||(e={}),null!==t&&&quot;object&quot;==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Er((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Er((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,Fr=new RegExp(_r.source,&quot;g&quot;);function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+=&quot;&quot;,t+=&quot;&quot;;(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+&quot;&quot;}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join(&quot;&quot;)})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||&quot;boolean&quot;===r?Rr(t):(&quot;number&quot;===r?Br:&quot;string&quot;===r?(n=dr(t))?(t=n,Dr):kr:t instanceof dr?Dr:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:&quot;function&quot;!=typeof t.valueOf&&&quot;function&quot;!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error(&quot;invalid format: &quot;+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?&quot; &quot;:e.fill+&quot;&quot;,this.align=void 0===e.align?&quot;>&quot;:e.align+&quot;&quot;,this.sign=void 0===e.sign?&quot;-&quot;:e.sign+&quot;&quot;,this.symbol=void 0===e.symbol?&quot;&quot;:e.symbol+&quot;&quot;,this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?&quot;&quot;:e.type+&quot;&quot;}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf(&quot;e&quot;))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1];return o<0?&quot;0.&quot;+new Array(-o).join(&quot;0&quot;)+r:r.length>o+1?r.slice(0,o+1)+&quot;.&quot;+r.slice(o+1):r+new Array(o-r.length+2).join(&quot;0&quot;)}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?&quot;0&quot;:&quot;&quot;)+(void 0===this.width?&quot;&quot;:Math.max(1,0|this.width))+(this.comma?&quot;,&quot;:&quot;&quot;)+(void 0===this.precision?&quot;&quot;:&quot;.&quot;+Math.max(0,0|this.precision))+(this.trim?&quot;~&quot;:&quot;&quot;)+this.type};var ao={&quot;%&quot;:(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+&quot;&quot;,d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString(&quot;en&quot;).replace(/,/g,&quot;&quot;):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join(&quot;0&quot;):a>0?r.slice(0,a)+&quot;.&quot;+r.slice(a):&quot;0.&quot;+new Array(1-a).join(&quot;0&quot;)+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=[&quot;y&quot;,&quot;z&quot;,&quot;a&quot;,&quot;f&quot;,&quot;p&quot;,&quot;n&quot;,&quot;\u00b5&quot;,&quot;m&quot;,&quot;&quot;,&quot;k&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;,&quot;Z&quot;,&quot;Y&quot;];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?&quot;,f&quot;:r)).type){case&quot;s&quot;:var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case&quot;&quot;:case&quot;e&quot;:case&quot;g&quot;:case&quot;p&quot;:case&quot;r&quot;:null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-(&quot;e&quot;===r.type));break;case&quot;f&quot;:case&quot;%&quot;:null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*(&quot;%&quot;===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+&quot;&quot;,function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?&quot;&quot;:e.currency[0]+&quot;&quot;,a=void 0===e.currency?&quot;&quot;:e.currency[1]+&quot;&quot;,i=void 0===e.decimal?&quot;.&quot;:e.decimal+&quot;&quot;,s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?&quot;%&quot;:e.percent+&quot;&quot;,c=void 0===e.minus?&quot;\u2212&quot;:e.minus+&quot;&quot;,u=void 0===e.nan?&quot;NaN&quot;:e.nan+&quot;&quot;;function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;&quot;n&quot;===y?(m=!0,y=&quot;g&quot;):ao[y]||(void 0===h&&(h=12),v=!0,y=&quot;g&quot;),(f||&quot;0&quot;===t&&&quot;=&quot;===n)&&(f=!0,t=&quot;0&quot;,n=&quot;=&quot;);var T=&quot;$&quot;===p?o:&quot;#&quot;===p&&/[boxX]/.test(y)?&quot;0&quot;+y.toLowerCase():&quot;&quot;,b=&quot;$&quot;===p?a:/[%p]/.test(y)?l:&quot;&quot;,x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if(&quot;c&quot;===y)S=x(e)+S,e=&quot;&quot;;else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case&quot;.&quot;:o=t=r;break;case&quot;0&quot;:0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&&quot;+&quot;!==d&&(A=!1),p=(A?&quot;(&quot;===d?d:c:&quot;-&quot;===d||&quot;(&quot;===d?&quot;&quot;:d)+p,S=(&quot;s&quot;===y?po[8+Qr/3]:&quot;&quot;)+S+(A&&&quot;(&quot;===d?&quot;)&quot;:&quot;&quot;),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):&quot;&quot;;switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=&quot;&quot;),n){case&quot;<&quot;:e=p+e+S+w;break;case&quot;=&quot;:e=p+w+e+S;break;case&quot;^&quot;:e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+&quot;&quot;},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type=&quot;f&quot;,e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:&quot;,&quot;,grouping:[3],currency:[&quot;$&quot;,&quot;&quot;]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Do,ceil:Eo,min:Vo,max:Lo}=Math;const Bo=Ao(&quot;ceilLog2&quot;),No=Ao(&quot;factorial&quot;);function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao(&quot;gaussian&quot;);function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes(&quot;e&quot;))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split(&quot;e&quot;);let r=&quot;&quot;;return+n[1]+t>0&&(r=&quot;+&quot;),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co(&quot;vtkMath::Jacobi: Error extracting eigenfunctions&quot;),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co(&quot;Unable to factor linear system&quot;),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co(&quot;Unable to factor linear system&quot;),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Da(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Ea=Ao(&quot;GetScalarTypeFittingRange&quot;),Va=Ao(&quot;GetAdjustedScalarRange&quot;);const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Do,ceil:Eo,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo(&quot;Number of columns of A must match number of rows of B.&quot;);const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co(&quot;Matrix has 0 determinant&quot;),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co(&quot;Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()&quot;),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Da,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Ea,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;#&quot;;return`${t}${e.map(Ga).join(&quot;&quot;)}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(&quot;, &quot;)})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};const Wa=1e-6,Ha=&quot;coincide&quot;,ja=&quot;disjoint&quot;;function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?&quot;x&quot;:i[1]>i[2]?&quot;y&quot;:&quot;z&quot;;const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case&quot;x&quot;:l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case&quot;y&quot;:l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case&quot;z&quot;:l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha};function Ja(e,t){t.classHierarchy.push(&quot;vtkPlane&quot;),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}const ei={normal:[0,0,1],origin:[0,0,0]};function ti(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ei,n),jt.obj(e,t),jt.setGetArray(e,t,[&quot;normal&quot;,&quot;origin&quot;],3),Ja(e,t)}var ni={newInstance:jt.newInstance(ti,&quot;vtkPlane&quot;),extend:ti,...Qa};const ri=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function oi(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ai(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ii(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function si(e){return ii(e,ri)}function li(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function ci(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)li(e,...t[n]);else for(let n=0;n<t.length;n+=3)li(e,...t.slice(n,n+3));return e}function ui(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function fi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function gi(e,t,n,r){return!!ai(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function mi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function hi(e,t){return e[2*t+1]-e[2*t]}function vi(e){return[hi(e,0),hi(e,1),hi(e,2)]}function yi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function bi(e){return e.slice(4,6)}function xi(e){const t=vi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function Ci(e){if(ai(e)){const t=vi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Si(e){return[e[0],e[2],e[4]]}function Ai(e){return[e[1],e[3],e[5]]}function Ii(e,t){return e<=0&&t>=0||e>=0&&t<=0}function wi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Pi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=wi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return si(n),ci(n,r)}function Ri(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Mi(e,t,n,r){const o=[].concat(ri),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Di(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ni.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!ai(e)||!ai(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Li(e,t){if(!ai(e)||!ai(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Bi(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Ni(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ni.evaluate(n,t,l)}let i=2;for(;i--&&!(Ii(o[r[i][0]],o[r[i][4]])&&Ii(o[r[i][1]],o[r[i][5]])&&Ii(o[r[i][2]],o[r[i][6]])&&Ii(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class _i{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ri))}getBounds(){return this.bounds}equals(e){return oi(this.bounds,e)}isValid(){return ai(this.bounds)}setBounds(e){return ii(this.bounds,e)}reset(){return si(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return li(this.bounds,...t)}addPoints(e){return ci(this.bounds,e)}addBounds(e,t,n,r,o,a){return ui(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return di(this.bounds,e,t,n)}setMaxPoint(e,t,n){return pi(this.bounds,e,t,n)}inflate(e){return fi(this.bounds,e)}scale(e,t,n){return gi(this.bounds,e,t,n)}getCenter(){return mi(this.bounds)}getLength(e){return hi(this.bounds,e)}getLengths(){return vi(this.bounds)}getMaxLength(){return xi(this.bounds)}getDiagonalLength(){return Ci(this.bounds)}getMinPoint(){return Si(this.bounds)}getMaxPoint(){return Ai(this.bounds)}getXRange(){return yi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return bi(this.bounds)}getCorners(e){return wi(this.bounds,e)}computeCornerPoints(e,t){return Pi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Mi(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Ri(this.bounds,e)}cutWithPlane(e,t){return Ni(this.bounds,e,t)}intersectBox(e,t,n,r){return Di(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Li(this.bounds,e)}containsPoint(e,t,n){return Bi(this.bounds,e,t,n)}contains(e){return Li(this.bounds,e)}}var Fi,ki={newInstance:function(e){const t=e&&e.bounds;return new _i(t)},equals:oi,isValid:ai,setBounds:ii,reset:si,addPoint:li,addPoints:ci,addBounds:ui,setMinPoint:di,setMaxPoint:pi,inflate:fi,scale:gi,scaleAboutCenter:function(e,t,n,r){if(!ai(e))return!1;const o=mi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],gi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:mi,getLength:hi,getLengths:vi,getMaxLength:xi,getDiagonalLength:Ci,getMinPoint:Si,getMaxPoint:Ai,getXRange:yi,getYRange:Ti,getZRange:bi,getCorners:wi,computeCornerPoints:Pi,computeLocalBounds:Mi,transformBounds:Oi,computeScale3:Ri,cutWithPlane:Ni,intersectBox:Di,intersectPlane:Ei,intersect:Vi,intersects:Li,containsPoint:Bi,contains:function(e,t){return!!Li(e,t)&&!!Bi(e,...Si(t))&&!!Bi(e,...Ai(t))},INIT_BOUNDS:ri};function Gi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Ui(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function zi(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function Wi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Fi=new i(4),i!=Float32Array&&(Fi[0]=0,Fi[1]=0,Fi[2]=0,Fi[3]=0);var Hi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),Ui(),Ui(),ie();var ji={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Ki}=ji;function $i(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function qi(e,t){t.classHierarchy.push(&quot;vtkProp&quot;),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=$i(&quot;pick&quot;),e.hasKey=$i(&quot;hasKey&quot;),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Ki.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Ki.DISPLAY)}const Xi={allocatedRenderTime:10,coordinateSystem:Ki.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function Yi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xi,n),jt.obj(e,t),jt.get(e,t,[&quot;estimatedRenderTime&quot;,&quot;allocatedRenderTime&quot;]),jt.setGet(e,t,[&quot;_parentProp&quot;,&quot;coordinateSystem&quot;,&quot;dragable&quot;,&quot;pickable&quot;,&quot;renderTimeMultiplier&quot;,&quot;useBounds&quot;,&quot;visibility&quot;]),jt.moveToProtected(e,t,[&quot;parentProp&quot;]),qi(e,t)}var Zi={newInstance:jt.newInstance(Yi,&quot;vtkProp&quot;),extend:Yi,...ji};function Qi(e,t){t.classHierarchy.push(&quot;vtkProp3D&quot;),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Ui();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=Ui();zi(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>ki.getCenter(t.bounds),e.getLength=()=>ki.getLength(t.bounds),e.getXRange=()=>ki.getXRange(t.bounds),e.getYRange=()=>ki.getYRange(t.bounds),e.getZRange=()=>ki.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const Ji={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Zi.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,[&quot;bounds&quot;,&quot;isIdentity&quot;]),jt.getArray(e,t,[&quot;orientation&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;position&quot;,&quot;scale&quot;],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,Qi(e,t)}var ts={newInstance:jt.newInstance(es,&quot;vtkProp3D&quot;),extend:es};const ns={FLAT:0,GOURAUD:1,PHONG:2},rs={POINTS:0,WIREFRAME:1,SURFACE:2};var os={Shading:ns,Representation:rs,Interpolation:ns};const{Representation:as,Interpolation:is}=os;function ss(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ls(e,t){t.classHierarchy.push(&quot;vtkProperty&quot;),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ss(&quot;ComputeCompositeColor&quot;),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ss(&quot;AddShaderVariable&quot;),e.setInterpolationToFlat=()=>e.setInterpolation(is.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(is.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(is.PHONG),e.getInterpolationAsString=()=>jt.enumToString(is,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(as.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(as.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(as.POINTS),e.getRepresentationAsString=()=>jt.enumToString(as,t.representation)}const cs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:is.GOURAUD,representation:as.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function us(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cs,n),jt.obj(e,t),jt.setGet(e,t,[&quot;lighting&quot;,&quot;interpolation&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;metallic&quot;,&quot;roughness&quot;,&quot;normalStrength&quot;,&quot;emission&quot;,&quot;baseIOR&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;opacity&quot;,&quot;edgeVisibility&quot;,&quot;lineWidth&quot;,&quot;pointSize&quot;,&quot;backfaceCulling&quot;,&quot;frontfaceCulling&quot;,&quot;representation&quot;,&quot;diffuseTexture&quot;,&quot;metallicTexture&quot;,&quot;roughnessTexture&quot;,&quot;normalTexture&quot;,&quot;ambientOcclusionTexture&quot;,&quot;emissionTexture&quot;]),jt.setGetArray(e,t,[&quot;ambientColor&quot;,&quot;specularColor&quot;,&quot;diffuseColor&quot;,&quot;edgeColor&quot;],3),ls(e,t)}var ds={newInstance:jt.newInstance(us,&quot;vtkProperty&quot;),extend:us,...os};const{vtkDebugMacro:ps}=jt;function fs(e,t){t.classHierarchy.push(&quot;vtkActor&quot;);const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ds.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){ps(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.concat();const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const gs={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gs,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;backfaceProperty&quot;,&quot;forceOpaque&quot;,&quot;forceTranslucent&quot;,&quot;mapper&quot;]),fs(e,t)}var hs={newInstance:jt.newInstance(ms,&quot;vtkActor&quot;),extend:ms};const vs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},ys={VOID:&quot;&quot;,CHAR:&quot;Int8Array&quot;,SIGNED_CHAR:&quot;Int8Array&quot;,UNSIGNED_CHAR:&quot;Uint8Array&quot;,SHORT:&quot;Int16Array&quot;,UNSIGNED_SHORT:&quot;Uint16Array&quot;,INT:&quot;Int32Array&quot;,UNSIGNED_INT:&quot;Uint32Array&quot;,FLOAT:&quot;Float32Array&quot;,DOUBLE:&quot;Float64Array&quot;};var Ts={DefaultDataType:ys.FLOAT,DataTypeByteSize:vs,VtkDataTypes:ys};const{vtkErrorMacro:bs}=Kt,{DefaultDataType:xs}=Ts,Cs=1e-6;function Ss(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function As(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ss(r,0,1)}return Ss(e,t<0?0:t,n)}function Is(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function ws(e){return Object.prototype.toString.call(e).slice(8,-1)}const Ps={computeRange:As,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ss,getDataType:ws,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Os(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push(&quot;vtkDataArray&quot;),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=As(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Cs;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Ds({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=ws(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||bs(&quot;numberOfComponents must match&quot;);const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Rs={name:&quot;&quot;,numberOfComponents:1,dataType:xs,rangeTuple:[0,0]};function Ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Rs,n),!t.empty&&!t.values&&!t.size)throw new TypeError(&quot;Cannot create vtkDataArray object without: size > 0, values&quot;);if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=ws(t.values)),yt(e,t),St(e,t,[&quot;name&quot;,&quot;numberOfComponents&quot;]),t.size%t.numberOfComponents!=0)throw new RangeError(&quot;model.size is not a multiple of model.numberOfComponents&quot;);Os(e,t)}const Ds=Et(Ms,&quot;vtkDataArray&quot;);var Es={newInstance:Ds,extend:Ms,...Ps,...Ts};function Vs(e,t){t.classHierarchy.push(&quot;vtkAbstractMapper&quot;),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA(&quot;vtkPlane&quot;)&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Ls={clippingPlanes:[]};var Bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ls,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),Vs(e,t)};function Ns(e,t){e.getBounds=()=>(jt.vtkErrorMacro(&quot;vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED&quot;),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=ki.isValid(n)?ki.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return ki.getDiagonalLength(t)}}const _s=e=>({bounds:[...ki.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var Fs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_s(n)),Bs(e,t,n),jt.setGet(e,t,[&quot;viewSpecificProperties&quot;]),Ns(e,t)};const{vtkErrorMacro:ks,vtkWarningMacro:Gs}=jt;function Us(e,t){t.classHierarchy.push(&quot;vtkFieldData&quot;);const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>&quot;number&quot;==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():&quot;&quot;},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else ks(&quot;Unhandled case in passData&quot;);else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Es.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Gs(&quot;Unexpected case in interpolateData&quot;)}else t.insertTuples(s.getTuples());else ks(&quot;Unhandled case in interpolateData&quot;);else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Es.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const zs={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Ws(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zs,n),jt.obj(e,t),Us(e,t)}var Hs={newInstance:jt.newInstance(Ws,&quot;vtkFieldData&quot;),extend:Ws};const js={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ks={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:js,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:&quot;vtkGhostType&quot;};const{AttributeTypes:$s,AttributeCopyOperations:qs}=Ks,{vtkWarningMacro:Xs}=jt;function Ys(e,t){const n=[&quot;Scalars&quot;,&quot;Vectors&quot;,&quot;Normals&quot;,&quot;TCoords&quot;,&quot;Tensors&quot;,&quot;GlobalIds&quot;,&quot;PedigreeIds&quot;];function r(e){let t=n.find((t=>$s[t.toUpperCase()]===e||&quot;number&quot;!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push(&quot;vtkDataSetAttributes&quot;);const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&&quot;PEDIGREEIDS&quot;===a.toUpperCase()&&!n.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if(&quot;PEDIGREEIDS&quot;!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(qs).filter((e=>&quot;ALLCOPY&quot;!==e)).forEach((e=>{t.copyAttributeFlags[qs[e]]=Object.keys($s).filter((e=>&quot;NUM_ATTRIBUTES&quot;!==e)).reduce(((e,t)=>(e[$s[t]]=!0,e)),[])})),t.copyAttributeFlags[qs.COPYTUPLE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.INTERPOLATE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.COPYTUPLE][$s.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||&quot;vtkDataArray&quot;!==t.dataArrays[n].type||e.addArray(Es.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const Zs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Qs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zs,n),Hs.extend(e,t,n),jt.setGet(e,t,[&quot;activeScalars&quot;,&quot;activeNormals&quot;,&quot;activeTCoords&quot;,&quot;activeVectors&quot;,&quot;activeTensors&quot;,&quot;activeGlobalIds&quot;,&quot;activePedigreeIds&quot;]),t.arrays||(t.arrays={}),Ys(e,t)}var Js={newInstance:jt.newInstance(Qs,&quot;vtkDataSetAttributes&quot;),extend:Qs,...Ks};const el=[&quot;pointData&quot;,&quot;cellData&quot;,&quot;fieldData&quot;];function tl(e,t){t.classHierarchy.push(&quot;vtkDataSet&quot;),el.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Js.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),el.forEach((n=>{t[n]=Js.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const nl={};function rl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nl,n),jt.obj(e,t),jt.setGet(e,t,el),tl(e,t)}var ol={newInstance:jt.newInstance(rl,&quot;vtkDataSet&quot;),extend:rl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const al={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var il={StructuredType:al};const{StructuredType:sl}=il;var ll={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?sl.EMPTY:3===t?sl.XYZ_GRID:2===t?e[0]===e[1]?sl.YZ_PLANE:e[2]===e[3]?sl.XZ_PLANE:sl.XY_PLANE:1===t?e[0]<e[1]?sl.X_LINE:e[2]<e[3]?sl.Y_LINE:sl.Z_LINE:sl.SINGLE_POINT},...il};const{vtkErrorMacro:cl}=jt;function ul(e,t){t.classHierarchy.push(&quot;vtkImageData&quot;),e.setExtent=function(){if(t.deleted)return cl(&quot;instance deleted - cannot call any method&quot;),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=ll.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)cl(&quot;instance deleted - cannot call any method&quot;);else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void cl(&quot;Bad dimension specification&quot;);n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return cl(&quot;Requesting a point from an empty image.&quot;),null;const o=new Float64Array(3);switch(t.dataDescription){case al.EMPTY:return null;case al.SINGLE_POINT:break;case al.X_LINE:o[0]=n;break;case al.Y_LINE:o[1]=n;break;case al.Z_LINE:o[2]=n;break;case al.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case al.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case al.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case al.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:cl(&quot;Invalid dataDescription&quot;)}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>ki.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>ki.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>ki.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];ki.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Da(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Da(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return cl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return cl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const dl={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:al.EMPTY};function pl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dl,n),ol.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,[&quot;indexToWorld&quot;,&quot;worldToIndex&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;spacing&quot;],3),jt.setGetArray(e,t,[&quot;direction&quot;],9),jt.getArray(e,t,[&quot;extent&quot;],6),ul(e,t)}var fl={newInstance:jt.newInstance(pl,&quot;vtkImageData&quot;),extend:pl};const gl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var ml={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:gl},hl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:vl,VectorMode:yl}=ml,{VtkDataTypes:Tl}=Es,{ColorMode:bl}=hl,{vtkErrorMacro:xl}=jt;function Cl(e){return e}function Sl(e){return Math.floor(255*e+.5)}function Al(e,t){t.classHierarchy.push(&quot;vtkScalarsToColors&quot;),e.setVectorModeToMagnitude=()=>e.setVectorMode(yl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(yl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(yl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)xl(&quot;Values and annotations do not have the same number of tuples so ignoring&quot;);else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===bl.DEFAULT&&t.getDataType()===Tl.UNSIGNED_CHAR||n===bl.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:&quot;vtkDataArray&quot;,name:&quot;temp&quot;,numberOfComponents:4,dataType:Tl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Es.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,vl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,vl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===yl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==yl.MAGNITUDE||1!==c&&1!==s||(i=yl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case yl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case yl.RGBCOLORS:break;case yl.MAGNITUDE:default:{const o=Es.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Sl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Tl.UNSIGNED_CHAR)return n;const i=Es.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Tl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=Cl;switch(n.getDataType()!==Tl.FLOAT&&n.getDataType()!==Tl.DOUBLE||(s=Sl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return xl(&quot;Cannot convert colors&quot;),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==bl.DEFAULT||n.getDataType()!==Tl.UNSIGNED_CHAR)&&r!==bl.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Il={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:yl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function wl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Il,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,[&quot;vectorSize&quot;,&quot;vectorComponent&quot;,&quot;vectorMode&quot;,&quot;alpha&quot;,&quot;indexedLookup&quot;]),jt.setArray(e,t,[&quot;mappingRange&quot;],2),jt.getArray(e,t,[&quot;mappingRange&quot;]),Al(e,t)}var Pl={newInstance:jt.newInstance(wl,&quot;vtkScalarsToColors&quot;),extend:wl,...ml};const{vtkErrorMacro:Ol}=jt;function Rl(e,t){t.classHierarchy.push(&quot;vtkLookupTable&quot;),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Ol(&quot;Expected 4 components for RGBA colors&quot;),!1;if(n.getDataType()!==ys.UNSIGNED_CHAR)return Ol(&quot;Expected unsigned char values for RGBA colors&quot;),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ml={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Dl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ml,n),Pl.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,[&quot;buildTime&quot;]),jt.setGet(e,t,[&quot;numberOfColors&quot;,&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;]),jt.setArray(e,t,[&quot;alphaRange&quot;,&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;],2),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;,&quot;alphaRange&quot;,&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),Rl(e,t)}var El={newInstance:jt.newInstance(Dl,&quot;vtkLookupTable&quot;),extend:Dl};let Vl=1,Ll=0;const Bl=[&quot;VTK_RESOLVE_OFF&quot;,&quot;VTK_RESOLVE_POLYGON_OFFSET&quot;];function Nl(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;Ll=e}var _l={getResolveCoincidentTopologyAsString:function(){return Bl[Ll]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Vl},getResolveCoincidentTopology:function(){return Ll},setResolveCoincidentTopology:Nl,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){Vl=e},setResolveCoincidentTopologyToDefault:function(){Nl(0)},setResolveCoincidentTopologyToOff:function(){Nl(0)},setResolveCoincidentTopologyToPolygonOffset:function(){Nl(1)}};function Fl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=(e,r)=>{t[n.key]={factor:e,offset:r}}}))}const kl=[&quot;Polygon&quot;,&quot;Line&quot;,&quot;Point&quot;],Gl={};Fl(Gl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},kl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Ul={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,[&quot;resolveCoincidentTopology&quot;]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(_l).forEach((t=>{e[t]=_l[t]})),Object.keys(Gl).forEach((t=>{e[t]=Gl[t]})),Fl(e,t.topologyOffset,kl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=Gl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:Gl,otherStaticMethods:_l,CATEGORIES:kl};const zl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Wl={PassTypes:zl};const{FieldAssociations:Hl}=ol,{staticOffsetAPI:jl,otherStaticMethods:Kl}=Ul,{ColorMode:$l,ScalarMode:ql,GetArray:Xl}=hl,{VectorMode:Yl}=ml,{VtkDataTypes:Zl}=Es;function Ql(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Jl(e,t){t.classHierarchy.push(&quot;vtkMapper&quot;),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString($l,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(ql,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===ql.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===ql.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===ql.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===ql.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_FIELD_DATA){const t=e.getFieldData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==a){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(n))e.mapScalarsToTexture(o,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},e.scalarToTextureCoordinate=(e,t,n)=>{let r=.5,o=1;return _a(e)||(o=.49,r=(e-t)*n,r>1e3?r=1e3:r<-1e3&&(r=-1e3)),{texCoordS:r,texCoordT:o}},e.createColorTextureCoordinates=(t,n,r,o,a,i,s,l,c)=>{const u=(i[1]-i[0])/l,d=[];d[0]=i[0]-u,d[1]=i[1]+u;const p=1/(d[1]-d[0]),f=n.getData(),g=t.getData();let m=0,h=0;if(a<0||a>=o)for(let t=0;t<r;++t){let t=0;for(let e=0;e<o;++e)t+=g[m]*g[m],m++;let n=Math.sqrt(t);c&&(n=El.applyLogScale(n,s,i));const r=e.scalarToTextureCoordinate(n,d[0],p);f[h]=r.texCoordS,f[h+1]=r.texCoordT,h+=2}else{m+=a;for(let t=0;t<r;++t){let t=g[m];c&&(t=El.applyLogScale(t,s,i));const n=e.scalarToTextureCoordinate(t,d[0],p);f[h]=n.texCoordS,f[h+1]=n.texCoordT,h+=2,m+=o}}},e.mapScalarsToTexture=(n,r)=>{const o=t.lookupTable.getRange(),a=t.lookupTable.usingLogScale();a&&El.getLogRange(o,o);const i=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==r){t.lookupTable.setAlpha(r),t.colorTextureMap=null,t.lookupTable.build();let e=t.lookupTable.getNumberOfAvailableColors();e>4094&&(e=4094),e<64&&(e=64),e+=2;const n=(o[1]-o[0])/(e-2),s=new Float64Array(2*e);for(let t=0;t<e;++t)s[t]=o[0]+t*n-n/2,a&&(s[t]=10**s[t]);for(let t=0;t<e;++t)s[t+e]=NaN;t.colorTextureMap=fl.newInstance(),t.colorTextureMap.setExtent(0,e-1,0,1,0,0);const l=Es.newInstance({numberOfComponents:1,values:s});t.colorTextureMap.getPointData().setScalars(t.lookupTable.mapScalars(l,t.colorMode,0)),t.lookupTable.setAlpha(i)}if(!t.colorCoordinates||e.getMTime()>t.colorCoordinates.getMTime()||e.getInputData(0).getMTime()>t.colorCoordinates.getMTime()||t.lookupTable.getMTime()>t.colorCoordinates.getMTime()){t.colorCoordinates=null;const r=n.getNumberOfComponents(),i=n.getNumberOfTuples();t.colorCoordinates=Es.newInstance({numberOfComponents:2,values:new Float32Array(2*i)});let s=t.lookupTable.getVectorComponent();t.lookupTable.getVectorMode()===Yl.MAGNITUDE&&n.getNumberOfComponents()>1&&(s=-1),e.createColorTextureCoordinates(n,t.colorCoordinates,i,r,s,o,t.lookupTable.getRange(),t.colorTextureMap.getPointData().getScalars().getNumberOfTuples()/2-2,a)}},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=n=>{if(!t.interpolateScalarsBeforeMapping)return!1;if(t.lookupTable&&t.lookupTable.getIndexedLookup())return!1;const r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName),o=r.scalars;return!(!o||r.cellFlag||t.colorMode===$l.DEFAULT&&o.getDataType()===Zl.UNSIGNED_CHAR||t.colorMode===$l.DIRECT_SCALARS)},e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=Ql(&quot;AcquireInvertibleLookupTable&quot;),e.valueToColor=Ql(&quot;ValueToColor&quot;),e.colorToValue=Ql(&quot;ColorToValue&quot;),e.useInvertibleColorFor=Ql(&quot;UseInvertibleColorFor&quot;),e.clearInvertibleColor=Ql(&quot;ClearInvertibleColor&quot;),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(zl.ID_LOW24),o=e.getRawPixelBuffer(zl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Hl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Hl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===zl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(zl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===zl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t],n*=256,n+=r[t+1],n*=256,n+=r[t+2];const a=s[n];e.getPixelBuffer(zl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const ec={colorMapColors:null,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function tc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ec,n),Fs(e,t,n),jt.get(e,t,[&quot;colorCoordinates&quot;,&quot;colorMapColors&quot;,&quot;colorTextureMap&quot;,&quot;selectionWebGLIdsToVTKIds&quot;]),jt.setGet(e,t,[&quot;colorByArrayName&quot;,&quot;arrayAccessMode&quot;,&quot;colorMode&quot;,&quot;fieldDataTupleId&quot;,&quot;interpolateScalarsBeforeMapping&quot;,&quot;lookupTable&quot;,&quot;populateSelectionSettings&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;useLookupTableScalarRange&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),Ul.implementCoincidentTopologyMethods(e,t),Jl(e,t)}var nc={newInstance:jt.newInstance(tc,&quot;vtkMapper&quot;),extend:tc,...jl,...Kl,...hl};function rc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function oc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const ac={extractCellSizes:rc,getNumberOfCells:oc};function ic(e,t){t.classHierarchy.push(&quot;vtkCellArray&quot;);const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=oc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=rc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function sc(e){return{empty:!0,numberOfComponents:1,dataType:ys.UNSIGNED_INT,...e}}function lc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Es.extend(e,t,sc(n)),ic(e,t)}var cc={newInstance:jt.newInstance(lc,&quot;vtkCellArray&quot;),extend:lc,...ac};const{vtkErrorMacro:uc}=jt,dc=[1,-1,1,-1,1,-1];function pc(e,t){t.classHierarchy.push(&quot;vtkPoints&quot;),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return uc(`getBounds called on an array with components of\\n        ${e.getNumberOfComponents()}`),dc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const fc={empty:!0,numberOfComponents:3,dataType:ys.FLOAT,bounds:[1,-1,1,-1,1,-1]};function gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fc,n),Es.extend(e,t,n),pc(e,t)}var mc={newInstance:jt.newInstance(gc,&quot;vtkPoints&quot;),extend:gc};function hc(e,t){t.classHierarchy.push(&quot;vtkCell&quot;),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro(&quot;vtkCell.evaluatePosition is not implemented.&quot;)}}const vc={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function yc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vc,n),jt.obj(e,t),t.points||(t.points=mc.newInstance()),jt.get(e,t,[&quot;points&quot;,&quot;pointsIds&quot;]),hc(e,t)}var Tc={newInstance:jt.newInstance(yc,&quot;vtkCell&quot;),extend:yc};function bc(e,t){t.classHierarchy.push(&quot;vtkCellLinks&quot;),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA(&quot;vtkPolyData&quot;)){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Tc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Tc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const xc={array:null,maxId:0,extend:0};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),jt.obj(e,t),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,&quot;vtkCellLinks&quot;),extend:Cc};const Ac=0,Ic=1,wc=2,Pc=3,Oc=4,Rc=5,Mc=6,Dc=7,Ec=9,Vc=21,Lc=41,Bc=42,Nc=[&quot;vtkEmptyCell&quot;,&quot;vtkVertex&quot;,&quot;vtkPolyVertex&quot;,&quot;vtkLine&quot;,&quot;vtkPolyLine&quot;,&quot;vtkTriangle&quot;,&quot;vtkTriangleStrip&quot;,&quot;vtkPolygon&quot;,&quot;vtkPixel&quot;,&quot;vtkQuad&quot;,&quot;vtkTetra&quot;,&quot;vtkVoxel&quot;,&quot;vtkHexahedron&quot;,&quot;vtkWedge&quot;,&quot;vtkPyramid&quot;,&quot;vtkPentagonalPrism&quot;,&quot;vtkHexagonalPrism&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkQuadraticEdge&quot;,&quot;vtkQuadraticTriangle&quot;,&quot;vtkQuadraticQuad&quot;,&quot;vtkQuadraticTetra&quot;,&quot;vtkQuadraticHexahedron&quot;,&quot;vtkQuadraticWedge&quot;,&quot;vtkQuadraticPyramid&quot;,&quot;vtkBiQuadraticQuad&quot;,&quot;vtkTriQuadraticHexahedron&quot;,&quot;vtkQuadraticLinearQuad&quot;,&quot;vtkQuadraticLinearWedge&quot;,&quot;vtkBiQuadraticQuadraticWedge&quot;,&quot;vtkBiQuadraticQuadraticHexahedron&quot;,&quot;vtkBiQuadraticTriangle&quot;,&quot;vtkCubicLine&quot;,&quot;vtkQuadraticPolygon&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkConvexPointSet&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkParametricCurve&quot;,&quot;vtkParametricSurface&quot;,&quot;vtkParametricTriSurface&quot;,&quot;vtkParametricQuadSurface&quot;,&quot;vtkParametricTetraRegion&quot;,&quot;vtkParametricHexRegion&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkHigherOrderEdge&quot;,&quot;vtkHigherOrderTriangle&quot;,&quot;vtkHigherOrderQuad&quot;,&quot;vtkHigherOrderPolygon&quot;,&quot;vtkHigherOrderTetrahedron&quot;,&quot;vtkHigherOrderWedge&quot;,&quot;vtkHigherOrderPyramid&quot;,&quot;vtkHigherOrderHexahedron&quot;],_c={getClassNameFromTypeId:function(e){return e<Nc.length?Nc[e]:&quot;UnknownClass&quot;},getTypeIdFromClassName:function(e){return Nc.findIndex(e)},isLinear:function(e){return e<Vc||e===Lc||e===Bc},hasSubCells:function(e){return e===Mc||e===Oc||e===wc}};function Fc(e,t){t.classHierarchy.push(&quot;vtkCellTypes&quot;),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Ac},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const kc={size:0,maxId:-1,extend:1e3};function Gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kc,n),jt.obj(e,t),jt.get(e,t,[&quot;size&quot;,&quot;maxId&quot;,&quot;extend&quot;]),jt.getArray(e,t,[&quot;typeArray&quot;,&quot;locationArray&quot;]),Fc(e,t)}var Uc={newInstance:jt.newInstance(Gc,&quot;vtkCellTypes&quot;),extend:Gc,..._c},zc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Wc}=zc;function Hc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Hc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Wc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Wc.YES_INTERSECTION:Wc.NO_INTERSECTION}const Kc={distanceToLine:Hc,intersection:jc};function $c(e,t){t.classHierarchy.push(&quot;vtkLine&quot;),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Wc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Hc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Hc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Hc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Hc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const qc={orientations:null};function Xc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qc,n),Tc.extend(e,t,n),jt.setGet(e,t,[&quot;orientations&quot;]),$c(e,t)}var Yc={newInstance:jt.newInstance(Xc,&quot;vtkLine&quot;),extend:Xc,...Kc,...zc};function Zc(e,t){t.classHierarchy.push(&quot;vtkPointSet&quot;),t.points?t.points=We(t.points):t.points=mc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=mc.newInstance(),t.points.shallowCopy(e.getPoints())}}const Qc={};function Jc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qc,n),ol.extend(e,t,n),jt.setGet(e,t,[&quot;points&quot;]),Zc(e,t)}var eu={newInstance:jt.newInstance(Jc,&quot;vtkPointSet&quot;),extend:Jc};function tu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function nu(e,t,n,r){tu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const ru={computeNormalDirection:tu,computeNormal:nu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];nu(e,t,n,d),nu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,D=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ni.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ni.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(D=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[D],P[D]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function ou(e,t){t.classHierarchy.push(&quot;vtkTriangle&quot;),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(nu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ni.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=Yc.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),tu(l,c,u,d),ni.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=Yc.distanceToLine(e,c,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Yc.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Yc.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Yc.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const au={};function iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,au,n),Tc.extend(e,t,n),ou(e,t)}var su={newInstance:jt.newInstance(iu,&quot;vtkTriangle&quot;),extend:iu,...ru};const lu=[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;],{vtkWarningMacro:cu}=jt,uu={[Pc]:Yc,[Oc]:Yc,[Rc]:su};function du(e,t){t.classHierarchy.push(&quot;vtkPolyData&quot;),lu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\\w|[A-Z]|\\b\\w)/g,(e=>e.toUpperCase())).replace(/\\s+/g,&quot;&quot;)}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=cc.newInstance()})),e.getNumberOfCells=()=>lu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),lu.forEach((n=>{t[n]=cc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?wc:Ic,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Oc:Pc,1===t&&cu(&quot;Building VTK_LINE &quot;,n,&quot; with only one point, but VTK_LINE needs at least two points. Check the input.&quot;),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=Rc;break;case 4:l[n]=Ec;break;default:l[n]=Dc}t<3&&cu(&quot;Building VTK_TRIANGLE &quot;,n,&quot; with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.&quot;),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Mc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Uc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Sc.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Ic:case wc:o=t.verts;break;case Pc:case Oc:o=t.lines;break;case Rc:case Ec:case Dc:o=t.polys;break;case Mc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||uu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const pu={};function fu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pu,n),eu.extend(e,t,n),jt.get(e,t,[&quot;cells&quot;,&quot;links&quot;]),jt.setGet(e,t,[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;]),du(e,t)}var gu={newInstance:jt.newInstance(fu,&quot;vtkPolyData&quot;),extend:fu};function mu(e,t){t.classHierarchy.push(&quot;vtkTexture&quot;),e.imageLoaded=()=>{t.image.removeEventListener(&quot;load&quot;,e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener(&quot;load&quot;,e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext(&quot;2d&quot;).getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement(&quot;canvas&quot;);e.width=t.image.width,e.height=t.image.height;const n=e.getContext(&quot;2d&quot;);return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const hu={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hu,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,[&quot;canvas&quot;,&quot;image&quot;,&quot;jsImageData&quot;,&quot;imageLoaded&quot;,&quot;resizable&quot;]),jt.setGet(e,t,[&quot;repeat&quot;,&quot;edgeClamp&quot;,&quot;interpolate&quot;,&quot;mipLevel&quot;]),mu(e,t)}const yu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Tu={newInstance:jt.newInstance(vu,&quot;vtkTexture&quot;),extend:vu,...yu};const bu=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],xu=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Cu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Su=[0,1,0,1,0,1,0,1,2,2,2,2],Au=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Iu=new Float64Array(3),wu=new Float64Array(3),Pu=new Float64Array(3),Ou=new Float64Array(3),Ru=new Float64Array(3),Mu=new Float64Array(3),Du=new Float64Array(16);function Eu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Vu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],Vn(Pu,Iu,r),Pu[0]+=.1,Vn(wu,Pu,o),Pn(Ru,wu,Iu),Pu[0]-=.1,Pu[1]+=.1,Vn(wu,Pu,o),Pn(Mu,wu,Iu);for(let e=0;e<3;e++)Ru[e]/=.05*u[0],Mu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],a[0]<-.5?On(Pu,Ru,a[0]*i-l.width):a[0]>.5?On(Pu,Ru,a[0]*i):On(Pu,Ru,a[0]*i-l.width/2),wn(Iu,Iu,Pu),On(Pu,Mu,a[1]*i-l.height/2),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Pu,Ru,l.width),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Pu,Mu,l.height),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Pu,Ru,l.width),Pn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(Du,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Iu[0]=f[3*u],Iu[1]=f[3*u+1],Iu[2]=f[3*u+2],Vn(Pu,Iu,n),Iu[0]=f[3*u+3],Iu[1]=f[3*u+4],Iu[2]=f[3*u+5],Vn(Ou,Iu,n),Pn(Pu,Pu,Ou);const r=[Pu[0],Pu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Lu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,[&quot;renderable&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;tmActor&quot;,&quot;ticks&quot;]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],Vu(e,t)}),&quot;vtkCubeAxesActorHelper&quot;);function Bu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActor&quot;),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=ki.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Iu[s]=t.dataBounds[a]-.1*r*bu[a][s],Iu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Iu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Pu,Iu,e),Iu[s]=t.dataBounds[a],Vn(Ou,Iu,e),Pn(Pu,Ou,Pu),Mn(Pu,Pu),i=Pu[2]>o,t.camera.getParallelProjection()||(Mn(Ou,Ou),i=Dn(Ou,Pu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Au[t][0]].length+2*r[Au[t][1]].length,a+=r[Au[t][0]].length+r[Au[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Cu[e][0],l[3*u+2]=Cu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Au[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Au[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Su[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=xu[a][e];if(1===n[d]){const e=Su[d],n=3*Cu[d][0],p=3*Cu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Au[a][0]]=.5*(t.dataBounds[2*Au[a][0]]+t.dataBounds[2*Au[a][0]+1]),s[3*l+Au[a][1]]=.5*(t.dataBounds[2*Au[a][1]]+t.dataBounds[2*Au[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[xu[e][t]]++;const a=[],i=[];for(let e=0;e<3;e++){const n=go().domain([t.dataBounds[2*e],t.dataBounds[2*e+1]]);a[e]=n.ticks(5);const r=n.tickFormat(5);i[e]=a[e].map(r)}e.updatePolyData(r,n,a),e.updateTextData(r,n,a,i),(o||t.forceUpdate)&&e.updateTextureAtlas(i)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Eu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Eu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Eu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),ki.setBounds(t.bounds,t.gridActor.getBounds()),ki.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function Nu(e){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...ki.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:12,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},...e}}function _u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nu(n)),hs.extend(e,t,n),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=[&quot;X-Axis&quot;,&quot;Y-Axis&quot;,&quot;Z-Axis&quot;],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.tmTexture=Tu.newInstance(),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=nc.newInstance(),t.polyData=gu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=hs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=gu.newInstance(),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;boundsScaleFactor&quot;,&quot;faceVisibilityAngle&quot;,&quot;gridLines&quot;,&quot;tickLabelPixelOffset&quot;]),jt.setGetArray(e,t,[&quot;dataBounds&quot;],6),jt.setGetArray(e,t,[&quot;axisLabels&quot;],3),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;camera&quot;,&quot;tmTexture&quot;,&quot;textValues&quot;,&quot;textPolyData&quot;,&quot;tickCounts&quot;,&quot;gridActor&quot;]),Bu(e,t)}var Fu={newInstance:jt.newInstance(_u,&quot;vtkCubeAxesActor&quot;),extend:_u,newCubeAxesActorHelper:Lu};function ku(e,t){t.classHierarchy.push(&quot;vtkOpenGLCubeAxesActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gu={};const Uu=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=Fu.newCubeAxesActorHelper(),ku(e,t)}),&quot;vtkOpenGLCubeAxesActor&quot;);rn(&quot;vtkCubeAxesActor&quot;,Uu);const zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Wu={ObjectType:zu};const{ObjectType:Hu}=Wu;function ju(e,t){function n(e){switch(e){case Hu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Hu.TEXTURE_BUFFER:if(&quot;TEXTURE_BUFFER&quot;in t.context)return t.context.TEXTURE_BUFFER;case Hu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push(&quot;vtkOpenGLBufferObject&quot;);let r=null,o=null,a=!0,i=&quot;&quot;;e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i=&quot;Trying to upload array buffer to incompatible buffer.&quot;,!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const Ku={objectType:Hu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function $u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ku,n),jt.obj(e,t),jt.get(e,t,[&quot;_openGLRenderWindow&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),ju(e,t)}var qu={newInstance:jt.newInstance($u),extend:$u,...Wu};const{vtkErrorMacro:Xu}=jt;function Yu(e,t){t.classHierarchy.push(&quot;vtkOpenGLCellArrayBufferObject&quot;),e.setType(zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=qu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n){for(let r=0;r<e;++r)f(t[n+r])},linesToWireframe(e,t,n){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1])},polysToWireframe(e,t,n){if(e>2)for(let r=0;r<e;++r)f(t[n+r]),f(t[n+(r+1)%e])},stripsToWireframe(e,t,n){if(e>2){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1]);for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+2])}},polysToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+0]),f(t[n+r+1]),f(t[n+r+2])},stripsToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+1+r%2]),f(t[n+r+1+(r+1)%2])}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===rs.POINTS||&quot;verts&quot;===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===rs.WIREFRAME||&quot;lines&quot;===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,D=0,E=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];D+=n*n;const r=.5*(t[1]+t[0]);E+=r*r}const V=D>0&&(Math.abs(E)/D>1e6||Math.abs(Math.log10(D))>3||0===D&&E>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;)C(A[e],A,e+1),e+=A[e]+1,T++;return t.elementCount=w,e.upload(O,zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,Ui(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):Xu(&quot;Wrong type for coordScale, expected vec3 or null&quot;):Xu(&quot;Wrong type for coordShift, expected vec3 or null&quot;)}}const Zu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function Qu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zu,n),qu.extend(e,t,n),jt.setGet(e,t,[&quot;colorBO&quot;,&quot;elementCount&quot;,&quot;stride&quot;,&quot;colorBOStride&quot;,&quot;vertexOffset&quot;,&quot;normalOffset&quot;,&quot;tCoordOffset&quot;,&quot;tCoordComponents&quot;,&quot;colorOffset&quot;,&quot;colorComponents&quot;,&quot;customData&quot;]),jt.get(e,t,[&quot;coordShift&quot;,&quot;coordScale&quot;,&quot;coordShiftAndScaleEnabled&quot;,&quot;inverseShiftAndScaleMatrix&quot;]),Yu(e,t)}var Ju={newInstance:jt.newInstance(Qu),extend:Qu};const{vtkErrorMacro:ed}=jt;function td(e,t){t.classHierarchy.push(&quot;vtkShader&quot;),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||&quot;Unknown&quot;===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e=&quot;Fragment&quot;===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return ed(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const nd={shaderType:&quot;Unknown&quot;,source:&quot;&quot;,error:&quot;&quot;,handle:0,dirty:!1,context:null};function rd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nd,n),jt.obj(e,t),jt.setGet(e,t,[&quot;shaderType&quot;,&quot;source&quot;,&quot;error&quot;,&quot;handle&quot;,&quot;context&quot;]),td(e,t)}var od={newInstance:jt.newInstance(rd,&quot;vtkShader&quot;),extend:rd};const{vtkErrorMacro:ad}=jt;function id(e,t){t.classHierarchy.push(&quot;vtkShaderProgram&quot;),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(ad(`Links failed: ${t.error}`),0):(ad(t.error),0):(ad(t.fragmentShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.fragmentShader.getError()),0):(ad(t.vertexShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.vertexShader.getError()),0),e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error=&quot;Program has not been initialized, and/or does not have shaders.&quot;,!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return ad(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error=&quot;Shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===n.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error=&quot;Could not create shader program.&quot;,!1;t.handle=e,t.linked=!1}return&quot;Vertex&quot;===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),&quot;Fragment&quot;===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error=&quot;shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===e.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;switch(0===t.handle&&(t.error=&quot;This shader program has not been initialized yet.&quot;),e.getShaderType()){case&quot;Vertex&quot;:return t.vertexShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case&quot;Fragment&quot;:return t.fragmentShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const sd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:&quot;&quot;,handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=od.newInstance(),t.vertexShader.setShaderType(&quot;Vertex&quot;),t.fragmentShader=od.newInstance(),t.fragmentShader.setShaderType(&quot;Fragment&quot;),t.geometryShader=od.newInstance(),t.geometryShader.setShaderType(&quot;Geometry&quot;),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;error&quot;,&quot;handle&quot;,&quot;compiled&quot;,&quot;bound&quot;,&quot;md5Hash&quot;,&quot;vertexShader&quot;,&quot;fragmentShader&quot;,&quot;geometryShader&quot;,&quot;linked&quot;]),id(e,t)}var cd={newInstance:jt.newInstance(ld,&quot;vtkShaderProgram&quot;),extend:ld,substitute:function(e,t,n,r){const o=&quot;string&quot;==typeof n?n:n.join(&quot;\\n&quot;),a=!1===r?t:new RegExp(t,&quot;g&quot;),i=e.replace(a,o);return{replace:i!==o,result:i}}};function ud(e,t){t.classHierarchy.push(&quot;vtkOpenGLVertexArrayObject&quot;),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;)),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension(&quot;OES_vertex_array_object&quot;),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const dd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,[&quot;supported&quot;]),jt.setGet(e,t,[&quot;forceEmulation&quot;]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,&quot;vtkOpenGLVertexArrayObject&quot;),extend:pd};const gd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function md(e,t){t.classHierarchy.push(&quot;vtkOpenGLHelper&quot;),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===rs.POINTS||n===gd.Points?t.context.POINTS:e===rs.WIREFRAME||n===gd.Lines||n===gd.TrisEdges||n===gd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f(&quot;viewportSize&quot;,o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf(&quot;lineWidthStepSize&quot;,t/Math.ceil(t)),e.getProgram().setUniformf(&quot;halfLineWidth&quot;,n)}t.primitiveType===gd.Points||r.getProperty().getRepresentation()===rs.POINTS?e.getProgram().setUniformf(&quot;pointSize&quot;,r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf(&quot;pointSize&quot;,e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform float pointSize;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot;  gl_PointSize = pointSize;&quot;],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform vec2 viewportSize;&quot;,&quot;uniform float lineWidthStepSize;&quot;,&quot;uniform float halfLineWidth;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot; if (halfLineWidth > 0.0)&quot;,&quot;   {&quot;,&quot;   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;&quot;,&quot;   vec4 tmpPos = gl_Position;&quot;,&quot;   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;&quot;,&quot;   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];&quot;,&quot;   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];&quot;,&quot;   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);&quot;,&quot;   }&quot;]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===gd.Points?2:t.primitiveType===gd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const hd={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,[&quot;program&quot;,&quot;shaderSourceTime&quot;,&quot;VAO&quot;,&quot;attributeUpdateTime&quot;,&quot;CABO&quot;,&quot;primitiveType&quot;,&quot;pointPicking&quot;]),t.program=cd.newInstance(),t.VAO=fd.newInstance(),t.CABO=Ju.newInstance(),md(e,t)}var yd={newInstance:jt.newInstance(vd),extend:vd,primTypes:gd};const Td={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},bd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var xd={Wrap:Td,Filter:bd};const Cd=new Float32Array(1),Sd=new Int32Array(Cd.buffer);var Ad={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Cd[0]=e;const t=Sd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};const{Wrap:Id,Filter:wd}=xd,{VtkDataTypes:Pd}=Es,{vtkDebugMacro:Od,vtkErrorMacro:Rd,vtkWarningMacro:Md}=Kt,{toHalf:Dd}=Ad;function Ed(e,t){function n(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==Pd.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==Pd.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Dd(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o}function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension(&quot;OES_texture_half_float&quot;),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Ad.toHalf(Ad.fromHalf(e[u][l+s+t])*h*(1-v)+Ad.fromHalf(e[u][l+p+t])*h*v+Ad.fromHalf(e[u][c+s+t])*m*(1-v)+Ad.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&t.oglNorm16Ext)||e!==Pd.UNSIGNED_SHORT&&e!==Pd.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}const s=i&&(function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a);t.useHalfFloat=s}(a,c.offset,c.scale,r),t.useHalfFloat||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}t.classHierarchy.push(&quot;vtkOpenGLTexture&quot;),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent()),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(wd.LINEAR),e.setMagnificationFilter(wd.LINEAR)):(e.setMinificationFilter(wd.NEAREST),e.setMagnificationFilter(wd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Id.REPEAT),e.setWrapS(Id.REPEAT),e.setWrapT(Id.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()},e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Md(&quot;impossible case&quot;),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Od(`Unable to find suitable internal format for T=${n} NC= ${r}`),t.internalFormat),e.getDefaultInternalFormat=(e,n)=>{let r=0;return r=t._openGLRenderWindow.getDefaultTextureInternalFormat(e,n,t.oglNorm16Ext,t.useHalfFloat),r||(r||(Od(&quot;Unsupported internal texture type!&quot;),Od(`Unable to find suitable internal format for T=${e} NC= ${n}`)),r)},e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=e=>{if(t._openGLRenderWindow.getWebgl2())switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.SHORT:return t.context.SHORT;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case t.useHalfFloat&&Pd.SHORT:case t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case Pd.FLOAT:case Pd.VOID:default:return t.context.FLOAT}switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case Pd.FLOAT:case Pd.VOID:default:if(t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))return t.context.FLOAT;{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);if(e&&t.context.getExtension(&quot;OES_texture_half_float_linear&quot;))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case wd.NEAREST:return t.context.NEAREST;case wd.LINEAR:return t.context.LINEAR;case wd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case wd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case wd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case wd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Id.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Id.REPEAT:return t.context.REPEAT;case Id.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=n(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(n(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createDepthFromRaw=(n,r,a,i)=>(e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===Pd.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=r,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0):(Rd(&quot;Failed to determine texture parameters.&quot;),!1)),e.create2DFromImage=n=>{if(e.getOpenGLDataType(Pd.UNSIGNED_CHAR),e.getInternalFormat(Pd.UNSIGNED_CHAR,4),e.getFormat(Pd.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const r=!(t._openGLRenderWindow.getWebgl2()||Fo(n.width)&&Fo(n.height)),a=document.createElement(&quot;canvas&quot;);a.width=r?_o(n.width):n.width,a.height=r?_o(n.height):n.height,t.width=a.width,t.height=a.height;const i=a.getContext(&quot;2d&quot;);i.translate(0,a.height),i.scale(1,-1),i.drawImage(n,0,0,n.width,n.height,0,0,a.width,a.height);const s=a;return o(Pd.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Pd.UNSIGNED_CHAR,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Es.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.create3DFromRaw=(a,i,s,l,c,u)=>{if(e.getOpenGLDataType(c),e.getInternalFormat(c,l),e.getFormat(c,l),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=r(n(c,[u],!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(c)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=d[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,d[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,d[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(c,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Es.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=n*r*i,g=[],m=[];for(let e=0;e<c;++e)g[e]=0,m[e]=1;t.volumeInfo={scale:m,offset:g,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i};const h=structuredClone(p);if(t._openGLRenderWindow.getWebgl2()){if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=32767;return e.create3DFromRaw(n,r,i,c,u,d)}if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.UNSIGNED_SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=65535;return e.create3DFromRaw(n,r,i,c,u,d)}if(u===Pd.FLOAT||t.useHalfFloat&&(u===Pd.SHORT||u===Pd.UNSIGNED_SHORT))return e.create3DFromRaw(n,r,i,c,u,d);if(u===Pd.UNSIGNED_CHAR){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=255;return e.create3DFromRaw(n,r,i,c,u,d)}const o=new Float32Array(f*c);t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;let a=0;const s=h.scale.map((e=>1/e));for(let e=0;e<f;e++)for(let e=0;e<c;e++)o[a]=(d[a]-h.offset[e])*s[e],a++;return e.create3DFromRaw(n,r,i,c,Pd.FLOAT,o)}let v=(e,t,n,r,o)=>{e[t]=n},y=Pd.UNSIGNED_CHAR;if(u===Pd.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)?(y=Pd.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=Pd.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===Pd.FLOAT||c>=3)&&(T=4096);let b=1,x=1;f>T*T&&(b=Math.ceil(Math.sqrt(f/(T*T))),x=b);let C=Math.sqrt(f)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===Pd.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1}const Vd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Id.CLAMP_TO_EDGE,wrapT:Id.CLAMP_TO_EDGE,wrapR:Id.CLAMP_TO_EDGE,minificationFilter:wd.NEAREST,magnificationFilter:wd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,useHalfFloat:!0,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0};function Ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,[&quot;format&quot;,&quot;openGLDataType&quot;]),At(e,t,[&quot;keyMatrixTime&quot;,&quot;minificationFilter&quot;,&quot;magnificationFilter&quot;,&quot;wrapS&quot;,&quot;wrapT&quot;,&quot;wrapR&quot;,&quot;generateMipmap&quot;,&quot;oglNorm16Ext&quot;]),bt(e,t,[&quot;width&quot;,&quot;height&quot;,&quot;volumeInfo&quot;,&quot;components&quot;,&quot;handle&quot;,&quot;target&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),Ed(e,t)}const Bd=Et(Ld,&quot;vtkOpenGLTexture&quot;);var Nd={newInstance:Bd,extend:Ld,...xd};rn(&quot;vtkTexture&quot;,Bd);var _d=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexMC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\nvoid main()\\n{\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::PrimID::Impl\\n\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,Fd=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the polydata mappers fragment shader\\n\\nuniform int PrimitiveIDOffset;\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// optional color passed in from the vertex shader, vertexColor\\n//VTK::Color::Dec\\n\\n// optional surface normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// Depth Peeling Support\\n//VTK::DepthPeeling::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// label outline \\n//VTK::LabelOutline::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n//VTK::LabelOutlineHelperFunction\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::Color::Impl\\n\\n  // Generate the normal if we are not passed in one\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Light::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,kd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::Coincident::Dec&quot;,[&quot;uniform float cfactor;&quot;,&quot;uniform float coffset;&quot;]).result,t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;&quot;).result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;&quot;).result),n.Fragment=e}}},Gd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=cd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&&quot;&quot;!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&&quot;&quot;!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Ud}=ol,{primTypes:zd}=yd,{Representation:Wd,Shading:Hd}=ds,{ScalarMode:jd}=nc,{Filter:Kd,Wrap:$d}=Nd,{vtkErrorMacro:qd}=Kt,Xd={type:&quot;StartEvent&quot;},Yd={type:&quot;EndEvent&quot;},{CoordinateSystem:Zd}=Zi;function Qd(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType(&quot;vtkOpenGLActor&quot;),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=zd.Start;e<zd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let l=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;,&quot;uniform vec3 ambientColorUniform;&quot;,&quot;uniform vec3 diffuseColorUniform;&quot;];s&&(l=l.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let c=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];s&&(c=c.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),c=c.concat([&quot;  ambientColor = ambientColorUniform;&quot;,&quot;  diffuseColor = diffuseColorUniform;&quot;,&quot;  opacity = opacityUniform;&quot;]),s&&(c=c.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 scalarColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput =  scalarColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?t.renderable.getInterpolateScalarsBeforeMapping()&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);&quot;,&quot;  diffuseColor = texColor.rgb;&quot;,&quot;  ambientColor = texColor.rgb;&quot;,&quot;  opacity = opacity*texColor.a;&quot;])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat([&quot;uniform float opacityUniformBF; // the fragment opacity&quot;,&quot;uniform float ambientIntensityBF; // the material ambient&quot;,&quot;uniform float diffuseIntensityBF; // the material diffuse&quot;,&quot;uniform vec3 ambientColorUniformBF; // ambient material color&quot;,&quot;uniform vec3 diffuseColorUniformBF; // diffuse material color&quot;]),s?(l=l.concat([&quot;uniform float specularIntensityBF; // the material specular intensity&quot;,&quot;uniform vec3 specularColorUniformBF; // intensity weighted color&quot;,&quot;uniform float specularPowerUniformBF;&quot;]),c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  specularColor = specularIntensityBF * specularColorUniformBF;&quot;,&quot;  specularPower = specularPowerUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])):c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat([&quot;uniform samplerBuffer texture1;&quot;])),i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c).result):i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),i=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);let s=[];switch(a){case 0:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 1:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  float df = max(0.0, normalVCVSOutput.z);&quot;,&quot;  float sf = pow(df, specularPower);&quot;,&quot;  vec3 diffuseL = df * diffuseColor;&quot;,&quot;  vec3 specularL = sf * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,&quot;    {&quot;,`    float sf = sign(df)*pow(max(1e-5,\\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\\n                                                  normalize(-vertexVC.xyz))),\\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  vec3 vertLightDirectionVC;&quot;,&quot;  float attenuation;&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([&quot;  attenuation = 1.0;&quot;,`  if (lightPositional${e} == 0)`,&quot;    {&quot;,`      vertLightDirectionVC = lightDirectionVC${e};`,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,&quot;    float distanceVC = length(vertLightDirectionVC);&quot;,&quot;    vertLightDirectionVC = normalize(vertLightDirectionVC);&quot;,&quot;    attenuation = 1.0 /&quot;,`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,&quot;    // per OpenGL standard cone angle is 90 or less for a spot light&quot;,`    if (lightConeAngle${e} <= 90.0)`,&quot;      {&quot;,`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,&quot;      // if inside the cone&quot;,`      if (coneDot >= cos(radians(lightConeAngle${e})))`,&quot;        {&quot;,`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,&quot;        }&quot;,&quot;      else&quot;,&quot;        {&quot;,&quot;        attenuation = 0.0;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));&quot;,`    diffuseL += ((df) * lightColor${e});`,&quot;    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)&quot;,&quot;      {&quot;,`      float sf = sign(df)*attenuation*pow(max(1e-5,\\n                                                           dot(reflect(lightDirectionVC${e},\\n                                                                       normalVCVSOutput),\\n                                                               normalize(-vertexVC.xyz))),\\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;default:qd(&quot;bad light complexity&quot;)}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * normalMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Dec&quot;,[&quot;in vec3 normalVCVSOutput[];&quot;,&quot;out vec3 normalVCGSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCGSOutput = normalVCVSOutput[i];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;varying vec3 normalVCVSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalVCVSOutput);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.haveCellNormals?(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform mat3 normalMatrix;&quot;,&quot;uniform samplerBuffer textureN;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalMatrix *&quot;,&quot;    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput;&quot;,&quot;  if (abs(fdx.x) > 0.0)&quot;,&quot;    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }&quot;,&quot;  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}&quot;]).result):(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;&quot;]).result,a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;  fdx = normalize(fdx);&quot;,&quot;  fdy = normalize(fdy);&quot;,&quot;  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));&quot;,&quot;  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;,&quot;  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(o=cd.substitute(o,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCVSOutput = MCVCMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;in vec4 vertexVCVSOutput[];&quot;,&quot;out vec4 vertexVCGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCGSOutput = vertexVCVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;&quot;]).result):(o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,a&&a.length>=1)switch(i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}}else switch(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec3 tcoordVCVSOutput[];&quot;,&quot;out vec3 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec3 tcoordVCVSOutput;&quot;,&quot;uniform samplerCube texture1;&quot;]).result,i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`varying float clipDistancesVSOutput[${e}];`]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()||o.getEdgeVisibility()&&o.getRepresentation()===Wd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===zd.Points||o.getRepresentation()===Wd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===zd.Lines||o.getRepresentation()===Wd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==zd.Tris&&e!==zd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==zd.TrisEdges&&e!==zd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform int picking;&quot;,&quot;//VTK::Picking::Dec&quot;]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==zl.ID_LOW24&&t.lastSelectionState!==zl.ID_HIGH24||(a=cd.substitute(a,&quot;//VTK::Picking::Dec&quot;,[&quot;flat out int vertexIDVSOutput;\\n&quot;,&quot;uniform int VertexIDOffset;\\n&quot;]).result,a=cd.substitute(a,&quot;//VTK::Picking::Impl&quot;,&quot;  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;flat in int vertexIDVSOutput;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,[&quot;  int idx = vertexIDVSOutput;&quot;,&quot;//VTK::Picking::Impl&quot;]).result),t.lastSelectionState){case zl.ID_LOW24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);&quot;).result;break;case zl.ID_HIGH24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);&quot;).result;break;default:o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;uniform vec3 mapperIndex;&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===Hd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),h=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&n.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),n.getProgram().isUniformUsed(&quot;VertexIDOffset&quot;)&&n.getProgram().setUniformi(&quot;VertexIDOffset&quot;,t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;normalMC&quot;)&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;normalMC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting normalMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;normalMC&quot;),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||qd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||qd(&quot;Error setting tcoordMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),n.getProgram().isAttributeUsed(&quot;scalarColor&quot;)&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),&quot;scalarColor&quot;,n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||qd(&quot;Error setting scalarColor in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;scalarColor&quot;),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,r)}t.internalColorTexture&&n.getProgram().isUniformUsed(&quot;texture1&quot;)&&n.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi(&quot;picking&quot;,i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===Zd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4)}else s.setUniformMatrix(&quot;MCPCMatrix&quot;,n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed(&quot;MCVCMatrix&quot;)&&s.setUniformMatrix(&quot;MCVCMatrix&quot;,n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed(&quot;normalMatrix&quot;)&&s.setUniformMatrix3x3(&quot;normalMatrix&quot;,n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf(&quot;opacityUniform&quot;,i),o.setUniform3fArray(&quot;ambientColorUniform&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniform&quot;,l),o.setUniformf(&quot;ambient&quot;,c),o.setUniformf(&quot;diffuse&quot;,u);const f=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray(&quot;specularColorUniform&quot;,g),o.setUniformf(&quot;specularPowerUniform&quot;,p),o.setUniformf(&quot;specular&quot;,d),o.isUniformUsed(&quot;ambientIntensityBF&quot;)){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf(&quot;ambientIntensityBF&quot;,c),o.setUniformf(&quot;diffuseIntensityBF&quot;,u),o.setUniformf(&quot;opacityUniformBF&quot;,i),o.setUniform3fArray(&quot;ambientColorUniformBF&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniformBF&quot;,l),f<1)return;o.setUniformf(&quot;specularIntensityBF&quot;,d),o.setUniform3fArray(&quot;specularColorUniformBF&quot;,g),o.setUniformf(&quot;specularPowerUniformBF&quot;,p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():zl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Wd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===zl.ID_LOW24||t.lastSelectionState===zl.ID_HIGH24);for(let i=zd.Start;i<zd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===zd.TrisEdges||i===zd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(Xd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Yd),!t.currentInput)return void qd(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(null===o)return;t.renderable.mapScalars(o,1);const a=t.renderable.getColorMapColors();t.haveCellScalars=!1;const i=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(i!==jd.USE_CELL_DATA&&i!==jd.USE_CELL_FIELD_DATA&&i!==jd.USE_FIELD_DATA&&o.getPointData().getScalars()||i===jd.USE_POINT_FIELD_DATA||!a||(t.haveCellScalars=!0));let s=r.getProperty().getInterpolation()!==Hd.FLAT?o.getPointData().getNormals():null;null===s&&o.getCellData().getNormals()&&(t.haveCellNormals=!0,s=o.getCellData().getNormals());const l=r.getProperty().getRepresentation();let c=o.getPointData().getTCoords();if(t.openGLActor.getActiveTextures()||(c=null),t.renderable.getColorCoordinates()){c=t.renderable.getColorCoordinates(),t.internalColorTexture||(t.internalColorTexture=Nd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Kd.NEAREST),e.setMagnificationFilter(Kd.NEAREST),e.setWrapS($d.CLAMP_TO_EDGE),e.setWrapT($d.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${o.getMTime()}A${l}B${o.getMTime()}C${s?s.getMTime():1}D${a?a.getMTime():1}E${r.getProperty().getEdgeVisibility()}F${c?c.getMTime():1}`;if(t.VBOBuildString!==u){const n={points:o.getPoints(),normals:s,tcoords:c,colors:a,cellOffset:0,vertexOffset:0,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>o.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const i=[{inRep:&quot;verts&quot;,cells:o.getVerts()},{inRep:&quot;lines&quot;,cells:o.getLines()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()}],d=r.getProperty().getEdgeVisibility()&&l===Wd.SURFACE;for(let e=zd.Start;e<zd.End;e++)e!==zd.TrisEdges&&e!==zd.TriStripsEdges?(n.cellOffset+=t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,l,n,t.selectionWebGLIdsToVTKIds),n.vertexOffset+=t.primitives[e].getCABO().getElementCount()):d?t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,Wd.WIREFRAME,{...n,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[e].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&(t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),e.updateMaximumPointCellIds()),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Jd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:zl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function ep(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jd,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=zd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=zd.Start;e<zd.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),Qd(e,t)}const tp=Et(ep,&quot;vtkOpenGLPolyDataMapper&quot;);var np={newInstance:tp,extend:ep};rn(&quot;vtkMapper&quot;,tp);const{ColorMode:rp,ScalarMode:op,GetArray:ap}=hl;function ip(e,t){t.classHierarchy.push(&quot;vtkMapper2D&quot;),e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString(rp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(op,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===op.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===op.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===op.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===op.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_FIELD_DATA){const t=e.getFieldData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const sp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function lp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sp,n),Bs(e,t,n),jt.get(e,t,[&quot;colorMapColors&quot;]),jt.setGet(e,t,[&quot;arrayAccessMode&quot;,&quot;colorByArrayName&quot;,&quot;colorMode&quot;,&quot;lookupTable&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;transformCoordinate&quot;,&quot;useLookupTableScalarRange&quot;,&quot;viewSpecificProperties&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),ip(e,t)}var cp={newInstance:jt.newInstance(lp,&quot;vtkMapper2D&quot;),extend:lp};const up=1,{primTypes:dp}=yd,{ScalarMode:pp}=cp,{vtkErrorMacro:fp}=Kt,gp={type:&quot;StartEvent&quot;},mp={type:&quot;EndEvent&quot;};function hp(e,t){t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper2D&quot;),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType(&quot;vtkOpenGLActor2D&quot;),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model Coordinates\\n// WC - WC world coordinates\\n// VC - View Coordinates\\n// DC - Display Coordinates\\n\\nin vec4 vertexWC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nuniform mat4 WCVCMatrix;  // World to view matrix\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  gl_Position = WCVCMatrix*vertexWC;\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::PositionVC::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nuniform int PrimitiveIDOffset;\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Scalar coloring\\n//VTK::Color::Dec\\n\\n// Depth Peeling\\n//VTK::DepthPeeling::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Color::Impl\\n  //VTK::TCoord::Impl\\n\\n  //VTK::DepthPeeling::Impl\\n  //VTK::Picking::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=dp.Start;e<dp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(gp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(mp),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):fp(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==pp.USE_CELL_DATA&&a!==pp.USE_CELL_FIELD_DATA&&a!==pp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===pp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=mc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[dp.Points].getCABO().createVBO(r.getVerts(),&quot;verts&quot;,i,a),a.cellOffset+=t.primitives[dp.Lines].getCABO().createVBO(r.getLines(),&quot;lines&quot;,i,a),a.cellOffset+=t.primitives[dp.Tris].getCABO().createVBO(r.getPolys(),&quot;polys&quot;,i,a),a.cellOffset+=t.primitives[dp.TriStrips].getCABO().createVBO(r.getStrips(),&quot;strips&quot;,i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=dp.Start;a<dp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform samplerBuffer texture1;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);&quot;]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 diffuseColor;&quot;,&quot;out vec4 fcolorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorVSOutput = diffuseColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput[];\\n&quot;,&quot;out vec4 fcolorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorGSOutput = fcolorVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = fcolorVSOutput;&quot;]).result):(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform vec4 diffuseColor;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = diffuseColor;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordMC;&quot;,&quot;out float tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput[];\\n&quot;,&quot;out float tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,[&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));&quot;]).result):2===a&&(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordMC;&quot;,&quot;out vec2 tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];\\n&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);&quot;]).result),t.haveCellScalars&&(r=cd.substitute(r,&quot;//VTK::PrimID::Impl&quot;,[&quot;gl_PrimitiveID = gl_PrimitiveIDIn;&quot;]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=cd.substitute(r,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&e.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),e.getProgram().isAttributeUsed(&quot;vertexWC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;vertexWC&quot;,e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||fp(&quot;Error setting vertexWC in shader VAO.&quot;)),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||fp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;tcoordMC&quot;,e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||fp(&quot;Error setting tcoordMC in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),t.internalColorTexture&&e.getProgram().isUniformUsed(&quot;texture1&quot;)&&e.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi(&quot;picking&quot;,a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f(&quot;diffuseColor&quot;,i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===up?-1:1,x[15]=1,m(x,x),a.setUniformMatrix(&quot;WCVCMatrix&quot;,(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const vp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const yp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=dp,t.tmpMat4=g(new Float64Array(16));for(let e=dp.Start;e<dp.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),hp(e,t)}),&quot;vtkOpenGLPolyDataMapper2D&quot;);rn(&quot;vtkMapper2D&quot;,yp);const{VectorMode:Tp}=Pl;function bp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function xp(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Cp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Sp(e,t){t.classHierarchy.push(&quot;vtkScalarBarActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;;const n={},r=new Map;let o=0,a=1;bp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,bp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),&quot;NaN&quot;,&quot;Below&quot;,&quot;Above&quot;];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{bp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s(&quot;NaN&quot;,[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s(&quot;Below&quot;,[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s(&quot;ticks&quot;,t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s(&quot;Above&quot;,[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p=&quot;vertical&quot;===a?[1,0]:[0,1];&quot;vertical&quot;===a?(d[0]=l.width,d[1]=-l.height,&quot;middle&quot;===o[0]?n[1]-=l.width/2:&quot;right&quot;===o[0]&&(n[1]-=l.width),&quot;middle&quot;===o[1]?n[0]+=l.height/2:&quot;top&quot;===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,&quot;middle&quot;===o[0]?n[0]-=l.width/2:&quot;right&quot;===o[0]&&(n[0]-=l.width),&quot;middle&quot;===o[1]?n[1]-=l.height/2:&quot;top&quot;===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?[&quot;right&quot;,&quot;middle&quot;]:[&quot;middle&quot;,&quot;bottom&quot;];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;top&quot;],&quot;vertical&quot;,[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];&quot;ticks&quot;===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,&quot;horizontal&quot;,g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,&quot;horizontal&quot;,g,c)}const b=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Tp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Es.newInstance({numberOfComponents:i,values:c,name:&quot;Scalars&quot;});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Ap=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;tickLabelPixelOffset&quot;,&quot;renderable&quot;,&quot;topTitle&quot;,&quot;ticks&quot;,&quot;tickStrings&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;lastTickBounds&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;barActor&quot;,&quot;tmActor&quot;]),jt.getArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.barMapper=nc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=gu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=hs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Tu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Sp(e,t)}),&quot;vtkScalarBarActorHelper&quot;);function Ip(e,t){t.classHierarchy.push(&quot;vtkScalarBarActor&quot;),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(xp(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Cp())}}function wp(e){return{automated:!0,autoLayout:null,axisLabel:&quot;Scalar Value&quot;,barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:14,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function Pp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wp(n)),t.autoLayout||(t.autoLayout=xp(0,t)),t.generateTicks||(t.generateTicks=Cp()),hs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,[&quot;automated&quot;,&quot;autoLayout&quot;,&quot;axisTitlePixelOffset&quot;,&quot;axisLabel&quot;,&quot;scalarsToColors&quot;,&quot;tickLabelPixelOffset&quot;,&quot;generateTicks&quot;,&quot;drawNanAnnotation&quot;,&quot;drawBelowRangeSwatch&quot;,&quot;drawAboveRangeSwatch&quot;]),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;]),jt.getArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;],2),Ip(e,t)}var Op={newInstance:jt.newInstance(Pp,&quot;vtkScalarBarActor&quot;),extend:Pp,newScalarBarActorHelper:Ap};function Rp(e,t){t.classHierarchy.push(&quot;vtkOpenGLScalarBarActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Mp={};const Dp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Op.newScalarBarActorHelper(),Rp(e,t)}),&quot;vtkOpenGLScalarBarActor&quot;);rn(&quot;vtkScalarBarActor&quot;,Dp);const{vtkErrorMacro:Ep}=Kt;function Vp(e,t){t.classHierarchy.push(&quot;vtkOpenGLSkybox&quot;),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi(&quot;sbtexture&quot;,n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix(&quot;IMCPCMatrix&quot;,a),&quot;box&quot;===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f(&quot;camPos&quot;,e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Es.newInstance({numberOfComponents:3,values:e});n.setName(&quot;points&quot;);const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),&quot;box&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec3 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = wpos.xyz/wpos.w;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec3 TexCoords;\\n             uniform samplerCube sbtexture;\\n             uniform vec3 camPos;\\n             void main () {\\n               // skybox looks from inside out\\n               // which means we have to adjust\\n               // our tcoords. Otherwise text would\\n               // be flipped\\n               vec3 tc = normalize(TexCoords - camPos);\\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\\n               {\\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\\n               }\\n               else\\n               {\\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\\n               }\\n               gl_FragData[0] = textureCube(sbtexture, tc);\\n             }&quot;,&quot;&quot;)),&quot;background&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec2 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec2 TexCoords;\\n             uniform sampler2D sbtexture;\\n             void main () {\\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\\n             }&quot;,&quot;&quot;)),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),&quot;vertexMC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Ep(&quot;Error setting vertexMC in shader VAO.&quot;));const e=t.renderable.getTextures();e.length||Ep(&quot;vtkSkybox requires a texture map&quot;),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Lp={context:null};const Bp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lp,n),Zt.extend(e,t,n),t.openGLTexture=Nd.newInstance(),t.tris=yd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Vp(e,t)}));rn(&quot;vtkSkybox&quot;,Bp);const{FieldAssociations:Np}=ol;function _p(e,t){t.classHierarchy.push(&quot;vtkHardwareSelector&quot;),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const Fp={fieldAssociation:Np.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function kp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fp,n),jt.obj(e,t),jt.setGet(e,t,[&quot;fieldAssociation&quot;,&quot;captureZValues&quot;]),_p(e,t)}var Gp={newInstance:jt.newInstance(kp,&quot;vtkHardwareSelector&quot;),extend:kp};function Up(e,t){t.classHierarchy.push(&quot;vtkFramebuffer&quot;),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling saveCurrentBindings&quot;);const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling restorePreviousBindings&quot;);const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et(&quot;you must set the OpenGLRenderWindow before calling create&quot;)},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et(&quot;you must set the OpenGLRenderWindow before calling setColorBuffer&quot;);let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et(&quot;you must set the OpenGLRenderWindow before calling removeColorBuffer&quot;);let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et(&quot;Attaching depth buffer textures to fbo requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling setDepthBuffer&quot;)},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et(&quot;Attaching depth buffer textures to framebuffers requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling removeDepthBuffer&quot;)},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>{const e=[0,0];return null!==t.glFramebuffer&&(e[0]=t.glFramebuffer.width,e[1]=t.glFramebuffer.height),e},e.populateFramebuffer=()=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling populateFrameBuffer&quot;);e.bind();const n=t.context,r=Nd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(bd.LINEAR),r.setMagnificationFilter(bd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,ys.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const zp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Wp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zp,n),yt(e,t),t.colorBuffers&&et(&quot;you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.&quot;),t.colorBuffers=[],It(e,t,[&quot;colorBuffers&quot;]),Up(e,t)}var Hp={newInstance:Et(Wp,&quot;vtkFramebuffer&quot;),extend:Wp};function jp(e,t){t.classHierarchy.push(&quot;vtkSelectionNode&quot;),e.getBounds=()=>t.points.getBounds()}const Kp={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function $p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kp,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,[&quot;contentType&quot;,&quot;fieldType&quot;,&quot;properties&quot;,&quot;selectionList&quot;]),jp(e,t)}var qp={newInstance:jt.newInstance($p,&quot;vtkSelectionNode&quot;),extend:$p,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Xp}=Wl,{SelectionContent:Yp,SelectionField:Zp}=qp,{FieldAssociations:Qp}=ol,{vtkErrorMacro:Jp}=jt;function ef(e){return`${e.propID} ${e.compositeID}`}function tf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function nf(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function rf(e,t){let n=t;return n<<=24,n|=e,n}function of(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=nf(n[0],n[1],e.pixBuffer[Xp.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=nf(n[0],n[1],e.pixBuffer[Xp.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Xp.ID_LOW24]&&0===tf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area))return a;const s=nf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area),l=nf(n[0],n[1],e.pixBuffer[Xp.ID_HIGH24],e.area);return a.attributeID=rf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=of(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=of(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=of(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function af(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=qp.newInstance();switch(l.setContentType(Yp.INDICES),e){case Qp.FIELD_ASSOCIATION_CELLS:l.setFieldType(Zp.CELL);break;case Qp.FIELD_ASSOCIATION_POINTS:l.setFieldType(Zp.POINT);break;default:Jp(&quot;Unknown field association&quot;)}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function sf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=of(e,[n,t],0,u);if(r&&r.valid){const t=ef(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return af(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function lf(e,t){t.classHierarchy.push(&quot;vtkOpenGLHardwareSelector&quot;),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e[0]!==n[0]||e[1]!==n[1]?(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer()):t.framebuffer.bind()}else t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return sf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return Jp(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:&quot;StartEvent&quot;}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();for(e.beginSelection(),t.currentPass=Xp.MIN_KNOWN_PASS;t.currentPass<=Xp.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Xp.ACTOR_PASS&&&quot;function&quot;==typeof n[0].requestDepth&&&quot;function&quot;==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),e.processPixelBuffers());return e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:&quot;EndEvent&quot;}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Xp.ID_HIGH24){if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Xp.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if(&quot;function&quot;==typeof e[0].requestDepth&&&quot;function&quot;==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=nf(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Xp.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Xp.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(Xp,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=nf(e[0],e[1],t.pixBuffer[Xp.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=nf(e[0],e[1],t.pixBuffer[Xp.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Xp.ID_LOW24]&&0===tf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area))return a;const s=nf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area),l=nf(e[0],e[1],t.pixBuffer[Xp.ID_HIGH24],t.area);return a.attributeID=rf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=ef(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return af(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const cf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cf,n),Gp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,[&quot;area&quot;],4),jt.setGet(e,t,[&quot;_renderer&quot;,&quot;currentPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;maximumPointId&quot;,&quot;maximumCellId&quot;]),jt.setGetArray(e,t,[&quot;propColorValue&quot;],3),jt.moveToProtected(e,t,[&quot;renderer&quot;,&quot;openGLRenderWindow&quot;]),jt.event(e,t,&quot;event&quot;),lf(e,t)}var df={newInstance:jt.newInstance(uf,&quot;vtkOpenGLHardwareSelector&quot;),extend:uf,...Wl};const{vtkErrorMacro:pf}=Kt,{Representation:ff}=ds,{ObjectType:gf}=qu,{PassTypes:mf}=df,hf={type:&quot;StartEvent&quot;},vf={type:&quot;EndEvent&quot;};function yf(e,t){t.classHierarchy.push(&quot;vtkOpenGLGlyph3DMapper&quot;);const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(hf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(vf),!t.currentInput)return void pf(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;attribute mat3 gNormal;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * gNormal * normalMC;&quot;]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;];a&&(i=i.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let s=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];a&&(s=s.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),s=s.concat([&quot;  opacity = opacityUniform;&quot;]),a&&(s=s.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),t.drawingEdges||(i=i.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),n=cd.substitute(n,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 gColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput = gColor;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result,s=s.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])),o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,s).result,o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;vertexVCVSOutput = MCVCMatrix * gVertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result):(n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;]).result,n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=cd.substitute(n,&quot;//VTK::Picking::Dec&quot;,[&quot;attribute vec3 mapperIndexVS;&quot;,&quot;varying vec3 mapperIndexVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Picking::Impl&quot;,&quot;  mapperIndexVSOutput = mapperIndexVS;&quot;).result,e.Vertex=n,t=cd.substitute(t,&quot;//VTK::Picking::Dec&quot;,[&quot;varying vec3 mapperIndexVSOutput;&quot;,&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,t=cd.substitute(t,&quot;//VTK::Picking::Impl&quot;,[&quot;  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);&quot;,&quot;  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];&quot;]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3(&quot;normalMatrix&quot;,t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix(&quot;MCVCMatrix&quot;,t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray(&quot;ambientColorUniform&quot;,t.tmpColor),u.setUniform3fArray(&quot;diffuseColorUniform&quot;,t.tmpColor)}c&&u.setUniform3fArray(&quot;mapperIndex&quot;,c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===ff.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===mf.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed(&quot;normalMatrix&quot;),v=g.isUniformUsed(&quot;MCVCMatrix&quot;);if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed(&quot;gMatrix&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,&quot;gMatrix&quot;,0,64,t.context.FLOAT,4,!1,1)||pf(&quot;Error setting gMatrix in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gMatrix&quot;),e.getProgram().isAttributeUsed(&quot;gNormal&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,&quot;gNormal&quot;,0,36,t.context.FLOAT,3,!1,1)||pf(&quot;Error setting gNormal in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gNormal&quot;),e.getProgram().isAttributeUsed(&quot;gColor&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,&quot;gColor&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting gColor in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gColor&quot;),e.getProgram().isAttributeUsed(&quot;mapperIndexVS&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,&quot;mapperIndexVS&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting mapperIndexVS in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;mapperIndexVS&quot;),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=qu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=qu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=qu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=qu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,gf.ARRAY_BUFFER),t.normalBuffer.upload(n,gf.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),gf.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,gf.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Tf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const bf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),np.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),yf(e,t)}),&quot;vtkOpenGLGlyph3DMapper&quot;);rn(&quot;vtkGlyph3DMapper&quot;,bf);const{vtkErrorMacro:xf}=jt;class Cf{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Sf(e,t){t.classHierarchy.push(&quot;vtkClosedPolyLineToSurfaceFilter&quot;),e.requestData=(e,t)=>{const n=e[0];if(!n)return void xf(&quot;Invalid or missing input&quot;);const r=gu.newInstance();r.shallowCopy(n);const o=new Cf,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(cc.newInstance({values:c,name:&quot;faces&quot;})),t[0]=r}}const Af={};function If(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Af,n),jt.obj(e,t),jt.algo(e,t,1,1),Sf(e,t)}var wf={newInstance:jt.newInstance(If,&quot;vtkClosedPolyLineToSurfaceFilter&quot;),extend:If};const{vtkErrorMacro:Pf}=Kt;function Of(e,t){t.classHierarchy.push(&quot;vtkCutter&quot;);const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Pf(&quot;Invalid or missing input&quot;);if(!t.cutFunction)return void Pf(&quot;Missing cut function&quot;);const o=gu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error(&quot;Iterator is done&quot;);r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const Rf={cutFunction:null,cutScalars:null,cutValue:0};function Mf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),yt(e,t),Rt(e,t,1,1),At(e,t,[&quot;cutFunction&quot;,&quot;cutValue&quot;]),Of(e,t)}var Df={newInstance:Et(Mf,&quot;vtkCutter&quot;),extend:Mf};const Ef=e=>e,Vf=1e-6;class Lf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Ef}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=Dn(n,r);return a>=1||(En(this.tmp,n,r),Sn(this.tmp)<Vf&&(En(this.tmp,[1,0,0],e),Sn(this.tmp)<Vf&&En(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Bf=function(){return new Lf(!0)},Nf=function(){return new Lf(!1)};const _f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],Ff=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function kf(e,t){t.classHierarchy.push(&quot;vtkCubeSource&quot;),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=gu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Es.newInstance({name:&quot;Normals&quot;,values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Es.newInstance({name:&quot;TextureCoordinates&quot;,values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Bf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Nf().translate(...t.center).apply(o),t.matrix){Nf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Nf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Gf={xLength:1,yLength:1,zLength:1,pointType:&quot;Float64Array&quot;,generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;xLength&quot;,&quot;yLength&quot;,&quot;zLength&quot;,&quot;generate3DTextureCoordinates&quot;,&quot;generateFaces&quot;,&quot;generateLines&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;rotations&quot;],3),jt.setGetArray(e,t,[&quot;matrix&quot;],16),t._polys=cc.newInstance({values:Uint16Array.from(Ff)}),t._lineCells=cc.newInstance({values:Uint16Array.from(_f)}),jt.moveToProtected(e,t,[&quot;polys&quot;,&quot;lineCells&quot;]),jt.algo(e,t,0,1),kf(e,t)}var zf={newInstance:jt.newInstance(Uf,&quot;vtkCubeSource&quot;),extend:Uf};const{vtkErrorMacro:Wf}=jt;function Hf(e,t){t.classHierarchy.push(&quot;vtkImageDataOutlineFilter&quot;);const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA(&quot;vtkImageData&quot;))return void Wf(&quot;Invalid or missing input&quot;);const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Wf(&quot;Unable to fetch spatial extents of input image.&quot;)},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const jf={};function Kf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jf,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=zf.newInstance(),jt.moveToProtected(e,t,[&quot;cubeSource&quot;,&quot;tmpOut&quot;]),Hf(e,t)}var $f={newInstance:jt.newInstance(Kf,&quot;vtkImageDataOutlineFilter&quot;),extend:Kf};let qf;function Xf(e,t){t.classHierarchy.push(&quot;vtkAbstractTransform&quot;,&quot;vtkHomogeneousTransform&quot;,&quot;vtkTransform&quot;),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>qf({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const Yf={preMultiplyFlag:!1,matrix:[...vo]};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;preMultiplyFlag&quot;]),jt.setGetArray(e,t,[&quot;matrix&quot;],16),Xf(e,t)}qf=jt.newInstance(Zf,&quot;vtkTransform&quot;);var Qf={newInstance:qf,extend:Zf};const Jf={NEAREST:0,LINEAR:1};var eg={InterpolationType:Jf};const{vtkErrorMacro:tg}=Kt;function ng(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function rg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function og(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageResliceMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:&quot;EndEvent&quot;})):tg(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Jf.NEAREST?(t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.openGLTexture.setMinificationFilter(bd.LINEAR),t.openGLTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime(),e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(!r)return;const o=r.getPointData()?.getScalars();if(!o)return;t._scalars!==o&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=o);const a=o.getNumberOfComponents();let i=`${r.getMTime()}A${o.getMTime()}`;const s=t._openGLRenderWindow.getGraphicsResourceForObject(o);if(s?.vtkObj&&s?.hash===i&&t.openGLTextureString===i)t.openGLTexture=s.vtkObj,t.openGLTextureString=s.hash;else{t.openGLTexture||(t.openGLTexture=Nd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const e=r.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],o),t.openGLTextureString=i,o&&t._openGLRenderWindow.setGraphicsResourceForObject(o,t.openGLTexture,t.openGLTextureString)}const l=n.getProperty(),c=l.getIndependentComponents(),u=c?a:1,d=c?2*u:1,p=l.getRGBTransferFunction();i=ng(l,p,u);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===i&&t.colorTextureString===i)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(e*d*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),p){const r=new Float32Array(3*e);for(let t=0;t<u;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),c)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=i,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}const g=l.getPiecewiseFunction();i=ng(l,g,u);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(m?.vtkObj&&m?.hash===i&&t.pwfTextureString===i)t.pwfTexture=m.vtkObj,t.pwfTextureString=m.hash;else{const e=1024,n=e*d,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),g){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<u;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=i,g&&t._openGLRenderWindow.setGraphicsResourceForObject(g,t.pwfTexture,t.pwfTextureString)}const h=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==h){const e=Es.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName(&quot;points&quot;);const n=Es.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:tg(&quot;Slab mode requested without normals&quot;)}t.tris.getCABO().createVBO(n,&quot;polys&quot;,rs.SURFACE,r)}t.VBOBuildString=h,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed(&quot;texture1&quot;)&&a.setUniformi(&quot;texture1&quot;,t.openGLTexture.getTextureUnit()),a.isAttributeUsed(&quot;vertexWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexWC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting vertexWC in shader VAO.&quot;)),a.isAttributeUsed(&quot;normalWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;normalWC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting normalWC in shader VAO.&quot;)),a.isUniformUsed(&quot;slabThickness&quot;)&&a.setUniformf(&quot;slabThickness&quot;,t.renderable.getSlabThickness()),a.isUniformUsed(&quot;spacing&quot;)&&a.setUniform3fv(&quot;spacing&quot;,t.currentInput.getSpacing()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabTrapezoid&quot;)&&a.setUniformi(&quot;slabTrapezoid&quot;,t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed(&quot;WCTCMatrix&quot;)){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix(&quot;WCTCMatrix&quot;,t.tmpMat4)}a.isUniformUsed(&quot;vboScaling&quot;)&&a.setUniform3fv(&quot;vboScaling&quot;,n.getCABO().getCoordScale()),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed(&quot;MCPCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCPCMatrix&quot;,rg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed(&quot;MCVCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCVCMatrix&quot;,rg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d),o.setUniform4fv(&quot;backgroundColor&quot;,t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model coordinates\\n// WC - World coordinates\\n// VC - View coordinates\\n// DC - Display coordinates\\n// TC - Texture coordinates\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvoid main()\\n{\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the gpu image mapper fragment shader\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  //VTK::TCoord::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform mat4 WCTCMatrix;&quot;,&quot;out vec3 fragTexCoord;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;fragTexCoord = (WCTCMatrix * vertexWC).xyz;&quot;]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=[&quot;in vec3 fragTexCoord;&quot;,&quot;uniform highp sampler3D texture1;&quot;,&quot;uniform mat4 WCTCMatrix;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}s>0&&(u=u.concat([&quot;uniform vec3 spacing;&quot;,&quot;uniform float slabThickness;&quot;,&quot;uniform int slabType;&quot;,&quot;uniform int slabTrapezoid;&quot;,&quot;uniform vec3 vboScaling;&quot;]),u=u.concat([&quot;vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)&quot;,&quot;{&quot;,&quot;  vec4 retVal = vec4(1.0);&quot;,&quot;  if (slabType == 0) // min&quot;,&quot;  {&quot;,&quot;    retVal = min(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 1) // max&quot;,&quot;  {&quot;,&quot;    retVal = max(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 3) // sum&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  else // mean&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  return retVal;&quot;,&quot;}&quot;])),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,u).result;let d=[&quot;if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(texture1, fragTexCoord);&quot;];if(s>0&&(d=d.concat([&quot;// Get the first and last samples&quot;,&quot;int numSlices = 1;&quot;,&quot;float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;&quot;,&quot;vec3 normalxspacing = scaling * normalWCVSOutput;&quot;,&quot;float distTraveled = length(normalxspacing);&quot;,&quot;int trapezoid = 0;&quot;,&quot;while (distTraveled < slabThickness * 0.5)&quot;,&quot;{&quot;,&quot;  distTraveled += length(normalxspacing);&quot;,&quot;  float fnumSlices = float(numSlices);&quot;,&quot;  if (distTraveled > slabThickness * 0.5)&quot;,&quot;  {&quot;,&quot;    // Before stepping outside the slab, sample at the boundaries&quot;,&quot;    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;&quot;,&quot;    trapezoid = slabTrapezoid;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordNeg);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordPos);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;}&quot;,&quot;// Finally, if slab type is *mean*, divide the sum by the numSlices&quot;,&quot;if (slabType == 2)&quot;,&quot;{&quot;,&quot;  tvalue = tvalue / float(numSlices);&quot;,&quot;}&quot;])),c){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(l){case 1:d=d.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:d=d.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=[&quot;attribute vec4 vertexWC;&quot;];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat([&quot;attribute vec3 normalWC;&quot;,&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,c).result;let u=[&quot;gl_Position = MCPCMatrix * vertexWC;&quot;];l>0&&(u=u.concat([&quot;normalWCVSOutput = normalWC;&quot;,&quot;vertexWCVSOutput = vertexWC;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,u).result,a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result;let d=[];l>0&&(d=d.concat([&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),s=cd.substitute(s,&quot;//VTK::PositionVC::Dec&quot;,d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e=&quot;&quot;;const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`));const t=ue(n?.getDirection());ge(t,t);const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999||o>.999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ni.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getDimensions(),l=[0,i[0]-1,0,i[1]-1,0,i[2]-1];let c=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[c+a]=r[a],e[c+o[0]]=l[2*o[0]+n],e[c+o[1]]=l[2*o[1]+t],c+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const u=new Uint16Array(8);u[0]=3,u[1]=0,u[2]=1,u[3]=3,u[4]=3,u[5]=0,u[6]=3,u[7]=2;const d=s.getNormal();za.normalize(d);const p=new Float32Array(12);for(let e=0;e<4;++e)p[3*e]=d[0],p[3*e+1]=d[1],p[3*e+2]=d[2];t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(u,1);const f=Es.newInstance({numberOfComponents:3,values:p,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(f)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=gu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Es.newInstance({numberOfComponents:3,values:a,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(i)}else tg(&quot;Something went wrong.&quot;,&quot;A default slice plane should have been created in the beginning of&quot;,&quot;updateResliceGeometry.&quot;);t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)}}const ag={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,openGLTextureString:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1,_scalars:null};const ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ag,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=$f.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=gu.newInstance(),t.cutter=Df.newInstance(),t.lineToSurfaceFilter=wf.newInstance(),t.transform=Qf.newInstance(),bt(e,t,[&quot;openGLTexture&quot;]),og(e,t)}),&quot;vtkOpenGLImageResliceMapper&quot;);rn(&quot;vtkImageResliceMapper&quot;,ig);var sg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:lg}=Kt,{SlicingMode:cg}=sg;function ug(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function dg(e){const t=e.split(&quot;\\n&quot;),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function pg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t.renderable.isA(&quot;vtkImageMapper&quot;)&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(n.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,a=cd.substitute(a,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result,a=cd.substitute(a,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform sampler2D labelOutlineTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform float outlineOpacity;&quot;];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}}if(i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,c).result,!0===o.getProperty().getUseLabelOutline()&&(i=cd.substitute(i,&quot;//VTK::LabelOutline::Dec&quot;,[&quot;uniform int outlineThickness;&quot;,&quot;uniform float vpWidth;&quot;,&quot;uniform float vpHeight;&quot;,&quot;uniform float vpOffsetX;&quot;,&quot;uniform float vpOffsetY;&quot;,&quot;uniform mat4 PCWCMatrix;&quot;,&quot;uniform mat4 vWCtoIDX;&quot;,&quot;uniform ivec3 imageDimensions;&quot;]).result,i=cd.substitute(i,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result,i=cd.substitute(i,&quot;//VTK::LabelOutlineHelperFunction&quot;,[&quot;#ifdef vtkImageLabelOutlineOn&quot;,&quot;vec3 fragCoordToIndexSpace(vec4 fragCoord) {&quot;,&quot;  vec4 pcPos = vec4(&quot;,&quot;    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,&quot;,&quot;    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,&quot;,&quot;    (fragCoord.z - 0.5) * 2.0,&quot;,&quot;    1.0);&quot;,&quot;&quot;,&quot;  vec4 worldCoord = PCWCMatrix * pcPos;&quot;,&quot;  vec4 vertex = (worldCoord/worldCoord.w);&quot;,&quot;&quot;,&quot;  vec3 index = (vWCtoIDX * vertex).xyz;&quot;,&quot;&quot;,&quot;  // half voxel fix for labelmapOutline&quot;,&quot;  return (index + vec3(0.5)) / vec3(imageDimensions);&quot;,&quot;}&quot;,&quot;#endif&quot;]).result),l){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];let t=[&quot;vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);&quot;];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, opacity);&quot;]);break;case 2:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,t).result}else switch(s){case 1:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[...dg(&quot;\\n                #ifdef vtkImageLabelOutlineOn\\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); \\n                  float centerValue = texture2D(texture1, centerPosIS.xy).r;\\n                  bool pixelOnBorder = false;\\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\\n                  float opacityToUse = scalarOpacity * opacity;\\n                  int segmentIndex = int(centerValue * 255.0);\\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\\n                  int actualThickness = int(textureValue * 255.0);\\n\\n                  if (actualThickness == 0) {\\n                    gl_FragData[0] = vec4(0.0, 0.0, 1.0, 1.0);\\n                    return;\\n                  }\\n                  if (opacityToUse > 0.01) {\\n                    for (int i = -actualThickness; i <= actualThickness; i++) {\\n                      for (int j = -actualThickness; j <= actualThickness; j++) {\\n                        if (i == 0 || j == 0) {\\n                          continue;\\n                        }\\n                        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n                          gl_FragCoord.y + float(j),\\n                          gl_FragCoord.z, gl_FragCoord.w);\\n                        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n                        float value = texture2D(texture1, neighborPosIS.xy).r;\\n                        if (value != centerValue) {\\n                          pixelOnBorder = true;\\n                          break;\\n                        }\\n                      }\\n                      if (pixelOnBorder == true) {\\n                        break;\\n                      }\\n                    }\\n                    if (pixelOnBorder == true) {\\n                      gl_FragData[0] = vec4(tColor, outlineOpacity);\\n                    }\\n                    else {\\n                      gl_FragData[0] = vec4(tColor, opacityToUse);\\n                    }\\n                  }\\n                #else\\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\\n                #endif\\n                &quot;)]).result;break;case 2:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;float intensity = tcolor.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);&quot;]).result;break;case 3:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]).result;break;default:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;]).result}t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||lg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||lg(&quot;Error setting tcoordMC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi(&quot;texture1&quot;,a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi(&quot;colorTexture1&quot;,c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi(&quot;pwfTexture1&quot;,u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;labelOutlineTexture1&quot;,p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf(&quot;outlineOpacity&quot;,e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();a.setUniform3i(&quot;imageDimensions&quot;,o[0],o[1],1),a.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const i=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,i.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const l=e.getRenderTargetSize();a.setUniformf(&quot;vpWidth&quot;,l[0]),a.setUniformf(&quot;vpHeight&quot;,l[1]);const c=e.getRenderTargetOffset();a.setUniformf(&quot;vpOffsetX&quot;,c[0]/l[0]),a.setUniformf(&quot;vpOffsetY&quot;,c[1]/l[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf(&quot;opacity&quot;,o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):lg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=ug(l,f,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.vtkObj&&m?.hash===g&&t.colorTextureString===g)t.colorTexture=m.vtkObj,t.colorTextureString=m.hash;else{const e=1024,n=new Uint8Array(e*p*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST)):(t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR)),f){const r=new Float32Array(3*e);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),u)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,p,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=g,f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,t.colorTextureString)}const h=l.getPiecewiseFunction(),v=ug(l,h,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.vtkObj&&y?.hash===v&&t.pwfTextureString===v)t.pwfTexture=y.vtkObj,t.pwfTextureString=y.hash;else{const e=1024,n=e*p,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),h){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<d;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),u)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,p,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=v,h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,t.pwfTextureString)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA(&quot;vtkImageArrayMapper&quot;)?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===cg.I&&(S=x-C[0]),T===cg.J&&(S=x-C[2]),T!==cg.K&&T!==cg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Nd.newInstance({resizable:!0}),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(new Set([1,3,4]).has(s)&&i===ys.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.NEAREST)):t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST)):(4!==s||i!==ys.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(bd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(bd.LINEAR)),t.openGLTexture.setWrapS(Td.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Td.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[cg.X,cg.Y,cg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===cg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===cg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===cg.K||T===cg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):lg(&quot;Reformat slicing not yet supported.&quot;);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);m?.vtkObj?(t.openGLTexture=m.vtkObj,t.VBOBuildString=m.hash):(t._scalars!==g&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=g),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t._openGLRenderWindow.setGraphicsResourceForObject(g,t.openGLTexture,t.VBOBuildString)),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Es.newInstance({numberOfComponents:3,values:r});h.setName(&quot;points&quot;);const v=Es.newInstance({numberOfComponents:2,values:l});v.setName(&quot;tcoords&quot;);const y=new Uint16Array(8);y[0]=3,y[1]=0,y[2]=1,y[3]=3,y[4]=3,y[5]=0,y[6]=3,y[7]=2;const C=Es.newInstance({numberOfComponents:1,values:y});t.tris.getCABO().createVBO(C,&quot;polys&quot;,rs.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=e=>{t.labelOutlineThicknessTexture||(t.labelOutlineThicknessTexture=Nd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]}}const fg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,_scalars:null};const gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fg,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),pg(e,t)}),&quot;vtkOpenGLImageMapper&quot;);rn(&quot;vtkAbstractImageMapper&quot;,gg);const{vtkErrorMacro:mg}=jt;function hg(e,t,n){if(t.apply(e)){const t=e.getIndependentComponents();return`${e.getMTime()}-${t}-${n}`}return&quot;0&quot;}function vg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageCPRMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow))},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentImageDataInput,o=t.currentCenterlineInput;n.getProperty().getInterpolationType()===Jf.NEAREST?(t.volumeTexture.setMinificationFilter(bd.NEAREST),t.volumeTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.volumeTexture.setMinificationFilter(bd.LINEAR),t.volumeTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR));const a=r.getMTime();if(t.volumeTextureTime!==a){const e=r.getDimensions(),n=r.getPointData().getScalars();if(!n)return;t.volumeTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.volumeTexture.releaseGraphicsResources(t._openGLRenderWindow),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromRaw(e[0],e[1],e[2],n.getNumberOfComponents(),n.getDataType(),n.getData(),t.renderable.getPreferSizeOverAccuracy()),t.volumeTextureTime=a}const i=r.getPointData()&&r.getPointData().getScalars();if(!i)return;const s=i.getNumberOfComponents(),l=n.getProperty(),c=l.getIndependentComponents(),u=c?s:1,d=c?2*u:1,p=hg(l,l.getRGBTransferFunction,u);if(t.colorTextureString!==p){const e=1024,n=new Uint8Array(e*d*3);let r=l.getRGBTransferFunction();if(r){const o=new Float32Array(3*e);for(let t=0;t<u;t++){r=l.getRGBTransferFunction(t);const a=r.getRange();if(r.getTable(a[0],a[1],e,o,1),c)for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r],n[t*e*6+r+3*e]=255*o[r];else for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=p}const f=hg(l,l.getPiecewiseFunction,u);if(t.pwfTextureString!==f){const e=1024,n=e*d,r=new Uint8Array(n);let o=l.getPiecewiseFunction();if(t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),o){const r=new Float32Array(n),a=new Float32Array(e);for(let t=0;t<u;++t)if(o=l.getPiecewiseFunction(t),null===o)r.fill(1);else{const n=o.getRange();if(o.getTable(n[0],n[1],e,a,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=a[n],r[t*e*2+n+e]=a[n];else for(let n=0;n<e;n++)r[t*e*2+n]=a[n]}t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=f}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<o.getMTime()){const e=o.getNumberOfPoints(),n=e<=1?0:e-1,r=o.getDistancesToFirstPoint(),a=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,a-r[e],0],t),t+=3,s.set([l,a-r[e],0],t),t+=3,s.set([l,a-r[e+1],0],t),t+=3,s.set([0,a-r[e+1],0],t),t+=3;const c=Es.newInstance({numberOfComponents:3,values:s});c.setName(&quot;points&quot;);const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Es.newInstance({numberOfComponents:1,values:u}),p=o.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Es.newInstance({numberOfComponents:3,values:f,name:&quot;centerlinePosition&quot;}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Es.newInstance({numberOfComponents:1,values:v,name:&quot;quadIndex&quot;})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getCenterlineTangentDirections(),r=new Float32Array(3*i),o=new Float32Array(3*i);for(let t=0,a=0;t<n;++t){const n=3*t;for(let t=0;t<4;++t)r[a+0]=e[n+0],r[a+1]=e[n+1],r[a+2]=e[n+2],o[a+0]=e[n+3],o[a+1]=e[n+4],o[a+2]=e[n+5],a+=3}const a=Es.newInstance({numberOfComponents:3,values:r,name:&quot;centerlineTopDirection&quot;}),s=Es.newInstance({numberOfComponents:3,values:o,name:&quot;centerlineBotDirection&quot;});y.push(a,s)}t.tris.getCABO().createVBO(d,&quot;polys&quot;,rs.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result;const s=[&quot;attribute vec3 centerlinePosition;&quot;,&quot;attribute float quadIndex;&quot;,&quot;uniform float width;&quot;,&quot;out vec2 quadOffsetVSOutput;&quot;,&quot;out vec3 centerlinePosVSOutput;&quot;],l=t.renderable.getUseUniformOrientation();l?s.push(&quot;out vec3 centerlineDirVSOutput;&quot;,&quot;uniform vec3 centerlineDirection;&quot;):s.push(&quot;out vec3 centerlineTopDirVSOutput;&quot;,&quot;out vec3 centerlineBotDirVSOutput;&quot;,&quot;out float centerlineAngleVSOutput;&quot;,&quot;attribute vec3 centerlineTopDirection;&quot;,&quot;attribute vec3 centerlineBotDirection;&quot;),a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,s).result;const c=[&quot;quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);&quot;,&quot;centerlinePosVSOutput = centerlinePosition;&quot;];l?c.push(&quot;centerlineDirVSOutput = centerlineDirection;&quot;):c.push(&quot;vec3 sumVec = centerlineTopDirection + centerlineBotDirection;&quot;,&quot;float sumLen2 = dot(sumVec, sumVec);&quot;,&quot;float diffLen2 = 4.0 - sumLen2;&quot;,&quot;if (diffLen2 < 0.001) {&quot;,&quot;  // vectors are too close to each other, use lerp&quot;,&quot;  centerlineAngleVSOutput = -1.0; // use negative angle as a flag for lerp&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection;&quot;,&quot;} else if (sumLen2 == 0.0) {&quot;,&quot;  // vector are opposite to each other, don't make a choice for the user&quot;,&quot;  // use slerp without direction, it will display the centerline color on each row of pixel&quot;,&quot;  centerlineAngleVSOutput = 0.0;&quot;,&quot;  centerlineTopDirVSOutput = vec3(0.0);&quot;,&quot;  centerlineBotDirVSOutput = vec3(0.0);&quot;,&quot;} else {&quot;,&quot;  // use slerp&quot;,&quot;  centerlineAngleVSOutput = 2.0 * atan(sqrt(diffLen2/sumLen2));&quot;,&quot;  float sinAngle = sin(centerlineAngleVSOutput);&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection / sinAngle;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection / sinAngle;&quot;,&quot;}&quot;),a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,c).result;const u=t.volumeTexture.getComponents(),d=o.getProperty().getIndependentComponents();let p=[&quot;uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates&quot;,&quot;in vec2 quadOffsetVSOutput;&quot;,&quot;in vec3 centerlinePosVSOutput;&quot;,&quot;uniform highp sampler3D volumeTexture;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;];l?p.push(&quot;in vec3 centerlineDirVSOutput;&quot;):p.push(&quot;in vec3 centerlineTopDirVSOutput;&quot;,&quot;in vec3 centerlineBotDirVSOutput;&quot;,&quot;in float centerlineAngleVSOutput;&quot;);const f=t.renderable.getCenterPoint();if(f&&p.push(&quot;uniform vec3 globalCenterPoint;&quot;),d){for(let e=1;e<u;e++)p=p.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(u){case 1:p=p.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,p).result;let g=[];if(l?g.push(&quot;vec3 interpolatedCenterlineDir = centerlineDirVSOutput;&quot;):g.push(&quot;vec3 interpolatedCenterlineDir;&quot;,&quot;if (centerlineAngleVSOutput < 0.0) {&quot;,&quot;  // Lerp&quot;,&quot;  interpolatedCenterlineDir = quadOffsetVSOutput.y * centerlineTopDirVSOutput + (1.0 - quadOffsetVSOutput.y) * centerlineBotDirVSOutput;&quot;,&quot;} else {&quot;,&quot;  // Slerp&quot;,&quot;  float topInterpolationAngle = quadOffsetVSOutput.y * centerlineAngleVSOutput;&quot;,&quot;  float botInterpolationAngle = centerlineAngleVSOutput - topInterpolationAngle;&quot;,&quot;  interpolatedCenterlineDir = sin(topInterpolationAngle) * centerlineTopDirVSOutput + sin(botInterpolationAngle) * centerlineBotDirVSOutput;&quot;,&quot;}&quot;,&quot;// Slerp should give a normalized vector but when sin(angle) is small, rounding error occurs&quot;,&quot;// Normalize for both lerp and slerp&quot;,&quot;interpolatedCenterlineDir = normalize(interpolatedCenterlineDir);&quot;),f?g.push(&quot;float baseOffset = dot(interpolatedCenterlineDir, globalCenterPoint - centerlinePosVSOutput);&quot;,&quot;float horizontalOffset = quadOffsetVSOutput.x + baseOffset;&quot;):g.push(&quot;float horizontalOffset = quadOffsetVSOutput.x;&quot;),g.push(&quot;vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * interpolatedCenterlineDir;&quot;,&quot;vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;&quot;,&quot;if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(volumeTexture, volumePosTC);&quot;),d){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<u;++t)g=g.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(u){case 1:g=g.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(u){case 1:g=g.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:g=g.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,g).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||mg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getCABO().getCustomData().forEach((e=>{e&&n.getProgram().isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),e.name,e.offset,n.getCABO().getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&mg(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const a=t.volumeTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;volumeTexture&quot;,a),n.getProgram().setUniformf(&quot;width&quot;,t.renderable.getWidth()),n.getProgram().setUniform4f(&quot;backgroundColor&quot;,...t.renderable.getBackgroundColor()),n.getProgram().isUniformUsed(&quot;centerlineDirection&quot;)){const e=t.renderable.getUniformDirection();n.getProgram().setUniform3fArray(&quot;centerlineDirection&quot;,e)}if(n.getProgram().isUniformUsed(&quot;globalCenterPoint&quot;)){const e=t.renderable.getCenterPoint();n.getProgram().setUniform3fArray(&quot;globalCenterPoint&quot;,e)}const i=t.currentImageDataInput,s=i.getWorldToIndex(),l=P(new Float32Array(16),Rn([],i.getDimensions())),c=oe(l,l,s);if(n.getProgram().setUniformMatrix(&quot;MCTCMatrix&quot;,c),t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)}}const yg={currentRenderPass:null,volumeTexture:null,volumeTextureTime:0,colorTexture:null,colorTextureString:null,pwfTexture:null,pwfTextureString:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Tg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yg,n),Zt.extend(e,t,n),kd(e,t,n),jt.algo(e,t,2,0),t.tris=yd.newInstance(),t.volumeTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.pwfTexture=Nd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),vg(e,t)}),&quot;vtkOpenGLImageCPRMapper&quot;);function bg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageSlice&quot;),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkImageCPRMapper&quot;,Tg);const xg={context:null,keyMatrixTime:null,keyMatrices:null};const Cg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bg(e,t)}),&quot;vtkOpenGLImageSlice&quot;);function Sg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolume&quot;),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn(&quot;vtkImageSlice&quot;,Cg);const Ag={};const Ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ag,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,[&quot;context&quot;]),Sg(e,t)}),&quot;vtkOpenGLVolume&quot;);rn(&quot;vtkVolume&quot;,Ig);const wg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},Pg={FRACTIONAL:0,PROPORTIONAL:1};var Og={InterpolationType:wg,OpacityMode:Pg};const Rg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5};var Mg={BlendMode:Rg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Dg,vtkErrorMacro:Eg}=Kt;function Vg(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function Lg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolumeMapper&quot;),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType(&quot;vtkOpenGLVolume&quot;);const n=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const r=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera()),e.renderPiece(r,n)}},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\n\\nvarying vec3 vertexVCVSOutput;\\nuniform mat4 PCVCMatrix;\\n\\nuniform float dcxmin;\\nuniform float dcxmax;\\nuniform float dcymin;\\nuniform float dcymax;\\n\\nvoid main()\\n{\\n  // dcsmall is the device coords reduced to the\\n  // x y area covered by the volume\\n  vec4 dcsmall = vec4(\\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\\n    vertexDC.z,\\n    vertexDC.w);\\n  vec4 vcpos = PCVCMatrix * dcsmall;\\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\\n  gl_Position = dcsmall;\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkVolumeFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the volume mappers fragment shader\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvarying vec3 vertexVCVSOutput;\\n\\n// first declare the settings from the mapper\\n// that impact the code paths in here\\n\\n// always set vtkNumComponents 1,2,3,4\\n//VTK::NumComponents\\n\\n// possibly define vtkTrilinearOn\\n//VTK::TrilinearOn\\n\\n// possibly define vtkIndependentComponents\\n//VTK::IndependentComponentsOn\\n\\n// possibly define any \\&quot;proportional\\&quot; components\\n//VTK::vtkProportionalComponents\\n\\n// Define the blend mode to use\\n#define vtkBlendMode //VTK::BlendMode\\n\\n// Possibly define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n#ifdef vtkImageLabelOutlineOn\\n\\nuniform float outlineOpacity;\\nuniform float vpWidth;\\nuniform float vpHeight;\\nuniform float vpOffsetX;\\nuniform float vpOffsetY;\\nuniform mat4 PCWCMatrix;\\nuniform mat4 vWCtoIDX;\\n#endif\\n\\n// define vtkLightComplexity\\n//VTK::LightComplexity\\n#if vtkLightComplexity > 0\\nuniform float vSpecularPower;\\nuniform float vAmbient;\\nuniform float vDiffuse;\\nuniform float vSpecular;\\n//VTK::Light::Dec\\n#endif\\n\\n//VTK::VolumeShadowOn\\n//VTK::SurfaceShadowOn\\n//VTK::localAmbientOcclusionOn\\n//VTK::LAO::Dec\\n//VTK::VolumeShadow::Dec\\n\\n// define vtkComputeNormalFromOpacity\\n//VTK::vtkComputeNormalFromOpacity\\n\\n// possibly define vtkGradientOpacityOn\\n//VTK::GradientOpacityOn\\n#ifdef vtkGradientOpacityOn\\nuniform float goscale0;\\nuniform float goshift0;\\nuniform float gomin0;\\nuniform float gomax0;\\n#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\nuniform float goscale1;\\nuniform float goshift1;\\nuniform float gomin1;\\nuniform float gomax1;\\n#if vtkNumComponents >= 3\\nuniform float goscale2;\\nuniform float goshift2;\\nuniform float gomin2;\\nuniform float gomax2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float goscale3;\\nuniform float goshift3;\\nuniform float gomin3;\\nuniform float gomax3;\\n#endif\\n#endif\\n#endif\\n\\n// if you want to see the raw tiled\\n// data in webgl1 uncomment the following line\\n// #define debugtile\\n\\n// camera values\\nuniform float camThick;\\nuniform float camNear;\\nuniform float camFar;\\nuniform int cameraParallel;\\n\\n// values describing the volume geometry\\nuniform vec3 vOriginVC;\\nuniform vec3 vSpacing;\\nuniform ivec3 volumeDimensions; // 3d texture dimensions\\nuniform vec3 vPlaneNormal0;\\nuniform float vPlaneDistance0;\\nuniform vec3 vPlaneNormal1;\\nuniform float vPlaneDistance1;\\nuniform vec3 vPlaneNormal2;\\nuniform float vPlaneDistance2;\\nuniform vec3 vPlaneNormal3;\\nuniform float vPlaneDistance3;\\nuniform vec3 vPlaneNormal4;\\nuniform float vPlaneDistance4;\\nuniform vec3 vPlaneNormal5;\\nuniform float vPlaneDistance5;\\n\\n//VTK::ClipPlane::Dec\\n\\n// opacity and color textures\\nuniform sampler2D otexture;\\nuniform float oshift0;\\nuniform float oscale0;\\nuniform sampler2D ctexture;\\nuniform float cshift0;\\nuniform float cscale0;\\n\\n// jitter texture\\nuniform sampler2D jtexture;\\nuniform sampler2D ttexture;\\n\\n\\n// some 3D texture values\\nuniform float sampleDistance;\\nuniform vec3 vVCToIJK;\\n\\n// the heights defined below are the locations\\n// for the up to four components of the tfuns\\n// the tfuns have a height of 2XnumComps pixels so the\\n// values are computed to hit the middle of the two rows\\n// for that component\\n#ifdef vtkIndependentComponentsOn\\n#if vtkNumComponents == 2\\nuniform float mix0;\\nuniform float mix1;\\n#define height0 0.25\\n#define height1 0.75\\n#endif\\n#if vtkNumComponents == 3\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\n#define height0 0.17\\n#define height1 0.5\\n#define height2 0.83\\n#endif\\n#if vtkNumComponents == 4\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\nuniform float mix3;\\n#define height0 0.125\\n#define height1 0.375\\n#define height2 0.625\\n#define height3 0.875\\n#endif\\n#endif\\n\\n#if vtkNumComponents >= 2\\nuniform float oshift1;\\nuniform float oscale1;\\nuniform float cshift1;\\nuniform float cscale1;\\n#endif\\n#if vtkNumComponents >= 3\\nuniform float oshift2;\\nuniform float oscale2;\\nuniform float cshift2;\\nuniform float cscale2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float oshift3;\\nuniform float oscale3;\\nuniform float cshift3;\\nuniform float cscale3;\\n#endif\\n\\nuniform vec4 ipScalarRangeMin;\\nuniform vec4 ipScalarRangeMax;\\n\\n// declaration for intermixed geometry\\n//VTK::ZBuffer::Dec\\n\\n//=======================================================================\\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\\nvec3 rayDirVC;\\nfloat sampleDistanceISVS;\\nfloat sampleDistanceIS;\\n\\n#define SQRT3    1.7321\\n#define INV4PI   0.0796\\n#define EPSILON  0.001\\n#define PI       3.1415\\n#define PI2      9.8696\\n\\n//=======================================================================\\n// Webgl2 specific version of functions\\n#if __VERSION__ == 300\\n\\nuniform highp sampler3D texture1;\\n\\nvec4 getTextureValue(vec3 pos)\\n{\\n  vec4 tmp = texture(texture1, pos);\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.a = tmp.g;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n  return tmp;\\n}\\n\\n//=======================================================================\\n// WebGL1 specific version of functions\\n#else\\n\\nuniform sampler2D texture1;\\n\\nuniform float texWidth;\\nuniform float texHeight;\\nuniform int xreps;\\nuniform int xstride;\\nuniform int ystride;\\n\\n// if computing trilinear values from multiple z slices\\n#ifdef vtkTrilinearOn\\nvec4 getTextureValue(vec3 ijk)\\n{\\n  float zoff = 1.0/float(volumeDimensions.z);\\n  vec4 val1 = getOneTextureValue(ijk);\\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\\n\\n  float indexZ = float(volumeDimensions)*ijk.z;\\n  float zmix =  indexZ - floor(indexZ);\\n\\n  return mix(val1, val2, zmix);\\n}\\n\\nvec4 getOneTextureValue(vec3 ijk)\\n#else // nearest or fast linear\\nvec4 getTextureValue(vec3 ijk)\\n#endif\\n{\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n#ifdef debugtile\\n  vec2 tpos = vec2(ijk.x, ijk.y);\\n  vec4 tmp = texture2D(texture1, tpos);\\n  tmp.a = 1.0;\\n\\n#else\\n  int z = int(ijk.z * tdims.z);\\n  int yz = z / xreps;\\n  int xz = z - yz*xreps;\\n\\n  int tileWidth = volumeDimensions.x/xstride;\\n  int tileHeight = volumeDimensions.y/ystride;\\n\\n  xz *= tileWidth;\\n  yz *= tileHeight;\\n\\n  float ni = float(xz) + (ijk.x*float(tileWidth));\\n  float nj = float(yz) + (ijk.y*float(tileHeight));\\n\\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\\n\\n  vec4 tmp = texture2D(texture1, tpos);\\n\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.g = tmp.a;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n#endif\\n\\n  return tmp;\\n}\\n\\n// End of Webgl1 specific code\\n//=======================================================================\\n#endif\\n\\n//=======================================================================\\n// transformation between VC and IS space\\n\\n// convert vector position from idx to vc\\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\\nvec3 IStoVC(vec3 posIS){\\n  vec3 posVC = posIS / vVCToIJK;\\n  return posVC.x * vPlaneNormal0 +\\n         posVC.y * vPlaneNormal2 +\\n         posVC.z * vPlaneNormal4 +\\n         vOriginVC;\\n}\\n\\n// convert vector position from vc to idx\\nvec3 VCtoIS(vec3 posVC){\\n  posVC = posVC - vOriginVC;\\n  posVC = vec3(\\n    dot(posVC, vPlaneNormal0),\\n    dot(posVC, vPlaneNormal2),\\n    dot(posVC, vPlaneNormal4));\\n  return posVC * vVCToIJK;\\n}\\n#endif\\n\\n//Rotate vector to view coordinate\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\nvoid rotateToViewCoord(inout vec3 dirIS){\\n  dirIS.xyz =\\n    dirIS.x * vPlaneNormal0 +\\n    dirIS.y * vPlaneNormal2 +\\n    dirIS.z * vPlaneNormal4;\\n}\\n\\n//Rotate vector to idx coordinate\\nvec3 rotateToIDX(vec3 dirVC){\\n  vec3 dirIS;\\n  dirIS.xyz = vec3(\\n    dot(dirVC, vPlaneNormal0),\\n    dot(dirVC, vPlaneNormal2),\\n    dot(dirVC, vPlaneNormal4));\\n  return dirIS;\\n}\\n#endif\\n\\n//=======================================================================\\n// Given a normal compute the gradient opacity factors\\nfloat computeGradientOpacityFactor(\\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\\n{\\n#if defined(vtkGradientOpacityOn)\\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\\n#else\\n  return 1.0;\\n#endif\\n}\\n\\n//=======================================================================\\n// compute the normal and gradient magnitude for a position, uses forward difference\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\n#ifdef vtkClippingPlanesOn\\n  void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\\n  {\\n    vec3 g1VC[3];\\n    for (int i = 0; i < 3; ++i)\\n    {\\n      g1VC[i] = IStoVC(texPos[i]);\\n    }\\n    vec3 posVC = IStoVC(pos);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      for (int j = 0; j < 3; ++j)\\n      {\\n        if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\\n        {\\n          g1[j] = 0.0;\\n        }\\n      }\\n    }\\n  }\\n#endif\\n\\n  #ifdef vtkComputeNormalFromOpacity\\n    #ifdef vtkGradientOpacityOn\\n      vec4 computeDensityNormal(float gradientMag, vec3 scalarInterp[2])\\n      {\\n    #else\\n      //if gradient opacity not on but using density gradient\\n      vec4 computeDensityNormal(vec3 scalarInterp[2])\\n      {\\n    #endif\\n        vec3 opacityG1, opacityG2;\\n        opacityG1.x = texture2D(otexture, vec2(scalarInterp[0].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.y = texture2D(otexture, vec2(scalarInterp[0].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.z = texture2D(otexture, vec2(scalarInterp[0].z * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.x = texture2D(otexture, vec2(scalarInterp[1].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.y = texture2D(otexture, vec2(scalarInterp[1].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.z = texture2D(otexture, vec2(scalarInterp[1].z * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n        float gradOpacityFactor = 1.0f;\\n        if (gradientMag >= 0.0){\\n          gradOpacityFactor = computeGradientOpacityFactor(gradientMag, goscale0, goshift0, gomin0, gomax0);\\n        }\\n        opacityG1.xyz *= gradOpacityFactor;\\n        opacityG2.xyz *= gradOpacityFactor;\\n    #endif\\n\\n        vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\\n        // divide by spacing\\n        opacityG.xyz /= vSpacing;\\n        opacityG.w = length(opacityG.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(opacityG.xyz);\\n        if (length(opacityG.xyz) > 0.0) {\\n          return vec4(normalize(opacityG.xyz),opacityG.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n\\n      vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2])\\n      {\\n        vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n        vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n        vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n        vec3 texPosPVec[3];\\n        texPosPVec[0] = pos + xvec;\\n        texPosPVec[1] = pos + yvec;\\n        texPosPVec[2] = pos + zvec;\\n        vec3 texPosNVec[3];\\n        texPosNVec[0] = pos - xvec;\\n        texPosNVec[1] = pos - yvec;\\n        texPosNVec[2] = pos - zvec;\\n        vec3 g1, g2;\\n\\n        scalarInterp[0].x = getTextureValue(texPosPVec[0]).a;\\n        scalarInterp[0].y = getTextureValue(texPosPVec[1]).a;\\n        scalarInterp[0].z = getTextureValue(texPosPVec[2]).a;\\n        scalarInterp[1].x = getTextureValue(texPosNVec[0]).a;\\n        scalarInterp[1].y = getTextureValue(texPosNVec[1]).a;\\n        scalarInterp[1].z = getTextureValue(texPosNVec[2]).a;\\n\\n        #ifdef vtkClippingPlanesOn\\n          adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\\n          adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\\n        #endif\\n        vec4 result;\\n        result.x = scalarInterp[0].x - scalarInterp[1].x;\\n        result.y = scalarInterp[0].y - scalarInterp[1].y;\\n        result.z = scalarInterp[0].z - scalarInterp[1].z;\\n        // divide by spacing\\n        result.xyz /= vSpacing;\\n        result.w = length(result.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(result.xyz);\\n        if (length(result.xyz) > 0.0) {\\n          return vec4(normalize(result.xyz),result.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n  #endif\\n\\n  vec4 computeNormal(vec3 pos, vec3 tstep)\\n  {\\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n    vec3 texPosPVec[3];\\n    texPosPVec[0] = pos + xvec;\\n    texPosPVec[1] = pos + yvec;\\n    texPosPVec[2] = pos + zvec;\\n    vec3 texPosNVec[3];\\n    texPosNVec[0] = pos - xvec;\\n    texPosNVec[1] = pos - yvec;\\n    texPosNVec[2] = pos - zvec;\\n    vec3 g1, g2;\\n    g1.x = getTextureValue(texPosPVec[0]).a;\\n    g1.y = getTextureValue(texPosPVec[1]).a;\\n    g1.z = getTextureValue(texPosPVec[2]).a;\\n    g2.x = getTextureValue(texPosNVec[0]).a;\\n    g2.y = getTextureValue(texPosNVec[1]).a;\\n    g2.z = getTextureValue(texPosNVec[2]).a;\\n    #ifdef vtkClippingPlanesOn\\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\\n    #endif\\n    vec4 result;\\n    result = vec4(g1 - g2, -1.0);\\n    // divide by spacing\\n    result.xyz /= vSpacing;\\n    result.w = length(result.xyz);\\n    if (result.w > 0.0){\\n      // rotate to View Coords\\n      rotateToViewCoord(result.xyz);\\n      return vec4(normalize(result.xyz),result.w);\\n    } else {\\n      return vec4(0.0);\\n    }\\n  }\\n#endif\\n\\n#ifdef vtkImageLabelOutlineOn\\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\\n  vec4 pcPos = vec4(\\n    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\\n    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\\n    (fragCoord.z - 0.5) * 2.0,\\n    1.0);\\n\\n  vec4 worldCoord = PCWCMatrix * pcPos;\\n  vec4 vertex = (worldCoord/worldCoord.w);\\n\\n  vec3 index = (vWCtoIDX * vertex).xyz;\\n\\n  // half voxel fix for labelmapOutline\\n  return (index + vec3(0.5)) / vec3(volumeDimensions);\\n}\\n#endif\\n\\n//=======================================================================\\n// compute the normals and gradient magnitudes for a position\\n// for independent components\\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\\n{\\n  mat4 result;\\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\\n\\n  // divide by spacing\\n  distX /= vSpacing.x;\\n  distY /= vSpacing.y;\\n  distZ /= vSpacing.z;\\n\\n  mat3 rot;\\n  rot[0] = vPlaneNormal0;\\n  rot[1] = vPlaneNormal2;\\n  rot[2] = vPlaneNormal4;\\n\\n#if !defined(vtkComponent0Proportional)\\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\\n  result[0].a = length(result[0].xyz);\\n  result[0].xyz *= rot;\\n  if (result[0].w > 0.0)\\n  {\\n    result[0].xyz /= result[0].w;\\n  }\\n#endif\\n\\n// optionally compute the 2nd component\\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\\n  result[1].a = length(result[1].xyz);\\n  result[1].xyz *= rot;\\n  if (result[1].w > 0.0)\\n  {\\n    result[1].xyz /= result[1].w;\\n  }\\n#endif\\n\\n// optionally compute the 3rd component\\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\\n  result[2].a = length(result[2].xyz);\\n  result[2].xyz *= rot;\\n  if (result[2].w > 0.0)\\n  {\\n    result[2].xyz /= result[2].w;\\n  }\\n#endif\\n\\n// optionally compute the 4th component\\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\\n  result[3].a = length(result[3].xyz);\\n  result[3].xyz *= rot;\\n  if (result[3].w > 0.0)\\n  {\\n    result[3].xyz /= result[3].w;\\n  }\\n#endif\\n\\n  return result;\\n}\\n\\n//=======================================================================\\n// global shadow - secondary ray\\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\\nfloat random()\\n{\\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\\n  uint pcg_state = floatBitsToUint(jitter);\\n  uint state = pcg_state;\\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\\n}\\n#endif\\n\\n#ifdef VolumeShadowOn\\n// henyey greenstein phase function\\nfloat phase_function(float cos_angle)\\n{\\n  // divide by 2.0 instead of 4pi to increase intensity\\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\\n}\\n\\n// Computes the intersection between a ray and a box\\nstruct Hit\\n{\\n  float tmin;\\n  float tmax;\\n};\\n\\nstruct Ray\\n{\\n  vec3 origin;\\n  vec3 dir;\\n  vec3 invDir;\\n};\\n\\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\\n{\\n  vec3 tbot = r.invDir * (boundMin - r.origin);\\n  vec3 ttop = r.invDir * (boundMax - r.origin);\\n  vec3 tmin = min(ttop, tbot);\\n  vec3 tmax = max(ttop, tbot);\\n  vec2 t = max(tmin.xx, tmin.yz);\\n  float t0 = max(t.x, t.y);\\n  t = min(tmax.xx, tmax.yz);\\n  float t1 = min(t.x, t.y);\\n  hit.tmin = t0;\\n  hit.tmax = t1;\\n  return t1 > max(t0,0.0);\\n}\\n\\n// As BBoxIntersect requires the inverse of the ray coords,\\n// this function is used to avoid numerical issues\\nvoid safe_0_vector(inout Ray ray)\\n{\\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\\n}\\n\\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\\n{\\n  float shadow = 1.0;\\n  float opacity = 0.0;\\n\\n  // modify sample distance with a random number between 1.5 and 3.0\\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\\n\\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\\n\\n  // compute the start and end points for the ray\\n  Ray ray;\\n  Hit hit;\\n  ray.origin = posIS;\\n  ray.dir = lightDirNormIS;\\n  safe_0_vector(ray);\\n  ray.invDir = 1.0/ray.dir;\\n\\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\\n  {\\n    return 1.0;\\n  }\\n  float maxdist = hit.tmax;\\n\\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\\n  maxdist = min(maxdist,maxgi);\\n  if(maxdist < EPSILON) {\\n    return 1.0;\\n  }\\n\\n  // support gradient opacity\\n  #ifdef vtkGradientOpacityOn\\n    vec4 normal;\\n  #endif\\n\\n  float current_dist = 0.0;\\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\\n  float clamped_step = 0.0;\\n\\n  vec4 scalar = vec4(0.0);\\n  while(current_dist < maxdist)\\n  {\\n#ifdef vtkClippingPlanesOn\\n    vec3 posVC = IStoVC(posIS);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\\n      {\\n        current_dist = maxdist;\\n      }\\n    }\\n#endif\\n    scalar = getTextureValue(posIS);\\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n      normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    shadow *= 1.0 - opacity;\\n\\n    // optimization: early termination\\n    if (shadow < EPSILON){\\n      return 0.0;\\n    }\\n\\n    clamped_step = min(maxdist - current_dist, current_step);\\n    posIS += clamped_step * lightDirNormIS;\\n    current_dist += current_step;\\n  }\\n\\n  return shadow;\\n}\\n\\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\\n{\\n  vec3 vertLight = vec3(0.0);\\n  vec3 secondary_contrib = vec3(0.0);\\n  // here we assume only positional light, no effect of cones\\n  for (int i = 0; i < lightNum; i++)\\n  {\\n    #if(vtkLightComplexity==3)\\n      if (lightPositional[i] == 1){\\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\\n      }else{\\n        vertLight = - lightDirectionVC[i];\\n      }\\n    #else\\n      vertLight = - lightDirectionVC[i];\\n    #endif\\n    // here we assume achromatic light, only intensity\\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\\n    float phase_attenuation = 0.5;\\n    if (abs(anisotropy) > EPSILON){\\n      phase_attenuation = phase_function(dDotL);\\n    }\\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\\n    secondary_contrib += tColor * vAmbient;\\n  }\\n  return secondary_contrib;\\n}\\n#endif\\n\\n//=======================================================================\\n// local ambient occlusion\\n#ifdef localAmbientOcclusionOn\\nvec3 sample_direction_uniform(int i)\\n{\\n  float rand = random() * 0.5;\\n  float theta = PI2 * (kernelSample[i][0] + rand);\\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\\n}\\n\\n// return a matrix that transform startDir into z axis; startDir should be normalized\\nmat3 zBaseRotationalMatrix(vec3 startDir){\\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\\n  float cosA = startDir.z;\\n  float k = 1.0 / (1.0 + cosA);\\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\\n  return matrix;\\n}\\n\\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\\n  // apply LAO only at selected locations, otherwise return full brightness\\n  if (normal.w > 0.0 && op > 0.05){\\n    float total_transmittance = 0.0;\\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\\n    vec3 currPos, randomDirStep;\\n    float weight, transmittance, opacity;\\n    for (int i = 0; i < kernelSize; i++)\\n    {\\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\\n      currPos = posIS;\\n      transmittance = 1.0;\\n      for (int j = 0; j < kernelRadius ; j++){\\n        currPos += randomDirStep;\\n        // check if it's at clipping plane, if so return full brightness\\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\\n          #ifdef vtkGradientOpacityOn\\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n          #endif\\n          transmittance *= 1.0 - opacity;\\n        }\\n        else{\\n          break;\\n        }\\n      }\\n      total_transmittance += transmittance / float(kernelRadius) * weight;\\n\\n      // early termination if fully translucent\\n      if (total_transmittance > 1.0 - EPSILON){\\n        return 1.0;\\n      }\\n    }\\n    // average transmittance and reduce variance\\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\\n  } else {\\n    return 1.0;\\n  }\\n}\\n#endif\\n\\n//=======================================================================\\n// surface light contribution\\n#if vtkLightComplexity > 0\\n  void applyLighting(inout vec3 tColor, vec4 normal)\\n  {\\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\\n    vec3 specular = vec3(0.0, 0.0, 0.0);\\n    float df, sf = 0.0;\\n    for (int i = 0; i < lightNum; i++){\\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\\n        diffuse += df * lightColor[i];\\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\\n        specular += sf * lightColor[i];\\n    }\\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\\n  }\\n  #ifdef SurfaceShadowOn\\n  #if vtkLightComplexity < 3\\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float ndotL,vdotR;\\n        vertLightDirection = lightDirectionVC[i];\\n        ndotL = dot(normal.xyz, vertLightDirection);\\n        if (ndotL < 0.0 && twoSidedLighting)\\n        {\\n          ndotL = -ndotL;\\n        }\\n        if (ndotL > 0.0)\\n        {\\n          diffuse += ndotL * lightColor[i];\\n          //specular\\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n          if (vdotR > 0.0)\\n          {\\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n          }\\n        }\\n        #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n        #endif\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #else\\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float distance,attenuation,ndotL,vdotR;\\n        vec3 lightDir;\\n        if (lightPositional[i] == 1){\\n          lightDir = lightDirectionVC[i];\\n          vertLightDirection = posVC - lightPositionVC[i];\\n          distance = length(vertLightDirection);\\n          vertLightDirection = normalize(vertLightDirection);\\n          attenuation = 1.0 / (lightAttenuation[i].x\\n                              + lightAttenuation[i].y * distance\\n                              + lightAttenuation[i].z * distance * distance);\\n          // per OpenGL standard cone angle is 90 or less for a spot light\\n          if (lightConeAngle[i] <= 90.0){\\n            float coneDot = dot(vertLightDirection, lightDir);\\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\\n            }\\n            else {\\n              attenuation = 0.0;\\n            }\\n          }\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * attenuation * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        } else {\\n          vertLightDirection = lightDirectionVC[i];\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        }\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #endif\\n  #endif\\n#endif\\n\\n//=======================================================================\\n// Given a texture value compute the color and opacity\\n//\\nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\\n{\\n#ifdef vtkImageLabelOutlineOn\\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\\n  vec4 centerValue = getTextureValue(centerPosIS);\\n  bool pixelOnBorder = false;\\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\\n\\n  // Get alpha of segment from opacity function.\\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n  int segmentIndex = int(centerValue.r * 255.0);\\n  \\n  // Use texture sampling for outlineThickness\\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\\n\\n  int actualThickness = int(textureValue * 255.0);\\n\\n  if (actualThickness == 0) {\\n    return vec4(0, 0, 1, 1);\\n  }\\n\\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\\n  // Saves a bunch of needless checks on the background.\\n  // TODO define epsilon when building shader?\\n  if (float(tColor.a) > 0.01) {\\n    for (int i = -actualThickness; i <= actualThickness; i++) {\\n      for (int j = -actualThickness; j <= actualThickness; j++) {\\n        if (i == 0 || j == 0) {\\n          continue;\\n        }\\n\\n        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n          gl_FragCoord.y + float(j),\\n          gl_FragCoord.z, gl_FragCoord.w);\\n\\n        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n        vec4 value = getTextureValue(neighborPosIS);\\n\\n        // If any of my neighbours are not the same value as I\\n        // am, this means I am on the border of the segment.\\n        // We can break the loops\\n        if (any(notEqual(value, centerValue))) {\\n          pixelOnBorder = true;\\n          break;\\n        }\\n      }\\n\\n      if (pixelOnBorder == true) {\\n        break;\\n      }\\n    }\\n\\n    // If I am on the border, I am displayed at full opacity\\n    if (pixelOnBorder == true) {\\n      tColor.a = outlineOpacity;\\n    }\\n  }\\n\\n#else\\n  // compute the normal and gradient magnitude if needed\\n  // We compute it as a vec4 if possible otherwise a mat4\\n  //\\n  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);\\n\\n  // compute the normal vectors as needed\\n  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\\n      #if !defined(vtkComponent0Proportional)\\n        vec4 normal0 = normalMat[0];\\n      #endif\\n      #if !defined(vtkComponent1Proportional)\\n        vec4 normal1 = normalMat[1];\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          vec4 normal2 = normalMat[2];\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            vec4 normal3 = normalMat[3];\\n          #endif\\n        #endif\\n      #endif\\n    #else\\n      vec4 normalLight;\\n      #ifdef vtkComputeNormalFromOpacity\\n        vec3 scalarInterp[2];\\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp);\\n        if (length(normal0)>0.0){\\n          #ifdef vtkGradientOpacityOn\\n            normalLight = computeDensityNormal(normal0.w, scalarInterp);\\n          #else\\n            normalLight = computeDensityNormal(scalarInterp);\\n          #endif\\n          if (length(normalLight) == 0.0){\\n            normalLight = normal0;\\n          }\\n        }\\n      #else\\n        vec4 normal0 = computeNormal(posIS, tstep);\\n        normalLight = normal0;\\n      #endif\\n    #endif\\n  #endif\\n\\n  // compute gradient opacity factors as needed\\n  #if defined(vtkGradientOpacityOn)\\n    #if !defined(vtkComponent0Proportional)\\n      goFactor.x =\\n        computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      #if !defined(vtkComponent1Proportional)\\n        goFactor.y =\\n          computeGradientOpacityFactor(normal1.a, goscale1, goshift1, gomin1, gomax1);\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          goFactor.z =\\n            computeGradientOpacityFactor(normal2.a, goscale2, goshift2, gomin2, gomax2);\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            goFactor.w =\\n              computeGradientOpacityFactor(normal3.a, goscale3, goshift3, gomin3, gomax3);\\n          #endif\\n        #endif\\n      #endif\\n    #endif\\n  #endif\\n\\n  // single component is always independent\\n  #if vtkNumComponents == 1\\n    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n    if (tColor.a < EPSILON){\\n      return vec4(0.0);\\n    }\\n  #endif\\n\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));\\n    #if !defined(vtkComponent0Proportional)\\n      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n      tColor *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));\\n    #endif\\n\\n    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\\n    #if !defined(vtkComponent1Proportional)\\n      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n      tColor1 *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));\\n    #endif\\n\\n    #if vtkNumComponents >= 3\\n      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\\n      #if !defined(vtkComponent2Proportional)\\n        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n      #else\\n        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n        tColor2 *= pwfValue;\\n        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));\\n      #endif\\n\\n      #if vtkNumComponents >= 4\\n        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\\n        #if !defined(vtkComponent3Proportional)\\n          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n        #else\\n          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n          tColor3 *= pwfValue;\\n          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));\\n        #endif\\n      #endif\\n    #endif\\n  #else // then not independent\\n\\n  #if vtkNumComponents == 2\\n    float lum = tValue.r * cscale0 + cshift0;\\n    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\\n    vec4 tColor = vec4(lum, lum, lum, alpha);\\n  #endif\\n  #if vtkNumComponents == 3\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\\n  #endif\\n  #if vtkNumComponents == 4\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\\n  #endif\\n  #endif // dependent\\n\\n  // apply lighting if requested as appropriate\\n  #if vtkLightComplexity > 0\\n    #if !defined(vtkComponent0Proportional)\\n      #if vtkNumComponents == 1\\n        #ifdef SurfaceShadowOn\\n            #if vtkLightComplexity < 3\\n                vec3 tColorS = applyLightingDirectional(posIS, tColor, normalLight);\\n            #else\\n                vec3 tColorS = applyLightingPositional(posIS, tColor, normalLight, IStoVC(posIS));\\n            #endif\\n        #endif\\n\\n        #ifdef VolumeShadowOn\\n          vec3 tColorVS = applyShadowRay(tColor.rgb, posIS, rayDirVC);\\n          #ifdef SurfaceShadowOn\\n            float vol_coef = volumetricScatteringBlending * (1.0 - tColor.a / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\\n            tColor.rgb = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\\n          #else\\n            tColor.rgb = tColorVS;\\n          #endif\\n        #else\\n            tColor.rgb = tColorS;\\n        #endif\\n\\n      #else\\n        applyLighting(tColor.rgb, normal0);\\n      #endif\\n    #endif\\n\\n    #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n      #if !defined(vtkComponent1Proportional)\\n        applyLighting(tColor1, normal1);\\n      #endif\\n    #if vtkNumComponents >= 3\\n      #if !defined(vtkComponent2Proportional)\\n        applyLighting(tColor2, normal2);\\n      #endif\\n    #if vtkNumComponents >= 4\\n      #if !defined(vtkComponent3Proportional)\\n        applyLighting(tColor3, normal3);\\n      #endif\\n    #endif\\n    #endif\\n    #endif\\n  #endif\\n\\n// perform final independent blend as needed\\n#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n  tColor.rgb += tColor1;\\n#if vtkNumComponents >= 3\\n  tColor.rgb += tColor2;\\n#if vtkNumComponents >= 4\\n  tColor.rgb += tColor3;\\n#endif\\n#endif\\n#endif\\n\\n#endif\\nreturn tColor;\\n}\\n\\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\\n  bool withinRange = false;\\n  #if vtkNumComponents == 1\\n    if (val.r >= min.r && val.r <= max.r) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2\\n     if (val.r >= min.r && val.r <= max.r &&\\n        val.g >= min.g && val.g <= max.g) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3\\n    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\\n        all(lessThanEqual(val, ipScalarRangeMax))) {\\n      withinRange = true;\\n    }\\n  #endif\\n  return withinRange;\\n}\\n\\n//=======================================================================\\n// Apply the specified blend mode operation along the ray's path.\\n//\\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\\n{\\n  vec3 tstep = 1.0/tdims;\\n\\n  // start slightly inside and apply some jitter\\n  vec3 delta = endIS - posIS;\\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\\n  float raySteps = length(delta)/sampleDistanceIS;\\n\\n  // avoid 0.0 jitter\\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\\n  float stepsTraveled = jitter;\\n\\n  // local vars for the loop\\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\\n  vec4 tValue;\\n  vec4 tColor;\\n\\n  // if we have less than one step then pick the middle point\\n  // as our value\\n  // if (raySteps <= 1.0)\\n  // {\\n  //   posIS = (posIS + endIS)*0.5;\\n  // }\\n\\n  // Perform initial step at the volume boundary\\n  // compute the scalar\\n  tValue = getTextureValue(posIS);\\n\\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\\n    // now map through opacity and color\\n    tColor = getColorForValue(tValue, posIS, tstep);\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\\n      gl_FragData[0] = tColor;\\n      return;\\n    }\\n\\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n\\n      float mix = (1.0 - color.a);\\n\\n      // this line should not be needed but nvidia seems to not handle\\n      // the break correctly on windows/chrome 58 angle\\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\\n\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n      stepsTraveled++;\\n      posIS += stepIS;\\n      if (color.a > 0.99) { color.a = 1.0; break; }\\n    }\\n\\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\\n    {\\n      posIS = endIS;\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\\n\\n      float mix = (1.0 - color.a);\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n    }\\n\\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\\n  #endif\\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\\n    // Find maximum/minimum intensity along the ray.\\n\\n    // Define the operation we will use (min or max)\\n    #if vtkBlendMode == 1\\n    #define OP max\\n    #else\\n    #define OP min\\n    #endif\\n\\n    // If the clipping range is shorter than the sample distance\\n    // we can skip the sampling loop along the ray.\\n    if (raySteps <= 1.0)\\n    {\\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\\n      return;\\n    }\\n\\n    vec4 value = tValue;\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // Update the maximum value if necessary\\n      value = OP(tValue, value);\\n\\n      // Otherwise, continue along the ray\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n    tValue = getTextureValue(posIS);\\n    value = OP(tValue, value);\\n\\n    // Now map through opacity and color\\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\\n    vec4 sum = vec4(0.);\\n\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n    }\\n\\n    if (raySteps <= 1.0) {\\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\\n      // Notes:\\n      // - We are comparing all values in the texture to see if any of them\\n      //   are outside of the scalar range. In the future we might want to allow\\n      //   scalar ranges for each component.\\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n        // Sum the values across each step in the path\\n        sum += tValue;\\n      }\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n\\n    // compute the scalar\\n    tValue = getTextureValue(posIS);\\n\\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n\\n      stepsTraveled++;\\n    }\\n\\n    #if vtkBlendMode == 3 // Average\\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\\n    #endif\\n\\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 5 // RADON\\n    float normalizedRayIntensity = 1.0;\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tValue = getTextureValue(posIS);\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar value\\n      tValue = getTextureValue(posIS);\\n\\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n      posIS += stepIS;\\n      stepsTraveled++;\\n    }\\n\\n    // map normalizedRayIntensity to color\\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\\n\\n  #endif\\n}\\n\\n//=======================================================================\\n// Compute a new start and end point for a given ray based\\n// on the provided bounded clipping plane (aka a rectangle)\\nvoid getRayPointIntersectionBounds(\\n  vec3 rayPos, vec3 rayDir,\\n  vec3 planeDir, float planeDist,\\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\\n  float vSize1, float vSize2)\\n{\\n  float result = dot(rayDir, planeDir);\\n  if (abs(result) < 1e-6)\\n  {\\n    return;\\n  }\\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\\n  vec3 xposVC = rayPos + rayDir*result;\\n  vec3 vxpos = xposVC - vOriginVC;\\n  vec2 vpos = vec2(\\n    dot(vxpos, vPlaneX),\\n    dot(vxpos, vPlaneY));\\n\\n  // on some apple nvidia systems this does not work\\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\\n  //     vpos.y < 0.0 || vpos.y > vSize2)\\n  // even just\\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\\n  // fails\\n  // so instead we compute a value that represents in and out\\n  //and then compute the return using this value\\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\\n\\n  tbounds = mix(\\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\\n   tbounds, // out value\\n   check);  // 0 in 1 out\\n}\\n\\n//=======================================================================\\n// given a\\n// - ray direction (rayDir)\\n// - starting point (vertexVCVSOutput)\\n// - bounding planes of the volume\\n// - optionally depth buffer values\\n// - far clipping plane\\n// compute the start/end distances of the ray we need to cast\\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\\n{\\n  vec2 dists = vec2(100.0*camFar, -1.0);\\n\\n  vec3 vSize = vSpacing*tdims;\\n\\n  // all this is in View Coordinates\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n\\n  //VTK::ClipPlane::Impl\\n\\n  // do not go behind front clipping plane\\n  dists.x = max(0.0,dists.x);\\n\\n  // do not go PAST far clipping plane\\n  float farDist = -camThick/rayDir.z;\\n  dists.y = min(farDist,dists.y);\\n\\n  // Do not go past the zbuffer value if set\\n  // This is used for intermixing opaque geometry\\n  //VTK::ZBuffer::Impl\\n\\n  return dists;\\n}\\n\\n//=======================================================================\\n// Compute the index space starting position (pos) and end\\n// position\\n//\\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\\n{\\n  // compute starting and ending values in volume space\\n  pos = vertexVCVSOutput + dists.x*rayDir;\\n  pos = pos - vOriginVC;\\n  // convert to volume basis and origin\\n  pos = vec3(\\n    dot(pos, vPlaneNormal0),\\n    dot(pos, vPlaneNormal2),\\n    dot(pos, vPlaneNormal4));\\n\\n  endPos = vertexVCVSOutput + dists.y*rayDir;\\n  endPos = endPos - vOriginVC;\\n  endPos = vec3(\\n    dot(endPos, vPlaneNormal0),\\n    dot(endPos, vPlaneNormal2),\\n    dot(endPos, vPlaneNormal4));\\n\\n  float delta = length(endPos - pos);\\n\\n  pos *= vVCToIJK;\\n  endPos *= vVCToIJK;\\n\\n  float delta2 = length(endPos - pos);\\n  sampleDistanceIS = sampleDistance*delta2/delta;\\n  #ifdef VolumeShadowOn\\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\\n  #endif\\n}\\n\\nvoid main()\\n{\\n\\n  if (cameraParallel == 1)\\n  {\\n    // Camera is parallel, so the rayDir is just the direction of the camera.\\n    rayDirVC = vec3(0.0, 0.0, -1.0);\\n  } else {\\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\\n    rayDirVC = normalize(vertexVCVSOutput);\\n  }\\n\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n  // compute the start and end points for the ray\\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\\n\\n  // do we need to composite? aka does the ray have any length\\n  // If not, bail out early\\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\\n  {\\n    discard;\\n  }\\n\\n  // IS = Index Space\\n  vec3 posIS;\\n  vec3 endIS;\\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\\n\\n  // Perform the blending operation along the ray\\n  applyBlend(posIS, endIS, tdims);\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Fragment;o.getProperty().getInterpolationType()===wg.LINEAR&&(a=cd.substitute(a,&quot;//VTK::TrilinearOn&quot;,&quot;#define vtkTrilinearOn&quot;).result),!0===o.getProperty().getUseLabelOutline()&&(a=cd.substitute(a,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result);const i=t.scalarTexture.getComponents();a=cd.substitute(a,&quot;//VTK::NumComponents&quot;,`#define vtkNumComponents ${i}`).result;const s=o.getProperty().getIndependentComponents();if(s){a=cd.substitute(a,&quot;//VTK::IndependentComponentsOn&quot;,&quot;#define vtkIndependentComponentsOn&quot;).result;const e=[];for(let t=0;t<i;t++)o.getProperty().getOpacityMode(t)===Pg.PROPORTIONAL&&e.push(`#define vtkComponent${t}Proportional`);e.length>0&&(a=cd.substitute(a,&quot;//VTK::vtkProportionalComponents&quot;,e.join(&quot;\\n&quot;)).result)}const l=t.currentInput.getSpatialExtent(),c=t.currentInput.getSpacing(),u=new Float64Array(3);In(u,(l[1]-l[0])*c[0],(l[3]-l[2])*c[1],(l[5]-l[4])*c[2]);const d=Sn(u)/e.getCurrentSampleDistance(r);a=cd.substitute(a,&quot;//VTK::MaximumSamplesValue&quot;,`${Math.ceil(d)}`).result,a=cd.substitute(a,&quot;//VTK::LightComplexity&quot;,`#define vtkLightComplexity ${t.lastLightComplexity}`).result,t.lastLightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(a=cd.substitute(a,&quot;//VTK::VolumeShadowOn&quot;,&quot;#define VolumeShadowOn&quot;).result),t.renderable.getVolumetricScatteringBlending()<1&&(a=cd.substitute(a,&quot;//VTK::SurfaceShadowOn&quot;,&quot;#define SurfaceShadowOn&quot;).result),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0&&(a=cd.substitute(a,&quot;//VTK::localAmbientOcclusionOn&quot;,&quot;#define localAmbientOcclusionOn&quot;).result)),t.gopacity=o.getProperty().getUseGradientOpacity(0);for(let e=1;s&&!t.gopacity&&e<i;++e)o.getProperty().getUseGradientOpacity(e)&&(t.gopacity=!0);t.gopacity&&(a=cd.substitute(a,&quot;//VTK::GradientOpacityOn&quot;,&quot;#define vtkGradientOpacityOn&quot;).result),t.renderable.getComputeNormalFromOpacity()&&(a=cd.substitute(a,&quot;//VTK::vtkComputeNormalFromOpacity&quot;,&quot;#define vtkComputeNormalFromOpacity&quot;).result),null!==t.zBufferTexture&&(a=cd.substitute(a,&quot;//VTK::ZBuffer::Dec&quot;,[&quot;uniform sampler2D zBufferTexture;&quot;,&quot;uniform float vpZWidth;&quot;,&quot;uniform float vpZHeight;&quot;]).result,a=cd.substitute(a,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));&quot;,&quot;float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;&quot;,&quot;zdepth = zdepth * 2.0 - 1.0;&quot;,&quot;if (cameraParallel == 0) {&quot;,&quot;zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}&quot;,&quot;else {&quot;,&quot;zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\\n&quot;,&quot;zdepth = -zdepth/rayDir.z;&quot;,&quot;dists.y = min(zdepth,dists.y);&quot;]).result),a=cd.substitute(a,&quot;//VTK::BlendMode&quot;,`${t.renderable.getBlendMode()}`).result,n.Fragment=a,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lastLightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[&quot;uniform int lightNum;&quot;,&quot;uniform bool twoSidedLighting;&quot;,`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,&quot;//VTK::Light::Dec&quot;],!1).result,3===t.lastLightComplexity&&(o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=cd.substitute(o,&quot;//VTK::VolumeShadow::Dec&quot;,[&quot;uniform float volumetricScatteringBlending;&quot;,&quot;uniform float giReach;&quot;,&quot;uniform float volumeShadowSamplingDistFactor;&quot;,&quot;uniform float anisotropy;&quot;,&quot;uniform float anisotropy2;&quot;],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=cd.substitute(o,&quot;//VTK::LAO::Dec&quot;,[&quot;uniform int kernelRadius;&quot;,`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,&quot;uniform int kernelSize;&quot;],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=cd.substitute(o,&quot;//VTK::ClipPlane::Dec&quot;,[&quot;uniform vec3 vClipPlaneNormals[6];&quot;,&quot;uniform float vClipPlaneDistances[6];&quot;,&quot;uniform vec3 vClipPlaneOrigins[6];&quot;,&quot;uniform int clip_numPlanes;&quot;,&quot;//VTK::ClipPlane::Dec&quot;,&quot;#define vtkClippingPlanesOn&quot;],!1).result,o=cd.substitute(o,&quot;//VTK::ClipPlane::Impl&quot;,[`for(int i = 0; i < ${e}; i++) {`,&quot;  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);&quot;,&quot;  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];&quot;,&quot;  if (rayDirRatio == 0.0)&quot;,&quot;  {&quot;,&quot;    if (equationResult < 0.0) dists.x = dists.y;&quot;,&quot;    continue;&quot;,&quot;  }&quot;,&quot;  float result = -1.0 * equationResult / rayDirRatio;&quot;,&quot;  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);&quot;,&quot;  else dists.x = max(dists.x, result);&quot;,&quot;}&quot;,&quot;//VTK::ClipPlane::Impl&quot;],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{let a=0;o.getProperty().getShade()&&t.renderable.getBlendMode()===Rg.COMPOSITE_BLEND&&(a=0,t.numberOfLights=0,r.getLights().forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===a&&(a=1)),1===a&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(a=2),a<3&&e.getPositional()&&(a=3)})));let i=!1;t.lastLightComplexity!==a&&(t.lastLightComplexity=a,i=!0);const s=t.scalarTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=!1;const u=[];if(l){for(let e=0;e<s;e++)u.push(o.getProperty().getOpacityMode(e));u.length>0&&(c=!0)}const d=t.currentInput.getSpatialExtent(),p=t.currentInput.getSpacing(),f=new Float64Array(3);In(f,(d[1]-d[0])*p[0],(d[3]-d[2])*p[1],(d[5]-d[4])*p[2]);const g=Sn(f)/e.getCurrentSampleDistance(r),m={interpolationType:o.getProperty().getInterpolationType(),useLabelOutline:o.getProperty().getUseLabelOutline(),numComp:s,usesProportionalComponents:c,iComps:l,maxSamples:g,useGradientOpacity:o.getProperty().getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),proportionalComponents:u};return t.previousState&&t.previousState.interpolationType===m.interpolationType&&t.previousState.useLabelOutline===m.useLabelOutline&&t.previousState.numComp===m.numComp&&t.previousState.usesProportionalComponents===m.usesProportionalComponents&&t.previousState.iComps===m.iComps&&t.previousState.maxSamples===m.maxSamples&&t.previousState.useGradientOpacity===m.useGradientOpacity&&t.previousState.blendMode===m.blendMode&&function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(t.previousState.proportionalComponents,m.proportionalComponents)?!!(0===n.getProgram()?.getHandle()||i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||!!t.lastZBufferTexture!=!!t.zBufferTexture||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime())&&(t.lastZBufferTexture=t.zBufferTexture,!0):(t.previousState={...m},!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed(&quot;vertexDC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexDC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified()),a.setUniformi(&quot;texture1&quot;,t.scalarTexture.getTextureUnit()),a.setUniformf(&quot;sampleDistance&quot;,e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange(),l=[],c=[];for(let e=0;e<4;e++)l[e]=s[0]*i.dataComputedScale[e]+i.dataComputedOffset[e],c[e]=s[1]*i.dataComputedScale[e]+i.dataComputedOffset[e],l[e]=(l[e]-i.offset[e])/i.scale[e],c[e]=(c[e]-i.offset[e])/i.scale[e];if(a.setUniform4f(&quot;ipScalarRangeMin&quot;,l[0],l[1],l[2],l[3]),a.setUniform4f(&quot;ipScalarRangeMax&quot;,c[0],c[1],c[2],c[3]),null!==t.zBufferTexture){a.setUniformi(&quot;zBufferTexture&quot;,t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf(&quot;vpZWidth&quot;,e[0]),a.setUniformf(&quot;vpZHeight&quot;,e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf(&quot;camThick&quot;,c[1]-c[0]),s.setUniformf(&quot;camNear&quot;,c[0]),s.setUniformf(&quot;camFar&quot;,c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf(&quot;dcxmin&quot;,g),s.setUniformf(&quot;dcxmax&quot;,m),s.setUniformf(&quot;dcymin&quot;,v),s.setUniformf(&quot;dcymax&quot;,y),s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f(&quot;vSpacing&quot;,x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f(&quot;vOriginVC&quot;,p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Dg(`The number of steps required ${Math.ceil(A)} is larger than the\\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\\n        Please either change the\\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f(&quot;vVCToIJK&quot;,I[0],I[1],I[2]),s.setUniform3i(&quot;volumeDimensions&quot;,d[0],d[1],d[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf(&quot;texWidth&quot;,t.scalarTexture.getWidth()),s.setUniformf(&quot;texHeight&quot;,t.scalarTexture.getHeight()),s.setUniformi(&quot;xreps&quot;,e.xreps),s.setUniformi(&quot;xstride&quot;,e.xstride),s.setUniformi(&quot;ystride&quot;,e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*Dn(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(o.getProperty().getUseLabelOutline()){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf(&quot;vpWidth&quot;,u[0]),s.setUniformf(&quot;vpHeight&quot;,u[1]);const d=e.getRenderTargetOffset();s.setUniformf(&quot;vpOffsetX&quot;,d[0]/u[0]),s.setUniformf(&quot;vpOffsetY&quot;,d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix(&quot;PCVCMatrix&quot;,t.projectionToView),0===t.lastLightComplexity)return;let O=0;const R=[],M=[],D=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],D[0+3*O]=-.5*w[0],D[1+3*O]=-.5*w[1],D[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi(&quot;twoSidedLighting&quot;,r.getTwoSidedLighting()),s.setUniformi(&quot;lightNum&quot;,O),s.setUniform3fv(&quot;lightColor&quot;,R),s.setUniform3fv(&quot;lightDirectionVC&quot;,M),s.setUniform3fv(&quot;lightHalfAngleVC&quot;,D),3===t.lastLightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv(&quot;lightPositionVC&quot;,e),s.setUniform3fv(&quot;lightAttenuation&quot;,n),s.setUniformfv(&quot;lightConeAngle&quot;,o),s.setUniformfv(&quot;lightExponent&quot;,a),s.setUniformiv(&quot;lightPositional&quot;,i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf(&quot;giReach&quot;,t.renderable.getGlobalIlluminationReach()),s.setUniformf(&quot;volumetricScatteringBlending&quot;,t.renderable.getVolumetricScatteringBlending()),s.setUniformf(&quot;volumeShadowSamplingDistFactor&quot;,t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf(&quot;anisotropy&quot;,t.renderable.getAnisotropy()),s.setUniformf(&quot;anisotropy2&quot;,t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi(&quot;kernelSize&quot;,e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv(&quot;kernelSample&quot;,n),s.setUniformi(&quot;kernelRadius&quot;,t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi(&quot;ctexture&quot;,t.colorTexture.getTextureUnit()),o.setUniformi(&quot;otexture&quot;,t.opacityTexture.getTextureUnit()),o.setUniformi(&quot;jtexture&quot;,t.jitterTexture.getTextureUnit()),o.setUniformi(&quot;ttexture&quot;,t.labelOutlineThicknessTexture.getTextureUnit());const a=t.scalarTexture.getVolumeInfo(),i=r.getProperty(),s=t.scalarTexture.getComponents(),l=r.getProperty().getIndependentComponents();if(l&&s>=2)for(let e=0;e<s;e++)o.setUniformf(`mix${e}`,r.getProperty().getComponentWeight(e));for(let e=0;e<s;e++){const t=l?e:0,n=a.scale[e],r=i.getScalarOpacity(t).getRange(),s=n/(r[1]-r[0]),c=(a.offset[e]-r[0])/(r[1]-r[0]);o.setUniformf(`oshift${e}`,c),o.setUniformf(`oscale${e}`,s);const u=i.getRGBTransferFunction(t).getRange(),d=(a.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);o.setUniformf(`cshift${e}`,d),o.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(l)for(let e=0;e<s;++e){const t=a.scale[e];if(i.getUseGradientOpacity(e)){const n=i.getGradientOpacityMinimumOpacity(e),r=i.getGradientOpacityMaximumOpacity(e);o.setUniformf(`gomin${e}`,n),o.setUniformf(`gomax${e}`,r);const a=[i.getGradientOpacityMinimumValue(e),i.getGradientOpacityMaximumValue(e)];o.setUniformf(`goscale${e}`,t*(r-n)/(a[1]-a[0])),o.setUniformf(`goshift${e}`,-a[0]*(r-n)/(a[1]-a[0])+n)}else o.setUniformf(`gomin${e}`,1),o.setUniformf(`gomax${e}`,1),o.setUniformf(`goscale${e}`,0),o.setUniformf(`goshift${e}`,1)}else{const e=a.scale[s-1],t=i.getGradientOpacityMinimumOpacity(0),n=i.getGradientOpacityMaximumOpacity(0);o.setUniformf(&quot;gomin0&quot;,t),o.setUniformf(&quot;gomax0&quot;,n);const r=[i.getGradientOpacityMinimumValue(0),i.getGradientOpacityMaximumValue(0)];o.setUniformf(&quot;goscale0&quot;,e*(n-t)/(r[1]-r[0])),o.setUniformf(&quot;goshift0&quot;,-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===r.getProperty().getUseLabelOutline()){const e=r.getProperty().getLabelOutlineOpacity();o.setUniformf(&quot;outlineOpacity&quot;,e)}t.lastLightComplexity>0&&(o.setUniformf(&quot;vAmbient&quot;,i.getAmbient()),o.setUniformf(&quot;vDiffuse&quot;,i.getDiffuse()),o.setUniformf(&quot;vSpecular&quot;,i.getSpecular()),o.setUniformf(&quot;vSpecularPower&quot;,i.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*Dn(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv(&quot;vClipPlaneNormals&quot;,o),c.setUniformfv(&quot;vClipPlaneDistances&quot;,a),c.setUniform3fv(&quot;vClipPlaneOrigins&quot;,i),c.setUniformi(&quot;clip_numPlanes&quot;,l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===wg.NEAREST?(t.scalarTexture.setMinificationFilter(bd.NEAREST),t.scalarTexture.setMagnificationFilter(bd.NEAREST)):(t.scalarTexture.setMinificationFilter(bd.LINEAR),t.scalarTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null,null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;uniform vec2 tfactor;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),[&quot;//VTK::System::Dec&quot;,&quot;//VTK::Output::Dec&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { gl_FragData[0] = texture2D(texture1,tcoord); }&quot;].join(&quot;\\n&quot;),&quot;&quot;);const e=t.copyShader;t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in copy shader VAO.&quot;)}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi(&quot;texture&quot;,n.getTextureUnit()),t.copyShader.setUniform2f(&quot;tfactor&quot;,t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Eg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;t._scalars!==a&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=a);const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(bd.LINEAR),t.jitterTexture.setMagnificationFilter(bd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,ys.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=i.getIndependentComponents()?s:1,c=i.getScalarOpacity(),u=t._openGLRenderWindow.getGraphicsResourceForObject(c);let d=Vg(i,c,l);if(u.vtkObj&&u.hash===d&&t.opacityTextureString===d)t.opacityTexture=u.vtkObj,t.opacityTextureString=u.hash;else{const r=1024,o=2*r*l,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<l;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.releaseGraphicsResources(t._openGLRenderWindow),t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(bd.LINEAR),t.opacityTexture.setMagnificationFilter(bd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))t.opacityTexture.create2DFromRaw(r,2*l,1,ys.FLOAT,a);else{const e=new Uint8Array(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*l,1,ys.UNSIGNED_CHAR,e)}t.opacityTextureString=d,c&&t._openGLRenderWindow.setGraphicsResourceForObject(c,t.opacityTexture,t.opacityTextureString)}const p=i.getRGBTransferFunction();d=Vg(i,p,l);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===d&&t.colorTextureString===d)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(2*e*l*3),r=new Float32Array(3*e);for(let t=0;t<l;++t){const o=i.getRGBTransferFunction(t),a=o.getRange();o.getTable(a[0],a[1],e,r,1);for(let o=0;o<3*e;++o)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.create2DFromRaw(e,2*l,3,ys.UNSIGNED_CHAR,n),t.colorTextureString=d,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}e.updateLabelOutlineThicknessTexture(r);const g=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(d=`${o.getMTime()}A${a.getMTime()}`,g?.vtkObj&&g?.hash===d&&t.scalarTextureString===d)t.scalarTexture=g.vtkObj,t.scalarTextureString=g.hash;else{const e=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.scalarTexture.releaseGraphicsResources(t._openGLRenderWindow),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],a,t.renderable.getPreferSizeOverAccuracy()),t.scalarTextureString=d,a&&t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,t.scalarTextureString)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Es.newInstance({numberOfComponents:3,values:e});r.setName(&quot;points&quot;);const o=Es.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=e=>{const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}}}const Bg={context:null,VBOBuildTime:null,scalarTexture:null,scalarTextureString:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lastLightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0,_scalars:null};const Ng=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bg,n),Zt.extend(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),t.scalarTexture=Nd.newInstance(),t.opacityTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.jitterTexture=Nd.newInstance(),t.jitterTexture.setWrapS(Td.REPEAT),t.jitterTexture.setWrapT(Td.REPEAT),t.labelOutlineThicknessTexture=Nd.newInstance(),t.framebuffer=Hp.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,[&quot;context&quot;]),Lg(e,t)}),&quot;vtkOpenGLVolumeMapper&quot;);rn(&quot;vtkVolumeMapper&quot;,Ng);const{vtkDebugMacro:_g}=Kt;function Fg(e,t){t.classHierarchy.push(&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent();const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():_g(&quot;No framebuffer to save/restore&quot;);const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const kg={};const Gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kg,n),Zt.extend(e,t,n),Fg(e,t)}),&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;);rn(&quot;vtkPixelSpaceCallbackMapper&quot;,Gg);var Ug=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtktextureObjectVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\nattribute vec2 tcoordDC;\\nvarying vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  tcoordVC = tcoordDC;\\n  gl_Position = vertexDC;\\n}\\n&quot;;const{Representation:zg}=ds;function Wg(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Nd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,&quot;Float32Array&quot;,null),s.activate(),s.sendParameters(),s.deactivate(),s}function Hg(e,t){return Wg(e,t,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE)}function jg(e,t){t.classHierarchy.push(&quot;vtkLICPingPongBufferManager&quot;),t._openGLRenderWindow?(t.quad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,zg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=Hg(t._openGLRenderWindow,t.size),t.seedTexture0=Hg(t._openGLRenderWindow,t.size),t.licTexture1=Hg(t._openGLRenderWindow,t.size),t.seedTexture1=Hg(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?Wg(t._openGLRenderWindow,t.size,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return Wg(e,t,Nd.Filter.LINEAR,Nd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error(&quot;Pass renderwindow to ping pong manager&quot;)}const Kg={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function $g(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kg,n),jt.obj(e,t),jt.get(e,t,[&quot;readIndex&quot;]),jt.setGet(e,t,[&quot;doEEPass&quot;,&quot;doVTPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;vectorTexture&quot;,&quot;maskVectorTexture&quot;,&quot;noiseTexture&quot;,&quot;framebuffer&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),jg(e,t)}var qg={newInstance:jt.newInstance($g,&quot;vtkLICPingPongBufferManager&quot;),extend:$g};const Xg=0,Yg=1,Zg=2,Qg=3,Jg=1;function em(e,t){function n(e,t){e.setUniformi(&quot;texLIC&quot;,t.getLICTextureUnit()),e.setUniformi(&quot;texSeedPts&quot;,t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push(&quot;vtkLineIntegralConvolution2D&quot;),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Hp.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t=&quot;xyzw&quot;;return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n/**\\nThis shader initializes the convolution for the LIC computation.\\n*/\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texMaskVectors;\\nuniform sampler2D texNoise;\\nuniform sampler2D texLIC;\\n\\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the *whole* domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value. this\\n// depends on the pass number.\\nvec2 getNoiseTC(vec2 vectc)\\n{\\n  // in pass 1 : convert from vector tc to noise tc\\n  // in pass 2 : use vector tc\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(vectc);\\n    }\\n  else\\n    {\\n    return vectc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the\\n// need to convert to noise texture coordinates.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 vectc = tcoordVC.st;\\n\\n  // lic => (convolution, mask, 0, step count)\\n  if (uStepNo == 0)\\n    {\\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\\n    float maskFlag;\\n    if (maskCriteria <= uMaskThreshold)\\n      {\\n      maskFlag = 1.0;\\n      }\\n    else\\n      {\\n      maskFlag = 0.0;\\n      }\\n    float noise = getNoise(vectc);\\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = texture2D(texLIC, vectc);\\n    }\\n\\n  // initial seed\\n  SeedOutput = vec4(vectc, 0.0, 1.0);\\n}\\n&quot;);const n=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// move vector field to normalized image space\\n// pre-processing for vtkLineIntegralConvolution2D\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Fragment shader used by the gaussian blur filter render pass.\\n\\nuniform sampler2D texVectors; // input texture\\nuniform vec2      uTexSize;   // size of texture\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  //VTK::LICComponentSelection::Impl\\n  V = V/uTexSize;\\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\\n}\\n&quot;,&quot;//VTK::LICComponentSelection::Impl&quot;,`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D  texVectors;\\nuniform sampler2D  texNoise;\\nuniform sampler2D  texLIC;\\nuniform sampler2D  texSeedPts;\\n\\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\\nuniform float uStepSize;        // step size in parametric space\\n\\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n//VTK::LICVectorLookup::Impl\\n\\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\\n// are very poorly supported in webgl\\nvec2 clampToBorder(vec2 uv){\\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\\n  {\\n    return vec2(0.0, 0.0);\\n  }\\n  return getVector(uv);\\n}\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the whole domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value.\\n// in pass 1 repeatedly tile the noise texture across\\n// the computational domain.\\nvec2 getNoiseTC(vec2 tc)\\n{\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(tc);\\n    }\\n  else\\n    {\\n    return tc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the need\\n// to convert to either noise or lic texture coordinates in\\n// pass 1 and 2 respectively.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\n// fourth-order Runge-Kutta streamline integration\\n// no bounds checks are made, therefore it's essential\\n// to have the entire texture initialized to 0\\n// and set clamp to border and have border color 0\\n// an integer is set if the step was taken, keeping\\n// an accurate step count is necessary to prevent\\n// boundary artifacts. Don't count the step if\\n// all vector lookups are identically 0. This is\\n// a proxy for \\&quot;stepped outside valid domain\\&quot;\\nvec2 rk4(vec2 pt0, float dt, out bool count)\\n{\\n  count=true;\\n  float dtHalf = dt * 0.5;\\n  vec2 pt1;\\n\\n  vec2 v0 = clampToBorder(pt0);\\n  pt1 = pt0 + v0 * dtHalf;\\n\\n  vec2 v1 = clampToBorder(pt1);\\n  pt1 = pt0 + v1 * dtHalf;\\n\\n  vec2 v2 = clampToBorder(pt1);\\n  pt1 = pt0 + v2 * dt;\\n\\n  vec2 v3 = clampToBorder(pt1);\\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\\n\\n  if (vSum == vec2(0.0, 0.0))\\n    {\\n      count = false;\\n    }\\n\\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\\n\\n return pt1;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic = texture2D(texLIC, lictc);\\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\\n\\n  bool count;\\n  vec2 pt1 = rk4(pt0, uStepSize, count);\\n\\n  if (count)\\n    {\\n    // accumulate lic step\\n    // (lic, mask, 0, step count)\\n    float noise = getNoise(pt1);\\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\\n    SeedOutput = vec4(pt1, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    // keep existing values\\n    LICOutput = lic;\\n    SeedOutput = vec4(pt0, 0.0, 1.0);\\n    }\\n}\\n&quot;,&quot;//VTK::LICVectorLookup::Impl&quot;,function(){const e=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      vec2 V = texture2D( texVectors, vectc ).xy;\\n\\n      // normalize if |V| not 0\\n\\n      float lenV = length( V );\\n\\n      if ( lenV > 1.0e-8 )\\n\\n        {\\n\\n        return V/lenV;\\n\\n        }\\n\\n      else\\n\\n        {\\n\\n        return vec2( 0.0, 0.0 );\\n\\n        }\\n\\n      }\\n\\n    &quot;,t=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      return texture2D( texVectors, vectc ).xy;\\n\\n      }\\n\\n    &quot;;return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(&quot; //VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n/**\\nThis shader finalizes the convolution for the LIC computation\\napplying the normalization. eg. if box kernel is used the this\\nis the number of steps taken.\\n*/\\n\\nuniform sampler2D texLIC;\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\\n  conv.r = conv.r/conv.a;\\n  // lic => (convolution, mask, 0, 1)\\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.CEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// gray scale contrast enhance stage implemented via histogram stretching\\n// if the min and max are tweaked it can generate out-of-range values\\n// these will be clamped in 0 to 1\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n\\nuniform sampler2D texLIC;  // most recent lic pass\\nuniform float uMin;        // min gray scale color value\\nuniform float uMaxMinDiff; // max-min\\n\\nin vec2 tcoordVC;\\n\\nvoid main( void )\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g!=0.0)\\n    {\\n    LICOutput = lic;\\n    }\\n  else\\n    {\\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\\n    LICOutput = vec4(CElic, lic.gb, 1.0);\\n    }\\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.EEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\\n// noise for pass2.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 EEOutput;\\n\\nuniform sampler2D texLIC; // most recent lic pass\\nuniform float     uDx;    // fragment size\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// kernel for simple laplace edge enhancement.\\n// p=Laplace(p)+p\\nfloat K[9] = float[9](\\n  -1.0, -1.0, -1.0,\\n  -1.0,  9.0, -1.0,\\n  -1.0, -1.0, -1.0\\n  );\\n\\n// determine if the fragment was masked\\nbool Masked(float val) { return val != 0.0; }\\n\\nvoid main(void)\\n{\\n  // tex coord neighbor offsets\\n  vec2 fragDx[9] = vec2[9](\\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\\n    );\\n\\n  vec2 lictc = tcoordVC.st;\\n\\n  // compute the convolution but don't use convovled values if\\n  // any masked fragments on the stencil. Fragments outside\\n  // the valid domain are masked during initialization, and\\n  // texture wrap parameters are clamp to border with border\\n  // color that contains masked flag\\n  float conv = 0.0;\\n  bool dontUse = false;\\n  for (int i=0; i<9; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    vec4 lic = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic.g);\\n    conv = conv + K[i] * lic.r;\\n    }\\n\\n  if (dontUse)\\n    {\\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    conv = clamp(conv, 0.0, 1.0);\\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\\n    }\\n\\n}\\n&quot;),t.AAHProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// horizontal pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDx;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.AAVProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// vertical pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\\n\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDy[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;)},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;f&&o[0]===f.getSize()[0]&&o[1]===f.getSize()[1]||(f=Hp.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=qg.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const g=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],m=1/o[0],h=1/o[1],v=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;v.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f(&quot;uTexSize&quot;,...o),e.setUniformi(&quot;texVectors&quot;,t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,0),y.setUniformf(&quot;uMaskThreshold&quot;,t.maskThreshold),y.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),y.setUniformi(&quot;texMaskVectors&quot;,t.bufs.getMaskVectorTextureUnit()),y.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:T}=t;v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,0),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),T.setUniformi(&quot;texVectors&quot;,t.bufs.getImageVectorTextureUnit()),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:b}=t;if(v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),r(t.bufs,o,b),t.enhancedLIC){t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDx&quot;,m),a.setUniformf(&quot;uDy&quot;,h),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,1),n(y,t.bufs),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,1),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),b.setUniformi(&quot;texSeedPts&quot;,t.bufs.getSeedTextureUnit()),r(t.bufs,o,b)}if(t.antiAlias){const e=t.AAHProgram;v.readyShaderProgram(e),e.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),e.setUniformf(&quot;uDx&quot;,m);const a=t.AAVProgram;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDy&quot;,h);for(let i=0;i<t.antiAlias;++i)v.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),v.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error(&quot;Invalid color range: &quot;,i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),c.setUniformf(&quot;uMin&quot;,i),c.setUniformf(&quot;uMaxMinDiff&quot;,l),r(t.bufs,o,c)}}const tm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function nm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tm,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;nuberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;componentIds&quot;,&quot;isComposite&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),em(e,t)}var rm={newInstance:jt.newInstance(nm,&quot;vtkLineIntegralConvolution2D&quot;),extend:nm};function om(e,t){t.classHierarchy.push(&quot;vtkSurfaceLICInterface&quot;)}const am={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Xg,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:Jg,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function im(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,am,n),jt.obj(e,t),jt.setGet(e,t,[&quot;enableLIC&quot;,&quot;numberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;transformVectors&quot;,&quot;maskOnSurface&quot;,&quot;maskThreshold&quot;,&quot;maskColor&quot;,&quot;maskIntensity&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;noiseTextureSize&quot;,&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;noiseGeneratorSeed&quot;,&quot;viewPortScale&quot;,&quot;rebuildNoiseTexture&quot;]),om(0,t)}var sm={newInstance:jt.newInstance(im,&quot;vtkSurfaceLICInterface&quot;),extend:im};const{Representation:lm}=ds;function cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICInterface&quot;),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get(&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;);n=r===Jg?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Nd.newInstance({wrapS:Nd.Wrap.REPEAT,wrapT:Nd.Wrap.REPEAT,minificationFilter:Nd.Filter.NEAREST,magnificationFilter:Nd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,&quot;Float32Array&quot;,d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.allocateTextures=()=>{const n=Nd.Filter.NEAREST,r=Nd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Nd.newInstance({wrapS:Nd.Wrap.CLAMP_TO_EDGE,wrapT:Nd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,&quot;Float32Array&quot;,null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Nd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,&quot;Float32Array&quot;,null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=Hp.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader combines surface geometry, LIC, and  scalar colors.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 RGBOutput;\\nlayout(location = 1) out vec4 HSLOutput;\\n\\nuniform sampler2D texVectors;       // vectors, depth\\nuniform sampler2D texGeomColors;    // scalar colors + lighting\\nuniform sampler2D texLIC;           // image lic\\nuniform int       uScalarColorMode; // select between blend, and map shader\\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\\nuniform float     uMaskIntensity;   // blending factor for mask color\\nuniform vec3      uMaskColor;       // color for the masked out fragments\\n\\nin vec2 tcoordVC;\\n\\n/**\\nConvert from RGB color space into HSL colorspace.\\n*/\\nvec3 RGBToHSL(vec3 RGB)\\n{\\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\\n\\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\\n  float RGBMaxMinDiff = RGBMax - RGBMin;\\n\\n  HSL.z = (RGBMax + RGBMin) / 2.0;\\n\\n  if (RGBMaxMinDiff == 0.0)\\n    {\\n    // Gray scale\\n    HSL.x = 0.0;\\n    HSL.y = 0.0;\\n    }\\n  else\\n    {\\n    // Color\\n    if (HSL.z < 0.5)\\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\\n    else\\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\\n\\n    float dR\\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dG\\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dB\\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n\\n    if (RGB.r == RGBMax)\\n      HSL.x = dB - dG;\\n    else\\n    if (RGB.g == RGBMax)\\n      HSL.x = (1.0 / 3.0) + dR - dB;\\n    else\\n    if (RGB.b == RGBMax)\\n      HSL.x = (2.0 / 3.0) + dG - dR;\\n\\n    if (HSL.x < 0.0)\\n      HSL.x += 1.0;\\n\\n    if (HSL.x > 1.0)\\n      HSL.x -= 1.0;\\n    }\\n\\n  return HSL;\\n}\\n\\n/**\\nHelper for HSL to RGB conversion.\\n*/\\nfloat Util(float v1, float v2, float vH)\\n{\\n  if (vH < 0.0)\\n    vH += 1.0;\\n\\n  if (vH > 1.0)\\n     vH -= 1.0;\\n\\n  if ((6.0 * vH) < 1.0)\\n    return (v1 + (v2 - v1) * 6.0 * vH);\\n\\n  if ((2.0 * vH) < 1.0)\\n    return (v2);\\n\\n  if ((3.0 * vH) < 2.0)\\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\\n\\n  return v1;\\n}\\n\\n/**\\nConvert from HSL space into RGB space.\\n*/\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  if (HSL.y == 0.0)\\n    {\\n    // Gray\\n    RGB.r = HSL.z;\\n    RGB.g = HSL.z;\\n    RGB.b = HSL.z;\\n    }\\n  else\\n    {\\n    // Chromatic\\n    float v2;\\n    if (HSL.z < 0.5)\\n      v2 = HSL.z * (1.0 + HSL.y);\\n    else\\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\\n\\n    float v1 = 2.0 * HSL.z - v2;\\n\\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\\n    RGB.g = Util(v1, v2, HSL.x);\\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\\n    }\\n\\n  return RGB.rgb;\\n}\\n\\nvoid main()\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n\\n  // depth is used to determine which fragment belong to us\\n  // and we can change\\n  float depth = texture2D(texVectors, tcoordVC.st).a;\\n\\n  vec3 fragColorRGB;\\n  float valid;\\n  if (depth > 1.0e-3)\\n    {\\n    // we own it\\n    // shade LIC'ed geometry, or apply mask\\n    if (lic.g!=0.0)\\n      {\\n      // it's masked\\n      // apply fragment mask\\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\\n      valid = 0.0;\\n      }\\n    else\\n      {\\n      if (uScalarColorMode==0)\\n        {\\n        // blend with scalars\\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\\n        }\\n      else\\n        {\\n        // multiply with scalars\\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\\n        }\\n      if (lic.b != 0.0)\\n        {\\n        // didn't have the required guard pixels\\n        // don't consider it in min max estimation\\n        // for histpgram stretching\\n        valid = 0.0;\\n        }\\n      else\\n        {\\n        // ok to use in min/max estimates for histogram\\n        // stretching\\n        valid = 1.0;\\n        }\\n      }\\n    }\\n  else\\n    {\\n    // we don't own it\\n    // pass through scalars\\n    fragColorRGB = geomColor.rgb;\\n    valid = 0.0;\\n    }\\n\\n  // if no further stages this texture is\\n  // copied to the screen\\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\\n\\n  // if further stages, move to hsl space for contrast\\n  // enhancement. encoding validity saves moving a texture to the cpu\\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\\n  HSLOutput = vec4(fragColorHSL, valid);\\n}\\n&quot;),t.licCopyPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader copies fragments and depths to the output buffer\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texDepth;     // z values from vertex shader\\nuniform sampler2D texRGBColors; // final rgb LIC colors\\n\\nin vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\\n\\n  // since we render a screen aligned quad\\n  // we're going to be writing fragments\\n  // not touched by the original geometry\\n  // it's critical not to modify those\\n  // fragments.\\n  if (gl_FragDepth == 1.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;),t.enhanceContrastPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// color contrast enhance stage implemented via histogram stretching\\n// on lightness channel. if the min and max are tweaked it can generate\\n// out-of-range values these will be clamped in 0 to 1\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texGeomColors; // scalars + lighting\\nuniform sampler2D texLIC;        // image lic, mask\\nuniform sampler2D texHSLColors;  // hsla colors\\n\\nuniform float     uLMin;         // min lightness over all fragments\\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\\n\\nin vec2 tcoordVC;\\n\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  float v;\\n  float h = HSL.x;\\n  float sl = HSL.y;\\n  float l = HSL.z;\\n\\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\\n  if (v <= 0.0) {\\n    RGB = vec3(0.0,0.0,0.0);\\n  } else {\\n    float m;\\n    int sextant;\\n    float fract, vsf, mid1, mid2;\\n\\n    m = l + l - v;\\n    h *= 6.0;\\n    sextant = int(h);\\n    fract = h - float(sextant);\\n\\n    vsf = (v - m) * fract;\\n    mid1 = m + vsf;\\n    mid2 = v - vsf;\\n    switch (sextant) {\\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\\n    }\\n  }\\n  return RGB;\\n}\\n\\nvoid main()\\n{\\n  // lookup hsl color , mask\\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\\n\\n  // don't modify masked fragments (masked => lic.g==1)\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g==0.0)\\n    {\\n    // normalize lightness channel\\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\\n    }\\n\\n  // back into rgb space\\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\\n\\n  // add alpha\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n  fragColor.a = geomColor.a;\\n\\n  gl_FragData[0] = fragColor;\\n}\\n&quot;),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,lm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=rm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi(&quot;texDepth&quot;,t.depthTexture.getTextureUnit()),r.setUniformi(&quot;texRGBColors&quot;,t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi(&quot;texVectors&quot;,t.vectorImage.getTextureUnit()),o.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get(&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;maskIntensity&quot;,&quot;maskColor&quot;,&quot;enhanceContrast&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;);if(o.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),o.setUniformi(&quot;uScalarColorMode&quot;,a),o.setUniformf(&quot;uLICIntensity&quot;,i),o.setUniformf(&quot;uMapBias&quot;,s),o.setUniformf(&quot;uMaskIntensity&quot;,l),o.setUniform3f(&quot;uMaskColor&quot;,...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===Zg||u===Qg){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit()),s.setUniformi(&quot;texHSLColors&quot;,t.HSLColorImage.getTextureUnit()),s.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),s.setUniformf(&quot;uLMin&quot;,o),s.setUniformf(&quot;uLMaxMinDiff&quot;,i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get(&quot;stepSize&quot;,&quot;numberOfSteps&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;transformVectors&quot;),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error(&quot;Failed to compute image LIC&quot;),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const um={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function dm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,um,n),sm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;reallocateTextures&quot;,&quot;licInterface&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cm(e,t)}var pm={newInstance:jt.newInstance(dm,&quot;vtkSurfaceLICInterface&quot;),extend:dm};const{vtkErrorMacro:fm}=Kt;function gm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICMapper&quot;);const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=cd.substitute(s,&quot;//VTK::Output::Dec&quot;,[&quot;//VTK::Output::Dec&quot;,&quot;layout(location = 2) out vec4 vectorTexture;&quot;,&quot;layout(location = 3) out vec4 maskVectorTexture;&quot;]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,[`attribute vec3 ${n};`,&quot;out vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[`licOutput = ${n};`,&quot;//VTK::TCoord::Impl&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform int uMaskOnSurface;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;in vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Impl&quot;,[&quot;// projected vectors&quot;,&quot;  vec3 tcoordLIC = normalMatrix * licOutput;&quot;,&quot;  vec3 normN = normalize(normalVCVSOutput);&quot;,&quot;  float k = dot(tcoordLIC, normN);&quot;,&quot;  vec3 projected = (tcoordLIC - k*normN);&quot;,&quot;  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;// vectors for fragment masking&quot;,&quot;  if (uMaskOnSurface == 0)&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(licOutput, 1.0);&quot;,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;    }&quot;,&quot;//VTK::TCoord::Impl&quot;],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi(&quot;uMaskOnSurface&quot;,t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(fm(&quot;SurfaceLICMapper Requires WebGL 2&quot;),a=!1),t.context.getExtension(&quot;EXT_color_buffer_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)||(fm(&quot;SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions.&quot;),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(fm(&quot;No input&quot;),a=!1);let i=t.renderable.getLicInterface();i||(i=sm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=pm.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(fm(&quot;No vector input array&quot;),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const mm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const hm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mm,n),np.extend(e,t,n),gm(e,t),At(e,t,[&quot;openGLLicInterface&quot;])}),&quot;vtkOpenGLSurfaceLICMapper&quot;);rn(&quot;vtkSurfaceLICMapper&quot;,hm);const{vtkErrorMacro:vm}=Kt;function ym(e,t){t.classHierarchy.push(&quot;vtkOpenGLSphereMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkSphereMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Spheres\\n\\nattribute vec4 vertexMC;\\nattribute vec2 offsetMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\n\\nuniform int cameraParallel;\\nuniform float scaleFactor;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  // compute the projected vertex position\\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\\n\\n  // make the triangle face the camera\\n  if (cameraParallel == 0)\\n    {\\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\\n    vec3 base1 = cross(base2,dir);\\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\\n    }\\n  else\\n    {\\n    // add in the offset\\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\\n    }\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;\\n&quot;]).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform float invertedDepth;\\n&quot;,&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float b = 2.0*dot(EyePos,EyeDir);\\n&quot;,&quot;  float c = dot(EyePos,EyePos) - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t = (-b - invertedDepth*sqrt(d))*0.5;\\n&quot;,&quot;    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\\n&quot;,&quot;    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;offsetMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||vm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isUniformUsed(&quot;invertedDepth&quot;)&&e.getProgram().setUniformf(&quot;invertedDepth&quot;,t.invert?-1:1),e.getProgram().isUniformUsed(&quot;scaleFactor&quot;)){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf(&quot;scaleFactor&quot;,t.renderable.getScaleFactor()):e.getProgram().setUniformf(&quot;scaleFactor&quot;,1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),o.isUniformUsed(&quot;MCVCMatrix&quot;))if(r.getIsIdentity())o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,n)}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Tm={};const bm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tm,n),np.extend(e,t,n),ym(e,t)}),&quot;vtkOpenGLSphereMapper&quot;);rn(&quot;vtkSphereMapper&quot;,bm);const{vtkErrorMacro:xm}=Kt;function Cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLStickMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkStickMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Sticks\\n\\nattribute vec4 vertexMC;\\nattribute vec3 orientMC;\\nattribute vec4 offsetMC;\\nattribute float radiusMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying float lengthVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\nvarying vec3 orientVCVSOutput;\\n\\nuniform int cameraParallel;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = radiusMC;\\n  lengthVCVSOutput = length(orientMC);\\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\\n\\n  // make sure it is pointing out of the screen\\n  if (orientVCVSOutput.z < 0.0)\\n    {\\n    orientVCVSOutput = -orientVCVSOutput;\\n    }\\n\\n  // make the basis\\n  vec3 xbase;\\n  vec3 ybase;\\n  vec3 dir = vec3(0.0,0.0,1.0);\\n  if (cameraParallel == 0)\\n    {\\n    dir = normalize(-vertexVCVSOutput.xyz);\\n    }\\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\\n    {\\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\\n    ybase = cross(xbase,orientVCVSOutput);\\n    }\\n  else\\n    {\\n    xbase = normalize(cross(orientVCVSOutput,dir));\\n    ybase = cross(orientVCVSOutput,xbase);\\n    }\\n\\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\\n    radiusVCVSOutput*offsets.x*xbase +\\n    radiusVCVSOutput*offsets.y*ybase +\\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,&quot;varying vec4 vertexVCVSOutput;&quot;).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,&quot;  vec4 vertexVC = vertexVCVSOutput;\\n&quot;).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 orientVCVSOutput;\\n&quot;,&quot;varying float lengthVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  vec3 base1;\\n&quot;,&quot;  if (abs(orientVCVSOutput.z) < 0.99) {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\\n&quot;,&quot;  vec3 base2 = cross(orientVCVSOutput,base1);\\n&quot;,&quot;  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\\n&quot;,&quot;  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n&quot;,&quot;  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n&quot;,&quot;  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*a*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t =  (-b - sqrt(d))/(2.0*a);\\n&quot;,&quot;    float tz = EyePos.z + t*EyeDir.z;\\n&quot;,&quot;    vec3 iPoint = EyePos + t*EyeDir;\\n&quot;,&quot;    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\\n&quot;,&quot;      float t2 = (-b + sqrt(d))/(2.0*a);\\n&quot;,&quot;      float tz2 = EyePos.z + t2*EyeDir.z;\\n&quot;,&quot;      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\\n&quot;,&quot;      else {\\n&quot;,&quot;        normalVCVSOutput = orientVCVSOutput;\\n&quot;,&quot;        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\\n&quot;,&quot;        iPoint = EyePos + t3*EyeDir;\\n&quot;,&quot;        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;        }\\n&quot;,&quot;      }\\n&quot;,&quot;    else {\\n&quot;,&quot;      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\\n&quot;,&quot;      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;      }\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed(&quot;orientMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;orientMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||xm(&quot;Error setting 'orientMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),&quot;offsetMC&quot;,0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||xm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;radiusMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;radiusMC&quot;,24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||xm(&quot;Error setting 'radiusMC' in shader VAO.&quot;))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),r.getIsIdentity())o.isUniformUsed(&quot;MCVCMatrix&quot;)&&o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc),o.isUniformUsed(&quot;normalMatrix&quot;)&&o.setUniformMatrix3x3(&quot;normalMatrix&quot;,i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed(&quot;MCVCMatrix&quot;)){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,t)}if(o.isUniformUsed(&quot;normalMatrix&quot;)){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3(&quot;normalMatrix&quot;,t)}}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():xm([&quot;Error setting orientationArray.\\n&quot;,&quot;You have to specify the stick orientation&quot;]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,zu.ARRAY_BUFFER),a.getColorBO().upload(g,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Sm={};const Am=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sm,n),np.extend(e,t,n),Cm(e,t)}),&quot;vtkOpenGLStickMapper&quot;);rn(&quot;vtkStickMapper&quot;,Am);const Im=[];Im[&quot;-&quot;.charCodeAt(0)]=62,Im[&quot;_&quot;.charCodeAt(0)]=63;const wm=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;for(let e=0;e<wm.length;e++)Im[wm.charCodeAt(e)]=e;function Pm(e){return void 0!==Im[e.charCodeAt(0)]}function Om(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<18;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<12;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<6;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<10;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<4;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<2;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error(&quot;BASE64: remain 1 should not happen&quot;)}return u}function Rm(e,t,n){const r=(e<<16)+(t<<8)+n;return wm[r>>18]+wm[r>>12&63]+wm[r>>6&63]+wm[63&r]}function Mm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Rm(t[n],t[n+1],t[n+2])}if(n>0){const e=Rm(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join(&quot;&quot;)}var Dm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)Pm(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):&quot;=&quot;===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Om(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Em={};function Vm(e,t){Em[e]=t}var Lm=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;http&quot;,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Em[e](t)},Bm=Uint8Array,Nm=Uint16Array,_m=Uint32Array,Fm=new Bm([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),km=new Bm([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Gm=new Bm([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Um=function(e,t){for(var n=new Nm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new _m(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},zm=Um(Fm,2),Wm=zm[0],Hm=zm[1];Wm[28]=258,Hm[258]=28;for(var jm=Um(km,0),Km=jm[0],$m=(jm[1],new Nm(32768)),qm=0;qm<32768;++qm){var Xm=(43690&qm)>>>1|(21845&qm)<<1;Xm=(61680&(Xm=(52428&Xm)>>>2|(13107&Xm)<<2))>>>4|(3855&Xm)<<4,$m[qm]=((65280&Xm)>>>8|(255&Xm)<<8)>>>1}var Ym=function(e,t,n){for(var r=e.length,o=0,a=new Nm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Nm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Nm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[$m[d]>>>l]=c}else for(i=new Nm(r),o=0;o<r;++o)e[o]&&(i[o]=$m[s[e[o]-1]++]>>>15-e[o]);return i},Zm=new Bm(288);for(qm=0;qm<144;++qm)Zm[qm]=8;for(qm=144;qm<256;++qm)Zm[qm]=9;for(qm=256;qm<280;++qm)Zm[qm]=7;for(qm=280;qm<288;++qm)Zm[qm]=8;var Qm=new Bm(32);for(qm=0;qm<32;++qm)Qm[qm]=5;var Jm=Ym(Zm,9,1),eh=Ym(Qm,5,1),th=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},nh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},rh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},oh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Nm:4==e.BYTES_PER_ELEMENT?_m:Bm)(n-t);return r.set(e.subarray(t,n)),r},ah=[&quot;unexpected EOF&quot;,&quot;invalid block type&quot;,&quot;invalid length/literal&quot;,&quot;invalid distance&quot;,&quot;stream finished&quot;,&quot;no stream handler&quot;,,&quot;no callback&quot;,&quot;invalid UTF-8 data&quot;,&quot;extra field too long&quot;,&quot;date not in range 1980-2099&quot;,&quot;filename too long&quot;,&quot;stream finishing&quot;,&quot;invalid zip data&quot;],ih=function(e,t,n){var r=new Error(t||ah[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,ih),!n)throw r;return r},sh=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new Bm(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new Bm(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new Bm(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=nh(e,c,1);var h=nh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&ih(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=Jm,p=eh,f=9,g=5;else if(2==h){var T=nh(e,c,31)+257,b=nh(e,c+10,15)+4,x=T+nh(e,c+5,31)+1;c+=14;for(var C=new Bm(x),S=new Bm(19),A=0;A<b;++A)S[Gm[A]]=nh(e,c+3*A,7);c+=3*b;var I=th(S),w=(1<<I)-1,P=Ym(S,I,1);for(A=0;A<x;){var O,R=P[nh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,D=0;for(16==O?(D=3+nh(e,c,3),c+=2,M=C[A-1]):17==O?(D=3+nh(e,c,7),c+=3):18==O&&(D=11+nh(e,c,127),c+=7);D--;)C[A++]=M}}var E=C.subarray(0,T),V=C.subarray(T);f=th(E),g=th(V),d=Ym(E,f,1),p=Ym(V,g,1)}else ih(1);if(c>m){a&&ih(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[rh(e,c)&L])>>>4;if((c+=15&M)>m){a&&ih(0);break}if(M||ih(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Fm[A=_-257];F=nh(e,c,(1<<k)-1)+Wm[A],c+=k}var G=p[rh(e,c)&B],U=G>>>4;if(G||ih(3),c+=15&G,V=Km[U],U>3&&(k=km[U],V+=rh(e,c)&(1<<k)-1,c+=k),c>m){a&&ih(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:oh(t,0,u)},lh=new Bm(0),ch=function(e,t){return e[t]|e[t+1]<<8},uh=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},dh=function(e,t){return uh(e,t)+4294967296*uh(e,t+4)};function ph(e,t){return sh(e,t)}function fh(e,t){return sh(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||ih(6,&quot;invalid gzip data&quot;);var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new Bm((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function gh(e,t){return sh(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&ih(6,&quot;invalid zlib data&quot;),32&n[1]&&ih(6,&quot;invalid zlib data: preset dictionaries not supported&quot;),e.subarray(2,-4)),t);var n}function mh(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?fh(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?ph(e,t):gh(e,t)}var hh=&quot;undefined&quot;!=typeof TextEncoder&&new TextEncoder,vh=&quot;undefined&quot;!=typeof TextDecoder&&new TextDecoder;try{vh.decode(lh,{stream:!0})}catch(e){}function yh(e,t){if(t){for(var n=&quot;&quot;,r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(vh)return vh.decode(e);var o=function(e){for(var t=&quot;&quot;,n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,oh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&ih(8),a}var Th=function(e,t){return t+30+ch(e,t+26)+ch(e,t+28)},bh=function(e,t,n){var r=ch(e,t+28),o=yh(e.subarray(t+46,t+46+r),!(2048&ch(e,t+8))),a=t+46+r,i=uh(e,t+20),s=n&&4294967295==i?xh(e,a):[i,uh(e,t+24),uh(e,t+42)],l=s[0],c=s[1],u=s[2];return[ch(e,t+10),l,c,o,a+ch(e,t+30)+ch(e,t+32),u]},xh=function(e,t){for(;1!=ch(e,t);t+=4+ch(e,t+2));return[dh(e,t+12),dh(e,t+4),dh(e,t+20)]};function Ch(e,t){for(var n={},r=e.length-22;101010256!=uh(e,r);--r)(!r||e.length-r>65558)&&ih(13);var o=ch(e,r+8);if(!o)return{};var a=uh(e,r+16),i=4294967295==a;i&&(r=uh(e,r-12),101075792!=uh(e,r)&&ih(13),o=uh(e,r+32),a=uh(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=bh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Th(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=ph(e.subarray(h,h+d),new Bm(p)):ih(14,&quot;unknown compression type &quot;+u):n[f]=oh(e,h,h+d))}return n}function Sh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?&quot;LittleEndian&quot;:2712847316===n[0]?&quot;BigEndian&quot;:null}&quot;function&quot;==typeof queueMicrotask?queueMicrotask:&quot;function&quot;==typeof setTimeout&&setTimeout;var Ah=Sh(),Ih=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:wh,vtkDebugMacro:Ph}=jt;let Oh=0;function Rh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener(&quot;progress&quot;,n.progressCallback),r}const Mh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;);const s=Rh(&quot;GET&quot;,i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(Ph(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&wh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||&quot;string&quot;!==n.dataType?&quot;arraybuffer&quot;:&quot;text&quot;,s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(yh(mh(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&&quot;gz&quot;!==n.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(yh(mh(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&&quot;gz&quot;!==t.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Rh(&quot;GET&quot;,e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(mh(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType=&quot;arraybuffer&quot;,o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};Vm(&quot;http&quot;,(e=>Mh));const{vtkDebugMacro:Dh}=jt;function Eh(e,t){t.classHierarchy.push(&quot;vtkCamera&quot;);const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;);const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Gi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Gi(o,[...t.position,1],n),Gi(a,[...t.focalPoint,1],n),Gi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=Hi(e[0],e[1],e[2],e[3]),n=Ui(),r=Hi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],Wi(r,t,r),Wi(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error(&quot;Off-Axis projection is not supported at this time&quot;);{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=Ui();zi(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const Vh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Lh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vh,n),jt.obj(e,t),jt.get(e,t,[&quot;distance&quot;]),jt.setGet(e,t,[&quot;parallelProjection&quot;,&quot;useHorizontalViewAngle&quot;,&quot;viewAngle&quot;,&quot;parallelScale&quot;,&quot;useOffAxisProjection&quot;,&quot;freezeFocalPoint&quot;,&quot;physicalScale&quot;]),jt.getArray(e,t,[&quot;directionOfProjection&quot;,&quot;viewPlaneNormal&quot;,&quot;position&quot;,&quot;focalPoint&quot;]),jt.setGetArray(e,t,[&quot;clippingRange&quot;,&quot;windowCenter&quot;],2),jt.setGetArray(e,t,[&quot;viewUp&quot;,&quot;screenBottomLeft&quot;,&quot;screenBottomRight&quot;,&quot;screenTopRight&quot;,&quot;physicalTranslation&quot;,&quot;physicalViewUp&quot;,&quot;physicalViewNorth&quot;],3),Eh(e,t)}var Bh={newInstance:jt.newInstance(Lh,&quot;vtkCamera&quot;),extend:Lh};function Nh(e,t){t.classHierarchy.push(&quot;vtkLight&quot;);const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType(&quot;HeadLight&quot;)},e.setLightTypeToCameraLight=()=>{e.setLightType(&quot;CameraLight&quot;)},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType(&quot;SceneLight&quot;)},e.lightTypeIsHeadLight=()=>&quot;HeadLight&quot;===t.lightType,e.lightTypeIsSceneLight=()=>&quot;SceneLight&quot;===t.lightType,e.lightTypeIsCameraLight=()=>&quot;CameraLight&quot;===t.lightType}const _h={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:&quot;SceneLight&quot;,shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_h,n),jt.obj(e,t),jt.setGet(e,t,[&quot;intensity&quot;,&quot;switch&quot;,&quot;positional&quot;,&quot;exponent&quot;,&quot;coneAngle&quot;,&quot;coneFalloff&quot;,&quot;transformMatrix&quot;,&quot;lightType&quot;,&quot;shadowAttenuation&quot;,&quot;attenuationValues&quot;]),jt.setGetArray(e,t,[&quot;color&quot;,&quot;position&quot;,&quot;focalPoint&quot;,&quot;attenuationValues&quot;],3),Nh(e,t)}var kh={newInstance:jt.newInstance(Fh,&quot;vtkLight&quot;),extend:Fh,LIGHT_TYPES:[&quot;HeadLight&quot;,&quot;CameraLight&quot;,&quot;SceneLight&quot;]};const{vtkErrorMacro:Gh}=jt;function Uh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push(&quot;vtkViewport&quot;),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Gh(&quot;call displayToView on your view instead&quot;),e.viewToDisplay=()=>Gh(&quot;callviewtodisplay on your view instead&quot;),e.getSize=()=>Gh(&quot;call getSize on your View instead&quot;),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=(&quot;PickPropFrom&quot;,()=>Gh(&quot;vtkViewport::PickPropFrom - NOT IMPLEMENTED&quot;))}const zh={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function Wh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zh,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),jt.setGetArray(e,t,[&quot;viewport&quot;],4),jt.setGetArray(e,t,[&quot;background&quot;,&quot;background2&quot;],3),Uh(e,t)}var Hh={newInstance:jt.newInstance(Wh,&quot;vtkViewport&quot;),extend:Wh};const{vtkDebugMacro:jh,vtkErrorMacro:Kh,vtkWarningMacro:$h}=Kt;function qh(e){return()=>Kh(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function Xh(e,t){t.classHierarchy.push(&quot;vtkRenderer&quot;);const n={type:&quot;ComputeVisiblePropBoundsEvent&quot;,renderer:e},r={type:&quot;ResetCameraClippingRangeEvent&quot;,renderer:e},o={type:&quot;ResetCameraEvent&quot;,renderer:e};e.updateCamera=()=>(t.activeCamera||(jh(&quot;No cameras are on, creating one.&quot;),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Kh(&quot;light has unknown light type&quot;,e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=qh(&quot;allocateTime&quot;),e.updateGeometry=qh(&quot;updateGeometry&quot;),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{jh(e.getClassName(),e,&quot;setting Layer to &quot;,n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:&quot;ActiveCameraEvent&quot;,camera:n}),!0),e.makeCamera=()=>{const t=Bh.newInstance();return e.invokeEvent({type:&quot;CreateCameraEvent&quot;,camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=kh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;WorldToView: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=ki.INIT_BOUNDS[0],t.allBounds[1]=ki.INIT_BOUNDS[1],t.allBounds[2]=ki.INIT_BOUNDS[2],t.allBounds[3]=ki.INIT_BOUNDS[3],t.allBounds[4]=ki.INIT_BOUNDS[4],t.allBounds[5]=ki.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),jh(&quot;Can't compute bounds, no 3D props are visible&quot;)),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return jh(&quot;Cannot reset camera!&quot;),!1;let i=null;if(!e.getActiveCamera())return Kh(&quot;Trying to reset non-existent camera&quot;),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&($h(&quot;Resetting view-up since view plane normal is parallel&quot;),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return jh(&quot;Cannot reset camera clipping range!&quot;),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Kh(&quot;Trying to reset clipping range of non-existent camera&quot;),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const Yh={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Zh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Yh,n),Hh.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,[&quot;_renderWindow&quot;,&quot;allocatedRenderTime&quot;,&quot;timeFactor&quot;,&quot;lastRenderTimeInSeconds&quot;,&quot;numberOfPropsRendered&quot;,&quot;lastRenderingUsedDepthPeeling&quot;,&quot;selector&quot;]),At(e,t,[&quot;twoSidedLighting&quot;,&quot;lightFollowCamera&quot;,&quot;automaticLightCreation&quot;,&quot;erase&quot;,&quot;draw&quot;,&quot;nearClippingPlaneTolerance&quot;,&quot;clippingRangeExpansion&quot;,&quot;backingStore&quot;,&quot;interactive&quot;,&quot;layer&quot;,&quot;preserveColorBuffer&quot;,&quot;preserveDepthBuffer&quot;,&quot;useDepthPeeling&quot;,&quot;occlusionRatio&quot;,&quot;maximumNumberOfPeels&quot;,&quot;delegate&quot;,&quot;backgroundTexture&quot;,&quot;texturedBackground&quot;,&quot;environmentTexture&quot;,&quot;environmentTextureDiffuseStrength&quot;,&quot;environmentTextureSpecularStrength&quot;,&quot;useEnvironmentTextureAsBackground&quot;,&quot;useShadows&quot;,&quot;pass&quot;]),It(e,t,[&quot;actors&quot;,&quot;volumes&quot;,&quot;lights&quot;]),Pt(e,t,[&quot;background&quot;],4,1),Ot(0,t,[&quot;renderWindow&quot;]),Xh(e,t)}var Qh={newInstance:Et(Zh,&quot;vtkRenderer&quot;),extend:Zh};const Jh=Object.create(null);function ev(e,t){Jh[e]=t}function tv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Jh[e]&&Jh[e](t)}function nv(e,t){t.classHierarchy.push(&quot;vtkRenderWindow&quot;),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return tv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6;const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join(&quot;\\n&quot;),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))}}const rv={defaultViewAPI:&quot;WebGL&quot;,renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1};function ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rv,n),jt.obj(e,t),jt.setGet(e,t,[&quot;interactor&quot;,&quot;numberOfLayers&quot;,&quot;_views&quot;,&quot;defaultViewAPI&quot;]),jt.get(e,t,[&quot;neverRendered&quot;]),jt.getArray(e,t,[&quot;renderers&quot;]),jt.moveToProtected(e,t,[&quot;views&quot;]),jt.event(e,t,&quot;completion&quot;),nv(e,t)}var av={newInstance:jt.newInstance(ov,&quot;vtkRenderWindow&quot;),extend:ov,registerViewConstructor:ev,listViewAPIs:function(){return Object.keys(Jh)},newAPISpecificView:tv};const iv={Unknown:0,LeftController:1,RightController:2},sv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var lv={Device:iv,Input:sv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:cv,Input:uv}=lv,{vtkWarningMacro:dv,vtkErrorMacro:pv,normalizeWheel:fv,vtkOnceErrorMacro:gv}=jt,mv={ctrlKey:!1,altKey:!1,shiftKey:!1},hv={&quot;xr-standard&quot;:[uv.Trigger,uv.Grip,uv.TrackPad,uv.Thumbstick,uv.A,uv.B]},vv=[&quot;StartAnimation&quot;,&quot;Animation&quot;,&quot;EndAnimation&quot;,&quot;PointerEnter&quot;,&quot;PointerLeave&quot;,&quot;MouseEnter&quot;,&quot;MouseLeave&quot;,&quot;StartMouseMove&quot;,&quot;MouseMove&quot;,&quot;EndMouseMove&quot;,&quot;LeftButtonPress&quot;,&quot;LeftButtonRelease&quot;,&quot;MiddleButtonPress&quot;,&quot;MiddleButtonRelease&quot;,&quot;RightButtonPress&quot;,&quot;RightButtonRelease&quot;,&quot;KeyPress&quot;,&quot;KeyDown&quot;,&quot;KeyUp&quot;,&quot;StartMouseWheel&quot;,&quot;MouseWheel&quot;,&quot;EndMouseWheel&quot;,&quot;StartPinch&quot;,&quot;Pinch&quot;,&quot;EndPinch&quot;,&quot;StartPan&quot;,&quot;Pan&quot;,&quot;EndPan&quot;,&quot;StartRotate&quot;,&quot;Rotate&quot;,&quot;EndRotate&quot;,&quot;Button3D&quot;,&quot;Move3D&quot;,&quot;StartPointerLock&quot;,&quot;EndPointerLock&quot;,&quot;StartInteraction&quot;,&quot;Interaction&quot;,&quot;EndInteraction&quot;,&quot;AnimationFrameRateUpdate&quot;];function yv(e){e.cancelable&&e.preventDefault()}function Tv(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function bv(e,t){t.classHierarchy.push(&quot;vtkRenderWindowInteractor&quot;);const n=new Set,r=new Map;let o=1;function a(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{pv(&quot;you want to call setView(view) instead of setRenderWindow on a vtk.js interactor&quot;)},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>dv(&quot;empty event loop&quot;),e.getCurrentRenderer=()=>(t.currentRenderer||a(0,0),t.currentRenderer);const i=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),o=n.getBoundingClientRect(),i=n.width/o.width,s=n.height/o.height,l={x:i*(e.clientX-o.left),y:s*(o.height-e.clientY+o.top),z:0};return(r.size<=1||!t.currentRenderer)&&a(l.x,l.y),l};function s(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function l(e){const t=s(e);return{key:e.key,keyCode:e.charCode,...t}}function c(e){return e.pointerType||&quot;&quot;}function u(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.bindEvents=n=>{t.container=n,n.addEventListener(&quot;contextmenu&quot;,yv),n.addEventListener(&quot;wheel&quot;,e.handleWheel),n.addEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.addEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.addEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.addEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.addEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.addEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.addEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.addEventListener(&quot;keypress&quot;,e.handleKeyPress),document.addEventListener(&quot;keydown&quot;,e.handleKeyDown),document.addEventListener(&quot;keyup&quot;,e.handleKeyUp),document.addEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),n.style.touchAction=&quot;none&quot;,n.style.userSelect=&quot;none&quot;,n.style.webkitTapHighlightColor=&quot;rgba(0,0,0,0)&quot;},e.unbindEvents=()=>{const{container:n}=t;n.removeEventListener(&quot;contextmenu&quot;,yv),n.removeEventListener(&quot;wheel&quot;,e.handleWheel),n.removeEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.removeEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.removeEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.removeEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.removeEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.removeEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.removeEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.removeEventListener(&quot;keypress&quot;,e.handleKeyPress),document.removeEventListener(&quot;keydown&quot;,e.handleKeyDown),document.removeEventListener(&quot;keyup&quot;,e.handleKeyUp),document.removeEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),t.container=null,r.clear()},e.handleKeyPress=t=>{const n=l(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=l(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=l(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerEnterEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerLeaveEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&yv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),r.has(n.pointerId)&&dv(&quot;[RenderWindowInteractor] duplicate pointerId detected&quot;),r.set(n.pointerId,{pointerId:n.pointerId,position:i(n)}),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(r.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&yv(n),r.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(r.has(t.pointerId))switch(r.delete(t.pointerId),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(r.has(t.pointerId)&&(r.get(t.pointerId).position=i(t)),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:pv(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=r=>{void 0!==r?n.has(r)?dv(&quot;requester is already registered for animating&quot;):(n.add(r),t.animationRequest||1!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):pv(&quot;undefined requester, can not start animating&quot;)},e.extendAnimation=r=>{const o=Date.now()+r;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(r){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.has(r))n.delete(r),t.animationRequest&&0===n.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=r&&r.getClassName?r.getClassName():r;dv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==n.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=n.gamepad,s=n.handedness;if(i){i.index in t.lastGamepadValues||(t.lastGamepadValues[i.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<i.buttons.length;++r)r in t.lastGamepadValues[i.index][s].buttons||(t.lastGamepadValues[i.index][s].buttons[r]=!1),t.lastGamepadValues[i.index][s].buttons[r]!==i.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,pressed:i.buttons[r].pressed,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController,input:hv[i.mapping]&&hv[i.mapping][r]?hv[i.mapping][r]:uv.Trigger}),t.lastGamepadValues[i.index][s].buttons[r]=i.buttons[r].pressed),t.lastGamepadValues[i.index][s].buttons[r]&&null!=a&&e.move3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController})}}))},e.handleMouseMove=n=>{const r={...s(n),position:i(n),deviceType:c(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const r=Date.now();t._animationFrameCount++,r-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(r-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=r,t._animationFrameCount=1),e.animationEvent(),u(),n.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{yv(n);const r={...fv(n),...s(n),position:i(n),deviceType:c(n)};0===t.wheelTimeoutID&&(o=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=o,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:pv(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);if(2===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture(&quot;TouchStart&quot;,t)}else if(1===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const o=[...r.values()];if(t.recognizeGestures)if(0===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonReleaseEvent(t)}else if(1===o.length){const t=Tv(r);e.recognizeGesture(&quot;TouchEnd&quot;,t);const a={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonPressEvent(a)}else{const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||u()},vv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void gv(&quot;\\n          Can not forward events without a current renderer on the interactor.\\n        &quot;);const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),&quot;TouchStart&quot;===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture=&quot;Start&quot;);if(&quot;TouchEnd&quot;===n)return&quot;Pinch&quot;===t.currentGesture&&(e.render(),e.endPinchEvent()),&quot;Rotate&quot;===t.currentGesture&&(e.render(),e.endRotateEvent()),&quot;Pan&quot;===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture=&quot;Start&quot;,void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,&quot;TouchMove&quot;===n)if(&quot;Start&quot;===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture=&quot;Pinch&quot;;const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture=&quot;Rotate&quot;;const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture=&quot;Pan&quot;;const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if(&quot;Rotate&quot;===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if(&quot;Pinch&quot;===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if(&quot;Pan&quot;===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e};const d=e.delete;e.delete=()=>{for(;n.size;)e.cancelAnimation(n.values().next().value);void 0!==document.hidden&&document.removeEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange),t.container&&e.unbindEvents(),d()},void 0!==document.hidden&&document.addEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange,!1)}const xv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:&quot;Start&quot;,animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,&quot;RenderEvent&quot;),vv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,[&quot;initialized&quot;,&quot;container&quot;,&quot;interactorStyle&quot;,&quot;lastFrameTime&quot;,&quot;recentAnimationFrameRate&quot;,&quot;_view&quot;]),jt.setGet(e,t,[&quot;lightFollowCamera&quot;,&quot;enabled&quot;,&quot;enableRender&quot;,&quot;recognizeGestures&quot;,&quot;desiredUpdateRate&quot;,&quot;stillUpdateRate&quot;,&quot;picker&quot;,&quot;preventDefaultOnPointerDown&quot;,&quot;preventDefaultOnPointerUp&quot;,&quot;mouseScrollDebounceByPass&quot;]),jt.moveToProtected(e,t,[&quot;view&quot;]),bv(e,t)}var Sv={newInstance:jt.newInstance(Cv,&quot;vtkRenderWindowInteractor&quot;),extend:Cv,handledEvents:vv,...lv};const{vtkErrorMacro:Av,VOID:Iv}=jt;function wv(e,t){t.classHierarchy.push(&quot;vtkInteractorObserver&quot;);const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Sv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):Iv),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Av(&quot;\\n          The interactor must be set before subscribing to events\\n        &quot;)),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const Pv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pv,n),jt.obj(e,t),jt.event(e,t,&quot;InteractionEvent&quot;),jt.event(e,t,&quot;StartInteractionEvent&quot;),jt.event(e,t,&quot;EndInteractionEvent&quot;),jt.get(e,t,[&quot;_interactor&quot;,&quot;enabled&quot;]),jt.setGet(e,t,[&quot;priority&quot;,&quot;processEvents&quot;]),jt.moveToProtected(e,t,[&quot;interactor&quot;]),wv(e,t)}var Rv={newInstance:jt.newInstance(Ov,&quot;vtkInteractorObserver&quot;),extend:Ov,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},Mv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Dv}=Mv,Ev={Rotate:Dv.IS_ROTATE,Pan:Dv.IS_PAN,Spin:Dv.IS_SPIN,Dolly:Dv.IS_DOLLY,CameraPose:Dv.IS_CAMERA_POSE,WindowLevel:Dv.IS_WINDOW_LEVEL,Slice:Dv.IS_SLICE};function Vv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyle&quot;),Object.keys(Ev).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Dv.IS_NONE&&(t.state=Ev[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:&quot;StartInteractionEvent&quot;}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Ev[n]&&(t.state=Dv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:&quot;EndInteractionEvent&quot;}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case&quot;r&quot;:case&quot;R&quot;:e.pokedRenderer.resetCamera(),n.render();break;case&quot;w&quot;:case&quot;W&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case&quot;s&quot;:case&quot;S&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case&quot;v&quot;:case&quot;V&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Lv={state:Dv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function Bv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lv,n),Rv.extend(e,t,n),Vv(e,t)}var Nv={newInstance:jt.newInstance(Bv,&quot;vtkInteractorStyle&quot;),extend:Bv,...Mv};const{States:_v}=Mv;function Fv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyleTrackballCamera&quot;),e.handleMouseMove=n=>{const r=n.position,o=n.pokedRenderer;switch(t.state){case _v.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad?!n||n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad||t.state!==_v.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===_v.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const t=e.pokedRenderer.getActiveCamera(),n=t.getPhysicalTranslation(),r=.025*t.getPhysicalScale(),o=t.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);t.setPhysicalTranslation(n[0]+o[0]*r,n[1]+o[1]*r,n[2]+o[2]*r)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case _v.IS_DOLLY:e.endDolly();break;case _v.IS_PAN:e.endPan();break;case _v.IS_SPIN:e.endSpin();break;case _v.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(n.pokedRenderer,n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=n.pokedRenderer.getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(n.pokedRenderer,o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(n.pokedRenderer,o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(n.pokedRenderer,o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&n.pokedRenderer.updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=e.pokedRenderer.getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(n.pokedRenderer,r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const kv={motionFactor:10,zoomFactor:10};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Nv.extend(e,t,n),jt.setGet(e,t,[&quot;motionFactor&quot;,&quot;zoomFactor&quot;]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,&quot;vtkInteractorStyleTrackballCamera&quot;),extend:Gv};function zv(e){return e}function Wv(e){return null===e||&quot;null&quot;===e?null:&quot;true&quot;===e||&quot;false&quot;!==e&&(void 0!==e&&&quot;undefined&quot;!==e?&quot;[&quot;===e[0]&&&quot;]&quot;===e[e.length-1]?e.substring(1,e.length-1).split(&quot;,&quot;).map((e=>Wv(e.trim()))):&quot;&quot;===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var Hv=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?Wv:zv,o=(t||&quot;&quot;).replace(/#.*/,&quot;&quot;).replace(&quot;?&quot;,&quot;&quot;).split(&quot;&&quot;);return o.forEach((e=>{const[t,o]=e.split(&quot;=&quot;).map((e=>decodeURIComponent(e)));t&&(n[t]=!o||r(o))})),n};function jv(e,t){t.classHierarchy.push(&quot;vtkRenderPass&quot;),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const Kv={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),jt.obj(e,t),jt.get(e,t,[&quot;currentOperation&quot;]),jt.setGet(e,t,[&quot;delegates&quot;,&quot;_currentParent&quot;,&quot;preDelegateOperations&quot;,&quot;postDelegateOperations&quot;]),jt.moveToProtected(e,t,[&quot;currentParent&quot;]),jv(e,t)}var qv={newInstance:jt.newInstance($v,&quot;vtkRenderPass&quot;),extend:$v};const{Representation:Xv}=ds,{vtkErrorMacro:Yv}=jt;function Zv(e){const t=cd.substitute(e.Fragment,&quot;//VTK::RenderPassFragmentShader::Impl&quot;,&quot;\\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\\n      gl_FragData[1].r = weight;\\n    &quot;,!1);e.Fragment=t.result}function Qv(e,t){t.classHierarchy.push(&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Es.newInstance({numberOfComponents:3,values:e});o.setName(&quot;points&quot;);const a=Es.newInstance({numberOfComponents:2,values:n});a.setName(&quot;tcoords&quot;);const i=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,&quot;polys&quot;,Xv.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Nd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,&quot;Float32Array&quot;,null),t.translucentRTexture=Nd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,&quot;Float32Array&quot;,null),t.translucentZTexture=Nd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],&quot;Float32Array&quot;,null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;attribute vec2 tcoordTC;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = tcoordTC; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),&quot;//VTK::System::Dec\\n\\nin vec2 tcoord;\\n\\nuniform sampler2D translucentRTexture;\\nuniform sampler2D translucentRGBATexture;\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\\n  float t2Color = texture(translucentRTexture, tcoord).r;\\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\\n}\\n&quot;,&quot;&quot;)},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;tcoordTC&quot;,t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;)},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension(&quot;EXT_color_buffer_half_float&quot;)&&!i.getExtension(&quot;EXT_color_buffer_float&quot;))return e.setCurrentOperation(&quot;translucentPass&quot;),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation(&quot;opaqueZBufferPass&quot;),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation(&quot;translucentPass&quot;),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi(&quot;translucentRGBATexture&quot;,t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi(&quot;translucentRTexture&quot;,t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate()},e.getShaderReplacement=()=>t._supported?Zv:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const Jv={framebuffer:null,copyShader:null,tris:null};function ey(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jv,n),qv.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),jt.get(e,t,[&quot;framebuffer&quot;]),Qv(e,t)}var ty={newInstance:jt.newInstance(ey,&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),extend:ey};function ny(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];if(s.getDraw()&&s.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=Hp.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation(&quot;zBufferPass&quot;),i.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation(&quot;opaquePass&quot;),i.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=ty.newInstance()),t.translucentPass.traverse(n,i,e)),t.volumeCount>0&&(e.setCurrentOperation(&quot;volumePass&quot;),i.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation(&quot;overlayPass&quot;),i.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const ry={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ry,n),qv.extend(e,t,n),jt.get(e,t,[&quot;framebuffer&quot;,&quot;opaqueActorCount&quot;,&quot;translucentActorCount&quot;,&quot;volumeCount&quot;]),ny(e,t)}var ay={newInstance:jt.newInstance(oy,&quot;vtkForwardPass&quot;),extend:oy},iy=n(594),sy=n.n(iy);const ly=[&quot;lastShaderProgramBound&quot;,&quot;context&quot;,&quot;_openGLRenderWindow&quot;];function cy(e,t){t.classHierarchy.push(&quot;vtkShaderCache&quot;),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=cd.substitute(o,&quot;VSOut&quot;,&quot;GSOut&quot;).result);const a=t._openGLRenderWindow.getWebgl2();let i=&quot;\\n&quot;,s=&quot;#version 100\\n&quot;;a?s=&quot;#version 300 es\\n#define attribute in\\n#define textureCube texture\\n#define texture2D texture\\n#define textureCubeLod textureLod\\n#define texture2DLod textureLod\\n&quot;:(t.context.getExtension(&quot;OES_standard_derivatives&quot;),t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(i=&quot;#extension GL_EXT_frag_depth : enable\\n&quot;),t.context.getExtension(&quot;EXT_shader_texture_lod&quot;)&&(i+=&quot;#extension GL_EXT_shader_texture_lod : enable\\n#define textureCubeLod textureCubeLodEXT\\n#define texture2DLod texture2DLodEXT&quot;)),o=cd.substitute(o,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,a?&quot;&quot;:&quot;#extension GL_OES_standard_derivatives : enable\\n&quot;,i,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;let l=cd.substitute(e,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;if(a){l=cd.substitute(l,&quot;varying&quot;,&quot;out&quot;).result,o=cd.substitute(o,&quot;varying&quot;,&quot;in&quot;).result;let e=&quot;&quot;,t=0;for(;o.includes(`gl_FragData[${t}]`);)o=cd.substitute(o,`gl_FragData\\\\[${t}\\\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\\n`,t++;o=cd.substitute(o,&quot;//VTK::Output::Dec&quot;,e).result}return{VSSource:l,FSSource:o,GSSource:cd.substitute(r,&quot;//VTK::System::Dec&quot;,s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=sy().hash(o);if(!(a in t.shaderPrograms)){const o=cd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const uy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,ly),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cy(e,t)}var py={newInstance:jt.newInstance(dy,&quot;vtkShaderCache&quot;),extend:dy};const{vtkErrorMacro:fy}=jt;function gy(e,t){t.classHierarchy.push(&quot;vtkOpenGLTextureUnitManager&quot;),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&fy(&quot;some texture units  were not properly released&quot;);t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const my={context:null,numberOfTextureUnits:0,textureUnits:0};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,[&quot;numberOfTextureUnits&quot;]),jt.setGet(e,t,[&quot;context&quot;]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,&quot;vtkOpenGLTextureUnitManager&quot;),extend:hy};function yy(e,t){t.classHierarchy.push(&quot;vtkRenderWindowViewNode&quot;),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.createSelector=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)}}const Ty={size:void 0,selector:void 0};function by(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ty,n),t.size||(t.size=[300,300]),jt.getArray(e,t,[&quot;size&quot;],2),jt.get(e,t,[&quot;selector&quot;]),Zt.extend(e,t,n),yy(e,t)}var xy={newInstance:jt.newInstance(by,&quot;vtkRenderWindowViewNode&quot;),extend:by};const{vtkDebugMacro:Cy,vtkErrorMacro:Sy}=jt,Ay={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Iy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let wy=0;const Py=[];function Oy(){wy++,Py.forEach((e=>e(wy)))}function Ry(){wy--,Py.forEach((e=>e(wy)))}function My(e){e.preventDefault()}function Dy(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderWindow&quot;);const n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if(&quot;__getUnderlyingContext&quot;===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}();e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener(&quot;webglcontextlost&quot;,My,!1),t.canvas.addEventListener(&quot;webglcontextrestored&quot;,e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow(e)}))}},e.initialize=()=>{if(!t.initialized){t.context=e.get3DContext(),t.textureUnitManager=vy.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND),t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Sy(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.activeFramebuffer?t.activeFramebuffer.getSize():t.size,e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:&quot;high-performance&quot;},r=null;const o=&quot;undefined&quot;!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext(&quot;webgl2&quot;,e),r&&(t.webgl2=!0,Cy(&quot;using webgl2&quot;))),r||(Cy(&quot;using webgl1&quot;),r=t.canvas.getContext(&quot;webgl&quot;,e)||t.canvas.getContext(&quot;experimental-webgl&quot;,e)),new Proxy(r,n)},e.restoreContext=()=>{const t=qv.newInstance();t.setCurrentOperation(&quot;Release&quot;),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?Sy(&quot;Hardware does not support the number of textures defined.&quot;):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case ys.CHAR:case ys.SIGNED_CHAR:case ys.UNSIGNED_CHAR:return 1;case n:case r:case ys.UNSIGNED_SHORT:case ys.SHORT:case ys.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case ys.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&ys.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&ys.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return t.context.R16F;case 2:return t.context.RG16F;case 3:return t.context.RGB16F;default:return t.context.RGBA16F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Ay,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension(&quot;OES_texture_float&quot;),o=n.getExtension(&quot;OES_texture_half_float&quot;),a=n.getExtension(&quot;WEBGL_debug_renderer_info&quot;),i=n.getExtension(&quot;WEBGL_draw_buffers&quot;),s=n.getExtension(&quot;EXT_texture_filter_anisotropic&quot;)||n.getExtension(&quot;WEBKIT_EXT_texture_filter_anisotropic&quot;),l=[[&quot;Max Vertex Attributes&quot;,&quot;MAX_VERTEX_ATTRIBS&quot;,n.getParameter(n.MAX_VERTEX_ATTRIBS)],[&quot;Max Varying Vectors&quot;,&quot;MAX_VARYING_VECTORS&quot;,n.getParameter(n.MAX_VARYING_VECTORS)],[&quot;Max Vertex Uniform Vectors&quot;,&quot;MAX_VERTEX_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],[&quot;Max Fragment Uniform Vectors&quot;,&quot;MAX_FRAGMENT_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],[&quot;Max Fragment Texture Image Units&quot;,&quot;MAX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],[&quot;Max Vertex Texture Image Units&quot;,&quot;MAX_VERTEX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],[&quot;Max Combined Texture Image Units&quot;,&quot;MAX_COMBINED_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],[&quot;Max 2D Texture Size&quot;,&quot;MAX_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_TEXTURE_SIZE)],[&quot;Max Cube Texture Size&quot;,&quot;MAX_CUBE_MAP_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],[&quot;Max Texture Anisotropy&quot;,&quot;MAX_TEXTURE_MAX_ANISOTROPY_EXT&quot;,s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],[&quot;Point Size Range&quot;,&quot;ALIASED_POINT_SIZE_RANGE&quot;,n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(&quot; - &quot;)],[&quot;Line Width Range&quot;,&quot;ALIASED_LINE_WIDTH_RANGE&quot;,n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(&quot; - &quot;)],[&quot;Max Viewport Dimensions&quot;,&quot;MAX_VIEWPORT_DIMS&quot;,n.getParameter(n.MAX_VIEWPORT_DIMS).join(&quot; - &quot;)],[&quot;Max Renderbuffer Size&quot;,&quot;MAX_RENDERBUFFER_SIZE&quot;,n.getParameter(n.MAX_RENDERBUFFER_SIZE)],[&quot;Framebuffer Red Bits&quot;,&quot;RED_BITS&quot;,n.getParameter(n.RED_BITS)],[&quot;Framebuffer Green Bits&quot;,&quot;GREEN_BITS&quot;,n.getParameter(n.GREEN_BITS)],[&quot;Framebuffer Blue Bits&quot;,&quot;BLUE_BITS&quot;,n.getParameter(n.BLUE_BITS)],[&quot;Framebuffer Alpha Bits&quot;,&quot;ALPHA_BITS&quot;,n.getParameter(n.ALPHA_BITS)],[&quot;Framebuffer Depth Bits&quot;,&quot;DEPTH_BITS&quot;,n.getParameter(n.DEPTH_BITS)],[&quot;Framebuffer Stencil Bits&quot;,&quot;STENCIL_BITS&quot;,n.getParameter(n.STENCIL_BITS)],[&quot;Framebuffer Subpixel Bits&quot;,&quot;SUBPIXEL_BITS&quot;,n.getParameter(n.SUBPIXEL_BITS)],[&quot;MSAA Samples&quot;,&quot;SAMPLES&quot;,n.getParameter(n.SAMPLES)],[&quot;MSAA Sample Buffers&quot;,&quot;SAMPLE_BUFFERS&quot;,n.getParameter(n.SAMPLE_BUFFERS)],[&quot;Supported Formats for UByte Render Targets     &quot;,&quot;UNSIGNED_BYTE RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.UNSIGNED_BYTE)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.UNSIGNED_BYTE)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.UNSIGNED_BYTE)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Half Float Render Targets&quot;,&quot;HALF FLOAT RENDER TARGET FORMATS&quot;,[o&&Iy(n,n.RGBA,o.HALF_FLOAT_OES)?&quot;RGBA&quot;:&quot;&quot;,o&&Iy(n,n.RGB,o.HALF_FLOAT_OES)?&quot;RGB&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?&quot;LUMINANCE&quot;:&quot;&quot;,o&&Iy(n,n.ALPHA,o.HALF_FLOAT_OES)?&quot;ALPHA&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Full Float Render Targets&quot;,&quot;FLOAT RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.FLOAT)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.FLOAT)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.FLOAT)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.FLOAT)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.FLOAT)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Max Multiple Render Targets Buffers&quot;,&quot;MAX_DRAW_BUFFERS_WEBGL&quot;,i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],[&quot;High Float Precision in Vertex Shader&quot;,&quot;HIGH_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Vertex Shader&quot;,&quot;MEDIUM_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Vertex Shader&quot;,&quot;LOW_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Float Precision in Fragment Shader&quot;,&quot;HIGH_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Fragment Shader&quot;,&quot;MEDIUM_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Fragment Shader&quot;,&quot;LOW_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Vertex Shader&quot;,&quot;HIGH_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Vertex Shader&quot;,&quot;MEDIUM_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Vertex Shader&quot;,&quot;LOW_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Fragment Shader&quot;,&quot;HIGH_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Fragment Shader&quot;,&quot;MEDIUM_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Fragment Shader&quot;,&quot;LOW_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Supported Extensions&quot;,&quot;EXTENSIONS&quot;,n.getSupportedExtensions().join(&quot;<br/>\\t\\t\\t\\t\\t    &quot;)],[&quot;WebGL Renderer&quot;,&quot;RENDERER&quot;,n.getParameter(n.RENDERER)],[&quot;WebGL Vendor&quot;,&quot;VENDOR&quot;,n.getParameter(n.VENDOR)],[&quot;WebGL Version&quot;,&quot;VERSION&quot;,n.getParameter(n.VERSION)],[&quot;Shading Language Version&quot;,&quot;SHADING_LANGUAGE_VERSION&quot;,n.getParameter(n.SHADING_LANGUAGE_VERSION)],[&quot;Unmasked Renderer&quot;,&quot;UNMASKED_RENDERER&quot;,a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],[&quot;Unmasked Vendor&quot;,&quot;UNMASKED_VENDOR&quot;,a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],[&quot;WebGL Version&quot;,&quot;WEBGL_VERSION&quot;,t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}()},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=df.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((function(){t.canvas.removeEventListener(&quot;webglcontextlost&quot;,My),t.canvas.removeEventListener(&quot;webglcontextrestored&quot;,e.restoreContext)}),e.delete,e.setViewStream,Ry),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.getGraphicsResourceForObject=e=>e?{vtkObj:t._graphicsResources.get(e),hash:t._graphicsResourceHash.get(e)}:null,e.setGraphicsResourceForObject=(e,n,r)=>{e&&(t._graphicsResources.set(e,n),t._graphicsResourceHash.set(e,r))},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach(((t,n)=>{e+=t.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResourcesForObject=n=>!!n&&(t._graphicsResources.get(n)?.releaseGraphicsResources(e),t._graphicsResources.delete(n)&&t._graphicsResourceHash.delete(n)),e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach(((t,n)=>{t.releaseGraphicsResources(e)})),t._graphicsResources.clear(),t._graphicsResourceHash.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))}}const Ey={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1};const Vy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),xy.extend(e,t,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,Oy(),t.selector||(t.selector=df.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,t._textureResourceIds=new Map,t._graphicsResources=new Map,t._graphicsResourceHash=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Vy),t.shaderCache=py.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=ay.newInstance(),jt.event(e,t,&quot;imageReady&quot;),jt.get(e,t,[&quot;shaderCache&quot;,&quot;textureUnitManager&quot;,&quot;webgl2&quot;,&quot;useBackgroundImage&quot;,&quot;activeFramebuffer&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;defaultToWebgl2&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Dy(e,t)}),&quot;vtkOpenGLRenderWindow&quot;);function Ly(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderModule&quot;),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}ev(&quot;WebGL&quot;,Vy);const By={device:null,handle:null};function Ny(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,By,n),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;handle&quot;]),Ly(e,t)}var _y={newInstance:jt.newInstance(Ny,&quot;vtkWebGPUShaderModule&quot;),extend:Ny};function Fy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderCache&quot;),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=_y.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const ky={shaderModules:null,device:null,window:null};function Gy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ky,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;,&quot;window&quot;]),Fy(e,t)}var Uy={newInstance:jt.newInstance(Gy,&quot;vtkWebGPUShaderCache&quot;),extend:Gy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join(&quot;\\n&quot;):n;let a=!1;-1!==e.search(t)&&(a=!0);let i=&quot;&quot;;r&&(i=&quot;g&quot;);const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function zy(e,t){t.classHierarchy.push(&quot;vtkWebGPUBindGroup&quot;),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join(&quot;\\n&quot;)}}const Wy={device:null,handle:null,label:null};function Hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;label&quot;,&quot;device&quot;,&quot;arrayInformation&quot;]),zy(e,t)}var jy={newInstance:jt.newInstance(Hy),extend:Hy};function Ky(e,t){t.classHierarchy.push(&quot;vtkWebGPUPipeline&quot;),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);&quot;vertex&quot;===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint=&quot;main&quot;),&quot;fragment&quot;===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint=&quot;main&quot;)}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const $y={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$y,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,[&quot;handle&quot;,&quot;pipelineDescription&quot;]),At(e,t,[&quot;device&quot;,&quot;renderEncoder&quot;,&quot;topology&quot;,&quot;vertexState&quot;]),Ky(e,t)}var Xy={newInstance:Et(qy,&quot;vtkWebGPUPipeline&quot;),extend:qy};function Yy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderDescription&quot;),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push(&quot;};&quot;),o=n,r[r.length-1]+=&quot;,&quot;,r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Input&quot;,r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push(&quot;};&quot;),o=o.concat(e),t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Output&quot;,[`-> ${t.type}Output`]).result}t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Dec&quot;,o).result}}const Zy={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function Qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zy,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,[&quot;type&quot;,&quot;hash&quot;,&quot;code&quot;]),jt.getArray(e,t,[&quot;outputTypes&quot;,&quot;outputNames&quot;,&quot;outputInterpolations&quot;]),Yy(e,t)}var Jy={newInstance:jt.newInstance(Qy,&quot;vtkWebGPUShaderDescription&quot;),extend:Qy};const eT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;sint&quot;},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;uint&quot;},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:&quot;sint&quot;},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:&quot;float&quot;},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;uint&quot;},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;sint&quot;},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:&quot;uint&quot;},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:&quot;sint&quot;},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:&quot;uint&quot;},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:&quot;sint&quot;},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:&quot;float&quot;},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;rgba8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;uint&quot;},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;sint&quot;},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;bgra8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:&quot;float&quot;},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:&quot;uint&quot;},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:&quot;sint&quot;},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:&quot;uint&quot;},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:&quot;sint&quot;},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:&quot;float&quot;},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:&quot;uint&quot;},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:&quot;sint&quot;},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:&quot;unfilterable-float&quot;},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;depth&quot;},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:&quot;depth&quot;},&quot;depth24plus-stencil8&quot;:{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:&quot;mixed&quot;},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;depth&quot;}};var tT=function(e){return!e||e.length<6?0:e in eT==1?eT[e]:(et(`unknown format ${e}`),null)},nT=function(e){if(!e||e.length<5)return 0;let t=1;&quot;x&quot;===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},rT=function(e){if(!e||e.length<5)return 0;let t;if(&quot;f&quot;===e[0])t=&quot;Float&quot;;else if(&quot;s&quot;===e[0])t=&quot;Int&quot;;else{if(&quot;u&quot;!==e[0])return void et(`unknown format ${e}`);t=&quot;Uint&quot;}const n=e.split(&quot;x&quot;)[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+=&quot;Array&quot;,t;et(`unknown format ${e}`)},oT=function(e){let t;if(&quot;f&quot;===e[0]||&quot;n&quot;===e[1])t=&quot;f32&quot;;else if(&quot;s&quot;===e[0]&&&quot;i&quot;===e[1])t=&quot;i32&quot;;else{if(&quot;u&quot;!==e[0]||&quot;i&quot;!==e[1])return void et(`unknown format ${e}`);t=&quot;u32&quot;}let n=1;return&quot;x&quot;===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},aT=function(e){if(!e)return 0;let t=1;return&quot;vec&quot;===e.substring(0,3)?t=Number(e[3]):&quot;mat&quot;===e.substring(0,3)&&(t=e[3]*e[5]),4*t},iT=function(e){if(e)return e.includes(&quot;f32&quot;)?&quot;Float32Array&quot;:e.includes(&quot;i32&quot;)?&quot;Int32Array&quot;:e.includes(&quot;u32&quot;)?&quot;Uint32Array&quot;:void et(`unknown format ${e}`)};function sT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function lT(e,t){t.classHierarchy.push(&quot;vtkWebGPUVertexInput&quot;),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:&quot;vertex&quot;,o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(sT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e=&quot;&quot;,n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=oT(a.format);n>0&&(e+=&quot;,\\n&quot;),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const cT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function uT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,[&quot;created&quot;,&quot;device&quot;,&quot;handle&quot;,&quot;indexBuffer&quot;]),lT(e,t)}var dT={newInstance:Et(uT,&quot;vtkWebGPUVertexInput&quot;),extend:uT};const pT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  // var vertex: vec4<f32> = vertexBC;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n&quot;,fT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function gT(e,t){t.classHierarchy.push(&quot;vtkWebGPUSimpleMapper&quot;),e.generateShaderDescriptions=(n,r,o)=>{const a=Jy.newInstance({type:&quot;vertex&quot;,hash:n,code:t.vertexShaderTemplate}),i=Jy.newInstance({type:&quot;fragment&quot;,hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp(&quot;//VTK::[^:]*::&quot;,&quot;g&quot;),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];&quot;replaceShaderIOStructs&quot;!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.replaceShaderCode(null,n),t.getShaderDescription(&quot;fragment&quot;).replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set(&quot;replaceShaderRenderEncoder&quot;,e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderRenderer&quot;,e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);s.addBuiltinInput(&quot;bool&quot;,&quot;@builtin(front_facing) frontFacing&quot;),i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderMapper&quot;,e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;    output.Position = rendererUBO.SCPCMatrix*vertexBC;&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription(&quot;vertex&quot;).addOutput(&quot;vec2<f32>&quot;,&quot;tcoordVS&quot;)},t.shaderReplacements.set(&quot;replaceShaderTCoord&quot;,e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=Xy.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const mT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:&quot;triangle-list&quot;,UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function hT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=dT.newInstance(),t.bindGroup=jy.newInstance({label:&quot;mapperBG&quot;}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||fT,t.vertexShaderTemplate=t.vertexShaderTemplate||pT,t.shaderReplacements=new Map,jt.get(e,t,[&quot;pipeline&quot;,&quot;vertexInput&quot;]),jt.setGet(e,t,[&quot;additionalBindables&quot;,&quot;device&quot;,&quot;fragmentShaderTemplate&quot;,&quot;interpolate&quot;,&quot;numberOfInstances&quot;,&quot;numberOfVertices&quot;,&quot;pipelineHash&quot;,&quot;shaderReplacements&quot;,&quot;SSBO&quot;,&quot;textureViews&quot;,&quot;topology&quot;,&quot;UBO&quot;,&quot;vertexShaderTemplate&quot;,&quot;WebGPURenderer&quot;]),gT(e,t)}var vT={newInstance:jt.newInstance(hT,&quot;vtkWebGPUSimpleMapper&quot;),extend:hT};function yT(e,t){t.classHierarchy.push(&quot;vtkWebGPUFullScreenQuad&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;),r.addOutput(&quot;vec4<f32>&quot;,&quot;vertexVC&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;,&quot;output.vertexVC = vec4<f32>(vertexBC, 1);&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,[&quot;vertexBC&quot;]),t.numberOfVertices=6}}const TT={};function bT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,TT,n),vT.extend(e,t,n),yT(e,t)}var xT={newInstance:jt.newInstance(bT,&quot;vtkWebGPUFullScreenQuad&quot;),extend:bT};const CT=[&quot;setBindGroup&quot;,&quot;setIndexBuffer&quot;,&quot;setVertexBuffer&quot;,&quot;draw&quot;,&quot;drawIndexed&quot;];function ST(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderEncoder&quot;),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!(&quot;depthStencil&quot;in n))console.log(&quot;mismatched depth attachments&quot;),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\\n${o}\\n versus pipeline\\n${a}\\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<CT.length;n++)e[CT[n]]=function(){return t.handle[CT[n]](...arguments)}}const AT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function IT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}],depthStencilAttachment:{view:void 0,depthLoadOp:&quot;clear&quot;,depthClearValue:0,depthStoreOp:&quot;store&quot;}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = computedColor;&quot;]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater-equal&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}},t.colorTextureViews=[],bt(e,t,[&quot;boundPipeline&quot;,&quot;colorTextureViews&quot;]),At(e,t,[&quot;depthTextureView&quot;,&quot;description&quot;,&quot;handle&quot;,&quot;label&quot;,&quot;pipelineHash&quot;,&quot;pipelineSettings&quot;,&quot;replaceShaderCodeFunction&quot;]),ST(e,t)}var wT={newInstance:Et(IT,&quot;vtkWebGPURenderEncoder&quot;),extend:IT},PT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const OT=[&quot;getMappedRange&quot;,&quot;mapAsync&quot;,&quot;unmap&quot;];function RT(e,t){t.classHierarchy.push(&quot;vtkWebGPUBuffer&quot;),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<OT.length;n++)e[OT[n]]=function(){return t.handle[OT[n]](...arguments)}}const MT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;strideInBytes&quot;,&quot;device&quot;,&quot;arrayInformation&quot;,&quot;label&quot;,&quot;sourceTime&quot;]),RT(e,t)}var ET={newInstance:jt.newInstance(DT),extend:DT,...PT};const{Representation:VT}=ds,{PrimitiveTypes:LT}=PT;class BT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function NT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function _T(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=NT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=NT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=NT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=NT(n,o,t),n.ibo[n.iboId++]=a}function FT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let kT;const GT=new Uint32Array(1),UT=new Uint32Array(2),zT=new Uint32Array(3),WT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)GT[0]=t[n+a],kT(GT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)UT[0]=t[n+a],UT[1]=t[n+(a+1)%e],kT(UT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o);for(let a=0;a<e-2;a++)UT[0]=t[n+a],UT[1]=t[n+a+2],kT(UT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n],zT[1]=t[n+a+1],zT[2]=t[n+a+2],kT(zT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n+a],zT[1]=t[n+a+1+a%2],zT[2]=t[n+a+1+(a+1)%2],kT(zT,r,o)}};function HT(e,t){t.classHierarchy.push(&quot;vtkWebGPUIndexBuffer&quot;),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case LT.Points:return&quot;points&quot;;case LT.Lines:return&quot;lines&quot;;case LT.Triangles:case LT.TriangleEdges:return&quot;polys&quot;;case LT.TriangleStripEdges:case LT.TriangleStrips:return&quot;strips&quot;;default:return&quot;&quot;}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new BT};let d=null;d=o===VT.POINTS||r===LT.Points?WT.anythingToPoints:o===VT.WIREFRAME||r===LT.Lines?WT[`${l}ToWireframe`]:WT[`${l}ToSurface`],kT=FT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format=&quot;uint16&quot;):(u.ibo=new Uint32Array(u.iboSize),e.format=&quot;uint32&quot;),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),kT=_T,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const jT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function KT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jT,n),ET.extend(e,t,n),jt.setGet(e,t,[&quot;flatIdToPointId&quot;,&quot;flatIdToCellId&quot;,&quot;flatSize&quot;,&quot;indexCount&quot;]),HT(e,t)}var $T={newInstance:jt.newInstance(KT),extend:KT,...PT};const{BufferUsage:qT}=PT,{vtkErrorMacro:XT}=Kt,{VtkDataTypes:YT}=Es;function ZT(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,&quot;packExtra&quot;)&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function QT(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function JT(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===qT.Index&&(n=$T.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=ET.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===qT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===qT.PointArray){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=ZT(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?&quot;flat&quot;:&quot;perspective&quot;}])}if(e.usage===qT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=QT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=ZT(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:&quot;flat&quot;}])}return e.usage===qT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push(&quot;vtkWebGPUBufferManager&quot;),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case YT.UNSIGNED_CHAR:t=&quot;uint8&quot;;break;case YT.FLOAT:t=&quot;float32&quot;;break;case YT.UNSIGNED_INT:t=&quot;uint32&quot;;break;case YT.INT:t=&quot;sint32&quot;;break;case YT.DOUBLE:t=&quot;float32&quot;;break;case YT.UNSIGNED_SHORT:t=&quot;uint16&quot;;break;case YT.SHORT:t=&quot;sin16&quot;;break;default:t=&quot;float32&quot;}switch(e.getNumberOfComponents()){case 2:t+=&quot;x2&quot;;break;case 3:t.includes(&quot;32&quot;)||XT(`unsupported x3 type for ${t}`),t+=&quot;x3&quot;;break;case 4:t+=&quot;x4&quot;}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:qT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=ET.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:&quot;float32x3&quot;}]),t.fullScreenQuadBuffer}}const eb={device:null,fullScreenQuadBuffer:null};function tb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eb,n),yt(e,t),At(e,t,[&quot;device&quot;]),JT(e,t)}var nb={newInstance:Et(tb),extend:tb,...PT};function rb(e,t){t.classHierarchy.push(&quot;vtkWebGPUSampler&quot;),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:&quot;clamp-to-edge&quot;,t.options.addressModeV=n.addressModeV?n.addressModeV:&quot;clamp-to-edge&quot;,t.options.addressModeW=n.addressModeW?n.addressModeW:&quot;clamp-to-edge&quot;,t.options.magFilter=n.magFilter?n.magFilter:&quot;nearest&quot;,t.options.minFilter=n.minFilter?n.minFilter:&quot;nearest&quot;,t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:&quot;nearest&quot;,t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const ob={device:null,handle:null,label:null,options:null};function ab(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ob,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;options&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;]),rb(e,t)}var ib={newInstance:jt.newInstance(ab),extend:ab};function sb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTextureView&quot;),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r=&quot;f32&quot;;&quot;sint&quot;===t.bindGroupLayoutEntry.texture.sampleType?r=&quot;i32&quot;:&quot;uint&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(r=&quot;u32&quot;);let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return&quot;depth&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=ib.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const lb={texture:null,handle:null,sampler:null,label:null};function cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:&quot;float&quot;,viewDimension:&quot;2d&quot;}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;texture&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;sampler&quot;]),sb(e,t)}var ub={newInstance:jt.newInstance(cb),extend:cb};const{BufferUsage:db}=nb;function pb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTexture&quot;),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?&quot;2d&quot;:&quot;3d&quot;;t.format=n.format?n.format:&quot;rgba8unorm&quot;,t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:&quot;rgba8unorm&quot;,t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format=&quot;rgba8unorm&quot;,n.flip=!0,n.nativeArray=n.jsImageData.data);const o=tT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&&quot;float&quot;===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?&quot;Uint16Array&quot;:i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Ad.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement(&quot;canvas&quot;);e.width=n.image.width,e.height=n.image.height;const t=e.getContext(&quot;2d&quot;);t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Tu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:db.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:db.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=tT(t.format);return 2===e.elementSize&&&quot;float&quot;===e.sampleType?1:255},e.getNumberOfComponents=()=>tT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?&quot;2d&quot;:&quot;3d&quot;);const o=ub.newInstance({label:n});return o.create(e,r),o}}const fb={device:null,handle:null,buffer:null,ready:!1,label:null};function gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fb,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;ready&quot;,&quot;width&quot;,&quot;height&quot;,&quot;depth&quot;,&quot;format&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;label&quot;]),pb(e,t)}var mb={newInstance:jt.newInstance(gb),extend:gb};function hb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOpaquePass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;opaquePassColor&quot;}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView(&quot;opaquePassColorTexture&quot;);t.renderEncoder.setColorTextureView(0,n),t.depthFormat=&quot;depth32float&quot;,t.depthTexture=mb.newInstance({label:&quot;opaquePassDepth&quot;}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;opaquePassDepthTexture&quot;);t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;opaquePass&quot;),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=wT.newInstance({label:&quot;OpaquePass&quot;}),t.renderEncoder.setPipelineHash(&quot;op&quot;)}}const vb={renderEncoder:null,colorTexture:null,depthTexture:null};function yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vb,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),hb(e,t)}var Tb={newInstance:jt.newInstance(yb,&quot;vtkWebGPUOpaquePass&quot;),extend:yb};function bb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=mb.newInstance({label:&quot;translucentPassColor&quot;}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView(&quot;oitpColorTexture&quot;);t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=mb.newInstance({label:&quot;translucentPassAccumulate&quot;}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView(&quot;oitpAccumTexture&quot;);t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=xT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash(&quot;oitpfsq&quot;),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\\n  if (reveal == 1.0) { discard; }\\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\\n  var total: f32 = max(tcolor.a, 0.01);\\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;)}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;translucentPass&quot;),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=wT.newInstance({label:&quot;translucentRender&quot;});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:void 0,clearValue:[1,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}],e.depthStencilAttachment={view:void 0,depthLoadOp:&quot;load&quot;,depthStoreOp:&quot;store&quot;},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addOutput(&quot;f32&quot;,&quot;outAccum&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);&quot;,&quot;output.outColor = vec4<f32>(computedColor.rgb*w, w);&quot;,&quot;output.outAccum = computedColor.a;&quot;]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash(&quot;oitpr&quot;),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!1,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;zero&quot;,dstFactor:&quot;one-minus-src&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=wT.newInstance({label:&quot;translucentFinal&quot;}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash(&quot;oitpf&quot;),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})}}const xb={colorTextureView:null,depthTextureView:null};function Cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),bb(e,t)}var Sb={newInstance:jt.newInstance(Cb,&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),extend:Cb};const{BufferUsage:Ab}=nb,{vtkErrorMacro:Ib}=jt;function wb(e,t){t.classHierarchy.push(&quot;vtkWebGPUUniformBuffer&quot;),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Ib(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:aT(n),offset:-1,nativeType:iT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Ab.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join(&quot;\\n&quot;)}}const Pb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function Ob(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;uniform&quot;}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,[&quot;binding&quot;,&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;,&quot;sizeInBytes&quot;]),wb(e,t)}var Rb={newInstance:jt.newInstance(Ob,&quot;vtkWebGPUUniformBuffer&quot;),extend:Ob};const{BufferUsage:Mb}=nb,{vtkErrorMacro:Db}=jt;function Eb(e,t){t.classHierarchy.push(&quot;vtkWebGPUStorageBuffer&quot;),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void Db(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=aT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:iT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Mb.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\\n};\\nstruct ${t.label}Struct\\n{\\n  values: array<${t.label}StructEntry>,\\n};\\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\\n`),r.join(&quot;\\n&quot;)},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Vb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function Lb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;read-only-storage&quot;}},jt.get(e,t,[&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;numberOfInstances&quot;,&quot;sizeInBytes&quot;]),Eb(e,t)}var Bb={newInstance:jt.newInstance(Lb,&quot;vtkWebGPUStorageBuffer&quot;),extend:Lb};const Nb=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Volume::TraverseDec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\\n{\\n  // todo multicomponent support\\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\\n}\\n\\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\\n{\\n  var result: vec4<f32>;\\n\\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\\n  result.w = 0.0;\\n\\n  // divide by spacing as that is our delta\\n  result = result / volumeSSBO.values[vNum].spacing;\\n  // now we have a gradient in unit tcoords\\n\\n  var grad: f32 = length(result.xyz);\\n  if (grad > 0.0)\\n  {\\n    // rotate to View Coords, needed for lighting and shading\\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\\n    result = nMat * result;\\n    result = result / length(result);\\n  }\\n\\n  // store gradient magnitude in .w\\n  result.w = grad;\\n\\n  return result;\\n}\\n\\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\\n{\\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n\\n  // convert to tcoords and reject if outside the volume\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\\n\\n  var scalar: f32 = getTextureValue(vTex, tpos);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n\\n  var gofactor: f32 = 1.0;\\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    normal = getGradient(vTex, tpos, vNum, scalar);\\n    if (componentSSBO.values[cNum].gomin <  1.0)\\n    {\\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\\n    }\\n  }\\n\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n\\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    color = color*abs(normal.z);\\n  }\\n\\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\\n\\n  return outColor;\\n}\\n\\n// adjust the start and end point of a raycast such that it intersects the unit cube.\\n// This function is used to take a raycast starting point and step vector\\n// and numSteps and return the startijng and ending steps for intersecting the\\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\\n// and bound it to intersecting the texture.\\n//\\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\\n{\\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\\n\\n  // move tpos to the start of the volume\\n  var adjust: f32 =\\n    min(\\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\\n      min(\\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\\n  if (adjust < 0.0)\\n  {\\n    result.x = result.x - adjust;\\n  }\\n\\n  // adjust length to the end\\n  adjust =\\n    max(\\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\\n      max(\\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\\n  if (adjust > 0.0)\\n  {\\n    result.y = result.y - adjust;\\n  }\\n\\n  return result;\\n}\\n\\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\\n{\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n  return vec4<f32>(color.rgb, opacity);\\n}\\n\\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var maxVal: f32 = -1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar > maxVal)\\n    {\\n      maxVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\\n}\\n\\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var minVal: f32 = 1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar < minVal)\\n    {\\n      minVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\\n}\\n\\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var avgVal: f32 = 0.0;\\n  var sampleCount: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      avgVal = avgVal + sample;\\n      sampleCount = sampleCount + 1.0;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  if (sampleCount <= 0.0)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\\n}\\n\\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var sumVal: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      sumVal = sumVal + sample;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\\n}\\n\\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\\n{\\n  // initial ray position is at the beginning\\n  var rayPosSC: vec4<f32> = minPosSC;\\n\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var curDist: f32 = 0.0;\\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n  var sampleColor: vec4<f32>;\\n//VTK::Volume::TraverseCalls\\n\\n  loop\\n  {\\n    // for each volume, sample and accumulate color\\n//VTK::Volume::CompositeCalls\\n\\n    // increment position\\n    curDist = curDist + mapperUBO.SampleDistance;\\n    rayPosSC = rayPosSC + rayStepSC;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayLengthSC) { break; }\\n    if (computedColor.a > 0.98) { break; }\\n  }\\n  return computedColor;\\n}\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\\n\\n  // discard empty rays\\n  if (rayMax <= rayMin) { discard; }\\n  else\\n  {\\n    // compute start and end ray positions in view coordinates\\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\\n\\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\\n    rayStepSC.w = 0.0;\\n\\n    var computedColor: vec4<f32>;\\n\\n//VTK::Volume::Loop\\n\\n//VTK::RenderEncoder::Impl\\n  }\\n\\n  return output;\\n}\\n&quot;,_b=new Float64Array(16),Fb=new Float64Array(16);function kb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePassFSQ&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;]).result,r.setCode(o),t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription(&quot;fragment&quot;);let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===Rg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push(&quot;    computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;)):(s.push(`  sampleColor = traverseVals[${e}];`),s.push(&quot;  computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;));a=Uy.substitute(a,&quot;//VTK::Volume::CompositeCalls&quot;,i).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseCalls&quot;,s).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseDec&quot;,[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===Rg.COMPOSITE_BLEND?l=!0:n===Rg.MAXIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.MINIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.AVERAGE_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.ADDITIVE_INTENSITY_BLEND&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result)}l&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[&quot;    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);&quot;]).result),o.setCode(a)},t.shaderReplacements.set(&quot;replaceShaderVolume&quot;,e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8Array(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;rgba8unorm&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;tfunTexture&quot;);t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;r16float&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;ofunTexture&quot;);t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(_b),b(_b,_b,o);const p=n.getMatrix();m(Fb,p),h(Fb,Fb),T(_b,Fb,_b);const f=d.getWorldToIndex();T(_b,f,_b);const v=d.getDimensions();g(Fb),x(Fb,Fb,[1/v[0],1/v[1],1/v[2]]),T(_b,Fb,_b);for(let t=0;t<16;t++)a[16*e+t]=_b[t];h(_b,_b);for(let t=0;t<4;t++)i[16*e+4*t]=_b[4*t],i[16*e+4*t+1]=_b[4*t+1],i[16*e+4*t+2]=_b[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry(&quot;SCTCMatrix&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;planeNormals&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;shade&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;tstep&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;spacing&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;ipScalarRange&quot;,&quot;vec4<f32>&quot;),t.SSBO.setAllInstancesFromArray(&quot;SCTCMatrix&quot;,a),t.SSBO.setAllInstancesFromArray(&quot;planeNormals&quot;,i),t.SSBO.setAllInstancesFromArray(&quot;shade&quot;,l),t.SSBO.setAllInstancesFromArray(&quot;tstep&quot;,s),t.SSBO.setAllInstancesFromArray(&quot;spacing&quot;,c),t.SSBO.setAllInstancesFromArray(&quot;ipScalarRange&quot;,u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=tT(l),u={scale:[255],offset:[0]};2===c.elementSize&&&quot;float&quot;===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry(&quot;cScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;cShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomin&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomax&quot;,&quot;f32&quot;),t.componentSSBO.setAllInstancesFromArray(&quot;cScale&quot;,d),t.componentSSBO.setAllInstancesFromArray(&quot;cShift&quot;,p),t.componentSSBO.setAllInstancesFromArray(&quot;oScale&quot;,f),t.componentSSBO.setAllInstancesFromArray(&quot;oShift&quot;,v),t.componentSSBO.setAllInstancesFromArray(&quot;goScale&quot;,A),t.componentSSBO.setAllInstancesFromArray(&quot;goShift&quot;,S),t.componentSSBO.setAllInstancesFromArray(&quot;gomin&quot;,y),t.componentSSBO.setAllInstancesFromArray(&quot;gomax&quot;,C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue(&quot;SampleDistance&quot;,r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=ib.newInstance({label:&quot;clampSampler&quot;}),t.clampSampler.create(t.device,{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}))},e.computePipelineHash=()=>{t.pipelineHash=&quot;volfsq&quot;;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Gb={volumes:null,rowLength:1024,lastVolumeLength:0};function Ub(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gb,n),xT.extend(e,t,n),t.fragmentShaderTemplate=Nb,t.UBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t.UBO.addEntry(&quot;SampleDistance&quot;,&quot;f32&quot;),t.SSBO=Bb.newInstance({label:&quot;volumeSSBO&quot;}),t.componentSSBO=Bb.newInstance({label:&quot;componentSSBO&quot;}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),kb(e,t)}var zb={newInstance:jt.newInstance(Ub,&quot;vtkWebGPUVolumePassFSQ&quot;),extend:Ub};const{Representation:Wb}=ds,{BufferUsage:Hb,PrimitiveTypes:jb}=nb,Kb=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],$b=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::VolumePass::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::VolumePass::Impl\\n\\n  // use the maximum (closest) of the current value and the zbuffer\\n  // the blend func will then take the min to find the farthest stop value\\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function qb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePass&quot;),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=zb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=xT.newInstance(),t._volumeCopyQuad.setPipelineHash(&quot;volpassfsq&quot;),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._copyUBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t._copyUBO.addEntry(&quot;tscale&quot;,&quot;vec2<f32>&quot;),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray(&quot;tscale&quot;,[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray(&quot;tscale&quot;,[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:Hb.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:jb.Triangles,representation:Wb.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:Hb.PointArray,format:&quot;float32x4&quot;,hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,[&quot;vertexBC&quot;]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+Kb[e][0],l[n++]=r+Kb[e][1],l[n++]=r+Kb[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation(&quot;volumeDepthRangePass&quot;),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=wT.newInstance({label:&quot;VolumePass DepthRange&quot;}),t._depthRangeEncoder.setPipelineHash(&quot;volr&quot;),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor1&quot;),t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor2&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);&quot;,&quot;output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);&quot;]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:null,clearValue:[1,1,1,1],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;}}}]}}),t._depthRangeTexture=mb.newInstance({label:&quot;volumePassMaxDepth&quot;}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView(&quot;maxTexture&quot;);t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=mb.newInstance({label:&quot;volumePassDepthMin&quot;}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView(&quot;minTexture&quot;);t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=mb.newInstance({label:&quot;volumePassColor&quot;}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;bgra8unorm&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView(&quot;volumePassColorTexture&quot;),t._colorTextureView.addSampler(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._clearEncoder=wT.newInstance({label:&quot;VolumePass Clear&quot;}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._clearEncoder.setPipelineHash(&quot;volpf&quot;),t._clearEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=wT.newInstance({label:&quot;volumePassCopy&quot;}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._copyEncoder.setPipelineHash(&quot;volcopypf&quot;),t._copyEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=wT.newInstance({label:&quot;volumePassMerge&quot;}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash(&quot;volpf&quot;),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const Xb={colorTextureView:null,depthTextureView:null,volumes:null};function Yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xb,n),qv.extend(e,t,n),t._mapper=vT.newInstance(),t._mapper.setFragmentShaderTemplate($b),t._mapper.getShaderReplacements().set(&quot;replaceShaderVolumePass&quot;,((e,t,n)=>{t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)})),t._boundsPoly=gu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),qb(e,t)}var Zb={newInstance:jt.newInstance(Yb,&quot;vtkWebGPUVolumePass&quot;),extend:Yb};function Qb(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e),t.opaquePass||(t.opaquePass=Tb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Sb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=Zb.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=wT.newInstance({label:&quot;forwardPassBlit&quot;}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._finalBlitEncoder.setPipelineHash(&quot;fpf&quot;),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}}),t._fsqSampler=ib.newInstance({label:&quot;finalPassSampler&quot;}),t._fsqSampler.create(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._fullScreenQuad=xT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash(&quot;fpfsq&quot;),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0),vec4<f32>(0.0),vec4<f32>(1.0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._finalBlitOutputTextureView=ub.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const Jb={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;opaquePass&quot;,&quot;translucentPass&quot;,&quot;volumePass&quot;]),Qb(e,t)}var tx={newInstance:jt.newInstance(ex,&quot;vtkForwardPass&quot;),extend:ex};const{VtkDataTypes:nx}=Es;function rx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format=&quot;r&quot;;break;case 2:e.format=&quot;rg&quot;;break;default:e.format=&quot;rgba&quot;}switch(e.dataArray.getDataType()){case nx.UNSIGNED_CHAR:e.format+=&quot;8unorm&quot;;break;case nx.FLOAT:case nx.UNSIGNED_INT:case nx.INT:case nx.DOUBLE:case nx.UNSIGNED_SHORT:case nx.SHORT:default:e.format+=&quot;16float&quot;}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format=&quot;rgba8unorm&quot;),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=mb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push(&quot;vtkWebGPUTextureManager&quot;),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const ox={handle:null,device:null};function ax(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ox,n),jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;]),rx(e,t)}var ix={newInstance:jt.newInstance(ax),extend:ax};class sx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&&quot;object&quot;==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function lx(e,t){t.classHierarchy.push(&quot;vtkWebGPUDevice&quot;),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro(&quot;layout not found&quot;),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro(&quot;attempt to cache an object without a hash&quot;),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const cx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cx,n),yt(e,t),At(e,t,[&quot;handle&quot;]),bt(e,t,[&quot;bufferManager&quot;,&quot;shaderCache&quot;,&quot;textureManager&quot;]),t.objectCache=new sx,t.shaderCache=Uy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=nb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=ix.newInstance(),t.textureManager.setDevice(e),t.pipelines={},lx(e,t)}var dx={newInstance:Et(ux,&quot;vtkWebGPUDevice&quot;),extend:ux};function px(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelectionPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;hardwareSelectorColor&quot;}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;rgba32uint&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView(&quot;hardwareSelectColorTexture&quot;);t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=mb.newInstance({label:&quot;hardwareSelectorDepth&quot;}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;depth32float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;hardwareSelectDepthTexture&quot;);t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation(&quot;cameraPass&quot;),r.traverse(e),e.setCurrentOperation(&quot;opaquePass&quot;),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=wT.newInstance({label:&quot;HardwareSelectionPass&quot;}),t.selectionRenderEncoder.setPipelineHash(&quot;sel&quot;),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<u32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);&quot;]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba32uint&quot;,blend:void 0}]}})}}const fx={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function gx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fx,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),px(e,t)}var mx={newInstance:jt.newInstance(gx,&quot;vtkWebGPUHardwareSelectionPass&quot;),extend:gx};const{SelectionContent:hx,SelectionField:vx}=qp,{FieldAssociations:yx}=ol,{vtkErrorMacro:Tx}=jt;function bx(e){return`${e.propID} ${e.compositeID}`}function xx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Cx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=xx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=xx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Cx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Cx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Cx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Cx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Cx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Sx(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelector&quot;),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Tx(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=ET.newInstance({label:&quot;hardwareSelectColorBuffer&quot;});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=ET.newInstance({label:&quot;hardwareSelectDepthBuffer&quot;}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:&quot;depth-only&quot;},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Cx(e,[n,t],0,u);if(r){const t=bx(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=qp.newInstance();switch(i.setContentType(hx.INDICES),e){case yx.FIELD_ASSOCIATION_CELLS:i.setFieldType(vx.CELL);break;case yx.FIELD_ASSOCIATION_POINTS:i.setFieldType(vx.POINT);break;default:Tx(&quot;Unknown field association&quot;)}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Ax={};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),Gp.extend(e,t,n),t._selectionPass=mx.newInstance(),jt.setGet(e,t,[&quot;_WebGPURenderWindow&quot;]),jt.moveToProtected(e,t,[&quot;WebGPURenderWindow&quot;]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,&quot;vtkWebGPUHardwareSelector&quot;),extend:Ix};const Px=Object.create(null);function Ox(e,t){t.classHierarchy.push(&quot;vtkWebGPUViewNodeFactory&quot;)}const Rx={};function Mx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rx,n),t.overrides=Px,tn.extend(e,t,n),Ox(0,t)}var Dx={newInstance:jt.newInstance(Mx,&quot;vtkWebGPUViewNodeFactory&quot;),extend:Mx};const{vtkErrorMacro:Ex}=jt,Vx={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Lx(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderWindow&quot;),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:&quot;premultiplied&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Ex(&quot;WebGPU is not enabled.&quot;);e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Ex(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:&quot;high-performance&quot;}),t.deleted||(t.device=dx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext(&quot;webgpu&quot;))},e.releaseGraphicsResources=()=>{const n=qv.newInstance();n.setCurrentOperation(&quot;Release&quot;),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Vx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=ET.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Ad.fromHalf(r.colorValues[o]),s[n+1]=255*Ad.fromHalf(r.colorValues[o+1]),s[n+2]=255*Ad.fromHalf(r.colorValues[o+2]),s[n+3]=255*Ad.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=wx.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Bx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Nx=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,xy.extend(e,t,n),t.myFactory=Dx.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Nx),t.renderPasses[0]=tx.newInstance(),t.selector||(t.selector=wx.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,&quot;imageReady&quot;),jt.event(e,t,&quot;initialized&quot;),jt.get(e,t,[&quot;commandEncoder&quot;,&quot;device&quot;,&quot;presentationFormat&quot;,&quot;useBackgroundImage&quot;,&quot;xrSupported&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;device&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Lx(e,t)}),&quot;vtkWebGPURenderWindow&quot;);ev(&quot;WebGPU&quot;,Nx);const _x=Hv(),Fx={margin:&quot;0&quot;,padding:&quot;0&quot;,position:&quot;absolute&quot;,top:&quot;0&quot;,left:&quot;0&quot;,width:&quot;100%&quot;,height:&quot;100%&quot;,overflow:&quot;hidden&quot;},kx={position:&quot;absolute&quot;,left:&quot;25px&quot;,top:&quot;25px&quot;,backgroundColor:&quot;white&quot;,borderRadius:&quot;5px&quot;,listStyle:&quot;none&quot;,padding:&quot;5px 10px&quot;,margin:&quot;0&quot;,display:&quot;block&quot;,border:&quot;solid 1px black&quot;,maxWidth:&quot;calc(100% - 70px)&quot;,maxHeight:&quot;calc(100% - 60px)&quot;,overflow:&quot;auto&quot;};function Gx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Ux(e,t){t.classHierarchy.push(&quot;vtkFullScreenRenderWindow&quot;);const n=document.querySelector(&quot;body&quot;);t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement(&quot;div&quot;),Gx(t.container,t.containerStyle||Fx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height=&quot;100%&quot;,n.style.height=&quot;100%&quot;,n.style.padding=&quot;0&quot;,n.style.margin=&quot;0&quot;),t.renderWindow=av.newInstance(),t.renderer=Qh.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(_x.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Sv.newInstance(),t.interactor.setInteractorStyle(Uv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?&quot;block&quot;:&quot;none&quot;)},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement(&quot;div&quot;),Gx(t.controlContainer,t.controlPanelStyle||kx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener(&quot;keypress&quot;,(t=>{&quot;c&quot;===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}))},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener(&quot;resize&quot;,e.resize),e.resize()}const zx={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Wx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zx,n),jt.obj(e,t),jt.get(e,t,[&quot;renderWindow&quot;,&quot;renderer&quot;,&quot;apiSpecificRenderWindow&quot;,&quot;interactor&quot;,&quot;rootContainer&quot;,&quot;container&quot;,&quot;controlContainer&quot;]),Ux(e,t)}var Hx={newInstance:jt.newInstance(Wx),extend:Wx},jx={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:Kx,Scale:$x}=jx,{ScalarMappingTarget:qx}=Pl,{vtkDebugMacro:Xx,vtkErrorMacro:Yx,vtkWarningMacro:Zx}=jt;function Qx(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Jx(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function eC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];Qx(o,i),Qx(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Jx(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Jx(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function tC(e,t){t.classHierarchy.push(&quot;vtkColorTransferFunction&quot;),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Yx(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(s<0||s>1)return Yx(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===$x.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Do(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===Kx.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===Kx.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;,t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===Kx.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===Kx.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;);for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Yx(&quot;Attempting to lookup a value with no points in the function&quot;),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Yx(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Yx(&quot;Index out of range!&quot;),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>t.indexedLookup&&e.getSize()?e.getSize():t.tableSize?t.tableSize:16777216,e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void Yx(&quot;attempt to set zero width color range&quot;);const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):Xx(&quot;Transfer Function Has No Points!&quot;)},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void Zx(&quot;Transfer Function Has No Points!&quot;);const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===qx.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===qx.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===qx.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===qx.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=Kx[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Yx(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=Kx.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const nC={clamping:!0,colorSpace:Kx.RGB,hSVWrap:!0,scale:$x.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function rC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nC,n),Pl.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,[&quot;buildTime&quot;,&quot;mappingRange&quot;]),jt.setGet(e,t,[&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;,&quot;colorSpace&quot;,&quot;discretize&quot;,&quot;numberOfValues&quot;]),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),tC(e,t)}var oC={newInstance:jt.newInstance(rC,&quot;vtkColorTransferFunction&quot;),extend:rC,...jx},aC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:iC,ScaleModes:sC}=aC,{vtkErrorMacro:lC}=jt;function cC(e,t){t.classHierarchy.push(&quot;vtkGlyph3DMapper&quot;),e.getOrientationModeAsString=()=>jt.enumToString(iC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(iC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(iC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(iC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(sC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(sC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(sC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(sC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===sC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(lC(&quot;Cannot scale by components since scale array does not have 3 components.&quot;),a=null);const l=r.getBounds(),c=[];ki.getCorners(l,c),t.bounds[0]=ki.INIT_BOUNDS[0],t.bounds[1]=ki.INIT_BOUNDS[1],t.bounds[2]=ki.INIT_BOUNDS[2],t.bounds[3]=ki.INIT_BOUNDS[3],t.bounds[4]=ki.INIT_BOUNDS[4],t.bounds[5]=ki.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case iC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case iC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case iC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case sC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case sC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case sC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const uC={orient:!0,orientationMode:iC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:sC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function dC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uC,n),nc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,[&quot;orient&quot;,&quot;orientationMode&quot;,&quot;orientationArray&quot;,&quot;scaleArray&quot;,&quot;scaleFactor&quot;,&quot;scaleMode&quot;,&quot;scaling&quot;]),jt.get(e,t,[&quot;colorArray&quot;,&quot;matrixArray&quot;,&quot;normalArray&quot;,&quot;buildTime&quot;]),cC(e,t)}var pC={newInstance:jt.newInstance(dC,&quot;vtkGlyph3DMapper&quot;),extend:dC,...aC};const{vtkErrorMacro:fC}=jt;function gC(e,t){t.classHierarchy.push(&quot;vtkPiecewiseFunction&quot;),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return&quot;Constant&quot;;case 1:return&quot;NonDecreasing&quot;;case 2:return&quot;NonIncreasing&quot;;default:return&quot;Varied&quot;}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(fC(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return fC(&quot;Index out of range!&quot;),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return fC(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(a<0||a>1)return fC(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const mC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function hC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,[&quot;allowDuplicateScalars&quot;,&quot;clamping&quot;]),jt.setArray(e,t,[&quot;range&quot;],2),jt.getArray(e,t,[&quot;range&quot;]),gC(e,t)}var vC={newInstance:jt.newInstance(hC,&quot;vtkPiecewiseFunction&quot;),extend:hC};const{InterpolationType:yC,OpacityMode:TC}=Og,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push(&quot;vtkVolumeProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(bC(&quot;Bad index - must be between 0 and 3&quot;),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=vC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=oC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=vC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return bC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(bC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(yC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(yC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(yC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(yC,t.interpolationType),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const CC={independentComponents:!0,interpolationType:yC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,CC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:TC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;shade&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,&quot;vtkVolumeProperty&quot;),extend:SC,...Og};const{vtkDebugMacro:IC}=jt;function wC(e,t){t.classHierarchy.push(&quot;vtkVolume&quot;),e.getVolumes=()=>e,e.makeProperty=AC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){IC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e));const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const PC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),wC(e,t)}var RC={newInstance:jt.newInstance(OC,&quot;vtkVolume&quot;),extend:OC};const{BlendMode:MC,FilterMode:DC}=Mg,EC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=vC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function VC(e,t){t.classHierarchy.push(&quot;vtkVolumeMapper&quot;);const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(MC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(MC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(MC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(MC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(MC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(MC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(MC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn(&quot;setAverageIPScalarRange is deprecated use setIpScalarRange&quot;),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(DC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(DC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(DC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(DC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Do(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const LC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:MC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:DC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LC,n),Bs(e,t,n),jt.setGet(e,t,[&quot;sampleDistance&quot;,&quot;imageSampleDistance&quot;,&quot;maximumSamplesPerRay&quot;,&quot;autoAdjustSampleDistances&quot;,&quot;initialInteractionScale&quot;,&quot;interactionSampleDistanceFactor&quot;,&quot;blendMode&quot;,&quot;filterMode&quot;,&quot;preferSizeOverAccuracy&quot;,&quot;computeNormalFromOpacity&quot;,&quot;volumetricScatteringBlending&quot;,&quot;globalIlluminationReach&quot;,&quot;volumeShadowSamplingDistFactor&quot;,&quot;anisotropy&quot;,&quot;localAmbientOcclusion&quot;,&quot;LAOKernelSize&quot;,&quot;LAOKernelRadius&quot;]),jt.setGetArray(e,t,[&quot;ipScalarRange&quot;],2),jt.event(e,t,&quot;lightingActivated&quot;),VC(e,t)}var NC={newInstance:jt.newInstance(BC,&quot;vtkVolumeMapper&quot;),extend:BC,...EC};const{InterpolationType:_C}=eg,{vtkErrorMacro:FC}=jt;function kC(e,t){t.classHierarchy.push(&quot;vtkImageProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return FC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(FC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(_C.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(_C.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(_C,t.interpolationType)}const GC={independentComponents:!1,interpolationType:_C.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function UC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,GC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;colorWindow&quot;,&quot;colorLevel&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;opacity&quot;,&quot;useLookupTableScalarRange&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),kC(e,t)}var zC={newInstance:jt.newInstance(UC,&quot;vtkImageProperty&quot;),extend:UC};const{vtkDebugMacro:WC}=jt;function HC(e,t){t.classHierarchy.push(&quot;vtkImageSlice&quot;),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=zC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){WC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),ki.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!ki.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),ki.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const jC={mapper:null,property:null,bounds:[...ki.INIT_BOUNDS]};function KC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),HC(e,t)}var $C={newInstance:jt.newInstance(KC,&quot;vtkImageSlice&quot;),extend:KC};function qC(e,t){t.classHierarchy.push(&quot;vtkAbstractImageMapper&quot;),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro(&quot;vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED&quot;),Fa())}const XC={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var YC=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,XC,n),Fs(e,t,n),jt.setGet(e,t,[&quot;slice&quot;,&quot;useCustomExtents&quot;]),jt.setGetArray(e,t,[&quot;customDisplayExtent&quot;],6),jt.setGetArray(e,t,[&quot;backgroundColor&quot;],4),qC(e,t)};function ZC(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA(&quot;vtkImageArrayMapper&quot;)?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ni.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:QC,otherStaticMethods:JC}=Ul,{SlicingMode:eS}=sg;function tS(e,t){function n(){let n;switch(t.slicingMode){case eS.X:n=0;break;case eS.Y:n=1;break;case eS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push(&quot;vtkImageMapper&quot;),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case eS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case eS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case eS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case eS.I:l=Ma(a[0],i[0],i[1]);break;case eS.J:l=Ma(a[1],i[2],i[3]);break;case eS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case eS.I:case eS.J:case eS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case eS.X:e.setSlice(r[0]);break;case eS.Y:e.setSlice(r[1]);break;case eS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(eS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(eS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(eS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(eS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(eS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(eS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case eS.X:n[0]=1;break;case eS.Y:n[1]=1;break;case eS.Z:n[2]=1;break;case eS.I:ea(r,[1,0,0],n);break;case eS.J:ea(r,[0,1,0],n);break;case eS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==eS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case eS.I:r[0]=a,r[1]=a;break;case eS.J:r[2]=a,r[3]=a;break;case eS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case eS.I:a[0]=s-r,a[1]=s+r;break;case eS.J:a[2]=s-r,a[3]=s+r;break;case eS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const nS={slicingMode:eS.NONE,closestIJKAxis:{ijkMode:eS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function rS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nS,n),YC(e,t,n),jt.get(e,t,[&quot;slicingMode&quot;]),jt.setGet(e,t,[&quot;closestIJKAxis&quot;,&quot;renderToRectangle&quot;,&quot;sliceAtFocalPoint&quot;,&quot;preferSizeOverAccuracy&quot;]),Ul.implementCoincidentTopologyMethods(e,t),tS(e,t)}var oS={newInstance:jt.newInstance(rS,&quot;vtkImageMapper&quot;),extend:rS,...QC,...JC,...sg};const{vtkErrorMacro:aS}=jt;function iS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function sS(e,t){t.classHierarchy.push(&quot;vtkAppendPolyData&quot;),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void aS(&quot;No input specified.&quot;);if(1===o)return void(r[0]=n[0]);const a=gu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===js.SINGLE?s=ys.FLOAT:t.outputPointsPrecision===js.DOUBLE&&(s=ys.DOUBLE);const v=mc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Es.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Es.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Es.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),iS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),iS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),iS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),iS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const lS={outputPointsPrecision:js.DEFAULT};function cS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lS,n),jt.setGet(e,t,[&quot;outputPointsPrecision&quot;]),jt.obj(e,t),jt.algo(e,t,1,1),sS(e,t)}var uS={newInstance:jt.newInstance(cS,&quot;vtkAppendPolyData&quot;),extend:cS};function dS(e,t){t.classHierarchy.push(&quot;vtkConeSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Nf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=gu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const pS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:&quot;Float64Array&quot;};function fS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),dS(e,t)}var gS={newInstance:jt.newInstance(fS,&quot;vtkConeSource&quot;),extend:fS};function mS(e,t){t.classHierarchy.push(&quot;vtkCylinderSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Es.newInstance({numberOfComponents:3,values:u,name:&quot;Normals&quot;}),p=new Float32Array(2*a),f=Es.newInstance({numberOfComponents:2,values:p,name:&quot;TCoords&quot;}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Nf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=gu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const hS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:&quot;Float64Array&quot;};function vS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;initAngle&quot;,&quot;otherRadius&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),mS(e,t)}var yS={newInstance:jt.newInstance(vS,&quot;vtkCylinderSource&quot;),extend:vS};function TS(e,t){t.classHierarchy.push(&quot;vtkArrowSource&quot;),e.requestData=function(e,n){if(t.deleted)return;const r=yS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Bf().rotateZ(-90).apply(a).apply(i);const s=gS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Nf().translate(1-.5*t.tipLength,0,0).apply(c);const u=uS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Nf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Nf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Nf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const bS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:&quot;Float64Array&quot;};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;tipResolution&quot;,&quot;tipRadius&quot;,&quot;tipLength&quot;,&quot;shaftResolution&quot;,&quot;shaftRadius&quot;,&quot;invert&quot;]),jt.setGetArray(e,t,[&quot;direction&quot;],3),jt.algo(e,t,0,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,&quot;vtkArrowSource&quot;),extend:xS};function SS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Bf().translate(...n).apply(e.getPoints().getData())}function AS(e,t){const n=e.getPoints().getBounds(),r=[0,0,0];r[t]=-n[2*t],Bf().translate(...r).apply(e.getPoints().getData())}function IS(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8Array(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Es.newInstance({name:&quot;color&quot;,numberOfComponents:3,values:a}))}function wS(e,t){t.classHierarchy.push(&quot;vtkAxesActor&quot;);const n=nc.newInstance();e.setMapper(n),e.update=()=>{const e=CS.newInstance({direction:[1,0,0],...t.config}).getOutputData();t.config.recenter?SS(e):AS(e,0),IS(e,...t.xAxisColor);const r=CS.newInstance({direction:[0,1,0],...t.config}).getOutputData();t.config.recenter?SS(r):AS(r,1),IS(r,...t.yAxisColor);const o=CS.newInstance({direction:[0,0,1],...t.config}).getOutputData();t.config.recenter?SS(o):AS(o,2),IS(o,...t.zAxisColor);const a=uS.newInstance();a.setInputData(e),a.addInputData(r),a.addInputData(o),n.setInputConnection(a.getOutputPort())},e.update();const r=jt.debounce(e.update,0),{setConfig:o,setXAxisColor:a,setYAxisColor:i,setZAxisColor:s}=e;e.setConfig=e=>!!o(e)&&(r(),!0),e.setXAxisColor=e=>!!a(e)&&(r(),!0),e.setYAxisColor=e=>!!i(e)&&(r(),!0),e.setZAxisColor=e=>!!s(e)&&(r(),!0)}const PS={config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1},xAxisColor:[255,0,0],yAxisColor:[255,255,0],zAxisColor:[0,128,0]};function OS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PS,n),hs.extend(e,t,n),jt.setGet(e,t,[&quot;config&quot;]),jt.setGetArray(e,t,[&quot;xAxisColor&quot;,&quot;yAxisColor&quot;,&quot;zAxisColor&quot;],3,255),wS(e,t)}var RS={newInstance:jt.newInstance(OS,&quot;vtkAxesActor&quot;),extend:OS};const MS=&quot;resetcamera&quot;,DS=&quot;orientation&quot;,ES={MODE_RESET_CAMERA:MS,MODE_ORIENTATION:DS,MODE_SAME:&quot;same&quot;};function VS(e,t){t.classHierarchy.push(&quot;vtkCameraSynchronizer&quot;);const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName(&quot;position&quot;),s=e.getReferenceByName(&quot;focalPoint&quot;),l=e.getReferenceByName(&quot;viewUp&quot;),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===DS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===MS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const LS={mode:DS,focalPoint:[0,0,0],distance:6.8,active:!0};function BS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LS,n),yt(e,t),At(e,t,[&quot;mode&quot;,&quot;active&quot;,&quot;srcRenderer&quot;,&quot;dstRenderer&quot;,&quot;distance&quot;]),Pt(e,t,[&quot;focalPoint&quot;],3,0),VS(e,t)}var NS={newInstance:Et(BS,&quot;vtkCameraSynchronizer&quot;),extend:BS,SynchronizationMode:ES};const _S={},FS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=NS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:NS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var kS=function(e,t,n){const r=e.get(&quot;synchronizedViewId&quot;).synchronizedViewId;if(!t.behaviors||!r)return;_S[r]||(_S[r]={});const o=_S[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=NS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];FS[e.type]?o[r]=new FS[e.type](n,e):console.log(&quot;No mapping for&quot;,e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const GS={},US=/instance:\\${([^}]+)}/,zS={},WS=[],HS={},jS={vtkPoints:mc,vtkCellArray:cc,vtkDataArray:Es};function KS(e){return e.map((e=>US.exec(e))).filter((e=>e)).map((e=>e[1]))}function $S(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),$S(e,t)})),t}function qS(e,t,n,r){if(!t)return Promise.reject(new Error(&quot;No instance provided.&quot;));const o=GS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function XS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=GS[e];return n&&n.build?n.build(t):(console.log(&quot;No builder for&quot;,e),null)}function YS(){Object.keys(GS).forEach((e=>{delete GS[e]}))}function ZS(){Object.keys(zS).forEach((e=>{delete zS[e]}))}function QS(e){if(1===e[1].length)return-1===WS.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===WS.indexOf(e[1][n]);return t}function JS(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(HS[r]){const{key:n,value:o}=HS[r];if(!n||e.properties[n]===o)return void WS.push((e=>`instance:\\${${e}}`)(t))}let o=n.getInstance(t);o||(o=XS(r,{managedInstanceId:t}),n.registerInstance(t,o)),qS(r,o,e,n)})),t.calls&&t.calls.filter(QS).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=US.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:&quot;addArray&quot;,a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:&quot;vtkDataArray&quot;,l=jS[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log(&quot;Error fetching array&quot;,JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error(&quot;Error in array handling for state&quot;,JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function eA(e,t,n){zS[t.id]||JS(e,t,n),zS[t.id]=!0}function tA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function nA(e){const t=e.name?`_${e.name}`:&quot;&quot;;return`${e.hash}_${e.dataType}${t}`}function rA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=nA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=nA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),tA(t.getPointData(),i.pointData),tA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=JS(t,s,r);return r.end(),l}}const oA=rA([&quot;points&quot;,&quot;polys&quot;,&quot;verts&quot;,&quot;lines&quot;,&quot;strips&quot;]),aA=rA([]);function iA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:JS;XS||qS?GS[e]={build:t,update:n}:delete GS[e]}const sA={vtkMapper:[&quot;vtkOpenGLPolyDataMapper&quot;,&quot;vtkCompositePolyDataMapper2&quot;,&quot;vtkDataSetMapper&quot;],vtkProperty:[&quot;vtkOpenGLProperty&quot;],vtkRenderer:[&quot;vtkOpenGLRenderer&quot;],vtkCamera:[&quot;vtkOpenGLCamera&quot;],vtkColorTransferFunction:[&quot;vtkPVDiscretizableColorTransferFunction&quot;],vtkActor:[&quot;vtkOpenGLActor&quot;,&quot;vtkPVLODActor&quot;],vtkLight:[&quot;vtkOpenGLLight&quot;,&quot;vtkPVLight&quot;],vtkTexture:[&quot;vtkOpenGLTexture&quot;],vtkImageMapper:[&quot;vtkOpenGLImageSliceMapper&quot;],vtkVolumeMapper:[&quot;vtkFixedPointVolumeRayCastMapper&quot;]},lA={vtkAxesActor:{build:RS.newInstance,update:JS},vtkRenderWindow:{build:av.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(QS).filter((e=>&quot;removeRenderer&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),JS(e,t,n),kS(e,t,n)}},vtkRenderer:{build:Qh.newInstance,update:function(e,t,n){JS(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=$S(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(QS).filter((e=>&quot;removeViewProp&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{const t=n.getInstance(e).get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:El.newInstance,update:JS},vtkCamera:{build:Bh.newInstance,update:eA},vtkPolyData:{build:gu.newInstance,update:oA},vtkImageData:{build:fl.newInstance,update:aA},vtkMapper:{build:nc.newInstance,update:JS},vtkGlyph3DMapper:{build:pC.newInstance,update:JS},vtkProperty:{build:ds.newInstance,update:JS},vtkActor:{build:hs.newInstance,update:JS},vtkLight:{build:kh.newInstance,update:JS},vtkColorTransferFunction:{build:oC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Tu.newInstance,update:JS},vtkVolume:{build:RC.newInstance,update:JS},vtkVolumeMapper:{build:NC.newInstance,update:JS},vtkVolumeProperty:{build:AC.newInstance,update:JS},vtkImageSlice:{build:$C.newInstance,update:JS},vtkImageMapper:{build:oS.newInstance,update:JS},vtkImageProperty:{build:zC.newInstance,update:JS},vtkPiecewiseFunction:{build:vC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:Fu.newInstance,update:JS},vtkScalarBarActor:{build:Op.newInstance,update:JS}};function cA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&YS(),Object.keys(lA).forEach((e=>{const t=lA[e];iA(e,t.build,t.update)}))}function uA(){Object.keys(sA).forEach((e=>{sA[e].forEach((t=>{GS[t]=GS[e]}))}))}cA(),uA(),HS.vtkPVLight={};var dA={build:XS,update:qS,genericUpdater:JS,oneTimeGenericUpdater:eA,setTypeMapping:iA,clearTypeMapping:YS,getSupportedTypes:function(){return Object.keys(GS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return ZS();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete zS[e]})),r},updateRenderWindow:function(e,t,n){return qS(&quot;vtkRenderWindow&quot;,e,t,n)},excludeInstance:function(e,t,n){HS[e]={key:t,value:n}},setDefaultMapping:cA,applyDefaultAliases:uA,alwaysUpdateCamera:function(){iA(&quot;vtkCamera&quot;,Bh.newInstance),uA()}};const pA={};function fA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if(&quot;string&quot;==typeof t&&(i=Dm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log(&quot;Error getting data array:&quot;),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use &quot;setArrayFetcher&quot; to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function gA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function mA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Dt(t,n,&quot;progressEvent&quot;),Dt(t,n,&quot;progressDone&quot;),t}function hA(){const e={};let t=&quot;default&quot;;return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function vA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;default&quot;,t=pA[e];return t||(t={...fA(),...gA(),...mA(),...hA()},pA[e]=t),t}function yA(e,t){let n=-1,r=100;const o=e=>e.get(&quot;managedInstanceId&quot;).managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get(&quot;synchronizedViewId&quot;).synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),dA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){dA.clearOneTimeUpdaters(a())}}}function TA(e,t){t.classHierarchy.push(&quot;vtkSynchronizableRenderWindow&quot;),t.synchronizerContext||(t.synchronizerContext=vA(t.synchronizerContextName));const n=yA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const bA={synchronizerContextName:&quot;default&quot;,synchronizerContext:null,synchronizedViewId:null};function xA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bA,n),av.extend(e,t),bt(e,t,[&quot;synchronizerContext&quot;]),TA(e,t)}var CA={newInstance:Et(xA,&quot;vtkSynchronizableRenderWindow&quot;),extend:xA,getSynchronizerContext:vA,setSynchronizerContext:function(e,t){pA[e]=t},clearSynchronizerContext:function(e){if(e&&pA[e]&&delete pA[e],!e){const e=Object.keys(pA);for(let t=0;t<e.length;t++)delete pA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;default&quot;;const n=yA(e,vA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:gA,createArrayHandler:fA,createProgressHandler:mA,createSceneMtimeHandler:hA,vtkObjectManager:dA};const{vtkErrorMacro:SA,vtkDebugMacro:AA}=jt;let IA=0;function wA(e){const t=document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`);return t?t.innerHTML:null}function PA(e){return&quot;/&quot;===e[0]?e.substr(1):e}const OA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=wA(PA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=wA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=PA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;)),s=wA(i);if(null===s)a(new Error(`No such array ${i}`));else{if(&quot;string&quot;===n.dataType){let e=atob(s);r.compression&&(e=yh(mh(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Dm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(AA(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&SA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--IA&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};Vm(&quot;html&quot;,(e=>OA));const{vtkErrorMacro:RA,vtkDebugMacro:MA}=jt;function DA(e){return function(e){return&quot;/&quot;===e[0]?e.substr(1):e}(function(e){return new URL(e,&quot;http://any&quot;).pathname}(e))}const EA=function(e){let t=!1,n=0,r=null,o=&quot;&quot;;var a;return(a=e.zipContent,new Promise(((e,t)=>{&quot;string&quot;==typeof a?e(function(e,t){if(t){for(var n=new Bm(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(hh)return hh.encode(e);var o=e.length,a=new Bm(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new Bm(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return oh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error(&quot;Invalid datatype to unpack.&quot;))}))).then((n=>{r=Ch(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith(&quot;index.json&quot;)&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\\.json$/,&quot;&quot;),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||RA(&quot;ERROR!!! zip not ready...&quot;);const u=DA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join(&quot;/&quot;));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if(&quot;string&quot;!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&(&quot;string&quot;===e.dataType||&quot;JSON&quot;===e.dataType?e.buffer=yh(mh(new Uint8Array(e.buffer))):e.buffer=mh(new Uint8Array(e.buffer)).buffer),&quot;JSON&quot;===e.ref.encode?e.values=JSON.parse(e.buffer):(Ah!==e.ref.encode&&Ah&&(MA(`Swap bytes of ${e.name}`),Ih(e.buffer,vs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&RA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(yh(mh(r))):JSON.parse(r),n()}}(i,s.compression,d);e(yh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];if(a.compression){if(&quot;gz&quot;===a.compression){const e=yh(mh(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error(&quot;Invalid compression&quot;))}return Promise.resolve(JSON.parse(yh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(yh(Ch(s))):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(yh(s))},fetchImage(e,n){const a=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=Mm(i.buffer);n.src=`data:image/${function(e){const t=e.split(&quot;.&quot;).pop().toLowerCase();return&quot;jpg&quot;===t?&quot;jpeg&quot;:t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(mh(s).buffer):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(s.buffer)}}};Vm(&quot;zip&quot;,(e=>EA(e)));var VA=n(892),LA=n.n(VA),BA=n(760),NA=n.n(BA),_A=n(311),FA=n.n(_A),kA=n(192),GA=n.n(kA),UA=n(60),zA=n.n(UA),WA=n(865),HA=n.n(WA),jA=n(34),KA={};KA.styleTagTransform=HA(),KA.setAttributes=GA(),KA.insert=FA().bind(null,&quot;head&quot;),KA.domAPI=NA(),KA.insertStyleElement=zA(),LA()(jA.Z,KA);var $A=jA.Z&&jA.Z.locals?jA.Z.locals:void 0;let qA=!0;function XA(e){e.preventDefault(),e.stopPropagation()}function YA(e,t){qA=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=Hx.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:&quot;100%&quot;,width:&quot;100%&quot;,position:&quot;absolute&quot;}}).getRenderWindow(),o=CA.getSynchronizerContext(),a=CA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement(&quot;div&quot;);n.setAttribute(&quot;class&quot;,$A.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?Mh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Lm(&quot;zip&quot;,{zipContent:t,callback:e=>{r.fetchJSON(null,&quot;index.json&quot;).then(i)}})})):Mh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Lm(&quot;zip&quot;,{zipContent:t.file,callback:t=>{e.fetchJSON(null,&quot;index.json&quot;).then(i)}})}else if(t.base64Str){const e=Dm(t.base64Str),n=Lm(&quot;zip&quot;,{zipContent:e,callback:e=>{n.fetchJSON(null,&quot;index.json&quot;).then(i)}})}}function ZA(e){qA=!1;const t=document.querySelector(&quot;.content&quot;),n=document.querySelector(&quot;body&quot;),r=e||t||n;r!==e?(r.classList.add($A.fullScreen),n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;):(n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;);const o=document.createElement(&quot;div&quot;);o.innerHTML=`<div class=&quot;${$A.bigFileDrop}&quot;/><input type=&quot;file&quot; accept=&quot;.zip,.vtksz&quot; style=&quot;display: none;&quot;/>`,r.appendChild(o);const a=o.querySelector(&quot;input&quot;);function i(e){XA(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(&quot;.&quot;).slice(-1)[0];YA(r,{file:n[0],ext:e})}}a.addEventListener(&quot;change&quot;,i),o.addEventListener(&quot;drop&quot;,i),o.addEventListener(&quot;click&quot;,(e=>a.click())),o.addEventListener(&quot;dragover&quot;,XA)}const QA=Hv();if(QA.url||QA.fileURL){const e=document.querySelector(&quot;.content&quot;),t=document.querySelector(&quot;body&quot;),n=e||t;n&&(n.classList.add($A.fullScreen),t.style.margin=&quot;0&quot;,t.style.padding=&quot;0&quot;),qA=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>YA(n,QA)))}setTimeout((()=>{qA&&ZA()}),100),window.OfflineLocalView={initLocalFileLoader:ZA,load:YA}},793:function(e){&quot;use strict&quot;;e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=&quot;&quot;,r=void 0!==t[5];return t[4]&&(n+=&quot;@supports (&quot;.concat(t[4],&quot;) {&quot;)),t[2]&&(n+=&quot;@media &quot;.concat(t[2],&quot; {&quot;)),r&&(n+=&quot;@layer&quot;.concat(t[5].length>0?&quot; &quot;.concat(t[5]):&quot;&quot;,&quot; {&quot;)),n+=e(t),r&&(n+=&quot;}&quot;),t[2]&&(n+=&quot;}&quot;),t[4]&&(n+=&quot;}&quot;),n})).join(&quot;&quot;)},t.i=function(e,n,r,o,a){&quot;string&quot;==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]=&quot;@layer&quot;.concat(u[5].length>0?&quot; &quot;.concat(u[5]):&quot;&quot;,&quot; {&quot;).concat(u[1],&quot;}&quot;)),u[5]=a),n&&(u[2]?(u[1]=&quot;@media &quot;.concat(u[2],&quot; {&quot;).concat(u[1],&quot;}&quot;),u[2]=n):u[2]=n),o&&(u[4]?(u[1]=&quot;@supports (&quot;.concat(u[4],&quot;) {&quot;).concat(u[1],&quot;}&quot;),u[4]=o):u[4]=&quot;&quot;.concat(o)),t.push(u))}},t}},490:function(e){&quot;use strict&quot;;e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['&quot;].*['&quot;]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/[&quot;'() \\t\\n]|(%20)/.test(e)||t.needQuotes?'&quot;'.concat(e.replace(/&quot;/g,'\\\\&quot;').replace(/\\n/g,&quot;\\\\n&quot;),'&quot;'):e):e}},22:function(e){&quot;use strict&quot;;e.exports=function(e){return e[1]}},145:function(e,t,n){&quot;use strict&quot;;var r=n(426),o=&quot;function&quot;==typeof Symbol&&&quot;symbol&quot;==typeof Symbol(&quot;foo&quot;),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,&quot;x&quot;,{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||&quot;function&quot;==typeof(o=r)&&&quot;[object Function]&quot;===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){&quot;use strict&quot;;e.exports=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;var e;try{e=this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window;if(&quot;object&quot;==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){&quot;use strict&quot;;e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&&quot;object&quot;==typeof t&&&quot;object&quot;==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){&quot;use strict&quot;;&quot;undefined&quot;!=typeof self?e.exports=self:&quot;undefined&quot;!=typeof window?e.exports=window:e.exports=Function(&quot;return this&quot;)()},177:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){&quot;use strict&quot;;var r=n(491);e.exports=function(){return&quot;object&quot;==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,&quot;globalThis&quot;);t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,&quot;globalThis&quot;,{configurable:!0,enumerable:!1,value:e,writable:!0})}else&quot;object&quot;==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){&quot;use strict&quot;;var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},&quot;toString&quot;),c=s.call((function(){}),&quot;prototype&quot;),u=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if(&quot;undefined&quot;==typeof window)return!1;for(var e in window)try{if(!p[&quot;$&quot;+e]&&o.call(window,e)&&null!==window[e]&&&quot;object&quot;==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&&quot;object&quot;==typeof e,n=&quot;[object Function]&quot;===a.call(e),r=i(e),s=t&&&quot;[object String]&quot;===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError(&quot;Object.keys called on a non-object&quot;);var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&&quot;prototype&quot;===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if(&quot;undefined&quot;==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&&quot;constructor&quot;===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){&quot;use strict&quot;;var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){&quot;use strict&quot;;var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r=&quot;[object Arguments]&quot;===n;return r||(r=&quot;[object Array]&quot;!==n&&null!==e&&&quot;object&quot;==typeof e&&&quot;number&quot;==typeof e.length&&e.length>=0&&&quot;[object Function]&quot;===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(&quot; &quot;),n.s1=r(&quot; &quot;),n.s2=r(&quot; &quot;),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+=&quot;\\0&quot;,r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=&quot;&quot;+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,&quot;global&quot;in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&&quot;object&quot;==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:&quot;string&quot;==o?e:e+&quot;\\0&quot;}function v(e,t){for(var n,r=e+&quot;&quot;,o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}(&quot;undefined&quot;!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){&quot;use strict&quot;;var t=[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r=&quot;&quot;;for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join(&quot;&quot;)}function l(e){return/[\\u0080-\\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a(&quot;hello&quot;)),&quot;undefined&quot;==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff=&quot;&quot;,this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){&quot;use strict&quot;;var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,&quot;.viewer-module-fullScreen_bbk9Y {\\n  position: absolute;\\n  width: 100vw;\\n  height: 100vh;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  z-index: -1;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\n\\n.viewer-module-fullParentSize_ETopO {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n}\\n\\n.viewer-module-bigFileDrop_aqCgh {\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  background-color: white;\\n  background-image: url(&quot;+d+&quot;);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n  background-size: contain;\\n  border-radius: 10px;\\n  width: 50px;\\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\\n  cursor: pointer;\\n}\\n\\n.viewer-module-progress_cYjQJ {\\n  flex: none;\\n  font-size: 50px;\\n  color: black;\\n  z-index: 1;\\n  background: rgba(128,128,128,.5);\\n  padding: 20px;\\n  border-radius: 10px;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\n&quot;,&quot;&quot;]),u.locals={fullScreen:&quot;viewer-module-fullScreen_bbk9Y&quot;,fullParentSize:&quot;viewer-module-fullParentSize_ETopO&quot;,bigFileDrop:&quot;viewer-module-bigFileDrop_aqCgh&quot;,progress:&quot;viewer-module-progress_cYjQJ&quot;},t.Z=u},396:function(e,t,n){var r=n(13),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){&quot;use strict&quot;;var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d=&quot;&quot;.concat(c,&quot; &quot;).concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){&quot;use strict&quot;;var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error(&quot;Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.&quot;);r.appendChild(n)}},60:function(e){&quot;use strict&quot;;e.exports=function(e){var t=document.createElement(&quot;style&quot;);return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){&quot;use strict&quot;;e.exports=function(e){var t=n.nc;t&&e.setAttribute(&quot;nonce&quot;,t)}},760:function(e){&quot;use strict&quot;;e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r=&quot;&quot;;n.supports&&(r+=&quot;@supports (&quot;.concat(n.supports,&quot;) {&quot;)),n.media&&(r+=&quot;@media &quot;.concat(n.media,&quot; {&quot;));var o=void 0!==n.layer;o&&(r+=&quot;@layer&quot;.concat(n.layer.length>0?&quot; &quot;.concat(n.layer):&quot;&quot;,&quot; {&quot;)),r+=n.css,o&&(r+=&quot;}&quot;),n.media&&(r+=&quot;}&quot;),n.supports&&(r+=&quot;}&quot;);var a=n.sourceMap;a&&&quot;undefined&quot;!=typeof btoa&&(r+=&quot;\\n/*# sourceMappingURL=data:application/json;base64,&quot;.concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))),&quot; */&quot;)),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){&quot;use strict&quot;;e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){&quot;use strict&quot;;e.exports=n.p+&quot;138e7b1469f64156810a.jpg&quot;},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error(&quot;define cannot be used indirect&quot;)},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;try{return this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){&quot;undefined&quot;!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p=&quot;&quot;,n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();\n<\/script>\n<script>\nvar container = document.querySelector('.content');\nvar base64Str = &quot;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&quot;;\n\nOfflineLocalView.load(container, { base64Str });\n<\/script>\n</body>\n</html>\n\" class=\"pyvista\" style=\"width: 99%; height: 600px; border: 1px solid rgb(221,221,221);\"></iframe>"}}, "a5ea10fdf64c4a2abcbf0698b85562a4": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}, "c870b6facb9643f5b0cde43bf00a6e91": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_fb5ce73bbed541409d4d176ece2db857", "style": "IPY_MODEL_a5ea10fdf64c4a2abcbf0698b85562a4", "value": "<iframe srcdoc=\"<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;/>\n    <meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;>\n  </head>\n  <body>\n    <div class=&quot;content&quot;></div>\n<script type=&quot;text/javascript&quot;>\n!function(){var e={334:function(){const e=document.querySelector(&quot;head&quot;);e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement(&quot;link&quot;);n.setAttribute(&quot;rel&quot;,&quot;icon&quot;),n.setAttribute(&quot;href&quot;,`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute(&quot;sizes&quot;,`${t}x${t}`),n.setAttribute(&quot;type&quot;,&quot;image/png&quot;),e.appendChild(n)}))},13:function(e,t,n){&quot;use strict&quot;;n.r(t),n.d(t,{initLocalFileLoader:function(){return ZA},load:function(){return YA}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return E},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return D},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ee},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return De},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i=&quot;undefined&quot;!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],D=r[2],E=Math.hypot(R,M,D);return E<a?null:(R*=E=1/E,M*=E,D*=E,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+D*o,C=D*R*s-M*o,S=R*M*s-D*o,A=M*M*s+i,I=D*M*s+R*o,w=R*D*s+M*o,P=M*D*s-R*o,O=D*D*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),E(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,D=(1-(p+v))*C,E=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=D,e[6]=E,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+D*I+L*w),e[14]=n[2]+w-(R*A+E*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return&quot;mat4(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;, &quot;+e[9]+&quot;, &quot;+e[10]+&quot;, &quot;+e[11]+&quot;, &quot;+e[12]+&quot;, &quot;+e[13]+&quot;, &quot;+e[14]+&quot;, &quot;+e[15]+&quot;)&quot;}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],D=t[12],E=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-D)<=a*Math.max(1,Math.abs(m),Math.abs(D))&&Math.abs(h-E)<=a*Math.max(1,Math.abs(h),Math.abs(E))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return&quot;mat3(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;)&quot;}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function De(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=De,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error(&quot;Invalid VTK object&quot;),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&&quot;object&quot;==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol(&quot;void&quot;),$e={};function qe(){}[&quot;log&quot;,&quot;debug&quot;,&quot;info&quot;,&quot;warn&quot;,&quot;error&quot;,&quot;time&quot;,&quot;timeEnd&quot;,&quot;group&quot;,&quot;groupEnd&quot;].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty(&quot;log&quot;)?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st(&quot;_&quot;===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=[&quot;TB&quot;,&quot;GB&quot;,&quot;MB&quot;,&quot;KB&quot;];let o=Number(e),a=&quot;B&quot;;for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot; &quot;;const n=[];let r=e;for(;r>1e3;)n.push((&quot;000&quot;+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),&quot;classHierarchy&quot;in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He(&quot;vtkObject&quot;);function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==[&quot;mtime&quot;].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||&quot;_&quot;===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(&quot;, &quot;)}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if(&quot;object&quot;==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(&quot;string&quot;==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError(&quot;Set Enum with invalid string argument&quot;)}if(&quot;number&quot;==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError(&quot;Set Enum outside numeric range&quot;)}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError(&quot;Set Enum with invalid argument (String/Number)&quot;)}},object(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(!ke()(t[n.name],o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}return!1}}};function Ct(e){if(&quot;object&quot;==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError(&quot;No setter for field&quot;)}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{&quot;object&quot;==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et(&quot;instance deleted - cannot call any method&quot;);else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=&quot; input ports. To add more input ports, use addInputConnection()&quot;,void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et(&quot;instance deleted - cannot call any method&quot;),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):o(e,i())},e.addInputConnection=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:&quot;Scalars&quot;;for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol(&quot;Event abort&quot;);function Dt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et(&quot;instance deleted - cannot call any method&quot;);const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA(&quot;vtkObject&quot;)}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt=&quot;__root__&quot;;function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=&quot;&quot;+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,[&quot;proxyId&quot;,&quot;proxyGroup&quot;,&quot;proxyName&quot;]),At(e,t,[&quot;proxyManager&quot;]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if(&quot;application&quot;===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,&quot;application&quot;),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return&quot;detail&quot;in e&&(n=e.detail),&quot;wheelDelta&quot;in e&&(n=-e.wheelDelta/120),&quot;wheelDeltaY&quot;in e&&(n=-e.wheelDeltaY/120),&quot;wheelDeltaX&quot;in e&&(t=-e.wheelDeltaX/120),&quot;axis&quot;in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,&quot;deltaY&quot;in e&&(o=e.deltaY),&quot;deltaX&quot;in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Dt,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Et,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Dt,newInstance:Et,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push(&quot;vtkViewNode&quot;),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)r.setVisited(!0);else{const r=e.createViewNode(n);r&&(r.setParent(e),r.setVisited(!0),t._renderableChildMap.set(n,r),t.children.push(r))}},e.addMissingNodes=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r],a=t._renderableChildMap.get(o);if(void 0!==a)a.setVisited(!0);else{const n=e.createViewNode(o);n&&(n.setParent(e),n.setVisited(!0),t._renderableChildMap.set(o,n),t.children.push(n))}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];-1===t.children.indexOf(o)&&(o.setParent(e),t.children.push(o)),o.setVisited(!0)}},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t(&quot;Cannot create view nodes without my own factory&quot;),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),t._renderableChildMap=new Map,jt.get(e,t,[&quot;visited&quot;]),jt.setGet(e,t,[&quot;_parent&quot;,&quot;renderable&quot;,&quot;myFactory&quot;]),jt.getArray(e,t,[&quot;children&quot;]),jt.moveToProtected(e,t,[&quot;parent&quot;]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,&quot;vtkViewNode&quot;),extend:Yt,PASS_TYPES:[&quot;Build&quot;,&quot;Render&quot;]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push(&quot;vtkViewNodeFactory&quot;),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s},e.registerOverride=(e,n)=>{t.overrides[e]=n}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,&quot;vtkViewNodeFactory&quot;),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push(&quot;vtkOpenGLViewNodeFactory&quot;)}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,&quot;vtkOpenGLViewNodeFactory&quot;),extend:sn};function cn(e,t){t.classHierarchy.push(&quot;vtkOpenGLCamera&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,[&quot;context&quot;,&quot;keyMatrixTime&quot;]),cn(e,t)}));rn(&quot;vtkCamera&quot;,dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderer&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn(&quot;No lights are on, creating one.&quot;),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();t.context.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,[&quot;shaderCache&quot;]),At(e,t,[&quot;selector&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),fn(e,t)}),&quot;vtkOpenGLRenderer&quot;);function hn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor&quot;),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkRenderer&quot;,mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor2D&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn(&quot;vtkActor&quot;,yn);const bn={context:null,activeTextures:null};const xn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function Dn(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function En(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn(&quot;vtkActor2D&quot;,xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn=&quot;\\\\s*([+-]?\\\\d+)\\\\s*&quot;,Jn=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*&quot;,er=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*&quot;,tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\\\(${Qn},${Qn},${Qn}\\\\)$`),rr=new RegExp(`^rgb\\\\(${er},${er},${er}\\\\)$`),or=new RegExp(`^rgba\\\\(${Qn},${Qn},${Qn},${Jn}\\\\)$`),ar=new RegExp(`^rgba\\\\(${er},${er},${er},${Jn}\\\\)$`),ir=new RegExp(`^hsl\\\\(${Jn},${er},${er}\\\\)$`),sr=new RegExp(`^hsla\\\\(${Jn},${er},${er},${Jn}\\\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+&quot;&quot;).trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):&quot;transparent&quot;===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?&quot;rgb(&quot;:&quot;rgba(&quot;}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?&quot;)&quot;:`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?&quot;0&quot;:&quot;&quot;)+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?&quot;hsl(&quot;:&quot;hsla(&quot;}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?&quot;)&quot;:`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Dr=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+&quot;&quot;}}return r.gamma=e,r}(1);function Er(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+&quot;&quot;}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&&quot;object&quot;==typeof e||(e={}),null!==t&&&quot;object&quot;==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Er((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Er((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,Fr=new RegExp(_r.source,&quot;g&quot;);function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+=&quot;&quot;,t+=&quot;&quot;;(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+&quot;&quot;}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join(&quot;&quot;)})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||&quot;boolean&quot;===r?Rr(t):(&quot;number&quot;===r?Br:&quot;string&quot;===r?(n=dr(t))?(t=n,Dr):kr:t instanceof dr?Dr:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:&quot;function&quot;!=typeof t.valueOf&&&quot;function&quot;!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error(&quot;invalid format: &quot;+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?&quot; &quot;:e.fill+&quot;&quot;,this.align=void 0===e.align?&quot;>&quot;:e.align+&quot;&quot;,this.sign=void 0===e.sign?&quot;-&quot;:e.sign+&quot;&quot;,this.symbol=void 0===e.symbol?&quot;&quot;:e.symbol+&quot;&quot;,this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?&quot;&quot;:e.type+&quot;&quot;}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf(&quot;e&quot;))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1];return o<0?&quot;0.&quot;+new Array(-o).join(&quot;0&quot;)+r:r.length>o+1?r.slice(0,o+1)+&quot;.&quot;+r.slice(o+1):r+new Array(o-r.length+2).join(&quot;0&quot;)}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?&quot;0&quot;:&quot;&quot;)+(void 0===this.width?&quot;&quot;:Math.max(1,0|this.width))+(this.comma?&quot;,&quot;:&quot;&quot;)+(void 0===this.precision?&quot;&quot;:&quot;.&quot;+Math.max(0,0|this.precision))+(this.trim?&quot;~&quot;:&quot;&quot;)+this.type};var ao={&quot;%&quot;:(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+&quot;&quot;,d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString(&quot;en&quot;).replace(/,/g,&quot;&quot;):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join(&quot;0&quot;):a>0?r.slice(0,a)+&quot;.&quot;+r.slice(a):&quot;0.&quot;+new Array(1-a).join(&quot;0&quot;)+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=[&quot;y&quot;,&quot;z&quot;,&quot;a&quot;,&quot;f&quot;,&quot;p&quot;,&quot;n&quot;,&quot;\u00b5&quot;,&quot;m&quot;,&quot;&quot;,&quot;k&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;,&quot;Z&quot;,&quot;Y&quot;];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?&quot;,f&quot;:r)).type){case&quot;s&quot;:var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case&quot;&quot;:case&quot;e&quot;:case&quot;g&quot;:case&quot;p&quot;:case&quot;r&quot;:null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-(&quot;e&quot;===r.type));break;case&quot;f&quot;:case&quot;%&quot;:null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*(&quot;%&quot;===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+&quot;&quot;,function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?&quot;&quot;:e.currency[0]+&quot;&quot;,a=void 0===e.currency?&quot;&quot;:e.currency[1]+&quot;&quot;,i=void 0===e.decimal?&quot;.&quot;:e.decimal+&quot;&quot;,s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?&quot;%&quot;:e.percent+&quot;&quot;,c=void 0===e.minus?&quot;\u2212&quot;:e.minus+&quot;&quot;,u=void 0===e.nan?&quot;NaN&quot;:e.nan+&quot;&quot;;function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;&quot;n&quot;===y?(m=!0,y=&quot;g&quot;):ao[y]||(void 0===h&&(h=12),v=!0,y=&quot;g&quot;),(f||&quot;0&quot;===t&&&quot;=&quot;===n)&&(f=!0,t=&quot;0&quot;,n=&quot;=&quot;);var T=&quot;$&quot;===p?o:&quot;#&quot;===p&&/[boxX]/.test(y)?&quot;0&quot;+y.toLowerCase():&quot;&quot;,b=&quot;$&quot;===p?a:/[%p]/.test(y)?l:&quot;&quot;,x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if(&quot;c&quot;===y)S=x(e)+S,e=&quot;&quot;;else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case&quot;.&quot;:o=t=r;break;case&quot;0&quot;:0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&&quot;+&quot;!==d&&(A=!1),p=(A?&quot;(&quot;===d?d:c:&quot;-&quot;===d||&quot;(&quot;===d?&quot;&quot;:d)+p,S=(&quot;s&quot;===y?po[8+Qr/3]:&quot;&quot;)+S+(A&&&quot;(&quot;===d?&quot;)&quot;:&quot;&quot;),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):&quot;&quot;;switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=&quot;&quot;),n){case&quot;<&quot;:e=p+e+S+w;break;case&quot;=&quot;:e=p+w+e+S;break;case&quot;^&quot;:e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+&quot;&quot;},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type=&quot;f&quot;,e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:&quot;,&quot;,grouping:[3],currency:[&quot;$&quot;,&quot;&quot;]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Do,ceil:Eo,min:Vo,max:Lo}=Math;const Bo=Ao(&quot;ceilLog2&quot;),No=Ao(&quot;factorial&quot;);function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao(&quot;gaussian&quot;);function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes(&quot;e&quot;))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split(&quot;e&quot;);let r=&quot;&quot;;return+n[1]+t>0&&(r=&quot;+&quot;),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co(&quot;vtkMath::Jacobi: Error extracting eigenfunctions&quot;),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co(&quot;Unable to factor linear system&quot;),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co(&quot;Unable to factor linear system&quot;),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Da(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Ea=Ao(&quot;GetScalarTypeFittingRange&quot;),Va=Ao(&quot;GetAdjustedScalarRange&quot;);const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Do,ceil:Eo,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo(&quot;Number of columns of A must match number of rows of B.&quot;);const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co(&quot;Matrix has 0 determinant&quot;),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co(&quot;Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()&quot;),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Da,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Ea,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;#&quot;;return`${t}${e.map(Ga).join(&quot;&quot;)}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(&quot;, &quot;)})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};const Wa=1e-6,Ha=&quot;coincide&quot;,ja=&quot;disjoint&quot;;function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?&quot;x&quot;:i[1]>i[2]?&quot;y&quot;:&quot;z&quot;;const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case&quot;x&quot;:l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case&quot;y&quot;:l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case&quot;z&quot;:l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha};function Ja(e,t){t.classHierarchy.push(&quot;vtkPlane&quot;),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}const ei={normal:[0,0,1],origin:[0,0,0]};function ti(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ei,n),jt.obj(e,t),jt.setGetArray(e,t,[&quot;normal&quot;,&quot;origin&quot;],3),Ja(e,t)}var ni={newInstance:jt.newInstance(ti,&quot;vtkPlane&quot;),extend:ti,...Qa};const ri=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function oi(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ai(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ii(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function si(e){return ii(e,ri)}function li(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function ci(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)li(e,...t[n]);else for(let n=0;n<t.length;n+=3)li(e,...t.slice(n,n+3));return e}function ui(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function fi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function gi(e,t,n,r){return!!ai(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function mi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function hi(e,t){return e[2*t+1]-e[2*t]}function vi(e){return[hi(e,0),hi(e,1),hi(e,2)]}function yi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function bi(e){return e.slice(4,6)}function xi(e){const t=vi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function Ci(e){if(ai(e)){const t=vi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Si(e){return[e[0],e[2],e[4]]}function Ai(e){return[e[1],e[3],e[5]]}function Ii(e,t){return e<=0&&t>=0||e>=0&&t<=0}function wi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Pi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=wi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return si(n),ci(n,r)}function Ri(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Mi(e,t,n,r){const o=[].concat(ri),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Di(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ni.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!ai(e)||!ai(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Li(e,t){if(!ai(e)||!ai(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Bi(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Ni(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ni.evaluate(n,t,l)}let i=2;for(;i--&&!(Ii(o[r[i][0]],o[r[i][4]])&&Ii(o[r[i][1]],o[r[i][5]])&&Ii(o[r[i][2]],o[r[i][6]])&&Ii(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class _i{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ri))}getBounds(){return this.bounds}equals(e){return oi(this.bounds,e)}isValid(){return ai(this.bounds)}setBounds(e){return ii(this.bounds,e)}reset(){return si(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return li(this.bounds,...t)}addPoints(e){return ci(this.bounds,e)}addBounds(e,t,n,r,o,a){return ui(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return di(this.bounds,e,t,n)}setMaxPoint(e,t,n){return pi(this.bounds,e,t,n)}inflate(e){return fi(this.bounds,e)}scale(e,t,n){return gi(this.bounds,e,t,n)}getCenter(){return mi(this.bounds)}getLength(e){return hi(this.bounds,e)}getLengths(){return vi(this.bounds)}getMaxLength(){return xi(this.bounds)}getDiagonalLength(){return Ci(this.bounds)}getMinPoint(){return Si(this.bounds)}getMaxPoint(){return Ai(this.bounds)}getXRange(){return yi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return bi(this.bounds)}getCorners(e){return wi(this.bounds,e)}computeCornerPoints(e,t){return Pi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Mi(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Ri(this.bounds,e)}cutWithPlane(e,t){return Ni(this.bounds,e,t)}intersectBox(e,t,n,r){return Di(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Li(this.bounds,e)}containsPoint(e,t,n){return Bi(this.bounds,e,t,n)}contains(e){return Li(this.bounds,e)}}var Fi,ki={newInstance:function(e){const t=e&&e.bounds;return new _i(t)},equals:oi,isValid:ai,setBounds:ii,reset:si,addPoint:li,addPoints:ci,addBounds:ui,setMinPoint:di,setMaxPoint:pi,inflate:fi,scale:gi,scaleAboutCenter:function(e,t,n,r){if(!ai(e))return!1;const o=mi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],gi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:mi,getLength:hi,getLengths:vi,getMaxLength:xi,getDiagonalLength:Ci,getMinPoint:Si,getMaxPoint:Ai,getXRange:yi,getYRange:Ti,getZRange:bi,getCorners:wi,computeCornerPoints:Pi,computeLocalBounds:Mi,transformBounds:Oi,computeScale3:Ri,cutWithPlane:Ni,intersectBox:Di,intersectPlane:Ei,intersect:Vi,intersects:Li,containsPoint:Bi,contains:function(e,t){return!!Li(e,t)&&!!Bi(e,...Si(t))&&!!Bi(e,...Ai(t))},INIT_BOUNDS:ri};function Gi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Ui(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function zi(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function Wi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Fi=new i(4),i!=Float32Array&&(Fi[0]=0,Fi[1]=0,Fi[2]=0,Fi[3]=0);var Hi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),Ui(),Ui(),ie();var ji={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Ki}=ji;function $i(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function qi(e,t){t.classHierarchy.push(&quot;vtkProp&quot;),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=$i(&quot;pick&quot;),e.hasKey=$i(&quot;hasKey&quot;),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Ki.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Ki.DISPLAY)}const Xi={allocatedRenderTime:10,coordinateSystem:Ki.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function Yi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xi,n),jt.obj(e,t),jt.get(e,t,[&quot;estimatedRenderTime&quot;,&quot;allocatedRenderTime&quot;]),jt.setGet(e,t,[&quot;_parentProp&quot;,&quot;coordinateSystem&quot;,&quot;dragable&quot;,&quot;pickable&quot;,&quot;renderTimeMultiplier&quot;,&quot;useBounds&quot;,&quot;visibility&quot;]),jt.moveToProtected(e,t,[&quot;parentProp&quot;]),qi(e,t)}var Zi={newInstance:jt.newInstance(Yi,&quot;vtkProp&quot;),extend:Yi,...ji};function Qi(e,t){t.classHierarchy.push(&quot;vtkProp3D&quot;),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Ui();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=Ui();zi(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>ki.getCenter(t.bounds),e.getLength=()=>ki.getLength(t.bounds),e.getXRange=()=>ki.getXRange(t.bounds),e.getYRange=()=>ki.getYRange(t.bounds),e.getZRange=()=>ki.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const Ji={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Zi.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,[&quot;bounds&quot;,&quot;isIdentity&quot;]),jt.getArray(e,t,[&quot;orientation&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;position&quot;,&quot;scale&quot;],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,Qi(e,t)}var ts={newInstance:jt.newInstance(es,&quot;vtkProp3D&quot;),extend:es};const ns={FLAT:0,GOURAUD:1,PHONG:2},rs={POINTS:0,WIREFRAME:1,SURFACE:2};var os={Shading:ns,Representation:rs,Interpolation:ns};const{Representation:as,Interpolation:is}=os;function ss(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ls(e,t){t.classHierarchy.push(&quot;vtkProperty&quot;),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ss(&quot;ComputeCompositeColor&quot;),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ss(&quot;AddShaderVariable&quot;),e.setInterpolationToFlat=()=>e.setInterpolation(is.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(is.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(is.PHONG),e.getInterpolationAsString=()=>jt.enumToString(is,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(as.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(as.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(as.POINTS),e.getRepresentationAsString=()=>jt.enumToString(as,t.representation)}const cs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:is.GOURAUD,representation:as.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function us(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cs,n),jt.obj(e,t),jt.setGet(e,t,[&quot;lighting&quot;,&quot;interpolation&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;metallic&quot;,&quot;roughness&quot;,&quot;normalStrength&quot;,&quot;emission&quot;,&quot;baseIOR&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;opacity&quot;,&quot;edgeVisibility&quot;,&quot;lineWidth&quot;,&quot;pointSize&quot;,&quot;backfaceCulling&quot;,&quot;frontfaceCulling&quot;,&quot;representation&quot;,&quot;diffuseTexture&quot;,&quot;metallicTexture&quot;,&quot;roughnessTexture&quot;,&quot;normalTexture&quot;,&quot;ambientOcclusionTexture&quot;,&quot;emissionTexture&quot;]),jt.setGetArray(e,t,[&quot;ambientColor&quot;,&quot;specularColor&quot;,&quot;diffuseColor&quot;,&quot;edgeColor&quot;],3),ls(e,t)}var ds={newInstance:jt.newInstance(us,&quot;vtkProperty&quot;),extend:us,...os};const{vtkDebugMacro:ps}=jt;function fs(e,t){t.classHierarchy.push(&quot;vtkActor&quot;);const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ds.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){ps(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.concat();const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const gs={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gs,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;backfaceProperty&quot;,&quot;forceOpaque&quot;,&quot;forceTranslucent&quot;,&quot;mapper&quot;]),fs(e,t)}var hs={newInstance:jt.newInstance(ms,&quot;vtkActor&quot;),extend:ms};const vs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},ys={VOID:&quot;&quot;,CHAR:&quot;Int8Array&quot;,SIGNED_CHAR:&quot;Int8Array&quot;,UNSIGNED_CHAR:&quot;Uint8Array&quot;,SHORT:&quot;Int16Array&quot;,UNSIGNED_SHORT:&quot;Uint16Array&quot;,INT:&quot;Int32Array&quot;,UNSIGNED_INT:&quot;Uint32Array&quot;,FLOAT:&quot;Float32Array&quot;,DOUBLE:&quot;Float64Array&quot;};var Ts={DefaultDataType:ys.FLOAT,DataTypeByteSize:vs,VtkDataTypes:ys};const{vtkErrorMacro:bs}=Kt,{DefaultDataType:xs}=Ts,Cs=1e-6;function Ss(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function As(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ss(r,0,1)}return Ss(e,t<0?0:t,n)}function Is(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function ws(e){return Object.prototype.toString.call(e).slice(8,-1)}const Ps={computeRange:As,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ss,getDataType:ws,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Os(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push(&quot;vtkDataArray&quot;),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=As(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Cs;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Ds({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=ws(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||bs(&quot;numberOfComponents must match&quot;);const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Rs={name:&quot;&quot;,numberOfComponents:1,dataType:xs,rangeTuple:[0,0]};function Ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Rs,n),!t.empty&&!t.values&&!t.size)throw new TypeError(&quot;Cannot create vtkDataArray object without: size > 0, values&quot;);if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=ws(t.values)),yt(e,t),St(e,t,[&quot;name&quot;,&quot;numberOfComponents&quot;]),t.size%t.numberOfComponents!=0)throw new RangeError(&quot;model.size is not a multiple of model.numberOfComponents&quot;);Os(e,t)}const Ds=Et(Ms,&quot;vtkDataArray&quot;);var Es={newInstance:Ds,extend:Ms,...Ps,...Ts};function Vs(e,t){t.classHierarchy.push(&quot;vtkAbstractMapper&quot;),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA(&quot;vtkPlane&quot;)&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Ls={clippingPlanes:[]};var Bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ls,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),Vs(e,t)};function Ns(e,t){e.getBounds=()=>(jt.vtkErrorMacro(&quot;vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED&quot;),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=ki.isValid(n)?ki.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return ki.getDiagonalLength(t)}}const _s=e=>({bounds:[...ki.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var Fs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_s(n)),Bs(e,t,n),jt.setGet(e,t,[&quot;viewSpecificProperties&quot;]),Ns(e,t)};const{vtkErrorMacro:ks,vtkWarningMacro:Gs}=jt;function Us(e,t){t.classHierarchy.push(&quot;vtkFieldData&quot;);const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>&quot;number&quot;==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():&quot;&quot;},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else ks(&quot;Unhandled case in passData&quot;);else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Es.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Gs(&quot;Unexpected case in interpolateData&quot;)}else t.insertTuples(s.getTuples());else ks(&quot;Unhandled case in interpolateData&quot;);else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Es.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const zs={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Ws(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zs,n),jt.obj(e,t),Us(e,t)}var Hs={newInstance:jt.newInstance(Ws,&quot;vtkFieldData&quot;),extend:Ws};const js={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ks={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:js,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:&quot;vtkGhostType&quot;};const{AttributeTypes:$s,AttributeCopyOperations:qs}=Ks,{vtkWarningMacro:Xs}=jt;function Ys(e,t){const n=[&quot;Scalars&quot;,&quot;Vectors&quot;,&quot;Normals&quot;,&quot;TCoords&quot;,&quot;Tensors&quot;,&quot;GlobalIds&quot;,&quot;PedigreeIds&quot;];function r(e){let t=n.find((t=>$s[t.toUpperCase()]===e||&quot;number&quot;!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push(&quot;vtkDataSetAttributes&quot;);const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&&quot;PEDIGREEIDS&quot;===a.toUpperCase()&&!n.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if(&quot;PEDIGREEIDS&quot;!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(qs).filter((e=>&quot;ALLCOPY&quot;!==e)).forEach((e=>{t.copyAttributeFlags[qs[e]]=Object.keys($s).filter((e=>&quot;NUM_ATTRIBUTES&quot;!==e)).reduce(((e,t)=>(e[$s[t]]=!0,e)),[])})),t.copyAttributeFlags[qs.COPYTUPLE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.INTERPOLATE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.COPYTUPLE][$s.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||&quot;vtkDataArray&quot;!==t.dataArrays[n].type||e.addArray(Es.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const Zs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Qs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zs,n),Hs.extend(e,t,n),jt.setGet(e,t,[&quot;activeScalars&quot;,&quot;activeNormals&quot;,&quot;activeTCoords&quot;,&quot;activeVectors&quot;,&quot;activeTensors&quot;,&quot;activeGlobalIds&quot;,&quot;activePedigreeIds&quot;]),t.arrays||(t.arrays={}),Ys(e,t)}var Js={newInstance:jt.newInstance(Qs,&quot;vtkDataSetAttributes&quot;),extend:Qs,...Ks};const el=[&quot;pointData&quot;,&quot;cellData&quot;,&quot;fieldData&quot;];function tl(e,t){t.classHierarchy.push(&quot;vtkDataSet&quot;),el.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Js.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),el.forEach((n=>{t[n]=Js.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const nl={};function rl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nl,n),jt.obj(e,t),jt.setGet(e,t,el),tl(e,t)}var ol={newInstance:jt.newInstance(rl,&quot;vtkDataSet&quot;),extend:rl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const al={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var il={StructuredType:al};const{StructuredType:sl}=il;var ll={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?sl.EMPTY:3===t?sl.XYZ_GRID:2===t?e[0]===e[1]?sl.YZ_PLANE:e[2]===e[3]?sl.XZ_PLANE:sl.XY_PLANE:1===t?e[0]<e[1]?sl.X_LINE:e[2]<e[3]?sl.Y_LINE:sl.Z_LINE:sl.SINGLE_POINT},...il};const{vtkErrorMacro:cl}=jt;function ul(e,t){t.classHierarchy.push(&quot;vtkImageData&quot;),e.setExtent=function(){if(t.deleted)return cl(&quot;instance deleted - cannot call any method&quot;),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=ll.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)cl(&quot;instance deleted - cannot call any method&quot;);else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void cl(&quot;Bad dimension specification&quot;);n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return cl(&quot;Requesting a point from an empty image.&quot;),null;const o=new Float64Array(3);switch(t.dataDescription){case al.EMPTY:return null;case al.SINGLE_POINT:break;case al.X_LINE:o[0]=n;break;case al.Y_LINE:o[1]=n;break;case al.Z_LINE:o[2]=n;break;case al.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case al.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case al.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case al.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:cl(&quot;Invalid dataDescription&quot;)}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>ki.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>ki.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>ki.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];ki.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Da(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Da(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return cl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return cl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const dl={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:al.EMPTY};function pl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dl,n),ol.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,[&quot;indexToWorld&quot;,&quot;worldToIndex&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;spacing&quot;],3),jt.setGetArray(e,t,[&quot;direction&quot;],9),jt.getArray(e,t,[&quot;extent&quot;],6),ul(e,t)}var fl={newInstance:jt.newInstance(pl,&quot;vtkImageData&quot;),extend:pl};const gl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var ml={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:gl},hl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:vl,VectorMode:yl}=ml,{VtkDataTypes:Tl}=Es,{ColorMode:bl}=hl,{vtkErrorMacro:xl}=jt;function Cl(e){return e}function Sl(e){return Math.floor(255*e+.5)}function Al(e,t){t.classHierarchy.push(&quot;vtkScalarsToColors&quot;),e.setVectorModeToMagnitude=()=>e.setVectorMode(yl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(yl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(yl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)xl(&quot;Values and annotations do not have the same number of tuples so ignoring&quot;);else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===bl.DEFAULT&&t.getDataType()===Tl.UNSIGNED_CHAR||n===bl.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:&quot;vtkDataArray&quot;,name:&quot;temp&quot;,numberOfComponents:4,dataType:Tl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Es.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,vl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,vl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===yl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==yl.MAGNITUDE||1!==c&&1!==s||(i=yl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case yl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case yl.RGBCOLORS:break;case yl.MAGNITUDE:default:{const o=Es.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Sl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Tl.UNSIGNED_CHAR)return n;const i=Es.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Tl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=Cl;switch(n.getDataType()!==Tl.FLOAT&&n.getDataType()!==Tl.DOUBLE||(s=Sl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return xl(&quot;Cannot convert colors&quot;),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==bl.DEFAULT||n.getDataType()!==Tl.UNSIGNED_CHAR)&&r!==bl.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Il={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:yl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function wl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Il,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,[&quot;vectorSize&quot;,&quot;vectorComponent&quot;,&quot;vectorMode&quot;,&quot;alpha&quot;,&quot;indexedLookup&quot;]),jt.setArray(e,t,[&quot;mappingRange&quot;],2),jt.getArray(e,t,[&quot;mappingRange&quot;]),Al(e,t)}var Pl={newInstance:jt.newInstance(wl,&quot;vtkScalarsToColors&quot;),extend:wl,...ml};const{vtkErrorMacro:Ol}=jt;function Rl(e,t){t.classHierarchy.push(&quot;vtkLookupTable&quot;),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Ol(&quot;Expected 4 components for RGBA colors&quot;),!1;if(n.getDataType()!==ys.UNSIGNED_CHAR)return Ol(&quot;Expected unsigned char values for RGBA colors&quot;),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ml={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Dl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ml,n),Pl.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,[&quot;buildTime&quot;]),jt.setGet(e,t,[&quot;numberOfColors&quot;,&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;]),jt.setArray(e,t,[&quot;alphaRange&quot;,&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;],2),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;,&quot;alphaRange&quot;,&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),Rl(e,t)}var El={newInstance:jt.newInstance(Dl,&quot;vtkLookupTable&quot;),extend:Dl};let Vl=1,Ll=0;const Bl=[&quot;VTK_RESOLVE_OFF&quot;,&quot;VTK_RESOLVE_POLYGON_OFFSET&quot;];function Nl(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;Ll=e}var _l={getResolveCoincidentTopologyAsString:function(){return Bl[Ll]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Vl},getResolveCoincidentTopology:function(){return Ll},setResolveCoincidentTopology:Nl,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){Vl=e},setResolveCoincidentTopologyToDefault:function(){Nl(0)},setResolveCoincidentTopologyToOff:function(){Nl(0)},setResolveCoincidentTopologyToPolygonOffset:function(){Nl(1)}};function Fl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=(e,r)=>{t[n.key]={factor:e,offset:r}}}))}const kl=[&quot;Polygon&quot;,&quot;Line&quot;,&quot;Point&quot;],Gl={};Fl(Gl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},kl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Ul={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,[&quot;resolveCoincidentTopology&quot;]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(_l).forEach((t=>{e[t]=_l[t]})),Object.keys(Gl).forEach((t=>{e[t]=Gl[t]})),Fl(e,t.topologyOffset,kl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=Gl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:Gl,otherStaticMethods:_l,CATEGORIES:kl};const zl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Wl={PassTypes:zl};const{FieldAssociations:Hl}=ol,{staticOffsetAPI:jl,otherStaticMethods:Kl}=Ul,{ColorMode:$l,ScalarMode:ql,GetArray:Xl}=hl,{VectorMode:Yl}=ml,{VtkDataTypes:Zl}=Es;function Ql(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Jl(e,t){t.classHierarchy.push(&quot;vtkMapper&quot;),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString($l,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(ql,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===ql.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===ql.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===ql.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===ql.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_FIELD_DATA){const t=e.getFieldData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==a){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(n))e.mapScalarsToTexture(o,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},e.scalarToTextureCoordinate=(e,t,n)=>{let r=.5,o=1;return _a(e)||(o=.49,r=(e-t)*n,r>1e3?r=1e3:r<-1e3&&(r=-1e3)),{texCoordS:r,texCoordT:o}},e.createColorTextureCoordinates=(t,n,r,o,a,i,s,l,c)=>{const u=(i[1]-i[0])/l,d=[];d[0]=i[0]-u,d[1]=i[1]+u;const p=1/(d[1]-d[0]),f=n.getData(),g=t.getData();let m=0,h=0;if(a<0||a>=o)for(let t=0;t<r;++t){let t=0;for(let e=0;e<o;++e)t+=g[m]*g[m],m++;let n=Math.sqrt(t);c&&(n=El.applyLogScale(n,s,i));const r=e.scalarToTextureCoordinate(n,d[0],p);f[h]=r.texCoordS,f[h+1]=r.texCoordT,h+=2}else{m+=a;for(let t=0;t<r;++t){let t=g[m];c&&(t=El.applyLogScale(t,s,i));const n=e.scalarToTextureCoordinate(t,d[0],p);f[h]=n.texCoordS,f[h+1]=n.texCoordT,h+=2,m+=o}}},e.mapScalarsToTexture=(n,r)=>{const o=t.lookupTable.getRange(),a=t.lookupTable.usingLogScale();a&&El.getLogRange(o,o);const i=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==r){t.lookupTable.setAlpha(r),t.colorTextureMap=null,t.lookupTable.build();let e=t.lookupTable.getNumberOfAvailableColors();e>4094&&(e=4094),e<64&&(e=64),e+=2;const n=(o[1]-o[0])/(e-2),s=new Float64Array(2*e);for(let t=0;t<e;++t)s[t]=o[0]+t*n-n/2,a&&(s[t]=10**s[t]);for(let t=0;t<e;++t)s[t+e]=NaN;t.colorTextureMap=fl.newInstance(),t.colorTextureMap.setExtent(0,e-1,0,1,0,0);const l=Es.newInstance({numberOfComponents:1,values:s});t.colorTextureMap.getPointData().setScalars(t.lookupTable.mapScalars(l,t.colorMode,0)),t.lookupTable.setAlpha(i)}if(!t.colorCoordinates||e.getMTime()>t.colorCoordinates.getMTime()||e.getInputData(0).getMTime()>t.colorCoordinates.getMTime()||t.lookupTable.getMTime()>t.colorCoordinates.getMTime()){t.colorCoordinates=null;const r=n.getNumberOfComponents(),i=n.getNumberOfTuples();t.colorCoordinates=Es.newInstance({numberOfComponents:2,values:new Float32Array(2*i)});let s=t.lookupTable.getVectorComponent();t.lookupTable.getVectorMode()===Yl.MAGNITUDE&&n.getNumberOfComponents()>1&&(s=-1),e.createColorTextureCoordinates(n,t.colorCoordinates,i,r,s,o,t.lookupTable.getRange(),t.colorTextureMap.getPointData().getScalars().getNumberOfTuples()/2-2,a)}},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=n=>{if(!t.interpolateScalarsBeforeMapping)return!1;if(t.lookupTable&&t.lookupTable.getIndexedLookup())return!1;const r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName),o=r.scalars;return!(!o||r.cellFlag||t.colorMode===$l.DEFAULT&&o.getDataType()===Zl.UNSIGNED_CHAR||t.colorMode===$l.DIRECT_SCALARS)},e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=Ql(&quot;AcquireInvertibleLookupTable&quot;),e.valueToColor=Ql(&quot;ValueToColor&quot;),e.colorToValue=Ql(&quot;ColorToValue&quot;),e.useInvertibleColorFor=Ql(&quot;UseInvertibleColorFor&quot;),e.clearInvertibleColor=Ql(&quot;ClearInvertibleColor&quot;),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(zl.ID_LOW24),o=e.getRawPixelBuffer(zl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Hl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Hl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===zl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(zl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===zl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t],n*=256,n+=r[t+1],n*=256,n+=r[t+2];const a=s[n];e.getPixelBuffer(zl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const ec={colorMapColors:null,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function tc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ec,n),Fs(e,t,n),jt.get(e,t,[&quot;colorCoordinates&quot;,&quot;colorMapColors&quot;,&quot;colorTextureMap&quot;,&quot;selectionWebGLIdsToVTKIds&quot;]),jt.setGet(e,t,[&quot;colorByArrayName&quot;,&quot;arrayAccessMode&quot;,&quot;colorMode&quot;,&quot;fieldDataTupleId&quot;,&quot;interpolateScalarsBeforeMapping&quot;,&quot;lookupTable&quot;,&quot;populateSelectionSettings&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;useLookupTableScalarRange&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),Ul.implementCoincidentTopologyMethods(e,t),Jl(e,t)}var nc={newInstance:jt.newInstance(tc,&quot;vtkMapper&quot;),extend:tc,...jl,...Kl,...hl};function rc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function oc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const ac={extractCellSizes:rc,getNumberOfCells:oc};function ic(e,t){t.classHierarchy.push(&quot;vtkCellArray&quot;);const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=oc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=rc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function sc(e){return{empty:!0,numberOfComponents:1,dataType:ys.UNSIGNED_INT,...e}}function lc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Es.extend(e,t,sc(n)),ic(e,t)}var cc={newInstance:jt.newInstance(lc,&quot;vtkCellArray&quot;),extend:lc,...ac};const{vtkErrorMacro:uc}=jt,dc=[1,-1,1,-1,1,-1];function pc(e,t){t.classHierarchy.push(&quot;vtkPoints&quot;),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return uc(`getBounds called on an array with components of\\n        ${e.getNumberOfComponents()}`),dc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const fc={empty:!0,numberOfComponents:3,dataType:ys.FLOAT,bounds:[1,-1,1,-1,1,-1]};function gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fc,n),Es.extend(e,t,n),pc(e,t)}var mc={newInstance:jt.newInstance(gc,&quot;vtkPoints&quot;),extend:gc};function hc(e,t){t.classHierarchy.push(&quot;vtkCell&quot;),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro(&quot;vtkCell.evaluatePosition is not implemented.&quot;)}}const vc={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function yc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vc,n),jt.obj(e,t),t.points||(t.points=mc.newInstance()),jt.get(e,t,[&quot;points&quot;,&quot;pointsIds&quot;]),hc(e,t)}var Tc={newInstance:jt.newInstance(yc,&quot;vtkCell&quot;),extend:yc};function bc(e,t){t.classHierarchy.push(&quot;vtkCellLinks&quot;),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA(&quot;vtkPolyData&quot;)){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Tc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Tc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const xc={array:null,maxId:0,extend:0};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),jt.obj(e,t),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,&quot;vtkCellLinks&quot;),extend:Cc};const Ac=0,Ic=1,wc=2,Pc=3,Oc=4,Rc=5,Mc=6,Dc=7,Ec=9,Vc=21,Lc=41,Bc=42,Nc=[&quot;vtkEmptyCell&quot;,&quot;vtkVertex&quot;,&quot;vtkPolyVertex&quot;,&quot;vtkLine&quot;,&quot;vtkPolyLine&quot;,&quot;vtkTriangle&quot;,&quot;vtkTriangleStrip&quot;,&quot;vtkPolygon&quot;,&quot;vtkPixel&quot;,&quot;vtkQuad&quot;,&quot;vtkTetra&quot;,&quot;vtkVoxel&quot;,&quot;vtkHexahedron&quot;,&quot;vtkWedge&quot;,&quot;vtkPyramid&quot;,&quot;vtkPentagonalPrism&quot;,&quot;vtkHexagonalPrism&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkQuadraticEdge&quot;,&quot;vtkQuadraticTriangle&quot;,&quot;vtkQuadraticQuad&quot;,&quot;vtkQuadraticTetra&quot;,&quot;vtkQuadraticHexahedron&quot;,&quot;vtkQuadraticWedge&quot;,&quot;vtkQuadraticPyramid&quot;,&quot;vtkBiQuadraticQuad&quot;,&quot;vtkTriQuadraticHexahedron&quot;,&quot;vtkQuadraticLinearQuad&quot;,&quot;vtkQuadraticLinearWedge&quot;,&quot;vtkBiQuadraticQuadraticWedge&quot;,&quot;vtkBiQuadraticQuadraticHexahedron&quot;,&quot;vtkBiQuadraticTriangle&quot;,&quot;vtkCubicLine&quot;,&quot;vtkQuadraticPolygon&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkConvexPointSet&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkParametricCurve&quot;,&quot;vtkParametricSurface&quot;,&quot;vtkParametricTriSurface&quot;,&quot;vtkParametricQuadSurface&quot;,&quot;vtkParametricTetraRegion&quot;,&quot;vtkParametricHexRegion&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkHigherOrderEdge&quot;,&quot;vtkHigherOrderTriangle&quot;,&quot;vtkHigherOrderQuad&quot;,&quot;vtkHigherOrderPolygon&quot;,&quot;vtkHigherOrderTetrahedron&quot;,&quot;vtkHigherOrderWedge&quot;,&quot;vtkHigherOrderPyramid&quot;,&quot;vtkHigherOrderHexahedron&quot;],_c={getClassNameFromTypeId:function(e){return e<Nc.length?Nc[e]:&quot;UnknownClass&quot;},getTypeIdFromClassName:function(e){return Nc.findIndex(e)},isLinear:function(e){return e<Vc||e===Lc||e===Bc},hasSubCells:function(e){return e===Mc||e===Oc||e===wc}};function Fc(e,t){t.classHierarchy.push(&quot;vtkCellTypes&quot;),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Ac},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const kc={size:0,maxId:-1,extend:1e3};function Gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kc,n),jt.obj(e,t),jt.get(e,t,[&quot;size&quot;,&quot;maxId&quot;,&quot;extend&quot;]),jt.getArray(e,t,[&quot;typeArray&quot;,&quot;locationArray&quot;]),Fc(e,t)}var Uc={newInstance:jt.newInstance(Gc,&quot;vtkCellTypes&quot;),extend:Gc,..._c},zc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Wc}=zc;function Hc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Hc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Wc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Wc.YES_INTERSECTION:Wc.NO_INTERSECTION}const Kc={distanceToLine:Hc,intersection:jc};function $c(e,t){t.classHierarchy.push(&quot;vtkLine&quot;),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Wc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Hc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Hc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Hc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Hc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const qc={orientations:null};function Xc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qc,n),Tc.extend(e,t,n),jt.setGet(e,t,[&quot;orientations&quot;]),$c(e,t)}var Yc={newInstance:jt.newInstance(Xc,&quot;vtkLine&quot;),extend:Xc,...Kc,...zc};function Zc(e,t){t.classHierarchy.push(&quot;vtkPointSet&quot;),t.points?t.points=We(t.points):t.points=mc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=mc.newInstance(),t.points.shallowCopy(e.getPoints())}}const Qc={};function Jc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qc,n),ol.extend(e,t,n),jt.setGet(e,t,[&quot;points&quot;]),Zc(e,t)}var eu={newInstance:jt.newInstance(Jc,&quot;vtkPointSet&quot;),extend:Jc};function tu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function nu(e,t,n,r){tu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const ru={computeNormalDirection:tu,computeNormal:nu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];nu(e,t,n,d),nu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,D=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ni.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ni.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(D=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[D],P[D]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function ou(e,t){t.classHierarchy.push(&quot;vtkTriangle&quot;),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(nu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ni.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=Yc.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),tu(l,c,u,d),ni.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=Yc.distanceToLine(e,c,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Yc.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Yc.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Yc.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const au={};function iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,au,n),Tc.extend(e,t,n),ou(e,t)}var su={newInstance:jt.newInstance(iu,&quot;vtkTriangle&quot;),extend:iu,...ru};const lu=[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;],{vtkWarningMacro:cu}=jt,uu={[Pc]:Yc,[Oc]:Yc,[Rc]:su};function du(e,t){t.classHierarchy.push(&quot;vtkPolyData&quot;),lu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\\w|[A-Z]|\\b\\w)/g,(e=>e.toUpperCase())).replace(/\\s+/g,&quot;&quot;)}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=cc.newInstance()})),e.getNumberOfCells=()=>lu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),lu.forEach((n=>{t[n]=cc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?wc:Ic,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Oc:Pc,1===t&&cu(&quot;Building VTK_LINE &quot;,n,&quot; with only one point, but VTK_LINE needs at least two points. Check the input.&quot;),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=Rc;break;case 4:l[n]=Ec;break;default:l[n]=Dc}t<3&&cu(&quot;Building VTK_TRIANGLE &quot;,n,&quot; with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.&quot;),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Mc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Uc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Sc.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Ic:case wc:o=t.verts;break;case Pc:case Oc:o=t.lines;break;case Rc:case Ec:case Dc:o=t.polys;break;case Mc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||uu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const pu={};function fu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pu,n),eu.extend(e,t,n),jt.get(e,t,[&quot;cells&quot;,&quot;links&quot;]),jt.setGet(e,t,[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;]),du(e,t)}var gu={newInstance:jt.newInstance(fu,&quot;vtkPolyData&quot;),extend:fu};function mu(e,t){t.classHierarchy.push(&quot;vtkTexture&quot;),e.imageLoaded=()=>{t.image.removeEventListener(&quot;load&quot;,e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener(&quot;load&quot;,e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext(&quot;2d&quot;).getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement(&quot;canvas&quot;);e.width=t.image.width,e.height=t.image.height;const n=e.getContext(&quot;2d&quot;);return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const hu={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hu,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,[&quot;canvas&quot;,&quot;image&quot;,&quot;jsImageData&quot;,&quot;imageLoaded&quot;,&quot;resizable&quot;]),jt.setGet(e,t,[&quot;repeat&quot;,&quot;edgeClamp&quot;,&quot;interpolate&quot;,&quot;mipLevel&quot;]),mu(e,t)}const yu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Tu={newInstance:jt.newInstance(vu,&quot;vtkTexture&quot;),extend:vu,...yu};const bu=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],xu=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Cu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Su=[0,1,0,1,0,1,0,1,2,2,2,2],Au=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Iu=new Float64Array(3),wu=new Float64Array(3),Pu=new Float64Array(3),Ou=new Float64Array(3),Ru=new Float64Array(3),Mu=new Float64Array(3),Du=new Float64Array(16);function Eu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Vu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],Vn(Pu,Iu,r),Pu[0]+=.1,Vn(wu,Pu,o),Pn(Ru,wu,Iu),Pu[0]-=.1,Pu[1]+=.1,Vn(wu,Pu,o),Pn(Mu,wu,Iu);for(let e=0;e<3;e++)Ru[e]/=.05*u[0],Mu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],a[0]<-.5?On(Pu,Ru,a[0]*i-l.width):a[0]>.5?On(Pu,Ru,a[0]*i):On(Pu,Ru,a[0]*i-l.width/2),wn(Iu,Iu,Pu),On(Pu,Mu,a[1]*i-l.height/2),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Pu,Ru,l.width),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Pu,Mu,l.height),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Pu,Ru,l.width),Pn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(Du,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Iu[0]=f[3*u],Iu[1]=f[3*u+1],Iu[2]=f[3*u+2],Vn(Pu,Iu,n),Iu[0]=f[3*u+3],Iu[1]=f[3*u+4],Iu[2]=f[3*u+5],Vn(Ou,Iu,n),Pn(Pu,Pu,Ou);const r=[Pu[0],Pu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Lu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,[&quot;renderable&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;tmActor&quot;,&quot;ticks&quot;]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],Vu(e,t)}),&quot;vtkCubeAxesActorHelper&quot;);function Bu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActor&quot;),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=ki.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Iu[s]=t.dataBounds[a]-.1*r*bu[a][s],Iu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Iu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Pu,Iu,e),Iu[s]=t.dataBounds[a],Vn(Ou,Iu,e),Pn(Pu,Ou,Pu),Mn(Pu,Pu),i=Pu[2]>o,t.camera.getParallelProjection()||(Mn(Ou,Ou),i=Dn(Ou,Pu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Au[t][0]].length+2*r[Au[t][1]].length,a+=r[Au[t][0]].length+r[Au[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Cu[e][0],l[3*u+2]=Cu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Au[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Au[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Su[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=xu[a][e];if(1===n[d]){const e=Su[d],n=3*Cu[d][0],p=3*Cu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Au[a][0]]=.5*(t.dataBounds[2*Au[a][0]]+t.dataBounds[2*Au[a][0]+1]),s[3*l+Au[a][1]]=.5*(t.dataBounds[2*Au[a][1]]+t.dataBounds[2*Au[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[xu[e][t]]++;const a=[],i=[];for(let e=0;e<3;e++){const n=go().domain([t.dataBounds[2*e],t.dataBounds[2*e+1]]);a[e]=n.ticks(5);const r=n.tickFormat(5);i[e]=a[e].map(r)}e.updatePolyData(r,n,a),e.updateTextData(r,n,a,i),(o||t.forceUpdate)&&e.updateTextureAtlas(i)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Eu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Eu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Eu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),ki.setBounds(t.bounds,t.gridActor.getBounds()),ki.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function Nu(e){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...ki.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:12,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},...e}}function _u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nu(n)),hs.extend(e,t,n),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=[&quot;X-Axis&quot;,&quot;Y-Axis&quot;,&quot;Z-Axis&quot;],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.tmTexture=Tu.newInstance(),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=nc.newInstance(),t.polyData=gu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=hs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=gu.newInstance(),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;boundsScaleFactor&quot;,&quot;faceVisibilityAngle&quot;,&quot;gridLines&quot;,&quot;tickLabelPixelOffset&quot;]),jt.setGetArray(e,t,[&quot;dataBounds&quot;],6),jt.setGetArray(e,t,[&quot;axisLabels&quot;],3),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;camera&quot;,&quot;tmTexture&quot;,&quot;textValues&quot;,&quot;textPolyData&quot;,&quot;tickCounts&quot;,&quot;gridActor&quot;]),Bu(e,t)}var Fu={newInstance:jt.newInstance(_u,&quot;vtkCubeAxesActor&quot;),extend:_u,newCubeAxesActorHelper:Lu};function ku(e,t){t.classHierarchy.push(&quot;vtkOpenGLCubeAxesActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gu={};const Uu=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=Fu.newCubeAxesActorHelper(),ku(e,t)}),&quot;vtkOpenGLCubeAxesActor&quot;);rn(&quot;vtkCubeAxesActor&quot;,Uu);const zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Wu={ObjectType:zu};const{ObjectType:Hu}=Wu;function ju(e,t){function n(e){switch(e){case Hu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Hu.TEXTURE_BUFFER:if(&quot;TEXTURE_BUFFER&quot;in t.context)return t.context.TEXTURE_BUFFER;case Hu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push(&quot;vtkOpenGLBufferObject&quot;);let r=null,o=null,a=!0,i=&quot;&quot;;e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i=&quot;Trying to upload array buffer to incompatible buffer.&quot;,!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const Ku={objectType:Hu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function $u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ku,n),jt.obj(e,t),jt.get(e,t,[&quot;_openGLRenderWindow&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),ju(e,t)}var qu={newInstance:jt.newInstance($u),extend:$u,...Wu};const{vtkErrorMacro:Xu}=jt;function Yu(e,t){t.classHierarchy.push(&quot;vtkOpenGLCellArrayBufferObject&quot;),e.setType(zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=qu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n){for(let r=0;r<e;++r)f(t[n+r])},linesToWireframe(e,t,n){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1])},polysToWireframe(e,t,n){if(e>2)for(let r=0;r<e;++r)f(t[n+r]),f(t[n+(r+1)%e])},stripsToWireframe(e,t,n){if(e>2){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1]);for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+2])}},polysToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+0]),f(t[n+r+1]),f(t[n+r+2])},stripsToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+1+r%2]),f(t[n+r+1+(r+1)%2])}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===rs.POINTS||&quot;verts&quot;===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===rs.WIREFRAME||&quot;lines&quot;===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,D=0,E=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];D+=n*n;const r=.5*(t[1]+t[0]);E+=r*r}const V=D>0&&(Math.abs(E)/D>1e6||Math.abs(Math.log10(D))>3||0===D&&E>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;)C(A[e],A,e+1),e+=A[e]+1,T++;return t.elementCount=w,e.upload(O,zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,Ui(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):Xu(&quot;Wrong type for coordScale, expected vec3 or null&quot;):Xu(&quot;Wrong type for coordShift, expected vec3 or null&quot;)}}const Zu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function Qu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zu,n),qu.extend(e,t,n),jt.setGet(e,t,[&quot;colorBO&quot;,&quot;elementCount&quot;,&quot;stride&quot;,&quot;colorBOStride&quot;,&quot;vertexOffset&quot;,&quot;normalOffset&quot;,&quot;tCoordOffset&quot;,&quot;tCoordComponents&quot;,&quot;colorOffset&quot;,&quot;colorComponents&quot;,&quot;customData&quot;]),jt.get(e,t,[&quot;coordShift&quot;,&quot;coordScale&quot;,&quot;coordShiftAndScaleEnabled&quot;,&quot;inverseShiftAndScaleMatrix&quot;]),Yu(e,t)}var Ju={newInstance:jt.newInstance(Qu),extend:Qu};const{vtkErrorMacro:ed}=jt;function td(e,t){t.classHierarchy.push(&quot;vtkShader&quot;),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||&quot;Unknown&quot;===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e=&quot;Fragment&quot;===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return ed(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const nd={shaderType:&quot;Unknown&quot;,source:&quot;&quot;,error:&quot;&quot;,handle:0,dirty:!1,context:null};function rd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nd,n),jt.obj(e,t),jt.setGet(e,t,[&quot;shaderType&quot;,&quot;source&quot;,&quot;error&quot;,&quot;handle&quot;,&quot;context&quot;]),td(e,t)}var od={newInstance:jt.newInstance(rd,&quot;vtkShader&quot;),extend:rd};const{vtkErrorMacro:ad}=jt;function id(e,t){t.classHierarchy.push(&quot;vtkShaderProgram&quot;),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(ad(`Links failed: ${t.error}`),0):(ad(t.error),0):(ad(t.fragmentShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.fragmentShader.getError()),0):(ad(t.vertexShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.vertexShader.getError()),0),e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error=&quot;Program has not been initialized, and/or does not have shaders.&quot;,!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return ad(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error=&quot;Shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===n.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error=&quot;Could not create shader program.&quot;,!1;t.handle=e,t.linked=!1}return&quot;Vertex&quot;===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),&quot;Fragment&quot;===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error=&quot;shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===e.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;switch(0===t.handle&&(t.error=&quot;This shader program has not been initialized yet.&quot;),e.getShaderType()){case&quot;Vertex&quot;:return t.vertexShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case&quot;Fragment&quot;:return t.fragmentShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const sd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:&quot;&quot;,handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=od.newInstance(),t.vertexShader.setShaderType(&quot;Vertex&quot;),t.fragmentShader=od.newInstance(),t.fragmentShader.setShaderType(&quot;Fragment&quot;),t.geometryShader=od.newInstance(),t.geometryShader.setShaderType(&quot;Geometry&quot;),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;error&quot;,&quot;handle&quot;,&quot;compiled&quot;,&quot;bound&quot;,&quot;md5Hash&quot;,&quot;vertexShader&quot;,&quot;fragmentShader&quot;,&quot;geometryShader&quot;,&quot;linked&quot;]),id(e,t)}var cd={newInstance:jt.newInstance(ld,&quot;vtkShaderProgram&quot;),extend:ld,substitute:function(e,t,n,r){const o=&quot;string&quot;==typeof n?n:n.join(&quot;\\n&quot;),a=!1===r?t:new RegExp(t,&quot;g&quot;),i=e.replace(a,o);return{replace:i!==o,result:i}}};function ud(e,t){t.classHierarchy.push(&quot;vtkOpenGLVertexArrayObject&quot;),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;)),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension(&quot;OES_vertex_array_object&quot;),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const dd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,[&quot;supported&quot;]),jt.setGet(e,t,[&quot;forceEmulation&quot;]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,&quot;vtkOpenGLVertexArrayObject&quot;),extend:pd};const gd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function md(e,t){t.classHierarchy.push(&quot;vtkOpenGLHelper&quot;),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===rs.POINTS||n===gd.Points?t.context.POINTS:e===rs.WIREFRAME||n===gd.Lines||n===gd.TrisEdges||n===gd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f(&quot;viewportSize&quot;,o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf(&quot;lineWidthStepSize&quot;,t/Math.ceil(t)),e.getProgram().setUniformf(&quot;halfLineWidth&quot;,n)}t.primitiveType===gd.Points||r.getProperty().getRepresentation()===rs.POINTS?e.getProgram().setUniformf(&quot;pointSize&quot;,r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf(&quot;pointSize&quot;,e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform float pointSize;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot;  gl_PointSize = pointSize;&quot;],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform vec2 viewportSize;&quot;,&quot;uniform float lineWidthStepSize;&quot;,&quot;uniform float halfLineWidth;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot; if (halfLineWidth > 0.0)&quot;,&quot;   {&quot;,&quot;   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;&quot;,&quot;   vec4 tmpPos = gl_Position;&quot;,&quot;   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;&quot;,&quot;   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];&quot;,&quot;   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];&quot;,&quot;   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);&quot;,&quot;   }&quot;]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===gd.Points?2:t.primitiveType===gd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const hd={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,[&quot;program&quot;,&quot;shaderSourceTime&quot;,&quot;VAO&quot;,&quot;attributeUpdateTime&quot;,&quot;CABO&quot;,&quot;primitiveType&quot;,&quot;pointPicking&quot;]),t.program=cd.newInstance(),t.VAO=fd.newInstance(),t.CABO=Ju.newInstance(),md(e,t)}var yd={newInstance:jt.newInstance(vd),extend:vd,primTypes:gd};const Td={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},bd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var xd={Wrap:Td,Filter:bd};const Cd=new Float32Array(1),Sd=new Int32Array(Cd.buffer);var Ad={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Cd[0]=e;const t=Sd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};const{Wrap:Id,Filter:wd}=xd,{VtkDataTypes:Pd}=Es,{vtkDebugMacro:Od,vtkErrorMacro:Rd,vtkWarningMacro:Md}=Kt,{toHalf:Dd}=Ad;function Ed(e,t){function n(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==Pd.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==Pd.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Dd(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o}function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension(&quot;OES_texture_half_float&quot;),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Ad.toHalf(Ad.fromHalf(e[u][l+s+t])*h*(1-v)+Ad.fromHalf(e[u][l+p+t])*h*v+Ad.fromHalf(e[u][c+s+t])*m*(1-v)+Ad.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&t.oglNorm16Ext)||e!==Pd.UNSIGNED_SHORT&&e!==Pd.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}const s=i&&(function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a);t.useHalfFloat=s}(a,c.offset,c.scale,r),t.useHalfFloat||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}t.classHierarchy.push(&quot;vtkOpenGLTexture&quot;),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent()),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(wd.LINEAR),e.setMagnificationFilter(wd.LINEAR)):(e.setMinificationFilter(wd.NEAREST),e.setMagnificationFilter(wd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Id.REPEAT),e.setWrapS(Id.REPEAT),e.setWrapT(Id.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()},e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Md(&quot;impossible case&quot;),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Od(`Unable to find suitable internal format for T=${n} NC= ${r}`),t.internalFormat),e.getDefaultInternalFormat=(e,n)=>{let r=0;return r=t._openGLRenderWindow.getDefaultTextureInternalFormat(e,n,t.oglNorm16Ext,t.useHalfFloat),r||(r||(Od(&quot;Unsupported internal texture type!&quot;),Od(`Unable to find suitable internal format for T=${e} NC= ${n}`)),r)},e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=e=>{if(t._openGLRenderWindow.getWebgl2())switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.SHORT:return t.context.SHORT;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case t.useHalfFloat&&Pd.SHORT:case t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case Pd.FLOAT:case Pd.VOID:default:return t.context.FLOAT}switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case Pd.FLOAT:case Pd.VOID:default:if(t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))return t.context.FLOAT;{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);if(e&&t.context.getExtension(&quot;OES_texture_half_float_linear&quot;))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case wd.NEAREST:return t.context.NEAREST;case wd.LINEAR:return t.context.LINEAR;case wd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case wd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case wd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case wd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Id.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Id.REPEAT:return t.context.REPEAT;case Id.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=n(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(n(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createDepthFromRaw=(n,r,a,i)=>(e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===Pd.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=r,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0):(Rd(&quot;Failed to determine texture parameters.&quot;),!1)),e.create2DFromImage=n=>{if(e.getOpenGLDataType(Pd.UNSIGNED_CHAR),e.getInternalFormat(Pd.UNSIGNED_CHAR,4),e.getFormat(Pd.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const r=!(t._openGLRenderWindow.getWebgl2()||Fo(n.width)&&Fo(n.height)),a=document.createElement(&quot;canvas&quot;);a.width=r?_o(n.width):n.width,a.height=r?_o(n.height):n.height,t.width=a.width,t.height=a.height;const i=a.getContext(&quot;2d&quot;);i.translate(0,a.height),i.scale(1,-1),i.drawImage(n,0,0,n.width,n.height,0,0,a.width,a.height);const s=a;return o(Pd.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Pd.UNSIGNED_CHAR,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Es.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.create3DFromRaw=(a,i,s,l,c,u)=>{if(e.getOpenGLDataType(c),e.getInternalFormat(c,l),e.getFormat(c,l),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=r(n(c,[u],!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(c)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=d[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,d[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,d[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(c,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Es.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=n*r*i,g=[],m=[];for(let e=0;e<c;++e)g[e]=0,m[e]=1;t.volumeInfo={scale:m,offset:g,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i};const h=structuredClone(p);if(t._openGLRenderWindow.getWebgl2()){if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=32767;return e.create3DFromRaw(n,r,i,c,u,d)}if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.UNSIGNED_SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=65535;return e.create3DFromRaw(n,r,i,c,u,d)}if(u===Pd.FLOAT||t.useHalfFloat&&(u===Pd.SHORT||u===Pd.UNSIGNED_SHORT))return e.create3DFromRaw(n,r,i,c,u,d);if(u===Pd.UNSIGNED_CHAR){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=255;return e.create3DFromRaw(n,r,i,c,u,d)}const o=new Float32Array(f*c);t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;let a=0;const s=h.scale.map((e=>1/e));for(let e=0;e<f;e++)for(let e=0;e<c;e++)o[a]=(d[a]-h.offset[e])*s[e],a++;return e.create3DFromRaw(n,r,i,c,Pd.FLOAT,o)}let v=(e,t,n,r,o)=>{e[t]=n},y=Pd.UNSIGNED_CHAR;if(u===Pd.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)?(y=Pd.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=Pd.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===Pd.FLOAT||c>=3)&&(T=4096);let b=1,x=1;f>T*T&&(b=Math.ceil(Math.sqrt(f/(T*T))),x=b);let C=Math.sqrt(f)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===Pd.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1}const Vd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Id.CLAMP_TO_EDGE,wrapT:Id.CLAMP_TO_EDGE,wrapR:Id.CLAMP_TO_EDGE,minificationFilter:wd.NEAREST,magnificationFilter:wd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,useHalfFloat:!0,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0};function Ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,[&quot;format&quot;,&quot;openGLDataType&quot;]),At(e,t,[&quot;keyMatrixTime&quot;,&quot;minificationFilter&quot;,&quot;magnificationFilter&quot;,&quot;wrapS&quot;,&quot;wrapT&quot;,&quot;wrapR&quot;,&quot;generateMipmap&quot;,&quot;oglNorm16Ext&quot;]),bt(e,t,[&quot;width&quot;,&quot;height&quot;,&quot;volumeInfo&quot;,&quot;components&quot;,&quot;handle&quot;,&quot;target&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),Ed(e,t)}const Bd=Et(Ld,&quot;vtkOpenGLTexture&quot;);var Nd={newInstance:Bd,extend:Ld,...xd};rn(&quot;vtkTexture&quot;,Bd);var _d=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexMC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\nvoid main()\\n{\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::PrimID::Impl\\n\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,Fd=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the polydata mappers fragment shader\\n\\nuniform int PrimitiveIDOffset;\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// optional color passed in from the vertex shader, vertexColor\\n//VTK::Color::Dec\\n\\n// optional surface normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// Depth Peeling Support\\n//VTK::DepthPeeling::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// label outline \\n//VTK::LabelOutline::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n//VTK::LabelOutlineHelperFunction\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::Color::Impl\\n\\n  // Generate the normal if we are not passed in one\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Light::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,kd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::Coincident::Dec&quot;,[&quot;uniform float cfactor;&quot;,&quot;uniform float coffset;&quot;]).result,t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;&quot;).result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;&quot;).result),n.Fragment=e}}},Gd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=cd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&&quot;&quot;!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&&quot;&quot;!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Ud}=ol,{primTypes:zd}=yd,{Representation:Wd,Shading:Hd}=ds,{ScalarMode:jd}=nc,{Filter:Kd,Wrap:$d}=Nd,{vtkErrorMacro:qd}=Kt,Xd={type:&quot;StartEvent&quot;},Yd={type:&quot;EndEvent&quot;},{CoordinateSystem:Zd}=Zi;function Qd(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType(&quot;vtkOpenGLActor&quot;),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=zd.Start;e<zd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let l=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;,&quot;uniform vec3 ambientColorUniform;&quot;,&quot;uniform vec3 diffuseColorUniform;&quot;];s&&(l=l.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let c=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];s&&(c=c.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),c=c.concat([&quot;  ambientColor = ambientColorUniform;&quot;,&quot;  diffuseColor = diffuseColorUniform;&quot;,&quot;  opacity = opacityUniform;&quot;]),s&&(c=c.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 scalarColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput =  scalarColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?t.renderable.getInterpolateScalarsBeforeMapping()&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);&quot;,&quot;  diffuseColor = texColor.rgb;&quot;,&quot;  ambientColor = texColor.rgb;&quot;,&quot;  opacity = opacity*texColor.a;&quot;])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat([&quot;uniform float opacityUniformBF; // the fragment opacity&quot;,&quot;uniform float ambientIntensityBF; // the material ambient&quot;,&quot;uniform float diffuseIntensityBF; // the material diffuse&quot;,&quot;uniform vec3 ambientColorUniformBF; // ambient material color&quot;,&quot;uniform vec3 diffuseColorUniformBF; // diffuse material color&quot;]),s?(l=l.concat([&quot;uniform float specularIntensityBF; // the material specular intensity&quot;,&quot;uniform vec3 specularColorUniformBF; // intensity weighted color&quot;,&quot;uniform float specularPowerUniformBF;&quot;]),c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  specularColor = specularIntensityBF * specularColorUniformBF;&quot;,&quot;  specularPower = specularPowerUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])):c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat([&quot;uniform samplerBuffer texture1;&quot;])),i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c).result):i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),i=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);let s=[];switch(a){case 0:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 1:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  float df = max(0.0, normalVCVSOutput.z);&quot;,&quot;  float sf = pow(df, specularPower);&quot;,&quot;  vec3 diffuseL = df * diffuseColor;&quot;,&quot;  vec3 specularL = sf * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,&quot;    {&quot;,`    float sf = sign(df)*pow(max(1e-5,\\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\\n                                                  normalize(-vertexVC.xyz))),\\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  vec3 vertLightDirectionVC;&quot;,&quot;  float attenuation;&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([&quot;  attenuation = 1.0;&quot;,`  if (lightPositional${e} == 0)`,&quot;    {&quot;,`      vertLightDirectionVC = lightDirectionVC${e};`,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,&quot;    float distanceVC = length(vertLightDirectionVC);&quot;,&quot;    vertLightDirectionVC = normalize(vertLightDirectionVC);&quot;,&quot;    attenuation = 1.0 /&quot;,`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,&quot;    // per OpenGL standard cone angle is 90 or less for a spot light&quot;,`    if (lightConeAngle${e} <= 90.0)`,&quot;      {&quot;,`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,&quot;      // if inside the cone&quot;,`      if (coneDot >= cos(radians(lightConeAngle${e})))`,&quot;        {&quot;,`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,&quot;        }&quot;,&quot;      else&quot;,&quot;        {&quot;,&quot;        attenuation = 0.0;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));&quot;,`    diffuseL += ((df) * lightColor${e});`,&quot;    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)&quot;,&quot;      {&quot;,`      float sf = sign(df)*attenuation*pow(max(1e-5,\\n                                                           dot(reflect(lightDirectionVC${e},\\n                                                                       normalVCVSOutput),\\n                                                               normalize(-vertexVC.xyz))),\\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;default:qd(&quot;bad light complexity&quot;)}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * normalMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Dec&quot;,[&quot;in vec3 normalVCVSOutput[];&quot;,&quot;out vec3 normalVCGSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCGSOutput = normalVCVSOutput[i];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;varying vec3 normalVCVSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalVCVSOutput);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.haveCellNormals?(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform mat3 normalMatrix;&quot;,&quot;uniform samplerBuffer textureN;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalMatrix *&quot;,&quot;    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput;&quot;,&quot;  if (abs(fdx.x) > 0.0)&quot;,&quot;    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }&quot;,&quot;  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}&quot;]).result):(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;&quot;]).result,a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;  fdx = normalize(fdx);&quot;,&quot;  fdy = normalize(fdy);&quot;,&quot;  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));&quot;,&quot;  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;,&quot;  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(o=cd.substitute(o,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCVSOutput = MCVCMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;in vec4 vertexVCVSOutput[];&quot;,&quot;out vec4 vertexVCGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCGSOutput = vertexVCVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;&quot;]).result):(o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,a&&a.length>=1)switch(i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}}else switch(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec3 tcoordVCVSOutput[];&quot;,&quot;out vec3 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec3 tcoordVCVSOutput;&quot;,&quot;uniform samplerCube texture1;&quot;]).result,i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`varying float clipDistancesVSOutput[${e}];`]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()||o.getEdgeVisibility()&&o.getRepresentation()===Wd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===zd.Points||o.getRepresentation()===Wd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===zd.Lines||o.getRepresentation()===Wd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==zd.Tris&&e!==zd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==zd.TrisEdges&&e!==zd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform int picking;&quot;,&quot;//VTK::Picking::Dec&quot;]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==zl.ID_LOW24&&t.lastSelectionState!==zl.ID_HIGH24||(a=cd.substitute(a,&quot;//VTK::Picking::Dec&quot;,[&quot;flat out int vertexIDVSOutput;\\n&quot;,&quot;uniform int VertexIDOffset;\\n&quot;]).result,a=cd.substitute(a,&quot;//VTK::Picking::Impl&quot;,&quot;  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;flat in int vertexIDVSOutput;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,[&quot;  int idx = vertexIDVSOutput;&quot;,&quot;//VTK::Picking::Impl&quot;]).result),t.lastSelectionState){case zl.ID_LOW24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);&quot;).result;break;case zl.ID_HIGH24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);&quot;).result;break;default:o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;uniform vec3 mapperIndex;&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===Hd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),h=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&n.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),n.getProgram().isUniformUsed(&quot;VertexIDOffset&quot;)&&n.getProgram().setUniformi(&quot;VertexIDOffset&quot;,t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;normalMC&quot;)&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;normalMC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting normalMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;normalMC&quot;),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||qd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||qd(&quot;Error setting tcoordMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),n.getProgram().isAttributeUsed(&quot;scalarColor&quot;)&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),&quot;scalarColor&quot;,n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||qd(&quot;Error setting scalarColor in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;scalarColor&quot;),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,r)}t.internalColorTexture&&n.getProgram().isUniformUsed(&quot;texture1&quot;)&&n.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi(&quot;picking&quot;,i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===Zd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4)}else s.setUniformMatrix(&quot;MCPCMatrix&quot;,n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed(&quot;MCVCMatrix&quot;)&&s.setUniformMatrix(&quot;MCVCMatrix&quot;,n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed(&quot;normalMatrix&quot;)&&s.setUniformMatrix3x3(&quot;normalMatrix&quot;,n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf(&quot;opacityUniform&quot;,i),o.setUniform3fArray(&quot;ambientColorUniform&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniform&quot;,l),o.setUniformf(&quot;ambient&quot;,c),o.setUniformf(&quot;diffuse&quot;,u);const f=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray(&quot;specularColorUniform&quot;,g),o.setUniformf(&quot;specularPowerUniform&quot;,p),o.setUniformf(&quot;specular&quot;,d),o.isUniformUsed(&quot;ambientIntensityBF&quot;)){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf(&quot;ambientIntensityBF&quot;,c),o.setUniformf(&quot;diffuseIntensityBF&quot;,u),o.setUniformf(&quot;opacityUniformBF&quot;,i),o.setUniform3fArray(&quot;ambientColorUniformBF&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniformBF&quot;,l),f<1)return;o.setUniformf(&quot;specularIntensityBF&quot;,d),o.setUniform3fArray(&quot;specularColorUniformBF&quot;,g),o.setUniformf(&quot;specularPowerUniformBF&quot;,p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():zl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Wd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===zl.ID_LOW24||t.lastSelectionState===zl.ID_HIGH24);for(let i=zd.Start;i<zd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===zd.TrisEdges||i===zd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(Xd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Yd),!t.currentInput)return void qd(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(null===o)return;t.renderable.mapScalars(o,1);const a=t.renderable.getColorMapColors();t.haveCellScalars=!1;const i=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(i!==jd.USE_CELL_DATA&&i!==jd.USE_CELL_FIELD_DATA&&i!==jd.USE_FIELD_DATA&&o.getPointData().getScalars()||i===jd.USE_POINT_FIELD_DATA||!a||(t.haveCellScalars=!0));let s=r.getProperty().getInterpolation()!==Hd.FLAT?o.getPointData().getNormals():null;null===s&&o.getCellData().getNormals()&&(t.haveCellNormals=!0,s=o.getCellData().getNormals());const l=r.getProperty().getRepresentation();let c=o.getPointData().getTCoords();if(t.openGLActor.getActiveTextures()||(c=null),t.renderable.getColorCoordinates()){c=t.renderable.getColorCoordinates(),t.internalColorTexture||(t.internalColorTexture=Nd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Kd.NEAREST),e.setMagnificationFilter(Kd.NEAREST),e.setWrapS($d.CLAMP_TO_EDGE),e.setWrapT($d.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${o.getMTime()}A${l}B${o.getMTime()}C${s?s.getMTime():1}D${a?a.getMTime():1}E${r.getProperty().getEdgeVisibility()}F${c?c.getMTime():1}`;if(t.VBOBuildString!==u){const n={points:o.getPoints(),normals:s,tcoords:c,colors:a,cellOffset:0,vertexOffset:0,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>o.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const i=[{inRep:&quot;verts&quot;,cells:o.getVerts()},{inRep:&quot;lines&quot;,cells:o.getLines()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()}],d=r.getProperty().getEdgeVisibility()&&l===Wd.SURFACE;for(let e=zd.Start;e<zd.End;e++)e!==zd.TrisEdges&&e!==zd.TriStripsEdges?(n.cellOffset+=t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,l,n,t.selectionWebGLIdsToVTKIds),n.vertexOffset+=t.primitives[e].getCABO().getElementCount()):d?t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,Wd.WIREFRAME,{...n,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[e].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&(t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),e.updateMaximumPointCellIds()),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Jd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:zl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function ep(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jd,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=zd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=zd.Start;e<zd.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),Qd(e,t)}const tp=Et(ep,&quot;vtkOpenGLPolyDataMapper&quot;);var np={newInstance:tp,extend:ep};rn(&quot;vtkMapper&quot;,tp);const{ColorMode:rp,ScalarMode:op,GetArray:ap}=hl;function ip(e,t){t.classHierarchy.push(&quot;vtkMapper2D&quot;),e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString(rp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(op,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===op.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===op.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===op.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===op.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_FIELD_DATA){const t=e.getFieldData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const sp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function lp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sp,n),Bs(e,t,n),jt.get(e,t,[&quot;colorMapColors&quot;]),jt.setGet(e,t,[&quot;arrayAccessMode&quot;,&quot;colorByArrayName&quot;,&quot;colorMode&quot;,&quot;lookupTable&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;transformCoordinate&quot;,&quot;useLookupTableScalarRange&quot;,&quot;viewSpecificProperties&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),ip(e,t)}var cp={newInstance:jt.newInstance(lp,&quot;vtkMapper2D&quot;),extend:lp};const up=1,{primTypes:dp}=yd,{ScalarMode:pp}=cp,{vtkErrorMacro:fp}=Kt,gp={type:&quot;StartEvent&quot;},mp={type:&quot;EndEvent&quot;};function hp(e,t){t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper2D&quot;),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType(&quot;vtkOpenGLActor2D&quot;),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model Coordinates\\n// WC - WC world coordinates\\n// VC - View Coordinates\\n// DC - Display Coordinates\\n\\nin vec4 vertexWC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nuniform mat4 WCVCMatrix;  // World to view matrix\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  gl_Position = WCVCMatrix*vertexWC;\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::PositionVC::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nuniform int PrimitiveIDOffset;\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Scalar coloring\\n//VTK::Color::Dec\\n\\n// Depth Peeling\\n//VTK::DepthPeeling::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Color::Impl\\n  //VTK::TCoord::Impl\\n\\n  //VTK::DepthPeeling::Impl\\n  //VTK::Picking::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=dp.Start;e<dp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(gp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(mp),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):fp(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==pp.USE_CELL_DATA&&a!==pp.USE_CELL_FIELD_DATA&&a!==pp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===pp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=mc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[dp.Points].getCABO().createVBO(r.getVerts(),&quot;verts&quot;,i,a),a.cellOffset+=t.primitives[dp.Lines].getCABO().createVBO(r.getLines(),&quot;lines&quot;,i,a),a.cellOffset+=t.primitives[dp.Tris].getCABO().createVBO(r.getPolys(),&quot;polys&quot;,i,a),a.cellOffset+=t.primitives[dp.TriStrips].getCABO().createVBO(r.getStrips(),&quot;strips&quot;,i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=dp.Start;a<dp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform samplerBuffer texture1;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);&quot;]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 diffuseColor;&quot;,&quot;out vec4 fcolorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorVSOutput = diffuseColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput[];\\n&quot;,&quot;out vec4 fcolorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorGSOutput = fcolorVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = fcolorVSOutput;&quot;]).result):(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform vec4 diffuseColor;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = diffuseColor;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordMC;&quot;,&quot;out float tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput[];\\n&quot;,&quot;out float tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,[&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));&quot;]).result):2===a&&(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordMC;&quot;,&quot;out vec2 tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];\\n&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);&quot;]).result),t.haveCellScalars&&(r=cd.substitute(r,&quot;//VTK::PrimID::Impl&quot;,[&quot;gl_PrimitiveID = gl_PrimitiveIDIn;&quot;]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=cd.substitute(r,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&e.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),e.getProgram().isAttributeUsed(&quot;vertexWC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;vertexWC&quot;,e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||fp(&quot;Error setting vertexWC in shader VAO.&quot;)),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||fp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;tcoordMC&quot;,e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||fp(&quot;Error setting tcoordMC in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),t.internalColorTexture&&e.getProgram().isUniformUsed(&quot;texture1&quot;)&&e.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi(&quot;picking&quot;,a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f(&quot;diffuseColor&quot;,i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===up?-1:1,x[15]=1,m(x,x),a.setUniformMatrix(&quot;WCVCMatrix&quot;,(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const vp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const yp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=dp,t.tmpMat4=g(new Float64Array(16));for(let e=dp.Start;e<dp.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),hp(e,t)}),&quot;vtkOpenGLPolyDataMapper2D&quot;);rn(&quot;vtkMapper2D&quot;,yp);const{VectorMode:Tp}=Pl;function bp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function xp(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Cp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Sp(e,t){t.classHierarchy.push(&quot;vtkScalarBarActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;;const n={},r=new Map;let o=0,a=1;bp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,bp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),&quot;NaN&quot;,&quot;Below&quot;,&quot;Above&quot;];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{bp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s(&quot;NaN&quot;,[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s(&quot;Below&quot;,[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s(&quot;ticks&quot;,t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s(&quot;Above&quot;,[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p=&quot;vertical&quot;===a?[1,0]:[0,1];&quot;vertical&quot;===a?(d[0]=l.width,d[1]=-l.height,&quot;middle&quot;===o[0]?n[1]-=l.width/2:&quot;right&quot;===o[0]&&(n[1]-=l.width),&quot;middle&quot;===o[1]?n[0]+=l.height/2:&quot;top&quot;===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,&quot;middle&quot;===o[0]?n[0]-=l.width/2:&quot;right&quot;===o[0]&&(n[0]-=l.width),&quot;middle&quot;===o[1]?n[1]-=l.height/2:&quot;top&quot;===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?[&quot;right&quot;,&quot;middle&quot;]:[&quot;middle&quot;,&quot;bottom&quot;];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;top&quot;],&quot;vertical&quot;,[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];&quot;ticks&quot;===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,&quot;horizontal&quot;,g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,&quot;horizontal&quot;,g,c)}const b=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Tp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Es.newInstance({numberOfComponents:i,values:c,name:&quot;Scalars&quot;});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Ap=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;tickLabelPixelOffset&quot;,&quot;renderable&quot;,&quot;topTitle&quot;,&quot;ticks&quot;,&quot;tickStrings&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;lastTickBounds&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;barActor&quot;,&quot;tmActor&quot;]),jt.getArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.barMapper=nc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=gu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=hs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Tu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Sp(e,t)}),&quot;vtkScalarBarActorHelper&quot;);function Ip(e,t){t.classHierarchy.push(&quot;vtkScalarBarActor&quot;),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(xp(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Cp())}}function wp(e){return{automated:!0,autoLayout:null,axisLabel:&quot;Scalar Value&quot;,barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:14,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function Pp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wp(n)),t.autoLayout||(t.autoLayout=xp(0,t)),t.generateTicks||(t.generateTicks=Cp()),hs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,[&quot;automated&quot;,&quot;autoLayout&quot;,&quot;axisTitlePixelOffset&quot;,&quot;axisLabel&quot;,&quot;scalarsToColors&quot;,&quot;tickLabelPixelOffset&quot;,&quot;generateTicks&quot;,&quot;drawNanAnnotation&quot;,&quot;drawBelowRangeSwatch&quot;,&quot;drawAboveRangeSwatch&quot;]),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;]),jt.getArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;],2),Ip(e,t)}var Op={newInstance:jt.newInstance(Pp,&quot;vtkScalarBarActor&quot;),extend:Pp,newScalarBarActorHelper:Ap};function Rp(e,t){t.classHierarchy.push(&quot;vtkOpenGLScalarBarActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Mp={};const Dp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Op.newScalarBarActorHelper(),Rp(e,t)}),&quot;vtkOpenGLScalarBarActor&quot;);rn(&quot;vtkScalarBarActor&quot;,Dp);const{vtkErrorMacro:Ep}=Kt;function Vp(e,t){t.classHierarchy.push(&quot;vtkOpenGLSkybox&quot;),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi(&quot;sbtexture&quot;,n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix(&quot;IMCPCMatrix&quot;,a),&quot;box&quot;===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f(&quot;camPos&quot;,e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Es.newInstance({numberOfComponents:3,values:e});n.setName(&quot;points&quot;);const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),&quot;box&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec3 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = wpos.xyz/wpos.w;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec3 TexCoords;\\n             uniform samplerCube sbtexture;\\n             uniform vec3 camPos;\\n             void main () {\\n               // skybox looks from inside out\\n               // which means we have to adjust\\n               // our tcoords. Otherwise text would\\n               // be flipped\\n               vec3 tc = normalize(TexCoords - camPos);\\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\\n               {\\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\\n               }\\n               else\\n               {\\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\\n               }\\n               gl_FragData[0] = textureCube(sbtexture, tc);\\n             }&quot;,&quot;&quot;)),&quot;background&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec2 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec2 TexCoords;\\n             uniform sampler2D sbtexture;\\n             void main () {\\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\\n             }&quot;,&quot;&quot;)),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),&quot;vertexMC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Ep(&quot;Error setting vertexMC in shader VAO.&quot;));const e=t.renderable.getTextures();e.length||Ep(&quot;vtkSkybox requires a texture map&quot;),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Lp={context:null};const Bp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lp,n),Zt.extend(e,t,n),t.openGLTexture=Nd.newInstance(),t.tris=yd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Vp(e,t)}));rn(&quot;vtkSkybox&quot;,Bp);const{FieldAssociations:Np}=ol;function _p(e,t){t.classHierarchy.push(&quot;vtkHardwareSelector&quot;),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const Fp={fieldAssociation:Np.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function kp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fp,n),jt.obj(e,t),jt.setGet(e,t,[&quot;fieldAssociation&quot;,&quot;captureZValues&quot;]),_p(e,t)}var Gp={newInstance:jt.newInstance(kp,&quot;vtkHardwareSelector&quot;),extend:kp};function Up(e,t){t.classHierarchy.push(&quot;vtkFramebuffer&quot;),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling saveCurrentBindings&quot;);const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling restorePreviousBindings&quot;);const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et(&quot;you must set the OpenGLRenderWindow before calling create&quot;)},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et(&quot;you must set the OpenGLRenderWindow before calling setColorBuffer&quot;);let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et(&quot;you must set the OpenGLRenderWindow before calling removeColorBuffer&quot;);let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et(&quot;Attaching depth buffer textures to fbo requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling setDepthBuffer&quot;)},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et(&quot;Attaching depth buffer textures to framebuffers requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling removeDepthBuffer&quot;)},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>{const e=[0,0];return null!==t.glFramebuffer&&(e[0]=t.glFramebuffer.width,e[1]=t.glFramebuffer.height),e},e.populateFramebuffer=()=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling populateFrameBuffer&quot;);e.bind();const n=t.context,r=Nd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(bd.LINEAR),r.setMagnificationFilter(bd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,ys.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const zp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Wp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zp,n),yt(e,t),t.colorBuffers&&et(&quot;you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.&quot;),t.colorBuffers=[],It(e,t,[&quot;colorBuffers&quot;]),Up(e,t)}var Hp={newInstance:Et(Wp,&quot;vtkFramebuffer&quot;),extend:Wp};function jp(e,t){t.classHierarchy.push(&quot;vtkSelectionNode&quot;),e.getBounds=()=>t.points.getBounds()}const Kp={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function $p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kp,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,[&quot;contentType&quot;,&quot;fieldType&quot;,&quot;properties&quot;,&quot;selectionList&quot;]),jp(e,t)}var qp={newInstance:jt.newInstance($p,&quot;vtkSelectionNode&quot;),extend:$p,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Xp}=Wl,{SelectionContent:Yp,SelectionField:Zp}=qp,{FieldAssociations:Qp}=ol,{vtkErrorMacro:Jp}=jt;function ef(e){return`${e.propID} ${e.compositeID}`}function tf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function nf(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function rf(e,t){let n=t;return n<<=24,n|=e,n}function of(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=nf(n[0],n[1],e.pixBuffer[Xp.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=nf(n[0],n[1],e.pixBuffer[Xp.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Xp.ID_LOW24]&&0===tf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area))return a;const s=nf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area),l=nf(n[0],n[1],e.pixBuffer[Xp.ID_HIGH24],e.area);return a.attributeID=rf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=of(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=of(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=of(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function af(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=qp.newInstance();switch(l.setContentType(Yp.INDICES),e){case Qp.FIELD_ASSOCIATION_CELLS:l.setFieldType(Zp.CELL);break;case Qp.FIELD_ASSOCIATION_POINTS:l.setFieldType(Zp.POINT);break;default:Jp(&quot;Unknown field association&quot;)}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function sf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=of(e,[n,t],0,u);if(r&&r.valid){const t=ef(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return af(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function lf(e,t){t.classHierarchy.push(&quot;vtkOpenGLHardwareSelector&quot;),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e[0]!==n[0]||e[1]!==n[1]?(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer()):t.framebuffer.bind()}else t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return sf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return Jp(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:&quot;StartEvent&quot;}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();for(e.beginSelection(),t.currentPass=Xp.MIN_KNOWN_PASS;t.currentPass<=Xp.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Xp.ACTOR_PASS&&&quot;function&quot;==typeof n[0].requestDepth&&&quot;function&quot;==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),e.processPixelBuffers());return e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:&quot;EndEvent&quot;}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Xp.ID_HIGH24){if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Xp.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if(&quot;function&quot;==typeof e[0].requestDepth&&&quot;function&quot;==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=nf(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Xp.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Xp.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(Xp,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=nf(e[0],e[1],t.pixBuffer[Xp.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=nf(e[0],e[1],t.pixBuffer[Xp.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Xp.ID_LOW24]&&0===tf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area))return a;const s=nf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area),l=nf(e[0],e[1],t.pixBuffer[Xp.ID_HIGH24],t.area);return a.attributeID=rf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=ef(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return af(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const cf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cf,n),Gp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,[&quot;area&quot;],4),jt.setGet(e,t,[&quot;_renderer&quot;,&quot;currentPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;maximumPointId&quot;,&quot;maximumCellId&quot;]),jt.setGetArray(e,t,[&quot;propColorValue&quot;],3),jt.moveToProtected(e,t,[&quot;renderer&quot;,&quot;openGLRenderWindow&quot;]),jt.event(e,t,&quot;event&quot;),lf(e,t)}var df={newInstance:jt.newInstance(uf,&quot;vtkOpenGLHardwareSelector&quot;),extend:uf,...Wl};const{vtkErrorMacro:pf}=Kt,{Representation:ff}=ds,{ObjectType:gf}=qu,{PassTypes:mf}=df,hf={type:&quot;StartEvent&quot;},vf={type:&quot;EndEvent&quot;};function yf(e,t){t.classHierarchy.push(&quot;vtkOpenGLGlyph3DMapper&quot;);const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(hf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(vf),!t.currentInput)return void pf(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;attribute mat3 gNormal;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * gNormal * normalMC;&quot;]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;];a&&(i=i.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let s=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];a&&(s=s.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),s=s.concat([&quot;  opacity = opacityUniform;&quot;]),a&&(s=s.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),t.drawingEdges||(i=i.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),n=cd.substitute(n,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 gColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput = gColor;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result,s=s.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])),o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,s).result,o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;vertexVCVSOutput = MCVCMatrix * gVertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result):(n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;]).result,n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=cd.substitute(n,&quot;//VTK::Picking::Dec&quot;,[&quot;attribute vec3 mapperIndexVS;&quot;,&quot;varying vec3 mapperIndexVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Picking::Impl&quot;,&quot;  mapperIndexVSOutput = mapperIndexVS;&quot;).result,e.Vertex=n,t=cd.substitute(t,&quot;//VTK::Picking::Dec&quot;,[&quot;varying vec3 mapperIndexVSOutput;&quot;,&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,t=cd.substitute(t,&quot;//VTK::Picking::Impl&quot;,[&quot;  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);&quot;,&quot;  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];&quot;]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3(&quot;normalMatrix&quot;,t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix(&quot;MCVCMatrix&quot;,t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray(&quot;ambientColorUniform&quot;,t.tmpColor),u.setUniform3fArray(&quot;diffuseColorUniform&quot;,t.tmpColor)}c&&u.setUniform3fArray(&quot;mapperIndex&quot;,c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===ff.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===mf.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed(&quot;normalMatrix&quot;),v=g.isUniformUsed(&quot;MCVCMatrix&quot;);if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed(&quot;gMatrix&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,&quot;gMatrix&quot;,0,64,t.context.FLOAT,4,!1,1)||pf(&quot;Error setting gMatrix in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gMatrix&quot;),e.getProgram().isAttributeUsed(&quot;gNormal&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,&quot;gNormal&quot;,0,36,t.context.FLOAT,3,!1,1)||pf(&quot;Error setting gNormal in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gNormal&quot;),e.getProgram().isAttributeUsed(&quot;gColor&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,&quot;gColor&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting gColor in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gColor&quot;),e.getProgram().isAttributeUsed(&quot;mapperIndexVS&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,&quot;mapperIndexVS&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting mapperIndexVS in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;mapperIndexVS&quot;),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=qu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=qu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=qu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=qu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,gf.ARRAY_BUFFER),t.normalBuffer.upload(n,gf.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),gf.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,gf.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Tf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const bf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),np.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),yf(e,t)}),&quot;vtkOpenGLGlyph3DMapper&quot;);rn(&quot;vtkGlyph3DMapper&quot;,bf);const{vtkErrorMacro:xf}=jt;class Cf{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Sf(e,t){t.classHierarchy.push(&quot;vtkClosedPolyLineToSurfaceFilter&quot;),e.requestData=(e,t)=>{const n=e[0];if(!n)return void xf(&quot;Invalid or missing input&quot;);const r=gu.newInstance();r.shallowCopy(n);const o=new Cf,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(cc.newInstance({values:c,name:&quot;faces&quot;})),t[0]=r}}const Af={};function If(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Af,n),jt.obj(e,t),jt.algo(e,t,1,1),Sf(e,t)}var wf={newInstance:jt.newInstance(If,&quot;vtkClosedPolyLineToSurfaceFilter&quot;),extend:If};const{vtkErrorMacro:Pf}=Kt;function Of(e,t){t.classHierarchy.push(&quot;vtkCutter&quot;);const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Pf(&quot;Invalid or missing input&quot;);if(!t.cutFunction)return void Pf(&quot;Missing cut function&quot;);const o=gu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error(&quot;Iterator is done&quot;);r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const Rf={cutFunction:null,cutScalars:null,cutValue:0};function Mf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),yt(e,t),Rt(e,t,1,1),At(e,t,[&quot;cutFunction&quot;,&quot;cutValue&quot;]),Of(e,t)}var Df={newInstance:Et(Mf,&quot;vtkCutter&quot;),extend:Mf};const Ef=e=>e,Vf=1e-6;class Lf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Ef}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=Dn(n,r);return a>=1||(En(this.tmp,n,r),Sn(this.tmp)<Vf&&(En(this.tmp,[1,0,0],e),Sn(this.tmp)<Vf&&En(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Bf=function(){return new Lf(!0)},Nf=function(){return new Lf(!1)};const _f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],Ff=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function kf(e,t){t.classHierarchy.push(&quot;vtkCubeSource&quot;),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=gu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Es.newInstance({name:&quot;Normals&quot;,values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Es.newInstance({name:&quot;TextureCoordinates&quot;,values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Bf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Nf().translate(...t.center).apply(o),t.matrix){Nf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Nf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Gf={xLength:1,yLength:1,zLength:1,pointType:&quot;Float64Array&quot;,generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;xLength&quot;,&quot;yLength&quot;,&quot;zLength&quot;,&quot;generate3DTextureCoordinates&quot;,&quot;generateFaces&quot;,&quot;generateLines&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;rotations&quot;],3),jt.setGetArray(e,t,[&quot;matrix&quot;],16),t._polys=cc.newInstance({values:Uint16Array.from(Ff)}),t._lineCells=cc.newInstance({values:Uint16Array.from(_f)}),jt.moveToProtected(e,t,[&quot;polys&quot;,&quot;lineCells&quot;]),jt.algo(e,t,0,1),kf(e,t)}var zf={newInstance:jt.newInstance(Uf,&quot;vtkCubeSource&quot;),extend:Uf};const{vtkErrorMacro:Wf}=jt;function Hf(e,t){t.classHierarchy.push(&quot;vtkImageDataOutlineFilter&quot;);const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA(&quot;vtkImageData&quot;))return void Wf(&quot;Invalid or missing input&quot;);const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Wf(&quot;Unable to fetch spatial extents of input image.&quot;)},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const jf={};function Kf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jf,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=zf.newInstance(),jt.moveToProtected(e,t,[&quot;cubeSource&quot;,&quot;tmpOut&quot;]),Hf(e,t)}var $f={newInstance:jt.newInstance(Kf,&quot;vtkImageDataOutlineFilter&quot;),extend:Kf};let qf;function Xf(e,t){t.classHierarchy.push(&quot;vtkAbstractTransform&quot;,&quot;vtkHomogeneousTransform&quot;,&quot;vtkTransform&quot;),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>qf({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const Yf={preMultiplyFlag:!1,matrix:[...vo]};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;preMultiplyFlag&quot;]),jt.setGetArray(e,t,[&quot;matrix&quot;],16),Xf(e,t)}qf=jt.newInstance(Zf,&quot;vtkTransform&quot;);var Qf={newInstance:qf,extend:Zf};const Jf={NEAREST:0,LINEAR:1};var eg={InterpolationType:Jf};const{vtkErrorMacro:tg}=Kt;function ng(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function rg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function og(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageResliceMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:&quot;EndEvent&quot;})):tg(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Jf.NEAREST?(t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.openGLTexture.setMinificationFilter(bd.LINEAR),t.openGLTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime(),e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(!r)return;const o=r.getPointData()?.getScalars();if(!o)return;t._scalars!==o&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=o);const a=o.getNumberOfComponents();let i=`${r.getMTime()}A${o.getMTime()}`;const s=t._openGLRenderWindow.getGraphicsResourceForObject(o);if(s?.vtkObj&&s?.hash===i&&t.openGLTextureString===i)t.openGLTexture=s.vtkObj,t.openGLTextureString=s.hash;else{t.openGLTexture||(t.openGLTexture=Nd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const e=r.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],o),t.openGLTextureString=i,o&&t._openGLRenderWindow.setGraphicsResourceForObject(o,t.openGLTexture,t.openGLTextureString)}const l=n.getProperty(),c=l.getIndependentComponents(),u=c?a:1,d=c?2*u:1,p=l.getRGBTransferFunction();i=ng(l,p,u);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===i&&t.colorTextureString===i)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(e*d*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),p){const r=new Float32Array(3*e);for(let t=0;t<u;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),c)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=i,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}const g=l.getPiecewiseFunction();i=ng(l,g,u);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(m?.vtkObj&&m?.hash===i&&t.pwfTextureString===i)t.pwfTexture=m.vtkObj,t.pwfTextureString=m.hash;else{const e=1024,n=e*d,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),g){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<u;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=i,g&&t._openGLRenderWindow.setGraphicsResourceForObject(g,t.pwfTexture,t.pwfTextureString)}const h=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==h){const e=Es.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName(&quot;points&quot;);const n=Es.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:tg(&quot;Slab mode requested without normals&quot;)}t.tris.getCABO().createVBO(n,&quot;polys&quot;,rs.SURFACE,r)}t.VBOBuildString=h,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed(&quot;texture1&quot;)&&a.setUniformi(&quot;texture1&quot;,t.openGLTexture.getTextureUnit()),a.isAttributeUsed(&quot;vertexWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexWC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting vertexWC in shader VAO.&quot;)),a.isAttributeUsed(&quot;normalWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;normalWC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting normalWC in shader VAO.&quot;)),a.isUniformUsed(&quot;slabThickness&quot;)&&a.setUniformf(&quot;slabThickness&quot;,t.renderable.getSlabThickness()),a.isUniformUsed(&quot;spacing&quot;)&&a.setUniform3fv(&quot;spacing&quot;,t.currentInput.getSpacing()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabTrapezoid&quot;)&&a.setUniformi(&quot;slabTrapezoid&quot;,t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed(&quot;WCTCMatrix&quot;)){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix(&quot;WCTCMatrix&quot;,t.tmpMat4)}a.isUniformUsed(&quot;vboScaling&quot;)&&a.setUniform3fv(&quot;vboScaling&quot;,n.getCABO().getCoordScale()),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed(&quot;MCPCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCPCMatrix&quot;,rg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed(&quot;MCVCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCVCMatrix&quot;,rg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d),o.setUniform4fv(&quot;backgroundColor&quot;,t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model coordinates\\n// WC - World coordinates\\n// VC - View coordinates\\n// DC - Display coordinates\\n// TC - Texture coordinates\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvoid main()\\n{\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the gpu image mapper fragment shader\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  //VTK::TCoord::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform mat4 WCTCMatrix;&quot;,&quot;out vec3 fragTexCoord;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;fragTexCoord = (WCTCMatrix * vertexWC).xyz;&quot;]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=[&quot;in vec3 fragTexCoord;&quot;,&quot;uniform highp sampler3D texture1;&quot;,&quot;uniform mat4 WCTCMatrix;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}s>0&&(u=u.concat([&quot;uniform vec3 spacing;&quot;,&quot;uniform float slabThickness;&quot;,&quot;uniform int slabType;&quot;,&quot;uniform int slabTrapezoid;&quot;,&quot;uniform vec3 vboScaling;&quot;]),u=u.concat([&quot;vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)&quot;,&quot;{&quot;,&quot;  vec4 retVal = vec4(1.0);&quot;,&quot;  if (slabType == 0) // min&quot;,&quot;  {&quot;,&quot;    retVal = min(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 1) // max&quot;,&quot;  {&quot;,&quot;    retVal = max(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 3) // sum&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  else // mean&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  return retVal;&quot;,&quot;}&quot;])),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,u).result;let d=[&quot;if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(texture1, fragTexCoord);&quot;];if(s>0&&(d=d.concat([&quot;// Get the first and last samples&quot;,&quot;int numSlices = 1;&quot;,&quot;float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;&quot;,&quot;vec3 normalxspacing = scaling * normalWCVSOutput;&quot;,&quot;float distTraveled = length(normalxspacing);&quot;,&quot;int trapezoid = 0;&quot;,&quot;while (distTraveled < slabThickness * 0.5)&quot;,&quot;{&quot;,&quot;  distTraveled += length(normalxspacing);&quot;,&quot;  float fnumSlices = float(numSlices);&quot;,&quot;  if (distTraveled > slabThickness * 0.5)&quot;,&quot;  {&quot;,&quot;    // Before stepping outside the slab, sample at the boundaries&quot;,&quot;    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;&quot;,&quot;    trapezoid = slabTrapezoid;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordNeg);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordPos);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;}&quot;,&quot;// Finally, if slab type is *mean*, divide the sum by the numSlices&quot;,&quot;if (slabType == 2)&quot;,&quot;{&quot;,&quot;  tvalue = tvalue / float(numSlices);&quot;,&quot;}&quot;])),c){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(l){case 1:d=d.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:d=d.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=[&quot;attribute vec4 vertexWC;&quot;];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat([&quot;attribute vec3 normalWC;&quot;,&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,c).result;let u=[&quot;gl_Position = MCPCMatrix * vertexWC;&quot;];l>0&&(u=u.concat([&quot;normalWCVSOutput = normalWC;&quot;,&quot;vertexWCVSOutput = vertexWC;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,u).result,a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result;let d=[];l>0&&(d=d.concat([&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),s=cd.substitute(s,&quot;//VTK::PositionVC::Dec&quot;,d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e=&quot;&quot;;const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`));const t=ue(n?.getDirection());ge(t,t);const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999||o>.999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ni.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getDimensions(),l=[0,i[0]-1,0,i[1]-1,0,i[2]-1];let c=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[c+a]=r[a],e[c+o[0]]=l[2*o[0]+n],e[c+o[1]]=l[2*o[1]+t],c+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const u=new Uint16Array(8);u[0]=3,u[1]=0,u[2]=1,u[3]=3,u[4]=3,u[5]=0,u[6]=3,u[7]=2;const d=s.getNormal();za.normalize(d);const p=new Float32Array(12);for(let e=0;e<4;++e)p[3*e]=d[0],p[3*e+1]=d[1],p[3*e+2]=d[2];t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(u,1);const f=Es.newInstance({numberOfComponents:3,values:p,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(f)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=gu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Es.newInstance({numberOfComponents:3,values:a,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(i)}else tg(&quot;Something went wrong.&quot;,&quot;A default slice plane should have been created in the beginning of&quot;,&quot;updateResliceGeometry.&quot;);t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)}}const ag={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,openGLTextureString:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1,_scalars:null};const ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ag,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=$f.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=gu.newInstance(),t.cutter=Df.newInstance(),t.lineToSurfaceFilter=wf.newInstance(),t.transform=Qf.newInstance(),bt(e,t,[&quot;openGLTexture&quot;]),og(e,t)}),&quot;vtkOpenGLImageResliceMapper&quot;);rn(&quot;vtkImageResliceMapper&quot;,ig);var sg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:lg}=Kt,{SlicingMode:cg}=sg;function ug(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function dg(e){const t=e.split(&quot;\\n&quot;),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function pg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t.renderable.isA(&quot;vtkImageMapper&quot;)&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(n.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,a=cd.substitute(a,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result,a=cd.substitute(a,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform sampler2D labelOutlineTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform float outlineOpacity;&quot;];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}}if(i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,c).result,!0===o.getProperty().getUseLabelOutline()&&(i=cd.substitute(i,&quot;//VTK::LabelOutline::Dec&quot;,[&quot;uniform int outlineThickness;&quot;,&quot;uniform float vpWidth;&quot;,&quot;uniform float vpHeight;&quot;,&quot;uniform float vpOffsetX;&quot;,&quot;uniform float vpOffsetY;&quot;,&quot;uniform mat4 PCWCMatrix;&quot;,&quot;uniform mat4 vWCtoIDX;&quot;,&quot;uniform ivec3 imageDimensions;&quot;]).result,i=cd.substitute(i,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result,i=cd.substitute(i,&quot;//VTK::LabelOutlineHelperFunction&quot;,[&quot;#ifdef vtkImageLabelOutlineOn&quot;,&quot;vec3 fragCoordToIndexSpace(vec4 fragCoord) {&quot;,&quot;  vec4 pcPos = vec4(&quot;,&quot;    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,&quot;,&quot;    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,&quot;,&quot;    (fragCoord.z - 0.5) * 2.0,&quot;,&quot;    1.0);&quot;,&quot;&quot;,&quot;  vec4 worldCoord = PCWCMatrix * pcPos;&quot;,&quot;  vec4 vertex = (worldCoord/worldCoord.w);&quot;,&quot;&quot;,&quot;  vec3 index = (vWCtoIDX * vertex).xyz;&quot;,&quot;&quot;,&quot;  // half voxel fix for labelmapOutline&quot;,&quot;  return (index + vec3(0.5)) / vec3(imageDimensions);&quot;,&quot;}&quot;,&quot;#endif&quot;]).result),l){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];let t=[&quot;vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);&quot;];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, opacity);&quot;]);break;case 2:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,t).result}else switch(s){case 1:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[...dg(&quot;\\n                #ifdef vtkImageLabelOutlineOn\\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); \\n                  float centerValue = texture2D(texture1, centerPosIS.xy).r;\\n                  bool pixelOnBorder = false;\\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\\n                  float opacityToUse = scalarOpacity * opacity;\\n                  int segmentIndex = int(centerValue * 255.0);\\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\\n                  int actualThickness = int(textureValue * 255.0);\\n\\n                  if (actualThickness == 0) {\\n                    gl_FragData[0] = vec4(0.0, 0.0, 1.0, 1.0);\\n                    return;\\n                  }\\n                  if (opacityToUse > 0.01) {\\n                    for (int i = -actualThickness; i <= actualThickness; i++) {\\n                      for (int j = -actualThickness; j <= actualThickness; j++) {\\n                        if (i == 0 || j == 0) {\\n                          continue;\\n                        }\\n                        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n                          gl_FragCoord.y + float(j),\\n                          gl_FragCoord.z, gl_FragCoord.w);\\n                        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n                        float value = texture2D(texture1, neighborPosIS.xy).r;\\n                        if (value != centerValue) {\\n                          pixelOnBorder = true;\\n                          break;\\n                        }\\n                      }\\n                      if (pixelOnBorder == true) {\\n                        break;\\n                      }\\n                    }\\n                    if (pixelOnBorder == true) {\\n                      gl_FragData[0] = vec4(tColor, outlineOpacity);\\n                    }\\n                    else {\\n                      gl_FragData[0] = vec4(tColor, opacityToUse);\\n                    }\\n                  }\\n                #else\\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\\n                #endif\\n                &quot;)]).result;break;case 2:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;float intensity = tcolor.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);&quot;]).result;break;case 3:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]).result;break;default:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;]).result}t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||lg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||lg(&quot;Error setting tcoordMC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi(&quot;texture1&quot;,a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi(&quot;colorTexture1&quot;,c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi(&quot;pwfTexture1&quot;,u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;labelOutlineTexture1&quot;,p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf(&quot;outlineOpacity&quot;,e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();a.setUniform3i(&quot;imageDimensions&quot;,o[0],o[1],1),a.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const i=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,i.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const l=e.getRenderTargetSize();a.setUniformf(&quot;vpWidth&quot;,l[0]),a.setUniformf(&quot;vpHeight&quot;,l[1]);const c=e.getRenderTargetOffset();a.setUniformf(&quot;vpOffsetX&quot;,c[0]/l[0]),a.setUniformf(&quot;vpOffsetY&quot;,c[1]/l[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf(&quot;opacity&quot;,o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):lg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=ug(l,f,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.vtkObj&&m?.hash===g&&t.colorTextureString===g)t.colorTexture=m.vtkObj,t.colorTextureString=m.hash;else{const e=1024,n=new Uint8Array(e*p*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST)):(t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR)),f){const r=new Float32Array(3*e);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),u)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,p,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=g,f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,t.colorTextureString)}const h=l.getPiecewiseFunction(),v=ug(l,h,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.vtkObj&&y?.hash===v&&t.pwfTextureString===v)t.pwfTexture=y.vtkObj,t.pwfTextureString=y.hash;else{const e=1024,n=e*p,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),h){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<d;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),u)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,p,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=v,h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,t.pwfTextureString)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA(&quot;vtkImageArrayMapper&quot;)?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===cg.I&&(S=x-C[0]),T===cg.J&&(S=x-C[2]),T!==cg.K&&T!==cg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Nd.newInstance({resizable:!0}),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(new Set([1,3,4]).has(s)&&i===ys.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.NEAREST)):t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST)):(4!==s||i!==ys.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(bd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(bd.LINEAR)),t.openGLTexture.setWrapS(Td.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Td.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[cg.X,cg.Y,cg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===cg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===cg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===cg.K||T===cg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):lg(&quot;Reformat slicing not yet supported.&quot;);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);m?.vtkObj?(t.openGLTexture=m.vtkObj,t.VBOBuildString=m.hash):(t._scalars!==g&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=g),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t._openGLRenderWindow.setGraphicsResourceForObject(g,t.openGLTexture,t.VBOBuildString)),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Es.newInstance({numberOfComponents:3,values:r});h.setName(&quot;points&quot;);const v=Es.newInstance({numberOfComponents:2,values:l});v.setName(&quot;tcoords&quot;);const y=new Uint16Array(8);y[0]=3,y[1]=0,y[2]=1,y[3]=3,y[4]=3,y[5]=0,y[6]=3,y[7]=2;const C=Es.newInstance({numberOfComponents:1,values:y});t.tris.getCABO().createVBO(C,&quot;polys&quot;,rs.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=e=>{t.labelOutlineThicknessTexture||(t.labelOutlineThicknessTexture=Nd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]}}const fg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,_scalars:null};const gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fg,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),pg(e,t)}),&quot;vtkOpenGLImageMapper&quot;);rn(&quot;vtkAbstractImageMapper&quot;,gg);const{vtkErrorMacro:mg}=jt;function hg(e,t,n){if(t.apply(e)){const t=e.getIndependentComponents();return`${e.getMTime()}-${t}-${n}`}return&quot;0&quot;}function vg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageCPRMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow))},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentImageDataInput,o=t.currentCenterlineInput;n.getProperty().getInterpolationType()===Jf.NEAREST?(t.volumeTexture.setMinificationFilter(bd.NEAREST),t.volumeTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.volumeTexture.setMinificationFilter(bd.LINEAR),t.volumeTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR));const a=r.getMTime();if(t.volumeTextureTime!==a){const e=r.getDimensions(),n=r.getPointData().getScalars();if(!n)return;t.volumeTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.volumeTexture.releaseGraphicsResources(t._openGLRenderWindow),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromRaw(e[0],e[1],e[2],n.getNumberOfComponents(),n.getDataType(),n.getData(),t.renderable.getPreferSizeOverAccuracy()),t.volumeTextureTime=a}const i=r.getPointData()&&r.getPointData().getScalars();if(!i)return;const s=i.getNumberOfComponents(),l=n.getProperty(),c=l.getIndependentComponents(),u=c?s:1,d=c?2*u:1,p=hg(l,l.getRGBTransferFunction,u);if(t.colorTextureString!==p){const e=1024,n=new Uint8Array(e*d*3);let r=l.getRGBTransferFunction();if(r){const o=new Float32Array(3*e);for(let t=0;t<u;t++){r=l.getRGBTransferFunction(t);const a=r.getRange();if(r.getTable(a[0],a[1],e,o,1),c)for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r],n[t*e*6+r+3*e]=255*o[r];else for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=p}const f=hg(l,l.getPiecewiseFunction,u);if(t.pwfTextureString!==f){const e=1024,n=e*d,r=new Uint8Array(n);let o=l.getPiecewiseFunction();if(t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),o){const r=new Float32Array(n),a=new Float32Array(e);for(let t=0;t<u;++t)if(o=l.getPiecewiseFunction(t),null===o)r.fill(1);else{const n=o.getRange();if(o.getTable(n[0],n[1],e,a,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=a[n],r[t*e*2+n+e]=a[n];else for(let n=0;n<e;n++)r[t*e*2+n]=a[n]}t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=f}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<o.getMTime()){const e=o.getNumberOfPoints(),n=e<=1?0:e-1,r=o.getDistancesToFirstPoint(),a=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,a-r[e],0],t),t+=3,s.set([l,a-r[e],0],t),t+=3,s.set([l,a-r[e+1],0],t),t+=3,s.set([0,a-r[e+1],0],t),t+=3;const c=Es.newInstance({numberOfComponents:3,values:s});c.setName(&quot;points&quot;);const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Es.newInstance({numberOfComponents:1,values:u}),p=o.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Es.newInstance({numberOfComponents:3,values:f,name:&quot;centerlinePosition&quot;}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Es.newInstance({numberOfComponents:1,values:v,name:&quot;quadIndex&quot;})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getCenterlineTangentDirections(),r=new Float32Array(3*i),o=new Float32Array(3*i);for(let t=0,a=0;t<n;++t){const n=3*t;for(let t=0;t<4;++t)r[a+0]=e[n+0],r[a+1]=e[n+1],r[a+2]=e[n+2],o[a+0]=e[n+3],o[a+1]=e[n+4],o[a+2]=e[n+5],a+=3}const a=Es.newInstance({numberOfComponents:3,values:r,name:&quot;centerlineTopDirection&quot;}),s=Es.newInstance({numberOfComponents:3,values:o,name:&quot;centerlineBotDirection&quot;});y.push(a,s)}t.tris.getCABO().createVBO(d,&quot;polys&quot;,rs.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result;const s=[&quot;attribute vec3 centerlinePosition;&quot;,&quot;attribute float quadIndex;&quot;,&quot;uniform float width;&quot;,&quot;out vec2 quadOffsetVSOutput;&quot;,&quot;out vec3 centerlinePosVSOutput;&quot;],l=t.renderable.getUseUniformOrientation();l?s.push(&quot;out vec3 centerlineDirVSOutput;&quot;,&quot;uniform vec3 centerlineDirection;&quot;):s.push(&quot;out vec3 centerlineTopDirVSOutput;&quot;,&quot;out vec3 centerlineBotDirVSOutput;&quot;,&quot;out float centerlineAngleVSOutput;&quot;,&quot;attribute vec3 centerlineTopDirection;&quot;,&quot;attribute vec3 centerlineBotDirection;&quot;),a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,s).result;const c=[&quot;quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);&quot;,&quot;centerlinePosVSOutput = centerlinePosition;&quot;];l?c.push(&quot;centerlineDirVSOutput = centerlineDirection;&quot;):c.push(&quot;vec3 sumVec = centerlineTopDirection + centerlineBotDirection;&quot;,&quot;float sumLen2 = dot(sumVec, sumVec);&quot;,&quot;float diffLen2 = 4.0 - sumLen2;&quot;,&quot;if (diffLen2 < 0.001) {&quot;,&quot;  // vectors are too close to each other, use lerp&quot;,&quot;  centerlineAngleVSOutput = -1.0; // use negative angle as a flag for lerp&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection;&quot;,&quot;} else if (sumLen2 == 0.0) {&quot;,&quot;  // vector are opposite to each other, don't make a choice for the user&quot;,&quot;  // use slerp without direction, it will display the centerline color on each row of pixel&quot;,&quot;  centerlineAngleVSOutput = 0.0;&quot;,&quot;  centerlineTopDirVSOutput = vec3(0.0);&quot;,&quot;  centerlineBotDirVSOutput = vec3(0.0);&quot;,&quot;} else {&quot;,&quot;  // use slerp&quot;,&quot;  centerlineAngleVSOutput = 2.0 * atan(sqrt(diffLen2/sumLen2));&quot;,&quot;  float sinAngle = sin(centerlineAngleVSOutput);&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection / sinAngle;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection / sinAngle;&quot;,&quot;}&quot;),a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,c).result;const u=t.volumeTexture.getComponents(),d=o.getProperty().getIndependentComponents();let p=[&quot;uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates&quot;,&quot;in vec2 quadOffsetVSOutput;&quot;,&quot;in vec3 centerlinePosVSOutput;&quot;,&quot;uniform highp sampler3D volumeTexture;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;];l?p.push(&quot;in vec3 centerlineDirVSOutput;&quot;):p.push(&quot;in vec3 centerlineTopDirVSOutput;&quot;,&quot;in vec3 centerlineBotDirVSOutput;&quot;,&quot;in float centerlineAngleVSOutput;&quot;);const f=t.renderable.getCenterPoint();if(f&&p.push(&quot;uniform vec3 globalCenterPoint;&quot;),d){for(let e=1;e<u;e++)p=p.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(u){case 1:p=p.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,p).result;let g=[];if(l?g.push(&quot;vec3 interpolatedCenterlineDir = centerlineDirVSOutput;&quot;):g.push(&quot;vec3 interpolatedCenterlineDir;&quot;,&quot;if (centerlineAngleVSOutput < 0.0) {&quot;,&quot;  // Lerp&quot;,&quot;  interpolatedCenterlineDir = quadOffsetVSOutput.y * centerlineTopDirVSOutput + (1.0 - quadOffsetVSOutput.y) * centerlineBotDirVSOutput;&quot;,&quot;} else {&quot;,&quot;  // Slerp&quot;,&quot;  float topInterpolationAngle = quadOffsetVSOutput.y * centerlineAngleVSOutput;&quot;,&quot;  float botInterpolationAngle = centerlineAngleVSOutput - topInterpolationAngle;&quot;,&quot;  interpolatedCenterlineDir = sin(topInterpolationAngle) * centerlineTopDirVSOutput + sin(botInterpolationAngle) * centerlineBotDirVSOutput;&quot;,&quot;}&quot;,&quot;// Slerp should give a normalized vector but when sin(angle) is small, rounding error occurs&quot;,&quot;// Normalize for both lerp and slerp&quot;,&quot;interpolatedCenterlineDir = normalize(interpolatedCenterlineDir);&quot;),f?g.push(&quot;float baseOffset = dot(interpolatedCenterlineDir, globalCenterPoint - centerlinePosVSOutput);&quot;,&quot;float horizontalOffset = quadOffsetVSOutput.x + baseOffset;&quot;):g.push(&quot;float horizontalOffset = quadOffsetVSOutput.x;&quot;),g.push(&quot;vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * interpolatedCenterlineDir;&quot;,&quot;vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;&quot;,&quot;if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(volumeTexture, volumePosTC);&quot;),d){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<u;++t)g=g.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(u){case 1:g=g.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(u){case 1:g=g.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:g=g.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,g).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||mg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getCABO().getCustomData().forEach((e=>{e&&n.getProgram().isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),e.name,e.offset,n.getCABO().getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&mg(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const a=t.volumeTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;volumeTexture&quot;,a),n.getProgram().setUniformf(&quot;width&quot;,t.renderable.getWidth()),n.getProgram().setUniform4f(&quot;backgroundColor&quot;,...t.renderable.getBackgroundColor()),n.getProgram().isUniformUsed(&quot;centerlineDirection&quot;)){const e=t.renderable.getUniformDirection();n.getProgram().setUniform3fArray(&quot;centerlineDirection&quot;,e)}if(n.getProgram().isUniformUsed(&quot;globalCenterPoint&quot;)){const e=t.renderable.getCenterPoint();n.getProgram().setUniform3fArray(&quot;globalCenterPoint&quot;,e)}const i=t.currentImageDataInput,s=i.getWorldToIndex(),l=P(new Float32Array(16),Rn([],i.getDimensions())),c=oe(l,l,s);if(n.getProgram().setUniformMatrix(&quot;MCTCMatrix&quot;,c),t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)}}const yg={currentRenderPass:null,volumeTexture:null,volumeTextureTime:0,colorTexture:null,colorTextureString:null,pwfTexture:null,pwfTextureString:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Tg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yg,n),Zt.extend(e,t,n),kd(e,t,n),jt.algo(e,t,2,0),t.tris=yd.newInstance(),t.volumeTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.pwfTexture=Nd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),vg(e,t)}),&quot;vtkOpenGLImageCPRMapper&quot;);function bg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageSlice&quot;),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkImageCPRMapper&quot;,Tg);const xg={context:null,keyMatrixTime:null,keyMatrices:null};const Cg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bg(e,t)}),&quot;vtkOpenGLImageSlice&quot;);function Sg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolume&quot;),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn(&quot;vtkImageSlice&quot;,Cg);const Ag={};const Ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ag,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,[&quot;context&quot;]),Sg(e,t)}),&quot;vtkOpenGLVolume&quot;);rn(&quot;vtkVolume&quot;,Ig);const wg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},Pg={FRACTIONAL:0,PROPORTIONAL:1};var Og={InterpolationType:wg,OpacityMode:Pg};const Rg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5};var Mg={BlendMode:Rg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Dg,vtkErrorMacro:Eg}=Kt;function Vg(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function Lg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolumeMapper&quot;),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType(&quot;vtkOpenGLVolume&quot;);const n=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const r=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera()),e.renderPiece(r,n)}},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\n\\nvarying vec3 vertexVCVSOutput;\\nuniform mat4 PCVCMatrix;\\n\\nuniform float dcxmin;\\nuniform float dcxmax;\\nuniform float dcymin;\\nuniform float dcymax;\\n\\nvoid main()\\n{\\n  // dcsmall is the device coords reduced to the\\n  // x y area covered by the volume\\n  vec4 dcsmall = vec4(\\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\\n    vertexDC.z,\\n    vertexDC.w);\\n  vec4 vcpos = PCVCMatrix * dcsmall;\\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\\n  gl_Position = dcsmall;\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkVolumeFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the volume mappers fragment shader\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvarying vec3 vertexVCVSOutput;\\n\\n// first declare the settings from the mapper\\n// that impact the code paths in here\\n\\n// always set vtkNumComponents 1,2,3,4\\n//VTK::NumComponents\\n\\n// possibly define vtkTrilinearOn\\n//VTK::TrilinearOn\\n\\n// possibly define vtkIndependentComponents\\n//VTK::IndependentComponentsOn\\n\\n// possibly define any \\&quot;proportional\\&quot; components\\n//VTK::vtkProportionalComponents\\n\\n// Define the blend mode to use\\n#define vtkBlendMode //VTK::BlendMode\\n\\n// Possibly define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n#ifdef vtkImageLabelOutlineOn\\n\\nuniform float outlineOpacity;\\nuniform float vpWidth;\\nuniform float vpHeight;\\nuniform float vpOffsetX;\\nuniform float vpOffsetY;\\nuniform mat4 PCWCMatrix;\\nuniform mat4 vWCtoIDX;\\n#endif\\n\\n// define vtkLightComplexity\\n//VTK::LightComplexity\\n#if vtkLightComplexity > 0\\nuniform float vSpecularPower;\\nuniform float vAmbient;\\nuniform float vDiffuse;\\nuniform float vSpecular;\\n//VTK::Light::Dec\\n#endif\\n\\n//VTK::VolumeShadowOn\\n//VTK::SurfaceShadowOn\\n//VTK::localAmbientOcclusionOn\\n//VTK::LAO::Dec\\n//VTK::VolumeShadow::Dec\\n\\n// define vtkComputeNormalFromOpacity\\n//VTK::vtkComputeNormalFromOpacity\\n\\n// possibly define vtkGradientOpacityOn\\n//VTK::GradientOpacityOn\\n#ifdef vtkGradientOpacityOn\\nuniform float goscale0;\\nuniform float goshift0;\\nuniform float gomin0;\\nuniform float gomax0;\\n#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\nuniform float goscale1;\\nuniform float goshift1;\\nuniform float gomin1;\\nuniform float gomax1;\\n#if vtkNumComponents >= 3\\nuniform float goscale2;\\nuniform float goshift2;\\nuniform float gomin2;\\nuniform float gomax2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float goscale3;\\nuniform float goshift3;\\nuniform float gomin3;\\nuniform float gomax3;\\n#endif\\n#endif\\n#endif\\n\\n// if you want to see the raw tiled\\n// data in webgl1 uncomment the following line\\n// #define debugtile\\n\\n// camera values\\nuniform float camThick;\\nuniform float camNear;\\nuniform float camFar;\\nuniform int cameraParallel;\\n\\n// values describing the volume geometry\\nuniform vec3 vOriginVC;\\nuniform vec3 vSpacing;\\nuniform ivec3 volumeDimensions; // 3d texture dimensions\\nuniform vec3 vPlaneNormal0;\\nuniform float vPlaneDistance0;\\nuniform vec3 vPlaneNormal1;\\nuniform float vPlaneDistance1;\\nuniform vec3 vPlaneNormal2;\\nuniform float vPlaneDistance2;\\nuniform vec3 vPlaneNormal3;\\nuniform float vPlaneDistance3;\\nuniform vec3 vPlaneNormal4;\\nuniform float vPlaneDistance4;\\nuniform vec3 vPlaneNormal5;\\nuniform float vPlaneDistance5;\\n\\n//VTK::ClipPlane::Dec\\n\\n// opacity and color textures\\nuniform sampler2D otexture;\\nuniform float oshift0;\\nuniform float oscale0;\\nuniform sampler2D ctexture;\\nuniform float cshift0;\\nuniform float cscale0;\\n\\n// jitter texture\\nuniform sampler2D jtexture;\\nuniform sampler2D ttexture;\\n\\n\\n// some 3D texture values\\nuniform float sampleDistance;\\nuniform vec3 vVCToIJK;\\n\\n// the heights defined below are the locations\\n// for the up to four components of the tfuns\\n// the tfuns have a height of 2XnumComps pixels so the\\n// values are computed to hit the middle of the two rows\\n// for that component\\n#ifdef vtkIndependentComponentsOn\\n#if vtkNumComponents == 2\\nuniform float mix0;\\nuniform float mix1;\\n#define height0 0.25\\n#define height1 0.75\\n#endif\\n#if vtkNumComponents == 3\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\n#define height0 0.17\\n#define height1 0.5\\n#define height2 0.83\\n#endif\\n#if vtkNumComponents == 4\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\nuniform float mix3;\\n#define height0 0.125\\n#define height1 0.375\\n#define height2 0.625\\n#define height3 0.875\\n#endif\\n#endif\\n\\n#if vtkNumComponents >= 2\\nuniform float oshift1;\\nuniform float oscale1;\\nuniform float cshift1;\\nuniform float cscale1;\\n#endif\\n#if vtkNumComponents >= 3\\nuniform float oshift2;\\nuniform float oscale2;\\nuniform float cshift2;\\nuniform float cscale2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float oshift3;\\nuniform float oscale3;\\nuniform float cshift3;\\nuniform float cscale3;\\n#endif\\n\\nuniform vec4 ipScalarRangeMin;\\nuniform vec4 ipScalarRangeMax;\\n\\n// declaration for intermixed geometry\\n//VTK::ZBuffer::Dec\\n\\n//=======================================================================\\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\\nvec3 rayDirVC;\\nfloat sampleDistanceISVS;\\nfloat sampleDistanceIS;\\n\\n#define SQRT3    1.7321\\n#define INV4PI   0.0796\\n#define EPSILON  0.001\\n#define PI       3.1415\\n#define PI2      9.8696\\n\\n//=======================================================================\\n// Webgl2 specific version of functions\\n#if __VERSION__ == 300\\n\\nuniform highp sampler3D texture1;\\n\\nvec4 getTextureValue(vec3 pos)\\n{\\n  vec4 tmp = texture(texture1, pos);\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.a = tmp.g;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n  return tmp;\\n}\\n\\n//=======================================================================\\n// WebGL1 specific version of functions\\n#else\\n\\nuniform sampler2D texture1;\\n\\nuniform float texWidth;\\nuniform float texHeight;\\nuniform int xreps;\\nuniform int xstride;\\nuniform int ystride;\\n\\n// if computing trilinear values from multiple z slices\\n#ifdef vtkTrilinearOn\\nvec4 getTextureValue(vec3 ijk)\\n{\\n  float zoff = 1.0/float(volumeDimensions.z);\\n  vec4 val1 = getOneTextureValue(ijk);\\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\\n\\n  float indexZ = float(volumeDimensions)*ijk.z;\\n  float zmix =  indexZ - floor(indexZ);\\n\\n  return mix(val1, val2, zmix);\\n}\\n\\nvec4 getOneTextureValue(vec3 ijk)\\n#else // nearest or fast linear\\nvec4 getTextureValue(vec3 ijk)\\n#endif\\n{\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n#ifdef debugtile\\n  vec2 tpos = vec2(ijk.x, ijk.y);\\n  vec4 tmp = texture2D(texture1, tpos);\\n  tmp.a = 1.0;\\n\\n#else\\n  int z = int(ijk.z * tdims.z);\\n  int yz = z / xreps;\\n  int xz = z - yz*xreps;\\n\\n  int tileWidth = volumeDimensions.x/xstride;\\n  int tileHeight = volumeDimensions.y/ystride;\\n\\n  xz *= tileWidth;\\n  yz *= tileHeight;\\n\\n  float ni = float(xz) + (ijk.x*float(tileWidth));\\n  float nj = float(yz) + (ijk.y*float(tileHeight));\\n\\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\\n\\n  vec4 tmp = texture2D(texture1, tpos);\\n\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.g = tmp.a;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n#endif\\n\\n  return tmp;\\n}\\n\\n// End of Webgl1 specific code\\n//=======================================================================\\n#endif\\n\\n//=======================================================================\\n// transformation between VC and IS space\\n\\n// convert vector position from idx to vc\\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\\nvec3 IStoVC(vec3 posIS){\\n  vec3 posVC = posIS / vVCToIJK;\\n  return posVC.x * vPlaneNormal0 +\\n         posVC.y * vPlaneNormal2 +\\n         posVC.z * vPlaneNormal4 +\\n         vOriginVC;\\n}\\n\\n// convert vector position from vc to idx\\nvec3 VCtoIS(vec3 posVC){\\n  posVC = posVC - vOriginVC;\\n  posVC = vec3(\\n    dot(posVC, vPlaneNormal0),\\n    dot(posVC, vPlaneNormal2),\\n    dot(posVC, vPlaneNormal4));\\n  return posVC * vVCToIJK;\\n}\\n#endif\\n\\n//Rotate vector to view coordinate\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\nvoid rotateToViewCoord(inout vec3 dirIS){\\n  dirIS.xyz =\\n    dirIS.x * vPlaneNormal0 +\\n    dirIS.y * vPlaneNormal2 +\\n    dirIS.z * vPlaneNormal4;\\n}\\n\\n//Rotate vector to idx coordinate\\nvec3 rotateToIDX(vec3 dirVC){\\n  vec3 dirIS;\\n  dirIS.xyz = vec3(\\n    dot(dirVC, vPlaneNormal0),\\n    dot(dirVC, vPlaneNormal2),\\n    dot(dirVC, vPlaneNormal4));\\n  return dirIS;\\n}\\n#endif\\n\\n//=======================================================================\\n// Given a normal compute the gradient opacity factors\\nfloat computeGradientOpacityFactor(\\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\\n{\\n#if defined(vtkGradientOpacityOn)\\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\\n#else\\n  return 1.0;\\n#endif\\n}\\n\\n//=======================================================================\\n// compute the normal and gradient magnitude for a position, uses forward difference\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\n#ifdef vtkClippingPlanesOn\\n  void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\\n  {\\n    vec3 g1VC[3];\\n    for (int i = 0; i < 3; ++i)\\n    {\\n      g1VC[i] = IStoVC(texPos[i]);\\n    }\\n    vec3 posVC = IStoVC(pos);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      for (int j = 0; j < 3; ++j)\\n      {\\n        if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\\n        {\\n          g1[j] = 0.0;\\n        }\\n      }\\n    }\\n  }\\n#endif\\n\\n  #ifdef vtkComputeNormalFromOpacity\\n    #ifdef vtkGradientOpacityOn\\n      vec4 computeDensityNormal(float gradientMag, vec3 scalarInterp[2])\\n      {\\n    #else\\n      //if gradient opacity not on but using density gradient\\n      vec4 computeDensityNormal(vec3 scalarInterp[2])\\n      {\\n    #endif\\n        vec3 opacityG1, opacityG2;\\n        opacityG1.x = texture2D(otexture, vec2(scalarInterp[0].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.y = texture2D(otexture, vec2(scalarInterp[0].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.z = texture2D(otexture, vec2(scalarInterp[0].z * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.x = texture2D(otexture, vec2(scalarInterp[1].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.y = texture2D(otexture, vec2(scalarInterp[1].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.z = texture2D(otexture, vec2(scalarInterp[1].z * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n        float gradOpacityFactor = 1.0f;\\n        if (gradientMag >= 0.0){\\n          gradOpacityFactor = computeGradientOpacityFactor(gradientMag, goscale0, goshift0, gomin0, gomax0);\\n        }\\n        opacityG1.xyz *= gradOpacityFactor;\\n        opacityG2.xyz *= gradOpacityFactor;\\n    #endif\\n\\n        vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\\n        // divide by spacing\\n        opacityG.xyz /= vSpacing;\\n        opacityG.w = length(opacityG.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(opacityG.xyz);\\n        if (length(opacityG.xyz) > 0.0) {\\n          return vec4(normalize(opacityG.xyz),opacityG.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n\\n      vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2])\\n      {\\n        vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n        vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n        vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n        vec3 texPosPVec[3];\\n        texPosPVec[0] = pos + xvec;\\n        texPosPVec[1] = pos + yvec;\\n        texPosPVec[2] = pos + zvec;\\n        vec3 texPosNVec[3];\\n        texPosNVec[0] = pos - xvec;\\n        texPosNVec[1] = pos - yvec;\\n        texPosNVec[2] = pos - zvec;\\n        vec3 g1, g2;\\n\\n        scalarInterp[0].x = getTextureValue(texPosPVec[0]).a;\\n        scalarInterp[0].y = getTextureValue(texPosPVec[1]).a;\\n        scalarInterp[0].z = getTextureValue(texPosPVec[2]).a;\\n        scalarInterp[1].x = getTextureValue(texPosNVec[0]).a;\\n        scalarInterp[1].y = getTextureValue(texPosNVec[1]).a;\\n        scalarInterp[1].z = getTextureValue(texPosNVec[2]).a;\\n\\n        #ifdef vtkClippingPlanesOn\\n          adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\\n          adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\\n        #endif\\n        vec4 result;\\n        result.x = scalarInterp[0].x - scalarInterp[1].x;\\n        result.y = scalarInterp[0].y - scalarInterp[1].y;\\n        result.z = scalarInterp[0].z - scalarInterp[1].z;\\n        // divide by spacing\\n        result.xyz /= vSpacing;\\n        result.w = length(result.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(result.xyz);\\n        if (length(result.xyz) > 0.0) {\\n          return vec4(normalize(result.xyz),result.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n  #endif\\n\\n  vec4 computeNormal(vec3 pos, vec3 tstep)\\n  {\\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n    vec3 texPosPVec[3];\\n    texPosPVec[0] = pos + xvec;\\n    texPosPVec[1] = pos + yvec;\\n    texPosPVec[2] = pos + zvec;\\n    vec3 texPosNVec[3];\\n    texPosNVec[0] = pos - xvec;\\n    texPosNVec[1] = pos - yvec;\\n    texPosNVec[2] = pos - zvec;\\n    vec3 g1, g2;\\n    g1.x = getTextureValue(texPosPVec[0]).a;\\n    g1.y = getTextureValue(texPosPVec[1]).a;\\n    g1.z = getTextureValue(texPosPVec[2]).a;\\n    g2.x = getTextureValue(texPosNVec[0]).a;\\n    g2.y = getTextureValue(texPosNVec[1]).a;\\n    g2.z = getTextureValue(texPosNVec[2]).a;\\n    #ifdef vtkClippingPlanesOn\\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\\n    #endif\\n    vec4 result;\\n    result = vec4(g1 - g2, -1.0);\\n    // divide by spacing\\n    result.xyz /= vSpacing;\\n    result.w = length(result.xyz);\\n    if (result.w > 0.0){\\n      // rotate to View Coords\\n      rotateToViewCoord(result.xyz);\\n      return vec4(normalize(result.xyz),result.w);\\n    } else {\\n      return vec4(0.0);\\n    }\\n  }\\n#endif\\n\\n#ifdef vtkImageLabelOutlineOn\\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\\n  vec4 pcPos = vec4(\\n    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\\n    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\\n    (fragCoord.z - 0.5) * 2.0,\\n    1.0);\\n\\n  vec4 worldCoord = PCWCMatrix * pcPos;\\n  vec4 vertex = (worldCoord/worldCoord.w);\\n\\n  vec3 index = (vWCtoIDX * vertex).xyz;\\n\\n  // half voxel fix for labelmapOutline\\n  return (index + vec3(0.5)) / vec3(volumeDimensions);\\n}\\n#endif\\n\\n//=======================================================================\\n// compute the normals and gradient magnitudes for a position\\n// for independent components\\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\\n{\\n  mat4 result;\\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\\n\\n  // divide by spacing\\n  distX /= vSpacing.x;\\n  distY /= vSpacing.y;\\n  distZ /= vSpacing.z;\\n\\n  mat3 rot;\\n  rot[0] = vPlaneNormal0;\\n  rot[1] = vPlaneNormal2;\\n  rot[2] = vPlaneNormal4;\\n\\n#if !defined(vtkComponent0Proportional)\\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\\n  result[0].a = length(result[0].xyz);\\n  result[0].xyz *= rot;\\n  if (result[0].w > 0.0)\\n  {\\n    result[0].xyz /= result[0].w;\\n  }\\n#endif\\n\\n// optionally compute the 2nd component\\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\\n  result[1].a = length(result[1].xyz);\\n  result[1].xyz *= rot;\\n  if (result[1].w > 0.0)\\n  {\\n    result[1].xyz /= result[1].w;\\n  }\\n#endif\\n\\n// optionally compute the 3rd component\\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\\n  result[2].a = length(result[2].xyz);\\n  result[2].xyz *= rot;\\n  if (result[2].w > 0.0)\\n  {\\n    result[2].xyz /= result[2].w;\\n  }\\n#endif\\n\\n// optionally compute the 4th component\\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\\n  result[3].a = length(result[3].xyz);\\n  result[3].xyz *= rot;\\n  if (result[3].w > 0.0)\\n  {\\n    result[3].xyz /= result[3].w;\\n  }\\n#endif\\n\\n  return result;\\n}\\n\\n//=======================================================================\\n// global shadow - secondary ray\\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\\nfloat random()\\n{\\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\\n  uint pcg_state = floatBitsToUint(jitter);\\n  uint state = pcg_state;\\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\\n}\\n#endif\\n\\n#ifdef VolumeShadowOn\\n// henyey greenstein phase function\\nfloat phase_function(float cos_angle)\\n{\\n  // divide by 2.0 instead of 4pi to increase intensity\\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\\n}\\n\\n// Computes the intersection between a ray and a box\\nstruct Hit\\n{\\n  float tmin;\\n  float tmax;\\n};\\n\\nstruct Ray\\n{\\n  vec3 origin;\\n  vec3 dir;\\n  vec3 invDir;\\n};\\n\\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\\n{\\n  vec3 tbot = r.invDir * (boundMin - r.origin);\\n  vec3 ttop = r.invDir * (boundMax - r.origin);\\n  vec3 tmin = min(ttop, tbot);\\n  vec3 tmax = max(ttop, tbot);\\n  vec2 t = max(tmin.xx, tmin.yz);\\n  float t0 = max(t.x, t.y);\\n  t = min(tmax.xx, tmax.yz);\\n  float t1 = min(t.x, t.y);\\n  hit.tmin = t0;\\n  hit.tmax = t1;\\n  return t1 > max(t0,0.0);\\n}\\n\\n// As BBoxIntersect requires the inverse of the ray coords,\\n// this function is used to avoid numerical issues\\nvoid safe_0_vector(inout Ray ray)\\n{\\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\\n}\\n\\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\\n{\\n  float shadow = 1.0;\\n  float opacity = 0.0;\\n\\n  // modify sample distance with a random number between 1.5 and 3.0\\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\\n\\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\\n\\n  // compute the start and end points for the ray\\n  Ray ray;\\n  Hit hit;\\n  ray.origin = posIS;\\n  ray.dir = lightDirNormIS;\\n  safe_0_vector(ray);\\n  ray.invDir = 1.0/ray.dir;\\n\\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\\n  {\\n    return 1.0;\\n  }\\n  float maxdist = hit.tmax;\\n\\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\\n  maxdist = min(maxdist,maxgi);\\n  if(maxdist < EPSILON) {\\n    return 1.0;\\n  }\\n\\n  // support gradient opacity\\n  #ifdef vtkGradientOpacityOn\\n    vec4 normal;\\n  #endif\\n\\n  float current_dist = 0.0;\\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\\n  float clamped_step = 0.0;\\n\\n  vec4 scalar = vec4(0.0);\\n  while(current_dist < maxdist)\\n  {\\n#ifdef vtkClippingPlanesOn\\n    vec3 posVC = IStoVC(posIS);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\\n      {\\n        current_dist = maxdist;\\n      }\\n    }\\n#endif\\n    scalar = getTextureValue(posIS);\\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n      normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    shadow *= 1.0 - opacity;\\n\\n    // optimization: early termination\\n    if (shadow < EPSILON){\\n      return 0.0;\\n    }\\n\\n    clamped_step = min(maxdist - current_dist, current_step);\\n    posIS += clamped_step * lightDirNormIS;\\n    current_dist += current_step;\\n  }\\n\\n  return shadow;\\n}\\n\\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\\n{\\n  vec3 vertLight = vec3(0.0);\\n  vec3 secondary_contrib = vec3(0.0);\\n  // here we assume only positional light, no effect of cones\\n  for (int i = 0; i < lightNum; i++)\\n  {\\n    #if(vtkLightComplexity==3)\\n      if (lightPositional[i] == 1){\\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\\n      }else{\\n        vertLight = - lightDirectionVC[i];\\n      }\\n    #else\\n      vertLight = - lightDirectionVC[i];\\n    #endif\\n    // here we assume achromatic light, only intensity\\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\\n    float phase_attenuation = 0.5;\\n    if (abs(anisotropy) > EPSILON){\\n      phase_attenuation = phase_function(dDotL);\\n    }\\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\\n    secondary_contrib += tColor * vAmbient;\\n  }\\n  return secondary_contrib;\\n}\\n#endif\\n\\n//=======================================================================\\n// local ambient occlusion\\n#ifdef localAmbientOcclusionOn\\nvec3 sample_direction_uniform(int i)\\n{\\n  float rand = random() * 0.5;\\n  float theta = PI2 * (kernelSample[i][0] + rand);\\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\\n}\\n\\n// return a matrix that transform startDir into z axis; startDir should be normalized\\nmat3 zBaseRotationalMatrix(vec3 startDir){\\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\\n  float cosA = startDir.z;\\n  float k = 1.0 / (1.0 + cosA);\\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\\n  return matrix;\\n}\\n\\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\\n  // apply LAO only at selected locations, otherwise return full brightness\\n  if (normal.w > 0.0 && op > 0.05){\\n    float total_transmittance = 0.0;\\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\\n    vec3 currPos, randomDirStep;\\n    float weight, transmittance, opacity;\\n    for (int i = 0; i < kernelSize; i++)\\n    {\\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\\n      currPos = posIS;\\n      transmittance = 1.0;\\n      for (int j = 0; j < kernelRadius ; j++){\\n        currPos += randomDirStep;\\n        // check if it's at clipping plane, if so return full brightness\\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\\n          #ifdef vtkGradientOpacityOn\\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n          #endif\\n          transmittance *= 1.0 - opacity;\\n        }\\n        else{\\n          break;\\n        }\\n      }\\n      total_transmittance += transmittance / float(kernelRadius) * weight;\\n\\n      // early termination if fully translucent\\n      if (total_transmittance > 1.0 - EPSILON){\\n        return 1.0;\\n      }\\n    }\\n    // average transmittance and reduce variance\\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\\n  } else {\\n    return 1.0;\\n  }\\n}\\n#endif\\n\\n//=======================================================================\\n// surface light contribution\\n#if vtkLightComplexity > 0\\n  void applyLighting(inout vec3 tColor, vec4 normal)\\n  {\\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\\n    vec3 specular = vec3(0.0, 0.0, 0.0);\\n    float df, sf = 0.0;\\n    for (int i = 0; i < lightNum; i++){\\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\\n        diffuse += df * lightColor[i];\\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\\n        specular += sf * lightColor[i];\\n    }\\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\\n  }\\n  #ifdef SurfaceShadowOn\\n  #if vtkLightComplexity < 3\\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float ndotL,vdotR;\\n        vertLightDirection = lightDirectionVC[i];\\n        ndotL = dot(normal.xyz, vertLightDirection);\\n        if (ndotL < 0.0 && twoSidedLighting)\\n        {\\n          ndotL = -ndotL;\\n        }\\n        if (ndotL > 0.0)\\n        {\\n          diffuse += ndotL * lightColor[i];\\n          //specular\\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n          if (vdotR > 0.0)\\n          {\\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n          }\\n        }\\n        #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n        #endif\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #else\\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float distance,attenuation,ndotL,vdotR;\\n        vec3 lightDir;\\n        if (lightPositional[i] == 1){\\n          lightDir = lightDirectionVC[i];\\n          vertLightDirection = posVC - lightPositionVC[i];\\n          distance = length(vertLightDirection);\\n          vertLightDirection = normalize(vertLightDirection);\\n          attenuation = 1.0 / (lightAttenuation[i].x\\n                              + lightAttenuation[i].y * distance\\n                              + lightAttenuation[i].z * distance * distance);\\n          // per OpenGL standard cone angle is 90 or less for a spot light\\n          if (lightConeAngle[i] <= 90.0){\\n            float coneDot = dot(vertLightDirection, lightDir);\\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\\n            }\\n            else {\\n              attenuation = 0.0;\\n            }\\n          }\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * attenuation * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        } else {\\n          vertLightDirection = lightDirectionVC[i];\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        }\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #endif\\n  #endif\\n#endif\\n\\n//=======================================================================\\n// Given a texture value compute the color and opacity\\n//\\nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\\n{\\n#ifdef vtkImageLabelOutlineOn\\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\\n  vec4 centerValue = getTextureValue(centerPosIS);\\n  bool pixelOnBorder = false;\\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\\n\\n  // Get alpha of segment from opacity function.\\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n  int segmentIndex = int(centerValue.r * 255.0);\\n  \\n  // Use texture sampling for outlineThickness\\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\\n\\n  int actualThickness = int(textureValue * 255.0);\\n\\n  if (actualThickness == 0) {\\n    return vec4(0, 0, 1, 1);\\n  }\\n\\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\\n  // Saves a bunch of needless checks on the background.\\n  // TODO define epsilon when building shader?\\n  if (float(tColor.a) > 0.01) {\\n    for (int i = -actualThickness; i <= actualThickness; i++) {\\n      for (int j = -actualThickness; j <= actualThickness; j++) {\\n        if (i == 0 || j == 0) {\\n          continue;\\n        }\\n\\n        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n          gl_FragCoord.y + float(j),\\n          gl_FragCoord.z, gl_FragCoord.w);\\n\\n        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n        vec4 value = getTextureValue(neighborPosIS);\\n\\n        // If any of my neighbours are not the same value as I\\n        // am, this means I am on the border of the segment.\\n        // We can break the loops\\n        if (any(notEqual(value, centerValue))) {\\n          pixelOnBorder = true;\\n          break;\\n        }\\n      }\\n\\n      if (pixelOnBorder == true) {\\n        break;\\n      }\\n    }\\n\\n    // If I am on the border, I am displayed at full opacity\\n    if (pixelOnBorder == true) {\\n      tColor.a = outlineOpacity;\\n    }\\n  }\\n\\n#else\\n  // compute the normal and gradient magnitude if needed\\n  // We compute it as a vec4 if possible otherwise a mat4\\n  //\\n  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);\\n\\n  // compute the normal vectors as needed\\n  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\\n      #if !defined(vtkComponent0Proportional)\\n        vec4 normal0 = normalMat[0];\\n      #endif\\n      #if !defined(vtkComponent1Proportional)\\n        vec4 normal1 = normalMat[1];\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          vec4 normal2 = normalMat[2];\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            vec4 normal3 = normalMat[3];\\n          #endif\\n        #endif\\n      #endif\\n    #else\\n      vec4 normalLight;\\n      #ifdef vtkComputeNormalFromOpacity\\n        vec3 scalarInterp[2];\\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp);\\n        if (length(normal0)>0.0){\\n          #ifdef vtkGradientOpacityOn\\n            normalLight = computeDensityNormal(normal0.w, scalarInterp);\\n          #else\\n            normalLight = computeDensityNormal(scalarInterp);\\n          #endif\\n          if (length(normalLight) == 0.0){\\n            normalLight = normal0;\\n          }\\n        }\\n      #else\\n        vec4 normal0 = computeNormal(posIS, tstep);\\n        normalLight = normal0;\\n      #endif\\n    #endif\\n  #endif\\n\\n  // compute gradient opacity factors as needed\\n  #if defined(vtkGradientOpacityOn)\\n    #if !defined(vtkComponent0Proportional)\\n      goFactor.x =\\n        computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      #if !defined(vtkComponent1Proportional)\\n        goFactor.y =\\n          computeGradientOpacityFactor(normal1.a, goscale1, goshift1, gomin1, gomax1);\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          goFactor.z =\\n            computeGradientOpacityFactor(normal2.a, goscale2, goshift2, gomin2, gomax2);\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            goFactor.w =\\n              computeGradientOpacityFactor(normal3.a, goscale3, goshift3, gomin3, gomax3);\\n          #endif\\n        #endif\\n      #endif\\n    #endif\\n  #endif\\n\\n  // single component is always independent\\n  #if vtkNumComponents == 1\\n    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n    if (tColor.a < EPSILON){\\n      return vec4(0.0);\\n    }\\n  #endif\\n\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));\\n    #if !defined(vtkComponent0Proportional)\\n      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n      tColor *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));\\n    #endif\\n\\n    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\\n    #if !defined(vtkComponent1Proportional)\\n      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n      tColor1 *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));\\n    #endif\\n\\n    #if vtkNumComponents >= 3\\n      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\\n      #if !defined(vtkComponent2Proportional)\\n        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n      #else\\n        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n        tColor2 *= pwfValue;\\n        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));\\n      #endif\\n\\n      #if vtkNumComponents >= 4\\n        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\\n        #if !defined(vtkComponent3Proportional)\\n          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n        #else\\n          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n          tColor3 *= pwfValue;\\n          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));\\n        #endif\\n      #endif\\n    #endif\\n  #else // then not independent\\n\\n  #if vtkNumComponents == 2\\n    float lum = tValue.r * cscale0 + cshift0;\\n    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\\n    vec4 tColor = vec4(lum, lum, lum, alpha);\\n  #endif\\n  #if vtkNumComponents == 3\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\\n  #endif\\n  #if vtkNumComponents == 4\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\\n  #endif\\n  #endif // dependent\\n\\n  // apply lighting if requested as appropriate\\n  #if vtkLightComplexity > 0\\n    #if !defined(vtkComponent0Proportional)\\n      #if vtkNumComponents == 1\\n        #ifdef SurfaceShadowOn\\n            #if vtkLightComplexity < 3\\n                vec3 tColorS = applyLightingDirectional(posIS, tColor, normalLight);\\n            #else\\n                vec3 tColorS = applyLightingPositional(posIS, tColor, normalLight, IStoVC(posIS));\\n            #endif\\n        #endif\\n\\n        #ifdef VolumeShadowOn\\n          vec3 tColorVS = applyShadowRay(tColor.rgb, posIS, rayDirVC);\\n          #ifdef SurfaceShadowOn\\n            float vol_coef = volumetricScatteringBlending * (1.0 - tColor.a / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\\n            tColor.rgb = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\\n          #else\\n            tColor.rgb = tColorVS;\\n          #endif\\n        #else\\n            tColor.rgb = tColorS;\\n        #endif\\n\\n      #else\\n        applyLighting(tColor.rgb, normal0);\\n      #endif\\n    #endif\\n\\n    #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n      #if !defined(vtkComponent1Proportional)\\n        applyLighting(tColor1, normal1);\\n      #endif\\n    #if vtkNumComponents >= 3\\n      #if !defined(vtkComponent2Proportional)\\n        applyLighting(tColor2, normal2);\\n      #endif\\n    #if vtkNumComponents >= 4\\n      #if !defined(vtkComponent3Proportional)\\n        applyLighting(tColor3, normal3);\\n      #endif\\n    #endif\\n    #endif\\n    #endif\\n  #endif\\n\\n// perform final independent blend as needed\\n#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n  tColor.rgb += tColor1;\\n#if vtkNumComponents >= 3\\n  tColor.rgb += tColor2;\\n#if vtkNumComponents >= 4\\n  tColor.rgb += tColor3;\\n#endif\\n#endif\\n#endif\\n\\n#endif\\nreturn tColor;\\n}\\n\\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\\n  bool withinRange = false;\\n  #if vtkNumComponents == 1\\n    if (val.r >= min.r && val.r <= max.r) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2\\n     if (val.r >= min.r && val.r <= max.r &&\\n        val.g >= min.g && val.g <= max.g) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3\\n    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\\n        all(lessThanEqual(val, ipScalarRangeMax))) {\\n      withinRange = true;\\n    }\\n  #endif\\n  return withinRange;\\n}\\n\\n//=======================================================================\\n// Apply the specified blend mode operation along the ray's path.\\n//\\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\\n{\\n  vec3 tstep = 1.0/tdims;\\n\\n  // start slightly inside and apply some jitter\\n  vec3 delta = endIS - posIS;\\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\\n  float raySteps = length(delta)/sampleDistanceIS;\\n\\n  // avoid 0.0 jitter\\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\\n  float stepsTraveled = jitter;\\n\\n  // local vars for the loop\\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\\n  vec4 tValue;\\n  vec4 tColor;\\n\\n  // if we have less than one step then pick the middle point\\n  // as our value\\n  // if (raySteps <= 1.0)\\n  // {\\n  //   posIS = (posIS + endIS)*0.5;\\n  // }\\n\\n  // Perform initial step at the volume boundary\\n  // compute the scalar\\n  tValue = getTextureValue(posIS);\\n\\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\\n    // now map through opacity and color\\n    tColor = getColorForValue(tValue, posIS, tstep);\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\\n      gl_FragData[0] = tColor;\\n      return;\\n    }\\n\\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n\\n      float mix = (1.0 - color.a);\\n\\n      // this line should not be needed but nvidia seems to not handle\\n      // the break correctly on windows/chrome 58 angle\\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\\n\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n      stepsTraveled++;\\n      posIS += stepIS;\\n      if (color.a > 0.99) { color.a = 1.0; break; }\\n    }\\n\\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\\n    {\\n      posIS = endIS;\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\\n\\n      float mix = (1.0 - color.a);\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n    }\\n\\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\\n  #endif\\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\\n    // Find maximum/minimum intensity along the ray.\\n\\n    // Define the operation we will use (min or max)\\n    #if vtkBlendMode == 1\\n    #define OP max\\n    #else\\n    #define OP min\\n    #endif\\n\\n    // If the clipping range is shorter than the sample distance\\n    // we can skip the sampling loop along the ray.\\n    if (raySteps <= 1.0)\\n    {\\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\\n      return;\\n    }\\n\\n    vec4 value = tValue;\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // Update the maximum value if necessary\\n      value = OP(tValue, value);\\n\\n      // Otherwise, continue along the ray\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n    tValue = getTextureValue(posIS);\\n    value = OP(tValue, value);\\n\\n    // Now map through opacity and color\\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\\n    vec4 sum = vec4(0.);\\n\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n    }\\n\\n    if (raySteps <= 1.0) {\\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\\n      // Notes:\\n      // - We are comparing all values in the texture to see if any of them\\n      //   are outside of the scalar range. In the future we might want to allow\\n      //   scalar ranges for each component.\\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n        // Sum the values across each step in the path\\n        sum += tValue;\\n      }\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n\\n    // compute the scalar\\n    tValue = getTextureValue(posIS);\\n\\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n\\n      stepsTraveled++;\\n    }\\n\\n    #if vtkBlendMode == 3 // Average\\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\\n    #endif\\n\\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 5 // RADON\\n    float normalizedRayIntensity = 1.0;\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tValue = getTextureValue(posIS);\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar value\\n      tValue = getTextureValue(posIS);\\n\\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n      posIS += stepIS;\\n      stepsTraveled++;\\n    }\\n\\n    // map normalizedRayIntensity to color\\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\\n\\n  #endif\\n}\\n\\n//=======================================================================\\n// Compute a new start and end point for a given ray based\\n// on the provided bounded clipping plane (aka a rectangle)\\nvoid getRayPointIntersectionBounds(\\n  vec3 rayPos, vec3 rayDir,\\n  vec3 planeDir, float planeDist,\\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\\n  float vSize1, float vSize2)\\n{\\n  float result = dot(rayDir, planeDir);\\n  if (abs(result) < 1e-6)\\n  {\\n    return;\\n  }\\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\\n  vec3 xposVC = rayPos + rayDir*result;\\n  vec3 vxpos = xposVC - vOriginVC;\\n  vec2 vpos = vec2(\\n    dot(vxpos, vPlaneX),\\n    dot(vxpos, vPlaneY));\\n\\n  // on some apple nvidia systems this does not work\\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\\n  //     vpos.y < 0.0 || vpos.y > vSize2)\\n  // even just\\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\\n  // fails\\n  // so instead we compute a value that represents in and out\\n  //and then compute the return using this value\\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\\n\\n  tbounds = mix(\\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\\n   tbounds, // out value\\n   check);  // 0 in 1 out\\n}\\n\\n//=======================================================================\\n// given a\\n// - ray direction (rayDir)\\n// - starting point (vertexVCVSOutput)\\n// - bounding planes of the volume\\n// - optionally depth buffer values\\n// - far clipping plane\\n// compute the start/end distances of the ray we need to cast\\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\\n{\\n  vec2 dists = vec2(100.0*camFar, -1.0);\\n\\n  vec3 vSize = vSpacing*tdims;\\n\\n  // all this is in View Coordinates\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n\\n  //VTK::ClipPlane::Impl\\n\\n  // do not go behind front clipping plane\\n  dists.x = max(0.0,dists.x);\\n\\n  // do not go PAST far clipping plane\\n  float farDist = -camThick/rayDir.z;\\n  dists.y = min(farDist,dists.y);\\n\\n  // Do not go past the zbuffer value if set\\n  // This is used for intermixing opaque geometry\\n  //VTK::ZBuffer::Impl\\n\\n  return dists;\\n}\\n\\n//=======================================================================\\n// Compute the index space starting position (pos) and end\\n// position\\n//\\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\\n{\\n  // compute starting and ending values in volume space\\n  pos = vertexVCVSOutput + dists.x*rayDir;\\n  pos = pos - vOriginVC;\\n  // convert to volume basis and origin\\n  pos = vec3(\\n    dot(pos, vPlaneNormal0),\\n    dot(pos, vPlaneNormal2),\\n    dot(pos, vPlaneNormal4));\\n\\n  endPos = vertexVCVSOutput + dists.y*rayDir;\\n  endPos = endPos - vOriginVC;\\n  endPos = vec3(\\n    dot(endPos, vPlaneNormal0),\\n    dot(endPos, vPlaneNormal2),\\n    dot(endPos, vPlaneNormal4));\\n\\n  float delta = length(endPos - pos);\\n\\n  pos *= vVCToIJK;\\n  endPos *= vVCToIJK;\\n\\n  float delta2 = length(endPos - pos);\\n  sampleDistanceIS = sampleDistance*delta2/delta;\\n  #ifdef VolumeShadowOn\\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\\n  #endif\\n}\\n\\nvoid main()\\n{\\n\\n  if (cameraParallel == 1)\\n  {\\n    // Camera is parallel, so the rayDir is just the direction of the camera.\\n    rayDirVC = vec3(0.0, 0.0, -1.0);\\n  } else {\\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\\n    rayDirVC = normalize(vertexVCVSOutput);\\n  }\\n\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n  // compute the start and end points for the ray\\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\\n\\n  // do we need to composite? aka does the ray have any length\\n  // If not, bail out early\\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\\n  {\\n    discard;\\n  }\\n\\n  // IS = Index Space\\n  vec3 posIS;\\n  vec3 endIS;\\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\\n\\n  // Perform the blending operation along the ray\\n  applyBlend(posIS, endIS, tdims);\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Fragment;o.getProperty().getInterpolationType()===wg.LINEAR&&(a=cd.substitute(a,&quot;//VTK::TrilinearOn&quot;,&quot;#define vtkTrilinearOn&quot;).result),!0===o.getProperty().getUseLabelOutline()&&(a=cd.substitute(a,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result);const i=t.scalarTexture.getComponents();a=cd.substitute(a,&quot;//VTK::NumComponents&quot;,`#define vtkNumComponents ${i}`).result;const s=o.getProperty().getIndependentComponents();if(s){a=cd.substitute(a,&quot;//VTK::IndependentComponentsOn&quot;,&quot;#define vtkIndependentComponentsOn&quot;).result;const e=[];for(let t=0;t<i;t++)o.getProperty().getOpacityMode(t)===Pg.PROPORTIONAL&&e.push(`#define vtkComponent${t}Proportional`);e.length>0&&(a=cd.substitute(a,&quot;//VTK::vtkProportionalComponents&quot;,e.join(&quot;\\n&quot;)).result)}const l=t.currentInput.getSpatialExtent(),c=t.currentInput.getSpacing(),u=new Float64Array(3);In(u,(l[1]-l[0])*c[0],(l[3]-l[2])*c[1],(l[5]-l[4])*c[2]);const d=Sn(u)/e.getCurrentSampleDistance(r);a=cd.substitute(a,&quot;//VTK::MaximumSamplesValue&quot;,`${Math.ceil(d)}`).result,a=cd.substitute(a,&quot;//VTK::LightComplexity&quot;,`#define vtkLightComplexity ${t.lastLightComplexity}`).result,t.lastLightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(a=cd.substitute(a,&quot;//VTK::VolumeShadowOn&quot;,&quot;#define VolumeShadowOn&quot;).result),t.renderable.getVolumetricScatteringBlending()<1&&(a=cd.substitute(a,&quot;//VTK::SurfaceShadowOn&quot;,&quot;#define SurfaceShadowOn&quot;).result),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0&&(a=cd.substitute(a,&quot;//VTK::localAmbientOcclusionOn&quot;,&quot;#define localAmbientOcclusionOn&quot;).result)),t.gopacity=o.getProperty().getUseGradientOpacity(0);for(let e=1;s&&!t.gopacity&&e<i;++e)o.getProperty().getUseGradientOpacity(e)&&(t.gopacity=!0);t.gopacity&&(a=cd.substitute(a,&quot;//VTK::GradientOpacityOn&quot;,&quot;#define vtkGradientOpacityOn&quot;).result),t.renderable.getComputeNormalFromOpacity()&&(a=cd.substitute(a,&quot;//VTK::vtkComputeNormalFromOpacity&quot;,&quot;#define vtkComputeNormalFromOpacity&quot;).result),null!==t.zBufferTexture&&(a=cd.substitute(a,&quot;//VTK::ZBuffer::Dec&quot;,[&quot;uniform sampler2D zBufferTexture;&quot;,&quot;uniform float vpZWidth;&quot;,&quot;uniform float vpZHeight;&quot;]).result,a=cd.substitute(a,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));&quot;,&quot;float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;&quot;,&quot;zdepth = zdepth * 2.0 - 1.0;&quot;,&quot;if (cameraParallel == 0) {&quot;,&quot;zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}&quot;,&quot;else {&quot;,&quot;zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\\n&quot;,&quot;zdepth = -zdepth/rayDir.z;&quot;,&quot;dists.y = min(zdepth,dists.y);&quot;]).result),a=cd.substitute(a,&quot;//VTK::BlendMode&quot;,`${t.renderable.getBlendMode()}`).result,n.Fragment=a,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lastLightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[&quot;uniform int lightNum;&quot;,&quot;uniform bool twoSidedLighting;&quot;,`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,&quot;//VTK::Light::Dec&quot;],!1).result,3===t.lastLightComplexity&&(o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=cd.substitute(o,&quot;//VTK::VolumeShadow::Dec&quot;,[&quot;uniform float volumetricScatteringBlending;&quot;,&quot;uniform float giReach;&quot;,&quot;uniform float volumeShadowSamplingDistFactor;&quot;,&quot;uniform float anisotropy;&quot;,&quot;uniform float anisotropy2;&quot;],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=cd.substitute(o,&quot;//VTK::LAO::Dec&quot;,[&quot;uniform int kernelRadius;&quot;,`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,&quot;uniform int kernelSize;&quot;],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=cd.substitute(o,&quot;//VTK::ClipPlane::Dec&quot;,[&quot;uniform vec3 vClipPlaneNormals[6];&quot;,&quot;uniform float vClipPlaneDistances[6];&quot;,&quot;uniform vec3 vClipPlaneOrigins[6];&quot;,&quot;uniform int clip_numPlanes;&quot;,&quot;//VTK::ClipPlane::Dec&quot;,&quot;#define vtkClippingPlanesOn&quot;],!1).result,o=cd.substitute(o,&quot;//VTK::ClipPlane::Impl&quot;,[`for(int i = 0; i < ${e}; i++) {`,&quot;  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);&quot;,&quot;  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];&quot;,&quot;  if (rayDirRatio == 0.0)&quot;,&quot;  {&quot;,&quot;    if (equationResult < 0.0) dists.x = dists.y;&quot;,&quot;    continue;&quot;,&quot;  }&quot;,&quot;  float result = -1.0 * equationResult / rayDirRatio;&quot;,&quot;  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);&quot;,&quot;  else dists.x = max(dists.x, result);&quot;,&quot;}&quot;,&quot;//VTK::ClipPlane::Impl&quot;],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{let a=0;o.getProperty().getShade()&&t.renderable.getBlendMode()===Rg.COMPOSITE_BLEND&&(a=0,t.numberOfLights=0,r.getLights().forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===a&&(a=1)),1===a&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(a=2),a<3&&e.getPositional()&&(a=3)})));let i=!1;t.lastLightComplexity!==a&&(t.lastLightComplexity=a,i=!0);const s=t.scalarTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=!1;const u=[];if(l){for(let e=0;e<s;e++)u.push(o.getProperty().getOpacityMode(e));u.length>0&&(c=!0)}const d=t.currentInput.getSpatialExtent(),p=t.currentInput.getSpacing(),f=new Float64Array(3);In(f,(d[1]-d[0])*p[0],(d[3]-d[2])*p[1],(d[5]-d[4])*p[2]);const g=Sn(f)/e.getCurrentSampleDistance(r),m={interpolationType:o.getProperty().getInterpolationType(),useLabelOutline:o.getProperty().getUseLabelOutline(),numComp:s,usesProportionalComponents:c,iComps:l,maxSamples:g,useGradientOpacity:o.getProperty().getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),proportionalComponents:u};return t.previousState&&t.previousState.interpolationType===m.interpolationType&&t.previousState.useLabelOutline===m.useLabelOutline&&t.previousState.numComp===m.numComp&&t.previousState.usesProportionalComponents===m.usesProportionalComponents&&t.previousState.iComps===m.iComps&&t.previousState.maxSamples===m.maxSamples&&t.previousState.useGradientOpacity===m.useGradientOpacity&&t.previousState.blendMode===m.blendMode&&function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(t.previousState.proportionalComponents,m.proportionalComponents)?!!(0===n.getProgram()?.getHandle()||i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||!!t.lastZBufferTexture!=!!t.zBufferTexture||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime())&&(t.lastZBufferTexture=t.zBufferTexture,!0):(t.previousState={...m},!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed(&quot;vertexDC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexDC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified()),a.setUniformi(&quot;texture1&quot;,t.scalarTexture.getTextureUnit()),a.setUniformf(&quot;sampleDistance&quot;,e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange(),l=[],c=[];for(let e=0;e<4;e++)l[e]=s[0]*i.dataComputedScale[e]+i.dataComputedOffset[e],c[e]=s[1]*i.dataComputedScale[e]+i.dataComputedOffset[e],l[e]=(l[e]-i.offset[e])/i.scale[e],c[e]=(c[e]-i.offset[e])/i.scale[e];if(a.setUniform4f(&quot;ipScalarRangeMin&quot;,l[0],l[1],l[2],l[3]),a.setUniform4f(&quot;ipScalarRangeMax&quot;,c[0],c[1],c[2],c[3]),null!==t.zBufferTexture){a.setUniformi(&quot;zBufferTexture&quot;,t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf(&quot;vpZWidth&quot;,e[0]),a.setUniformf(&quot;vpZHeight&quot;,e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf(&quot;camThick&quot;,c[1]-c[0]),s.setUniformf(&quot;camNear&quot;,c[0]),s.setUniformf(&quot;camFar&quot;,c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf(&quot;dcxmin&quot;,g),s.setUniformf(&quot;dcxmax&quot;,m),s.setUniformf(&quot;dcymin&quot;,v),s.setUniformf(&quot;dcymax&quot;,y),s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f(&quot;vSpacing&quot;,x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f(&quot;vOriginVC&quot;,p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Dg(`The number of steps required ${Math.ceil(A)} is larger than the\\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\\n        Please either change the\\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f(&quot;vVCToIJK&quot;,I[0],I[1],I[2]),s.setUniform3i(&quot;volumeDimensions&quot;,d[0],d[1],d[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf(&quot;texWidth&quot;,t.scalarTexture.getWidth()),s.setUniformf(&quot;texHeight&quot;,t.scalarTexture.getHeight()),s.setUniformi(&quot;xreps&quot;,e.xreps),s.setUniformi(&quot;xstride&quot;,e.xstride),s.setUniformi(&quot;ystride&quot;,e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*Dn(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(o.getProperty().getUseLabelOutline()){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf(&quot;vpWidth&quot;,u[0]),s.setUniformf(&quot;vpHeight&quot;,u[1]);const d=e.getRenderTargetOffset();s.setUniformf(&quot;vpOffsetX&quot;,d[0]/u[0]),s.setUniformf(&quot;vpOffsetY&quot;,d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix(&quot;PCVCMatrix&quot;,t.projectionToView),0===t.lastLightComplexity)return;let O=0;const R=[],M=[],D=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],D[0+3*O]=-.5*w[0],D[1+3*O]=-.5*w[1],D[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi(&quot;twoSidedLighting&quot;,r.getTwoSidedLighting()),s.setUniformi(&quot;lightNum&quot;,O),s.setUniform3fv(&quot;lightColor&quot;,R),s.setUniform3fv(&quot;lightDirectionVC&quot;,M),s.setUniform3fv(&quot;lightHalfAngleVC&quot;,D),3===t.lastLightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv(&quot;lightPositionVC&quot;,e),s.setUniform3fv(&quot;lightAttenuation&quot;,n),s.setUniformfv(&quot;lightConeAngle&quot;,o),s.setUniformfv(&quot;lightExponent&quot;,a),s.setUniformiv(&quot;lightPositional&quot;,i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf(&quot;giReach&quot;,t.renderable.getGlobalIlluminationReach()),s.setUniformf(&quot;volumetricScatteringBlending&quot;,t.renderable.getVolumetricScatteringBlending()),s.setUniformf(&quot;volumeShadowSamplingDistFactor&quot;,t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf(&quot;anisotropy&quot;,t.renderable.getAnisotropy()),s.setUniformf(&quot;anisotropy2&quot;,t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi(&quot;kernelSize&quot;,e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv(&quot;kernelSample&quot;,n),s.setUniformi(&quot;kernelRadius&quot;,t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi(&quot;ctexture&quot;,t.colorTexture.getTextureUnit()),o.setUniformi(&quot;otexture&quot;,t.opacityTexture.getTextureUnit()),o.setUniformi(&quot;jtexture&quot;,t.jitterTexture.getTextureUnit()),o.setUniformi(&quot;ttexture&quot;,t.labelOutlineThicknessTexture.getTextureUnit());const a=t.scalarTexture.getVolumeInfo(),i=r.getProperty(),s=t.scalarTexture.getComponents(),l=r.getProperty().getIndependentComponents();if(l&&s>=2)for(let e=0;e<s;e++)o.setUniformf(`mix${e}`,r.getProperty().getComponentWeight(e));for(let e=0;e<s;e++){const t=l?e:0,n=a.scale[e],r=i.getScalarOpacity(t).getRange(),s=n/(r[1]-r[0]),c=(a.offset[e]-r[0])/(r[1]-r[0]);o.setUniformf(`oshift${e}`,c),o.setUniformf(`oscale${e}`,s);const u=i.getRGBTransferFunction(t).getRange(),d=(a.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);o.setUniformf(`cshift${e}`,d),o.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(l)for(let e=0;e<s;++e){const t=a.scale[e];if(i.getUseGradientOpacity(e)){const n=i.getGradientOpacityMinimumOpacity(e),r=i.getGradientOpacityMaximumOpacity(e);o.setUniformf(`gomin${e}`,n),o.setUniformf(`gomax${e}`,r);const a=[i.getGradientOpacityMinimumValue(e),i.getGradientOpacityMaximumValue(e)];o.setUniformf(`goscale${e}`,t*(r-n)/(a[1]-a[0])),o.setUniformf(`goshift${e}`,-a[0]*(r-n)/(a[1]-a[0])+n)}else o.setUniformf(`gomin${e}`,1),o.setUniformf(`gomax${e}`,1),o.setUniformf(`goscale${e}`,0),o.setUniformf(`goshift${e}`,1)}else{const e=a.scale[s-1],t=i.getGradientOpacityMinimumOpacity(0),n=i.getGradientOpacityMaximumOpacity(0);o.setUniformf(&quot;gomin0&quot;,t),o.setUniformf(&quot;gomax0&quot;,n);const r=[i.getGradientOpacityMinimumValue(0),i.getGradientOpacityMaximumValue(0)];o.setUniformf(&quot;goscale0&quot;,e*(n-t)/(r[1]-r[0])),o.setUniformf(&quot;goshift0&quot;,-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===r.getProperty().getUseLabelOutline()){const e=r.getProperty().getLabelOutlineOpacity();o.setUniformf(&quot;outlineOpacity&quot;,e)}t.lastLightComplexity>0&&(o.setUniformf(&quot;vAmbient&quot;,i.getAmbient()),o.setUniformf(&quot;vDiffuse&quot;,i.getDiffuse()),o.setUniformf(&quot;vSpecular&quot;,i.getSpecular()),o.setUniformf(&quot;vSpecularPower&quot;,i.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*Dn(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv(&quot;vClipPlaneNormals&quot;,o),c.setUniformfv(&quot;vClipPlaneDistances&quot;,a),c.setUniform3fv(&quot;vClipPlaneOrigins&quot;,i),c.setUniformi(&quot;clip_numPlanes&quot;,l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===wg.NEAREST?(t.scalarTexture.setMinificationFilter(bd.NEAREST),t.scalarTexture.setMagnificationFilter(bd.NEAREST)):(t.scalarTexture.setMinificationFilter(bd.LINEAR),t.scalarTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null,null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;uniform vec2 tfactor;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),[&quot;//VTK::System::Dec&quot;,&quot;//VTK::Output::Dec&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { gl_FragData[0] = texture2D(texture1,tcoord); }&quot;].join(&quot;\\n&quot;),&quot;&quot;);const e=t.copyShader;t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in copy shader VAO.&quot;)}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi(&quot;texture&quot;,n.getTextureUnit()),t.copyShader.setUniform2f(&quot;tfactor&quot;,t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Eg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;t._scalars!==a&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=a);const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(bd.LINEAR),t.jitterTexture.setMagnificationFilter(bd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,ys.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=i.getIndependentComponents()?s:1,c=i.getScalarOpacity(),u=t._openGLRenderWindow.getGraphicsResourceForObject(c);let d=Vg(i,c,l);if(u.vtkObj&&u.hash===d&&t.opacityTextureString===d)t.opacityTexture=u.vtkObj,t.opacityTextureString=u.hash;else{const r=1024,o=2*r*l,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<l;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.releaseGraphicsResources(t._openGLRenderWindow),t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(bd.LINEAR),t.opacityTexture.setMagnificationFilter(bd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))t.opacityTexture.create2DFromRaw(r,2*l,1,ys.FLOAT,a);else{const e=new Uint8Array(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*l,1,ys.UNSIGNED_CHAR,e)}t.opacityTextureString=d,c&&t._openGLRenderWindow.setGraphicsResourceForObject(c,t.opacityTexture,t.opacityTextureString)}const p=i.getRGBTransferFunction();d=Vg(i,p,l);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===d&&t.colorTextureString===d)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(2*e*l*3),r=new Float32Array(3*e);for(let t=0;t<l;++t){const o=i.getRGBTransferFunction(t),a=o.getRange();o.getTable(a[0],a[1],e,r,1);for(let o=0;o<3*e;++o)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.create2DFromRaw(e,2*l,3,ys.UNSIGNED_CHAR,n),t.colorTextureString=d,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}e.updateLabelOutlineThicknessTexture(r);const g=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(d=`${o.getMTime()}A${a.getMTime()}`,g?.vtkObj&&g?.hash===d&&t.scalarTextureString===d)t.scalarTexture=g.vtkObj,t.scalarTextureString=g.hash;else{const e=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.scalarTexture.releaseGraphicsResources(t._openGLRenderWindow),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],a,t.renderable.getPreferSizeOverAccuracy()),t.scalarTextureString=d,a&&t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,t.scalarTextureString)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Es.newInstance({numberOfComponents:3,values:e});r.setName(&quot;points&quot;);const o=Es.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=e=>{const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}}}const Bg={context:null,VBOBuildTime:null,scalarTexture:null,scalarTextureString:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lastLightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0,_scalars:null};const Ng=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bg,n),Zt.extend(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),t.scalarTexture=Nd.newInstance(),t.opacityTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.jitterTexture=Nd.newInstance(),t.jitterTexture.setWrapS(Td.REPEAT),t.jitterTexture.setWrapT(Td.REPEAT),t.labelOutlineThicknessTexture=Nd.newInstance(),t.framebuffer=Hp.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,[&quot;context&quot;]),Lg(e,t)}),&quot;vtkOpenGLVolumeMapper&quot;);rn(&quot;vtkVolumeMapper&quot;,Ng);const{vtkDebugMacro:_g}=Kt;function Fg(e,t){t.classHierarchy.push(&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent();const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():_g(&quot;No framebuffer to save/restore&quot;);const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const kg={};const Gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kg,n),Zt.extend(e,t,n),Fg(e,t)}),&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;);rn(&quot;vtkPixelSpaceCallbackMapper&quot;,Gg);var Ug=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtktextureObjectVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\nattribute vec2 tcoordDC;\\nvarying vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  tcoordVC = tcoordDC;\\n  gl_Position = vertexDC;\\n}\\n&quot;;const{Representation:zg}=ds;function Wg(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Nd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,&quot;Float32Array&quot;,null),s.activate(),s.sendParameters(),s.deactivate(),s}function Hg(e,t){return Wg(e,t,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE)}function jg(e,t){t.classHierarchy.push(&quot;vtkLICPingPongBufferManager&quot;),t._openGLRenderWindow?(t.quad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,zg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=Hg(t._openGLRenderWindow,t.size),t.seedTexture0=Hg(t._openGLRenderWindow,t.size),t.licTexture1=Hg(t._openGLRenderWindow,t.size),t.seedTexture1=Hg(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?Wg(t._openGLRenderWindow,t.size,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return Wg(e,t,Nd.Filter.LINEAR,Nd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error(&quot;Pass renderwindow to ping pong manager&quot;)}const Kg={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function $g(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kg,n),jt.obj(e,t),jt.get(e,t,[&quot;readIndex&quot;]),jt.setGet(e,t,[&quot;doEEPass&quot;,&quot;doVTPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;vectorTexture&quot;,&quot;maskVectorTexture&quot;,&quot;noiseTexture&quot;,&quot;framebuffer&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),jg(e,t)}var qg={newInstance:jt.newInstance($g,&quot;vtkLICPingPongBufferManager&quot;),extend:$g};const Xg=0,Yg=1,Zg=2,Qg=3,Jg=1;function em(e,t){function n(e,t){e.setUniformi(&quot;texLIC&quot;,t.getLICTextureUnit()),e.setUniformi(&quot;texSeedPts&quot;,t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push(&quot;vtkLineIntegralConvolution2D&quot;),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Hp.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t=&quot;xyzw&quot;;return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n/**\\nThis shader initializes the convolution for the LIC computation.\\n*/\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texMaskVectors;\\nuniform sampler2D texNoise;\\nuniform sampler2D texLIC;\\n\\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the *whole* domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value. this\\n// depends on the pass number.\\nvec2 getNoiseTC(vec2 vectc)\\n{\\n  // in pass 1 : convert from vector tc to noise tc\\n  // in pass 2 : use vector tc\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(vectc);\\n    }\\n  else\\n    {\\n    return vectc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the\\n// need to convert to noise texture coordinates.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 vectc = tcoordVC.st;\\n\\n  // lic => (convolution, mask, 0, step count)\\n  if (uStepNo == 0)\\n    {\\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\\n    float maskFlag;\\n    if (maskCriteria <= uMaskThreshold)\\n      {\\n      maskFlag = 1.0;\\n      }\\n    else\\n      {\\n      maskFlag = 0.0;\\n      }\\n    float noise = getNoise(vectc);\\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = texture2D(texLIC, vectc);\\n    }\\n\\n  // initial seed\\n  SeedOutput = vec4(vectc, 0.0, 1.0);\\n}\\n&quot;);const n=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// move vector field to normalized image space\\n// pre-processing for vtkLineIntegralConvolution2D\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Fragment shader used by the gaussian blur filter render pass.\\n\\nuniform sampler2D texVectors; // input texture\\nuniform vec2      uTexSize;   // size of texture\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  //VTK::LICComponentSelection::Impl\\n  V = V/uTexSize;\\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\\n}\\n&quot;,&quot;//VTK::LICComponentSelection::Impl&quot;,`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D  texVectors;\\nuniform sampler2D  texNoise;\\nuniform sampler2D  texLIC;\\nuniform sampler2D  texSeedPts;\\n\\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\\nuniform float uStepSize;        // step size in parametric space\\n\\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n//VTK::LICVectorLookup::Impl\\n\\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\\n// are very poorly supported in webgl\\nvec2 clampToBorder(vec2 uv){\\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\\n  {\\n    return vec2(0.0, 0.0);\\n  }\\n  return getVector(uv);\\n}\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the whole domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value.\\n// in pass 1 repeatedly tile the noise texture across\\n// the computational domain.\\nvec2 getNoiseTC(vec2 tc)\\n{\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(tc);\\n    }\\n  else\\n    {\\n    return tc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the need\\n// to convert to either noise or lic texture coordinates in\\n// pass 1 and 2 respectively.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\n// fourth-order Runge-Kutta streamline integration\\n// no bounds checks are made, therefore it's essential\\n// to have the entire texture initialized to 0\\n// and set clamp to border and have border color 0\\n// an integer is set if the step was taken, keeping\\n// an accurate step count is necessary to prevent\\n// boundary artifacts. Don't count the step if\\n// all vector lookups are identically 0. This is\\n// a proxy for \\&quot;stepped outside valid domain\\&quot;\\nvec2 rk4(vec2 pt0, float dt, out bool count)\\n{\\n  count=true;\\n  float dtHalf = dt * 0.5;\\n  vec2 pt1;\\n\\n  vec2 v0 = clampToBorder(pt0);\\n  pt1 = pt0 + v0 * dtHalf;\\n\\n  vec2 v1 = clampToBorder(pt1);\\n  pt1 = pt0 + v1 * dtHalf;\\n\\n  vec2 v2 = clampToBorder(pt1);\\n  pt1 = pt0 + v2 * dt;\\n\\n  vec2 v3 = clampToBorder(pt1);\\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\\n\\n  if (vSum == vec2(0.0, 0.0))\\n    {\\n      count = false;\\n    }\\n\\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\\n\\n return pt1;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic = texture2D(texLIC, lictc);\\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\\n\\n  bool count;\\n  vec2 pt1 = rk4(pt0, uStepSize, count);\\n\\n  if (count)\\n    {\\n    // accumulate lic step\\n    // (lic, mask, 0, step count)\\n    float noise = getNoise(pt1);\\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\\n    SeedOutput = vec4(pt1, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    // keep existing values\\n    LICOutput = lic;\\n    SeedOutput = vec4(pt0, 0.0, 1.0);\\n    }\\n}\\n&quot;,&quot;//VTK::LICVectorLookup::Impl&quot;,function(){const e=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      vec2 V = texture2D( texVectors, vectc ).xy;\\n\\n      // normalize if |V| not 0\\n\\n      float lenV = length( V );\\n\\n      if ( lenV > 1.0e-8 )\\n\\n        {\\n\\n        return V/lenV;\\n\\n        }\\n\\n      else\\n\\n        {\\n\\n        return vec2( 0.0, 0.0 );\\n\\n        }\\n\\n      }\\n\\n    &quot;,t=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      return texture2D( texVectors, vectc ).xy;\\n\\n      }\\n\\n    &quot;;return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(&quot; //VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n/**\\nThis shader finalizes the convolution for the LIC computation\\napplying the normalization. eg. if box kernel is used the this\\nis the number of steps taken.\\n*/\\n\\nuniform sampler2D texLIC;\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\\n  conv.r = conv.r/conv.a;\\n  // lic => (convolution, mask, 0, 1)\\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.CEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// gray scale contrast enhance stage implemented via histogram stretching\\n// if the min and max are tweaked it can generate out-of-range values\\n// these will be clamped in 0 to 1\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n\\nuniform sampler2D texLIC;  // most recent lic pass\\nuniform float uMin;        // min gray scale color value\\nuniform float uMaxMinDiff; // max-min\\n\\nin vec2 tcoordVC;\\n\\nvoid main( void )\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g!=0.0)\\n    {\\n    LICOutput = lic;\\n    }\\n  else\\n    {\\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\\n    LICOutput = vec4(CElic, lic.gb, 1.0);\\n    }\\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.EEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\\n// noise for pass2.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 EEOutput;\\n\\nuniform sampler2D texLIC; // most recent lic pass\\nuniform float     uDx;    // fragment size\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// kernel for simple laplace edge enhancement.\\n// p=Laplace(p)+p\\nfloat K[9] = float[9](\\n  -1.0, -1.0, -1.0,\\n  -1.0,  9.0, -1.0,\\n  -1.0, -1.0, -1.0\\n  );\\n\\n// determine if the fragment was masked\\nbool Masked(float val) { return val != 0.0; }\\n\\nvoid main(void)\\n{\\n  // tex coord neighbor offsets\\n  vec2 fragDx[9] = vec2[9](\\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\\n    );\\n\\n  vec2 lictc = tcoordVC.st;\\n\\n  // compute the convolution but don't use convovled values if\\n  // any masked fragments on the stencil. Fragments outside\\n  // the valid domain are masked during initialization, and\\n  // texture wrap parameters are clamp to border with border\\n  // color that contains masked flag\\n  float conv = 0.0;\\n  bool dontUse = false;\\n  for (int i=0; i<9; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    vec4 lic = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic.g);\\n    conv = conv + K[i] * lic.r;\\n    }\\n\\n  if (dontUse)\\n    {\\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    conv = clamp(conv, 0.0, 1.0);\\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\\n    }\\n\\n}\\n&quot;),t.AAHProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// horizontal pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDx;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.AAVProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// vertical pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\\n\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDy[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;)},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;f&&o[0]===f.getSize()[0]&&o[1]===f.getSize()[1]||(f=Hp.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=qg.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const g=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],m=1/o[0],h=1/o[1],v=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;v.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f(&quot;uTexSize&quot;,...o),e.setUniformi(&quot;texVectors&quot;,t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,0),y.setUniformf(&quot;uMaskThreshold&quot;,t.maskThreshold),y.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),y.setUniformi(&quot;texMaskVectors&quot;,t.bufs.getMaskVectorTextureUnit()),y.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:T}=t;v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,0),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),T.setUniformi(&quot;texVectors&quot;,t.bufs.getImageVectorTextureUnit()),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:b}=t;if(v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),r(t.bufs,o,b),t.enhancedLIC){t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDx&quot;,m),a.setUniformf(&quot;uDy&quot;,h),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,1),n(y,t.bufs),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,1),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),b.setUniformi(&quot;texSeedPts&quot;,t.bufs.getSeedTextureUnit()),r(t.bufs,o,b)}if(t.antiAlias){const e=t.AAHProgram;v.readyShaderProgram(e),e.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),e.setUniformf(&quot;uDx&quot;,m);const a=t.AAVProgram;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDy&quot;,h);for(let i=0;i<t.antiAlias;++i)v.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),v.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error(&quot;Invalid color range: &quot;,i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),c.setUniformf(&quot;uMin&quot;,i),c.setUniformf(&quot;uMaxMinDiff&quot;,l),r(t.bufs,o,c)}}const tm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function nm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tm,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;nuberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;componentIds&quot;,&quot;isComposite&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),em(e,t)}var rm={newInstance:jt.newInstance(nm,&quot;vtkLineIntegralConvolution2D&quot;),extend:nm};function om(e,t){t.classHierarchy.push(&quot;vtkSurfaceLICInterface&quot;)}const am={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Xg,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:Jg,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function im(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,am,n),jt.obj(e,t),jt.setGet(e,t,[&quot;enableLIC&quot;,&quot;numberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;transformVectors&quot;,&quot;maskOnSurface&quot;,&quot;maskThreshold&quot;,&quot;maskColor&quot;,&quot;maskIntensity&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;noiseTextureSize&quot;,&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;noiseGeneratorSeed&quot;,&quot;viewPortScale&quot;,&quot;rebuildNoiseTexture&quot;]),om(0,t)}var sm={newInstance:jt.newInstance(im,&quot;vtkSurfaceLICInterface&quot;),extend:im};const{Representation:lm}=ds;function cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICInterface&quot;),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get(&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;);n=r===Jg?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Nd.newInstance({wrapS:Nd.Wrap.REPEAT,wrapT:Nd.Wrap.REPEAT,minificationFilter:Nd.Filter.NEAREST,magnificationFilter:Nd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,&quot;Float32Array&quot;,d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.allocateTextures=()=>{const n=Nd.Filter.NEAREST,r=Nd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Nd.newInstance({wrapS:Nd.Wrap.CLAMP_TO_EDGE,wrapT:Nd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,&quot;Float32Array&quot;,null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Nd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,&quot;Float32Array&quot;,null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=Hp.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader combines surface geometry, LIC, and  scalar colors.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 RGBOutput;\\nlayout(location = 1) out vec4 HSLOutput;\\n\\nuniform sampler2D texVectors;       // vectors, depth\\nuniform sampler2D texGeomColors;    // scalar colors + lighting\\nuniform sampler2D texLIC;           // image lic\\nuniform int       uScalarColorMode; // select between blend, and map shader\\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\\nuniform float     uMaskIntensity;   // blending factor for mask color\\nuniform vec3      uMaskColor;       // color for the masked out fragments\\n\\nin vec2 tcoordVC;\\n\\n/**\\nConvert from RGB color space into HSL colorspace.\\n*/\\nvec3 RGBToHSL(vec3 RGB)\\n{\\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\\n\\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\\n  float RGBMaxMinDiff = RGBMax - RGBMin;\\n\\n  HSL.z = (RGBMax + RGBMin) / 2.0;\\n\\n  if (RGBMaxMinDiff == 0.0)\\n    {\\n    // Gray scale\\n    HSL.x = 0.0;\\n    HSL.y = 0.0;\\n    }\\n  else\\n    {\\n    // Color\\n    if (HSL.z < 0.5)\\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\\n    else\\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\\n\\n    float dR\\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dG\\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dB\\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n\\n    if (RGB.r == RGBMax)\\n      HSL.x = dB - dG;\\n    else\\n    if (RGB.g == RGBMax)\\n      HSL.x = (1.0 / 3.0) + dR - dB;\\n    else\\n    if (RGB.b == RGBMax)\\n      HSL.x = (2.0 / 3.0) + dG - dR;\\n\\n    if (HSL.x < 0.0)\\n      HSL.x += 1.0;\\n\\n    if (HSL.x > 1.0)\\n      HSL.x -= 1.0;\\n    }\\n\\n  return HSL;\\n}\\n\\n/**\\nHelper for HSL to RGB conversion.\\n*/\\nfloat Util(float v1, float v2, float vH)\\n{\\n  if (vH < 0.0)\\n    vH += 1.0;\\n\\n  if (vH > 1.0)\\n     vH -= 1.0;\\n\\n  if ((6.0 * vH) < 1.0)\\n    return (v1 + (v2 - v1) * 6.0 * vH);\\n\\n  if ((2.0 * vH) < 1.0)\\n    return (v2);\\n\\n  if ((3.0 * vH) < 2.0)\\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\\n\\n  return v1;\\n}\\n\\n/**\\nConvert from HSL space into RGB space.\\n*/\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  if (HSL.y == 0.0)\\n    {\\n    // Gray\\n    RGB.r = HSL.z;\\n    RGB.g = HSL.z;\\n    RGB.b = HSL.z;\\n    }\\n  else\\n    {\\n    // Chromatic\\n    float v2;\\n    if (HSL.z < 0.5)\\n      v2 = HSL.z * (1.0 + HSL.y);\\n    else\\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\\n\\n    float v1 = 2.0 * HSL.z - v2;\\n\\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\\n    RGB.g = Util(v1, v2, HSL.x);\\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\\n    }\\n\\n  return RGB.rgb;\\n}\\n\\nvoid main()\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n\\n  // depth is used to determine which fragment belong to us\\n  // and we can change\\n  float depth = texture2D(texVectors, tcoordVC.st).a;\\n\\n  vec3 fragColorRGB;\\n  float valid;\\n  if (depth > 1.0e-3)\\n    {\\n    // we own it\\n    // shade LIC'ed geometry, or apply mask\\n    if (lic.g!=0.0)\\n      {\\n      // it's masked\\n      // apply fragment mask\\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\\n      valid = 0.0;\\n      }\\n    else\\n      {\\n      if (uScalarColorMode==0)\\n        {\\n        // blend with scalars\\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\\n        }\\n      else\\n        {\\n        // multiply with scalars\\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\\n        }\\n      if (lic.b != 0.0)\\n        {\\n        // didn't have the required guard pixels\\n        // don't consider it in min max estimation\\n        // for histpgram stretching\\n        valid = 0.0;\\n        }\\n      else\\n        {\\n        // ok to use in min/max estimates for histogram\\n        // stretching\\n        valid = 1.0;\\n        }\\n      }\\n    }\\n  else\\n    {\\n    // we don't own it\\n    // pass through scalars\\n    fragColorRGB = geomColor.rgb;\\n    valid = 0.0;\\n    }\\n\\n  // if no further stages this texture is\\n  // copied to the screen\\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\\n\\n  // if further stages, move to hsl space for contrast\\n  // enhancement. encoding validity saves moving a texture to the cpu\\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\\n  HSLOutput = vec4(fragColorHSL, valid);\\n}\\n&quot;),t.licCopyPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader copies fragments and depths to the output buffer\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texDepth;     // z values from vertex shader\\nuniform sampler2D texRGBColors; // final rgb LIC colors\\n\\nin vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\\n\\n  // since we render a screen aligned quad\\n  // we're going to be writing fragments\\n  // not touched by the original geometry\\n  // it's critical not to modify those\\n  // fragments.\\n  if (gl_FragDepth == 1.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;),t.enhanceContrastPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// color contrast enhance stage implemented via histogram stretching\\n// on lightness channel. if the min and max are tweaked it can generate\\n// out-of-range values these will be clamped in 0 to 1\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texGeomColors; // scalars + lighting\\nuniform sampler2D texLIC;        // image lic, mask\\nuniform sampler2D texHSLColors;  // hsla colors\\n\\nuniform float     uLMin;         // min lightness over all fragments\\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\\n\\nin vec2 tcoordVC;\\n\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  float v;\\n  float h = HSL.x;\\n  float sl = HSL.y;\\n  float l = HSL.z;\\n\\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\\n  if (v <= 0.0) {\\n    RGB = vec3(0.0,0.0,0.0);\\n  } else {\\n    float m;\\n    int sextant;\\n    float fract, vsf, mid1, mid2;\\n\\n    m = l + l - v;\\n    h *= 6.0;\\n    sextant = int(h);\\n    fract = h - float(sextant);\\n\\n    vsf = (v - m) * fract;\\n    mid1 = m + vsf;\\n    mid2 = v - vsf;\\n    switch (sextant) {\\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\\n    }\\n  }\\n  return RGB;\\n}\\n\\nvoid main()\\n{\\n  // lookup hsl color , mask\\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\\n\\n  // don't modify masked fragments (masked => lic.g==1)\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g==0.0)\\n    {\\n    // normalize lightness channel\\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\\n    }\\n\\n  // back into rgb space\\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\\n\\n  // add alpha\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n  fragColor.a = geomColor.a;\\n\\n  gl_FragData[0] = fragColor;\\n}\\n&quot;),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,lm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=rm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi(&quot;texDepth&quot;,t.depthTexture.getTextureUnit()),r.setUniformi(&quot;texRGBColors&quot;,t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi(&quot;texVectors&quot;,t.vectorImage.getTextureUnit()),o.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get(&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;maskIntensity&quot;,&quot;maskColor&quot;,&quot;enhanceContrast&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;);if(o.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),o.setUniformi(&quot;uScalarColorMode&quot;,a),o.setUniformf(&quot;uLICIntensity&quot;,i),o.setUniformf(&quot;uMapBias&quot;,s),o.setUniformf(&quot;uMaskIntensity&quot;,l),o.setUniform3f(&quot;uMaskColor&quot;,...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===Zg||u===Qg){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit()),s.setUniformi(&quot;texHSLColors&quot;,t.HSLColorImage.getTextureUnit()),s.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),s.setUniformf(&quot;uLMin&quot;,o),s.setUniformf(&quot;uLMaxMinDiff&quot;,i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get(&quot;stepSize&quot;,&quot;numberOfSteps&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;transformVectors&quot;),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error(&quot;Failed to compute image LIC&quot;),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const um={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function dm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,um,n),sm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;reallocateTextures&quot;,&quot;licInterface&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cm(e,t)}var pm={newInstance:jt.newInstance(dm,&quot;vtkSurfaceLICInterface&quot;),extend:dm};const{vtkErrorMacro:fm}=Kt;function gm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICMapper&quot;);const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=cd.substitute(s,&quot;//VTK::Output::Dec&quot;,[&quot;//VTK::Output::Dec&quot;,&quot;layout(location = 2) out vec4 vectorTexture;&quot;,&quot;layout(location = 3) out vec4 maskVectorTexture;&quot;]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,[`attribute vec3 ${n};`,&quot;out vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[`licOutput = ${n};`,&quot;//VTK::TCoord::Impl&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform int uMaskOnSurface;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;in vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Impl&quot;,[&quot;// projected vectors&quot;,&quot;  vec3 tcoordLIC = normalMatrix * licOutput;&quot;,&quot;  vec3 normN = normalize(normalVCVSOutput);&quot;,&quot;  float k = dot(tcoordLIC, normN);&quot;,&quot;  vec3 projected = (tcoordLIC - k*normN);&quot;,&quot;  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;// vectors for fragment masking&quot;,&quot;  if (uMaskOnSurface == 0)&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(licOutput, 1.0);&quot;,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;    }&quot;,&quot;//VTK::TCoord::Impl&quot;],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi(&quot;uMaskOnSurface&quot;,t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(fm(&quot;SurfaceLICMapper Requires WebGL 2&quot;),a=!1),t.context.getExtension(&quot;EXT_color_buffer_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)||(fm(&quot;SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions.&quot;),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(fm(&quot;No input&quot;),a=!1);let i=t.renderable.getLicInterface();i||(i=sm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=pm.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(fm(&quot;No vector input array&quot;),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const mm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const hm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mm,n),np.extend(e,t,n),gm(e,t),At(e,t,[&quot;openGLLicInterface&quot;])}),&quot;vtkOpenGLSurfaceLICMapper&quot;);rn(&quot;vtkSurfaceLICMapper&quot;,hm);const{vtkErrorMacro:vm}=Kt;function ym(e,t){t.classHierarchy.push(&quot;vtkOpenGLSphereMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkSphereMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Spheres\\n\\nattribute vec4 vertexMC;\\nattribute vec2 offsetMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\n\\nuniform int cameraParallel;\\nuniform float scaleFactor;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  // compute the projected vertex position\\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\\n\\n  // make the triangle face the camera\\n  if (cameraParallel == 0)\\n    {\\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\\n    vec3 base1 = cross(base2,dir);\\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\\n    }\\n  else\\n    {\\n    // add in the offset\\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\\n    }\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;\\n&quot;]).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform float invertedDepth;\\n&quot;,&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float b = 2.0*dot(EyePos,EyeDir);\\n&quot;,&quot;  float c = dot(EyePos,EyePos) - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t = (-b - invertedDepth*sqrt(d))*0.5;\\n&quot;,&quot;    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\\n&quot;,&quot;    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;offsetMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||vm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isUniformUsed(&quot;invertedDepth&quot;)&&e.getProgram().setUniformf(&quot;invertedDepth&quot;,t.invert?-1:1),e.getProgram().isUniformUsed(&quot;scaleFactor&quot;)){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf(&quot;scaleFactor&quot;,t.renderable.getScaleFactor()):e.getProgram().setUniformf(&quot;scaleFactor&quot;,1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),o.isUniformUsed(&quot;MCVCMatrix&quot;))if(r.getIsIdentity())o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,n)}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Tm={};const bm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tm,n),np.extend(e,t,n),ym(e,t)}),&quot;vtkOpenGLSphereMapper&quot;);rn(&quot;vtkSphereMapper&quot;,bm);const{vtkErrorMacro:xm}=Kt;function Cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLStickMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkStickMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Sticks\\n\\nattribute vec4 vertexMC;\\nattribute vec3 orientMC;\\nattribute vec4 offsetMC;\\nattribute float radiusMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying float lengthVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\nvarying vec3 orientVCVSOutput;\\n\\nuniform int cameraParallel;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = radiusMC;\\n  lengthVCVSOutput = length(orientMC);\\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\\n\\n  // make sure it is pointing out of the screen\\n  if (orientVCVSOutput.z < 0.0)\\n    {\\n    orientVCVSOutput = -orientVCVSOutput;\\n    }\\n\\n  // make the basis\\n  vec3 xbase;\\n  vec3 ybase;\\n  vec3 dir = vec3(0.0,0.0,1.0);\\n  if (cameraParallel == 0)\\n    {\\n    dir = normalize(-vertexVCVSOutput.xyz);\\n    }\\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\\n    {\\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\\n    ybase = cross(xbase,orientVCVSOutput);\\n    }\\n  else\\n    {\\n    xbase = normalize(cross(orientVCVSOutput,dir));\\n    ybase = cross(orientVCVSOutput,xbase);\\n    }\\n\\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\\n    radiusVCVSOutput*offsets.x*xbase +\\n    radiusVCVSOutput*offsets.y*ybase +\\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,&quot;varying vec4 vertexVCVSOutput;&quot;).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,&quot;  vec4 vertexVC = vertexVCVSOutput;\\n&quot;).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 orientVCVSOutput;\\n&quot;,&quot;varying float lengthVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  vec3 base1;\\n&quot;,&quot;  if (abs(orientVCVSOutput.z) < 0.99) {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\\n&quot;,&quot;  vec3 base2 = cross(orientVCVSOutput,base1);\\n&quot;,&quot;  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\\n&quot;,&quot;  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n&quot;,&quot;  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n&quot;,&quot;  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*a*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t =  (-b - sqrt(d))/(2.0*a);\\n&quot;,&quot;    float tz = EyePos.z + t*EyeDir.z;\\n&quot;,&quot;    vec3 iPoint = EyePos + t*EyeDir;\\n&quot;,&quot;    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\\n&quot;,&quot;      float t2 = (-b + sqrt(d))/(2.0*a);\\n&quot;,&quot;      float tz2 = EyePos.z + t2*EyeDir.z;\\n&quot;,&quot;      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\\n&quot;,&quot;      else {\\n&quot;,&quot;        normalVCVSOutput = orientVCVSOutput;\\n&quot;,&quot;        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\\n&quot;,&quot;        iPoint = EyePos + t3*EyeDir;\\n&quot;,&quot;        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;        }\\n&quot;,&quot;      }\\n&quot;,&quot;    else {\\n&quot;,&quot;      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\\n&quot;,&quot;      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;      }\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed(&quot;orientMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;orientMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||xm(&quot;Error setting 'orientMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),&quot;offsetMC&quot;,0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||xm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;radiusMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;radiusMC&quot;,24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||xm(&quot;Error setting 'radiusMC' in shader VAO.&quot;))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),r.getIsIdentity())o.isUniformUsed(&quot;MCVCMatrix&quot;)&&o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc),o.isUniformUsed(&quot;normalMatrix&quot;)&&o.setUniformMatrix3x3(&quot;normalMatrix&quot;,i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed(&quot;MCVCMatrix&quot;)){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,t)}if(o.isUniformUsed(&quot;normalMatrix&quot;)){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3(&quot;normalMatrix&quot;,t)}}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():xm([&quot;Error setting orientationArray.\\n&quot;,&quot;You have to specify the stick orientation&quot;]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,zu.ARRAY_BUFFER),a.getColorBO().upload(g,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Sm={};const Am=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sm,n),np.extend(e,t,n),Cm(e,t)}),&quot;vtkOpenGLStickMapper&quot;);rn(&quot;vtkStickMapper&quot;,Am);const Im=[];Im[&quot;-&quot;.charCodeAt(0)]=62,Im[&quot;_&quot;.charCodeAt(0)]=63;const wm=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;for(let e=0;e<wm.length;e++)Im[wm.charCodeAt(e)]=e;function Pm(e){return void 0!==Im[e.charCodeAt(0)]}function Om(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<18;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<12;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<6;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<10;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<4;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<2;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error(&quot;BASE64: remain 1 should not happen&quot;)}return u}function Rm(e,t,n){const r=(e<<16)+(t<<8)+n;return wm[r>>18]+wm[r>>12&63]+wm[r>>6&63]+wm[63&r]}function Mm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Rm(t[n],t[n+1],t[n+2])}if(n>0){const e=Rm(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join(&quot;&quot;)}var Dm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)Pm(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):&quot;=&quot;===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Om(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Em={};function Vm(e,t){Em[e]=t}var Lm=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;http&quot;,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Em[e](t)},Bm=Uint8Array,Nm=Uint16Array,_m=Uint32Array,Fm=new Bm([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),km=new Bm([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Gm=new Bm([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Um=function(e,t){for(var n=new Nm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new _m(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},zm=Um(Fm,2),Wm=zm[0],Hm=zm[1];Wm[28]=258,Hm[258]=28;for(var jm=Um(km,0),Km=jm[0],$m=(jm[1],new Nm(32768)),qm=0;qm<32768;++qm){var Xm=(43690&qm)>>>1|(21845&qm)<<1;Xm=(61680&(Xm=(52428&Xm)>>>2|(13107&Xm)<<2))>>>4|(3855&Xm)<<4,$m[qm]=((65280&Xm)>>>8|(255&Xm)<<8)>>>1}var Ym=function(e,t,n){for(var r=e.length,o=0,a=new Nm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Nm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Nm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[$m[d]>>>l]=c}else for(i=new Nm(r),o=0;o<r;++o)e[o]&&(i[o]=$m[s[e[o]-1]++]>>>15-e[o]);return i},Zm=new Bm(288);for(qm=0;qm<144;++qm)Zm[qm]=8;for(qm=144;qm<256;++qm)Zm[qm]=9;for(qm=256;qm<280;++qm)Zm[qm]=7;for(qm=280;qm<288;++qm)Zm[qm]=8;var Qm=new Bm(32);for(qm=0;qm<32;++qm)Qm[qm]=5;var Jm=Ym(Zm,9,1),eh=Ym(Qm,5,1),th=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},nh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},rh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},oh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Nm:4==e.BYTES_PER_ELEMENT?_m:Bm)(n-t);return r.set(e.subarray(t,n)),r},ah=[&quot;unexpected EOF&quot;,&quot;invalid block type&quot;,&quot;invalid length/literal&quot;,&quot;invalid distance&quot;,&quot;stream finished&quot;,&quot;no stream handler&quot;,,&quot;no callback&quot;,&quot;invalid UTF-8 data&quot;,&quot;extra field too long&quot;,&quot;date not in range 1980-2099&quot;,&quot;filename too long&quot;,&quot;stream finishing&quot;,&quot;invalid zip data&quot;],ih=function(e,t,n){var r=new Error(t||ah[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,ih),!n)throw r;return r},sh=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new Bm(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new Bm(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new Bm(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=nh(e,c,1);var h=nh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&ih(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=Jm,p=eh,f=9,g=5;else if(2==h){var T=nh(e,c,31)+257,b=nh(e,c+10,15)+4,x=T+nh(e,c+5,31)+1;c+=14;for(var C=new Bm(x),S=new Bm(19),A=0;A<b;++A)S[Gm[A]]=nh(e,c+3*A,7);c+=3*b;var I=th(S),w=(1<<I)-1,P=Ym(S,I,1);for(A=0;A<x;){var O,R=P[nh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,D=0;for(16==O?(D=3+nh(e,c,3),c+=2,M=C[A-1]):17==O?(D=3+nh(e,c,7),c+=3):18==O&&(D=11+nh(e,c,127),c+=7);D--;)C[A++]=M}}var E=C.subarray(0,T),V=C.subarray(T);f=th(E),g=th(V),d=Ym(E,f,1),p=Ym(V,g,1)}else ih(1);if(c>m){a&&ih(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[rh(e,c)&L])>>>4;if((c+=15&M)>m){a&&ih(0);break}if(M||ih(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Fm[A=_-257];F=nh(e,c,(1<<k)-1)+Wm[A],c+=k}var G=p[rh(e,c)&B],U=G>>>4;if(G||ih(3),c+=15&G,V=Km[U],U>3&&(k=km[U],V+=rh(e,c)&(1<<k)-1,c+=k),c>m){a&&ih(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:oh(t,0,u)},lh=new Bm(0),ch=function(e,t){return e[t]|e[t+1]<<8},uh=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},dh=function(e,t){return uh(e,t)+4294967296*uh(e,t+4)};function ph(e,t){return sh(e,t)}function fh(e,t){return sh(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||ih(6,&quot;invalid gzip data&quot;);var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new Bm((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function gh(e,t){return sh(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&ih(6,&quot;invalid zlib data&quot;),32&n[1]&&ih(6,&quot;invalid zlib data: preset dictionaries not supported&quot;),e.subarray(2,-4)),t);var n}function mh(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?fh(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?ph(e,t):gh(e,t)}var hh=&quot;undefined&quot;!=typeof TextEncoder&&new TextEncoder,vh=&quot;undefined&quot;!=typeof TextDecoder&&new TextDecoder;try{vh.decode(lh,{stream:!0})}catch(e){}function yh(e,t){if(t){for(var n=&quot;&quot;,r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(vh)return vh.decode(e);var o=function(e){for(var t=&quot;&quot;,n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,oh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&ih(8),a}var Th=function(e,t){return t+30+ch(e,t+26)+ch(e,t+28)},bh=function(e,t,n){var r=ch(e,t+28),o=yh(e.subarray(t+46,t+46+r),!(2048&ch(e,t+8))),a=t+46+r,i=uh(e,t+20),s=n&&4294967295==i?xh(e,a):[i,uh(e,t+24),uh(e,t+42)],l=s[0],c=s[1],u=s[2];return[ch(e,t+10),l,c,o,a+ch(e,t+30)+ch(e,t+32),u]},xh=function(e,t){for(;1!=ch(e,t);t+=4+ch(e,t+2));return[dh(e,t+12),dh(e,t+4),dh(e,t+20)]};function Ch(e,t){for(var n={},r=e.length-22;101010256!=uh(e,r);--r)(!r||e.length-r>65558)&&ih(13);var o=ch(e,r+8);if(!o)return{};var a=uh(e,r+16),i=4294967295==a;i&&(r=uh(e,r-12),101075792!=uh(e,r)&&ih(13),o=uh(e,r+32),a=uh(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=bh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Th(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=ph(e.subarray(h,h+d),new Bm(p)):ih(14,&quot;unknown compression type &quot;+u):n[f]=oh(e,h,h+d))}return n}function Sh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?&quot;LittleEndian&quot;:2712847316===n[0]?&quot;BigEndian&quot;:null}&quot;function&quot;==typeof queueMicrotask?queueMicrotask:&quot;function&quot;==typeof setTimeout&&setTimeout;var Ah=Sh(),Ih=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:wh,vtkDebugMacro:Ph}=jt;let Oh=0;function Rh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener(&quot;progress&quot;,n.progressCallback),r}const Mh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;);const s=Rh(&quot;GET&quot;,i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(Ph(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&wh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||&quot;string&quot;!==n.dataType?&quot;arraybuffer&quot;:&quot;text&quot;,s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(yh(mh(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&&quot;gz&quot;!==n.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(yh(mh(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&&quot;gz&quot;!==t.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Rh(&quot;GET&quot;,e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(mh(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType=&quot;arraybuffer&quot;,o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};Vm(&quot;http&quot;,(e=>Mh));const{vtkDebugMacro:Dh}=jt;function Eh(e,t){t.classHierarchy.push(&quot;vtkCamera&quot;);const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;);const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Gi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Gi(o,[...t.position,1],n),Gi(a,[...t.focalPoint,1],n),Gi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=Hi(e[0],e[1],e[2],e[3]),n=Ui(),r=Hi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],Wi(r,t,r),Wi(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error(&quot;Off-Axis projection is not supported at this time&quot;);{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=Ui();zi(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const Vh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Lh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vh,n),jt.obj(e,t),jt.get(e,t,[&quot;distance&quot;]),jt.setGet(e,t,[&quot;parallelProjection&quot;,&quot;useHorizontalViewAngle&quot;,&quot;viewAngle&quot;,&quot;parallelScale&quot;,&quot;useOffAxisProjection&quot;,&quot;freezeFocalPoint&quot;,&quot;physicalScale&quot;]),jt.getArray(e,t,[&quot;directionOfProjection&quot;,&quot;viewPlaneNormal&quot;,&quot;position&quot;,&quot;focalPoint&quot;]),jt.setGetArray(e,t,[&quot;clippingRange&quot;,&quot;windowCenter&quot;],2),jt.setGetArray(e,t,[&quot;viewUp&quot;,&quot;screenBottomLeft&quot;,&quot;screenBottomRight&quot;,&quot;screenTopRight&quot;,&quot;physicalTranslation&quot;,&quot;physicalViewUp&quot;,&quot;physicalViewNorth&quot;],3),Eh(e,t)}var Bh={newInstance:jt.newInstance(Lh,&quot;vtkCamera&quot;),extend:Lh};function Nh(e,t){t.classHierarchy.push(&quot;vtkLight&quot;);const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType(&quot;HeadLight&quot;)},e.setLightTypeToCameraLight=()=>{e.setLightType(&quot;CameraLight&quot;)},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType(&quot;SceneLight&quot;)},e.lightTypeIsHeadLight=()=>&quot;HeadLight&quot;===t.lightType,e.lightTypeIsSceneLight=()=>&quot;SceneLight&quot;===t.lightType,e.lightTypeIsCameraLight=()=>&quot;CameraLight&quot;===t.lightType}const _h={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:&quot;SceneLight&quot;,shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_h,n),jt.obj(e,t),jt.setGet(e,t,[&quot;intensity&quot;,&quot;switch&quot;,&quot;positional&quot;,&quot;exponent&quot;,&quot;coneAngle&quot;,&quot;coneFalloff&quot;,&quot;transformMatrix&quot;,&quot;lightType&quot;,&quot;shadowAttenuation&quot;,&quot;attenuationValues&quot;]),jt.setGetArray(e,t,[&quot;color&quot;,&quot;position&quot;,&quot;focalPoint&quot;,&quot;attenuationValues&quot;],3),Nh(e,t)}var kh={newInstance:jt.newInstance(Fh,&quot;vtkLight&quot;),extend:Fh,LIGHT_TYPES:[&quot;HeadLight&quot;,&quot;CameraLight&quot;,&quot;SceneLight&quot;]};const{vtkErrorMacro:Gh}=jt;function Uh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push(&quot;vtkViewport&quot;),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Gh(&quot;call displayToView on your view instead&quot;),e.viewToDisplay=()=>Gh(&quot;callviewtodisplay on your view instead&quot;),e.getSize=()=>Gh(&quot;call getSize on your View instead&quot;),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=(&quot;PickPropFrom&quot;,()=>Gh(&quot;vtkViewport::PickPropFrom - NOT IMPLEMENTED&quot;))}const zh={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function Wh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zh,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),jt.setGetArray(e,t,[&quot;viewport&quot;],4),jt.setGetArray(e,t,[&quot;background&quot;,&quot;background2&quot;],3),Uh(e,t)}var Hh={newInstance:jt.newInstance(Wh,&quot;vtkViewport&quot;),extend:Wh};const{vtkDebugMacro:jh,vtkErrorMacro:Kh,vtkWarningMacro:$h}=Kt;function qh(e){return()=>Kh(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function Xh(e,t){t.classHierarchy.push(&quot;vtkRenderer&quot;);const n={type:&quot;ComputeVisiblePropBoundsEvent&quot;,renderer:e},r={type:&quot;ResetCameraClippingRangeEvent&quot;,renderer:e},o={type:&quot;ResetCameraEvent&quot;,renderer:e};e.updateCamera=()=>(t.activeCamera||(jh(&quot;No cameras are on, creating one.&quot;),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Kh(&quot;light has unknown light type&quot;,e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=qh(&quot;allocateTime&quot;),e.updateGeometry=qh(&quot;updateGeometry&quot;),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{jh(e.getClassName(),e,&quot;setting Layer to &quot;,n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:&quot;ActiveCameraEvent&quot;,camera:n}),!0),e.makeCamera=()=>{const t=Bh.newInstance();return e.invokeEvent({type:&quot;CreateCameraEvent&quot;,camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=kh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;WorldToView: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=ki.INIT_BOUNDS[0],t.allBounds[1]=ki.INIT_BOUNDS[1],t.allBounds[2]=ki.INIT_BOUNDS[2],t.allBounds[3]=ki.INIT_BOUNDS[3],t.allBounds[4]=ki.INIT_BOUNDS[4],t.allBounds[5]=ki.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),jh(&quot;Can't compute bounds, no 3D props are visible&quot;)),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return jh(&quot;Cannot reset camera!&quot;),!1;let i=null;if(!e.getActiveCamera())return Kh(&quot;Trying to reset non-existent camera&quot;),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&($h(&quot;Resetting view-up since view plane normal is parallel&quot;),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return jh(&quot;Cannot reset camera clipping range!&quot;),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Kh(&quot;Trying to reset clipping range of non-existent camera&quot;),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const Yh={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Zh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Yh,n),Hh.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,[&quot;_renderWindow&quot;,&quot;allocatedRenderTime&quot;,&quot;timeFactor&quot;,&quot;lastRenderTimeInSeconds&quot;,&quot;numberOfPropsRendered&quot;,&quot;lastRenderingUsedDepthPeeling&quot;,&quot;selector&quot;]),At(e,t,[&quot;twoSidedLighting&quot;,&quot;lightFollowCamera&quot;,&quot;automaticLightCreation&quot;,&quot;erase&quot;,&quot;draw&quot;,&quot;nearClippingPlaneTolerance&quot;,&quot;clippingRangeExpansion&quot;,&quot;backingStore&quot;,&quot;interactive&quot;,&quot;layer&quot;,&quot;preserveColorBuffer&quot;,&quot;preserveDepthBuffer&quot;,&quot;useDepthPeeling&quot;,&quot;occlusionRatio&quot;,&quot;maximumNumberOfPeels&quot;,&quot;delegate&quot;,&quot;backgroundTexture&quot;,&quot;texturedBackground&quot;,&quot;environmentTexture&quot;,&quot;environmentTextureDiffuseStrength&quot;,&quot;environmentTextureSpecularStrength&quot;,&quot;useEnvironmentTextureAsBackground&quot;,&quot;useShadows&quot;,&quot;pass&quot;]),It(e,t,[&quot;actors&quot;,&quot;volumes&quot;,&quot;lights&quot;]),Pt(e,t,[&quot;background&quot;],4,1),Ot(0,t,[&quot;renderWindow&quot;]),Xh(e,t)}var Qh={newInstance:Et(Zh,&quot;vtkRenderer&quot;),extend:Zh};const Jh=Object.create(null);function ev(e,t){Jh[e]=t}function tv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Jh[e]&&Jh[e](t)}function nv(e,t){t.classHierarchy.push(&quot;vtkRenderWindow&quot;),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return tv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6;const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join(&quot;\\n&quot;),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))}}const rv={defaultViewAPI:&quot;WebGL&quot;,renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1};function ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rv,n),jt.obj(e,t),jt.setGet(e,t,[&quot;interactor&quot;,&quot;numberOfLayers&quot;,&quot;_views&quot;,&quot;defaultViewAPI&quot;]),jt.get(e,t,[&quot;neverRendered&quot;]),jt.getArray(e,t,[&quot;renderers&quot;]),jt.moveToProtected(e,t,[&quot;views&quot;]),jt.event(e,t,&quot;completion&quot;),nv(e,t)}var av={newInstance:jt.newInstance(ov,&quot;vtkRenderWindow&quot;),extend:ov,registerViewConstructor:ev,listViewAPIs:function(){return Object.keys(Jh)},newAPISpecificView:tv};const iv={Unknown:0,LeftController:1,RightController:2},sv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var lv={Device:iv,Input:sv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:cv,Input:uv}=lv,{vtkWarningMacro:dv,vtkErrorMacro:pv,normalizeWheel:fv,vtkOnceErrorMacro:gv}=jt,mv={ctrlKey:!1,altKey:!1,shiftKey:!1},hv={&quot;xr-standard&quot;:[uv.Trigger,uv.Grip,uv.TrackPad,uv.Thumbstick,uv.A,uv.B]},vv=[&quot;StartAnimation&quot;,&quot;Animation&quot;,&quot;EndAnimation&quot;,&quot;PointerEnter&quot;,&quot;PointerLeave&quot;,&quot;MouseEnter&quot;,&quot;MouseLeave&quot;,&quot;StartMouseMove&quot;,&quot;MouseMove&quot;,&quot;EndMouseMove&quot;,&quot;LeftButtonPress&quot;,&quot;LeftButtonRelease&quot;,&quot;MiddleButtonPress&quot;,&quot;MiddleButtonRelease&quot;,&quot;RightButtonPress&quot;,&quot;RightButtonRelease&quot;,&quot;KeyPress&quot;,&quot;KeyDown&quot;,&quot;KeyUp&quot;,&quot;StartMouseWheel&quot;,&quot;MouseWheel&quot;,&quot;EndMouseWheel&quot;,&quot;StartPinch&quot;,&quot;Pinch&quot;,&quot;EndPinch&quot;,&quot;StartPan&quot;,&quot;Pan&quot;,&quot;EndPan&quot;,&quot;StartRotate&quot;,&quot;Rotate&quot;,&quot;EndRotate&quot;,&quot;Button3D&quot;,&quot;Move3D&quot;,&quot;StartPointerLock&quot;,&quot;EndPointerLock&quot;,&quot;StartInteraction&quot;,&quot;Interaction&quot;,&quot;EndInteraction&quot;,&quot;AnimationFrameRateUpdate&quot;];function yv(e){e.cancelable&&e.preventDefault()}function Tv(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function bv(e,t){t.classHierarchy.push(&quot;vtkRenderWindowInteractor&quot;);const n=new Set,r=new Map;let o=1;function a(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{pv(&quot;you want to call setView(view) instead of setRenderWindow on a vtk.js interactor&quot;)},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>dv(&quot;empty event loop&quot;),e.getCurrentRenderer=()=>(t.currentRenderer||a(0,0),t.currentRenderer);const i=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),o=n.getBoundingClientRect(),i=n.width/o.width,s=n.height/o.height,l={x:i*(e.clientX-o.left),y:s*(o.height-e.clientY+o.top),z:0};return(r.size<=1||!t.currentRenderer)&&a(l.x,l.y),l};function s(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function l(e){const t=s(e);return{key:e.key,keyCode:e.charCode,...t}}function c(e){return e.pointerType||&quot;&quot;}function u(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.bindEvents=n=>{t.container=n,n.addEventListener(&quot;contextmenu&quot;,yv),n.addEventListener(&quot;wheel&quot;,e.handleWheel),n.addEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.addEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.addEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.addEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.addEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.addEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.addEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.addEventListener(&quot;keypress&quot;,e.handleKeyPress),document.addEventListener(&quot;keydown&quot;,e.handleKeyDown),document.addEventListener(&quot;keyup&quot;,e.handleKeyUp),document.addEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),n.style.touchAction=&quot;none&quot;,n.style.userSelect=&quot;none&quot;,n.style.webkitTapHighlightColor=&quot;rgba(0,0,0,0)&quot;},e.unbindEvents=()=>{const{container:n}=t;n.removeEventListener(&quot;contextmenu&quot;,yv),n.removeEventListener(&quot;wheel&quot;,e.handleWheel),n.removeEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.removeEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.removeEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.removeEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.removeEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.removeEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.removeEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.removeEventListener(&quot;keypress&quot;,e.handleKeyPress),document.removeEventListener(&quot;keydown&quot;,e.handleKeyDown),document.removeEventListener(&quot;keyup&quot;,e.handleKeyUp),document.removeEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),t.container=null,r.clear()},e.handleKeyPress=t=>{const n=l(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=l(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=l(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerEnterEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerLeaveEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&yv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),r.has(n.pointerId)&&dv(&quot;[RenderWindowInteractor] duplicate pointerId detected&quot;),r.set(n.pointerId,{pointerId:n.pointerId,position:i(n)}),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(r.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&yv(n),r.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(r.has(t.pointerId))switch(r.delete(t.pointerId),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(r.has(t.pointerId)&&(r.get(t.pointerId).position=i(t)),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:pv(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=r=>{void 0!==r?n.has(r)?dv(&quot;requester is already registered for animating&quot;):(n.add(r),t.animationRequest||1!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):pv(&quot;undefined requester, can not start animating&quot;)},e.extendAnimation=r=>{const o=Date.now()+r;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(r){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.has(r))n.delete(r),t.animationRequest&&0===n.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=r&&r.getClassName?r.getClassName():r;dv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==n.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=n.gamepad,s=n.handedness;if(i){i.index in t.lastGamepadValues||(t.lastGamepadValues[i.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<i.buttons.length;++r)r in t.lastGamepadValues[i.index][s].buttons||(t.lastGamepadValues[i.index][s].buttons[r]=!1),t.lastGamepadValues[i.index][s].buttons[r]!==i.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,pressed:i.buttons[r].pressed,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController,input:hv[i.mapping]&&hv[i.mapping][r]?hv[i.mapping][r]:uv.Trigger}),t.lastGamepadValues[i.index][s].buttons[r]=i.buttons[r].pressed),t.lastGamepadValues[i.index][s].buttons[r]&&null!=a&&e.move3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController})}}))},e.handleMouseMove=n=>{const r={...s(n),position:i(n),deviceType:c(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const r=Date.now();t._animationFrameCount++,r-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(r-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=r,t._animationFrameCount=1),e.animationEvent(),u(),n.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{yv(n);const r={...fv(n),...s(n),position:i(n),deviceType:c(n)};0===t.wheelTimeoutID&&(o=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=o,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:pv(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);if(2===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture(&quot;TouchStart&quot;,t)}else if(1===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const o=[...r.values()];if(t.recognizeGestures)if(0===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonReleaseEvent(t)}else if(1===o.length){const t=Tv(r);e.recognizeGesture(&quot;TouchEnd&quot;,t);const a={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonPressEvent(a)}else{const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||u()},vv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void gv(&quot;\\n          Can not forward events without a current renderer on the interactor.\\n        &quot;);const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),&quot;TouchStart&quot;===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture=&quot;Start&quot;);if(&quot;TouchEnd&quot;===n)return&quot;Pinch&quot;===t.currentGesture&&(e.render(),e.endPinchEvent()),&quot;Rotate&quot;===t.currentGesture&&(e.render(),e.endRotateEvent()),&quot;Pan&quot;===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture=&quot;Start&quot;,void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,&quot;TouchMove&quot;===n)if(&quot;Start&quot;===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture=&quot;Pinch&quot;;const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture=&quot;Rotate&quot;;const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture=&quot;Pan&quot;;const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if(&quot;Rotate&quot;===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if(&quot;Pinch&quot;===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if(&quot;Pan&quot;===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e};const d=e.delete;e.delete=()=>{for(;n.size;)e.cancelAnimation(n.values().next().value);void 0!==document.hidden&&document.removeEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange),t.container&&e.unbindEvents(),d()},void 0!==document.hidden&&document.addEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange,!1)}const xv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:&quot;Start&quot;,animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,&quot;RenderEvent&quot;),vv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,[&quot;initialized&quot;,&quot;container&quot;,&quot;interactorStyle&quot;,&quot;lastFrameTime&quot;,&quot;recentAnimationFrameRate&quot;,&quot;_view&quot;]),jt.setGet(e,t,[&quot;lightFollowCamera&quot;,&quot;enabled&quot;,&quot;enableRender&quot;,&quot;recognizeGestures&quot;,&quot;desiredUpdateRate&quot;,&quot;stillUpdateRate&quot;,&quot;picker&quot;,&quot;preventDefaultOnPointerDown&quot;,&quot;preventDefaultOnPointerUp&quot;,&quot;mouseScrollDebounceByPass&quot;]),jt.moveToProtected(e,t,[&quot;view&quot;]),bv(e,t)}var Sv={newInstance:jt.newInstance(Cv,&quot;vtkRenderWindowInteractor&quot;),extend:Cv,handledEvents:vv,...lv};const{vtkErrorMacro:Av,VOID:Iv}=jt;function wv(e,t){t.classHierarchy.push(&quot;vtkInteractorObserver&quot;);const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Sv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):Iv),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Av(&quot;\\n          The interactor must be set before subscribing to events\\n        &quot;)),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const Pv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pv,n),jt.obj(e,t),jt.event(e,t,&quot;InteractionEvent&quot;),jt.event(e,t,&quot;StartInteractionEvent&quot;),jt.event(e,t,&quot;EndInteractionEvent&quot;),jt.get(e,t,[&quot;_interactor&quot;,&quot;enabled&quot;]),jt.setGet(e,t,[&quot;priority&quot;,&quot;processEvents&quot;]),jt.moveToProtected(e,t,[&quot;interactor&quot;]),wv(e,t)}var Rv={newInstance:jt.newInstance(Ov,&quot;vtkInteractorObserver&quot;),extend:Ov,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},Mv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Dv}=Mv,Ev={Rotate:Dv.IS_ROTATE,Pan:Dv.IS_PAN,Spin:Dv.IS_SPIN,Dolly:Dv.IS_DOLLY,CameraPose:Dv.IS_CAMERA_POSE,WindowLevel:Dv.IS_WINDOW_LEVEL,Slice:Dv.IS_SLICE};function Vv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyle&quot;),Object.keys(Ev).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Dv.IS_NONE&&(t.state=Ev[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:&quot;StartInteractionEvent&quot;}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Ev[n]&&(t.state=Dv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:&quot;EndInteractionEvent&quot;}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case&quot;r&quot;:case&quot;R&quot;:e.pokedRenderer.resetCamera(),n.render();break;case&quot;w&quot;:case&quot;W&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case&quot;s&quot;:case&quot;S&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case&quot;v&quot;:case&quot;V&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Lv={state:Dv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function Bv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lv,n),Rv.extend(e,t,n),Vv(e,t)}var Nv={newInstance:jt.newInstance(Bv,&quot;vtkInteractorStyle&quot;),extend:Bv,...Mv};const{States:_v}=Mv;function Fv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyleTrackballCamera&quot;),e.handleMouseMove=n=>{const r=n.position,o=n.pokedRenderer;switch(t.state){case _v.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad?!n||n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad||t.state!==_v.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===_v.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const t=e.pokedRenderer.getActiveCamera(),n=t.getPhysicalTranslation(),r=.025*t.getPhysicalScale(),o=t.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);t.setPhysicalTranslation(n[0]+o[0]*r,n[1]+o[1]*r,n[2]+o[2]*r)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case _v.IS_DOLLY:e.endDolly();break;case _v.IS_PAN:e.endPan();break;case _v.IS_SPIN:e.endSpin();break;case _v.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(n.pokedRenderer,n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=n.pokedRenderer.getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(n.pokedRenderer,o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(n.pokedRenderer,o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(n.pokedRenderer,o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&n.pokedRenderer.updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=e.pokedRenderer.getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(n.pokedRenderer,r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const kv={motionFactor:10,zoomFactor:10};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Nv.extend(e,t,n),jt.setGet(e,t,[&quot;motionFactor&quot;,&quot;zoomFactor&quot;]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,&quot;vtkInteractorStyleTrackballCamera&quot;),extend:Gv};function zv(e){return e}function Wv(e){return null===e||&quot;null&quot;===e?null:&quot;true&quot;===e||&quot;false&quot;!==e&&(void 0!==e&&&quot;undefined&quot;!==e?&quot;[&quot;===e[0]&&&quot;]&quot;===e[e.length-1]?e.substring(1,e.length-1).split(&quot;,&quot;).map((e=>Wv(e.trim()))):&quot;&quot;===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var Hv=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?Wv:zv,o=(t||&quot;&quot;).replace(/#.*/,&quot;&quot;).replace(&quot;?&quot;,&quot;&quot;).split(&quot;&&quot;);return o.forEach((e=>{const[t,o]=e.split(&quot;=&quot;).map((e=>decodeURIComponent(e)));t&&(n[t]=!o||r(o))})),n};function jv(e,t){t.classHierarchy.push(&quot;vtkRenderPass&quot;),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const Kv={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),jt.obj(e,t),jt.get(e,t,[&quot;currentOperation&quot;]),jt.setGet(e,t,[&quot;delegates&quot;,&quot;_currentParent&quot;,&quot;preDelegateOperations&quot;,&quot;postDelegateOperations&quot;]),jt.moveToProtected(e,t,[&quot;currentParent&quot;]),jv(e,t)}var qv={newInstance:jt.newInstance($v,&quot;vtkRenderPass&quot;),extend:$v};const{Representation:Xv}=ds,{vtkErrorMacro:Yv}=jt;function Zv(e){const t=cd.substitute(e.Fragment,&quot;//VTK::RenderPassFragmentShader::Impl&quot;,&quot;\\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\\n      gl_FragData[1].r = weight;\\n    &quot;,!1);e.Fragment=t.result}function Qv(e,t){t.classHierarchy.push(&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Es.newInstance({numberOfComponents:3,values:e});o.setName(&quot;points&quot;);const a=Es.newInstance({numberOfComponents:2,values:n});a.setName(&quot;tcoords&quot;);const i=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,&quot;polys&quot;,Xv.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Nd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,&quot;Float32Array&quot;,null),t.translucentRTexture=Nd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,&quot;Float32Array&quot;,null),t.translucentZTexture=Nd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],&quot;Float32Array&quot;,null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;attribute vec2 tcoordTC;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = tcoordTC; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),&quot;//VTK::System::Dec\\n\\nin vec2 tcoord;\\n\\nuniform sampler2D translucentRTexture;\\nuniform sampler2D translucentRGBATexture;\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\\n  float t2Color = texture(translucentRTexture, tcoord).r;\\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\\n}\\n&quot;,&quot;&quot;)},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;tcoordTC&quot;,t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;)},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension(&quot;EXT_color_buffer_half_float&quot;)&&!i.getExtension(&quot;EXT_color_buffer_float&quot;))return e.setCurrentOperation(&quot;translucentPass&quot;),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation(&quot;opaqueZBufferPass&quot;),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation(&quot;translucentPass&quot;),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi(&quot;translucentRGBATexture&quot;,t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi(&quot;translucentRTexture&quot;,t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate()},e.getShaderReplacement=()=>t._supported?Zv:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const Jv={framebuffer:null,copyShader:null,tris:null};function ey(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jv,n),qv.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),jt.get(e,t,[&quot;framebuffer&quot;]),Qv(e,t)}var ty={newInstance:jt.newInstance(ey,&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),extend:ey};function ny(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];if(s.getDraw()&&s.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=Hp.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation(&quot;zBufferPass&quot;),i.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation(&quot;opaquePass&quot;),i.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=ty.newInstance()),t.translucentPass.traverse(n,i,e)),t.volumeCount>0&&(e.setCurrentOperation(&quot;volumePass&quot;),i.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation(&quot;overlayPass&quot;),i.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const ry={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ry,n),qv.extend(e,t,n),jt.get(e,t,[&quot;framebuffer&quot;,&quot;opaqueActorCount&quot;,&quot;translucentActorCount&quot;,&quot;volumeCount&quot;]),ny(e,t)}var ay={newInstance:jt.newInstance(oy,&quot;vtkForwardPass&quot;),extend:oy},iy=n(594),sy=n.n(iy);const ly=[&quot;lastShaderProgramBound&quot;,&quot;context&quot;,&quot;_openGLRenderWindow&quot;];function cy(e,t){t.classHierarchy.push(&quot;vtkShaderCache&quot;),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=cd.substitute(o,&quot;VSOut&quot;,&quot;GSOut&quot;).result);const a=t._openGLRenderWindow.getWebgl2();let i=&quot;\\n&quot;,s=&quot;#version 100\\n&quot;;a?s=&quot;#version 300 es\\n#define attribute in\\n#define textureCube texture\\n#define texture2D texture\\n#define textureCubeLod textureLod\\n#define texture2DLod textureLod\\n&quot;:(t.context.getExtension(&quot;OES_standard_derivatives&quot;),t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(i=&quot;#extension GL_EXT_frag_depth : enable\\n&quot;),t.context.getExtension(&quot;EXT_shader_texture_lod&quot;)&&(i+=&quot;#extension GL_EXT_shader_texture_lod : enable\\n#define textureCubeLod textureCubeLodEXT\\n#define texture2DLod texture2DLodEXT&quot;)),o=cd.substitute(o,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,a?&quot;&quot;:&quot;#extension GL_OES_standard_derivatives : enable\\n&quot;,i,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;let l=cd.substitute(e,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;if(a){l=cd.substitute(l,&quot;varying&quot;,&quot;out&quot;).result,o=cd.substitute(o,&quot;varying&quot;,&quot;in&quot;).result;let e=&quot;&quot;,t=0;for(;o.includes(`gl_FragData[${t}]`);)o=cd.substitute(o,`gl_FragData\\\\[${t}\\\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\\n`,t++;o=cd.substitute(o,&quot;//VTK::Output::Dec&quot;,e).result}return{VSSource:l,FSSource:o,GSSource:cd.substitute(r,&quot;//VTK::System::Dec&quot;,s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=sy().hash(o);if(!(a in t.shaderPrograms)){const o=cd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const uy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,ly),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cy(e,t)}var py={newInstance:jt.newInstance(dy,&quot;vtkShaderCache&quot;),extend:dy};const{vtkErrorMacro:fy}=jt;function gy(e,t){t.classHierarchy.push(&quot;vtkOpenGLTextureUnitManager&quot;),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&fy(&quot;some texture units  were not properly released&quot;);t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const my={context:null,numberOfTextureUnits:0,textureUnits:0};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,[&quot;numberOfTextureUnits&quot;]),jt.setGet(e,t,[&quot;context&quot;]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,&quot;vtkOpenGLTextureUnitManager&quot;),extend:hy};function yy(e,t){t.classHierarchy.push(&quot;vtkRenderWindowViewNode&quot;),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.createSelector=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)}}const Ty={size:void 0,selector:void 0};function by(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ty,n),t.size||(t.size=[300,300]),jt.getArray(e,t,[&quot;size&quot;],2),jt.get(e,t,[&quot;selector&quot;]),Zt.extend(e,t,n),yy(e,t)}var xy={newInstance:jt.newInstance(by,&quot;vtkRenderWindowViewNode&quot;),extend:by};const{vtkDebugMacro:Cy,vtkErrorMacro:Sy}=jt,Ay={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Iy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let wy=0;const Py=[];function Oy(){wy++,Py.forEach((e=>e(wy)))}function Ry(){wy--,Py.forEach((e=>e(wy)))}function My(e){e.preventDefault()}function Dy(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderWindow&quot;);const n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if(&quot;__getUnderlyingContext&quot;===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}();e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener(&quot;webglcontextlost&quot;,My,!1),t.canvas.addEventListener(&quot;webglcontextrestored&quot;,e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow(e)}))}},e.initialize=()=>{if(!t.initialized){t.context=e.get3DContext(),t.textureUnitManager=vy.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND),t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Sy(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.activeFramebuffer?t.activeFramebuffer.getSize():t.size,e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:&quot;high-performance&quot;},r=null;const o=&quot;undefined&quot;!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext(&quot;webgl2&quot;,e),r&&(t.webgl2=!0,Cy(&quot;using webgl2&quot;))),r||(Cy(&quot;using webgl1&quot;),r=t.canvas.getContext(&quot;webgl&quot;,e)||t.canvas.getContext(&quot;experimental-webgl&quot;,e)),new Proxy(r,n)},e.restoreContext=()=>{const t=qv.newInstance();t.setCurrentOperation(&quot;Release&quot;),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?Sy(&quot;Hardware does not support the number of textures defined.&quot;):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case ys.CHAR:case ys.SIGNED_CHAR:case ys.UNSIGNED_CHAR:return 1;case n:case r:case ys.UNSIGNED_SHORT:case ys.SHORT:case ys.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case ys.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&ys.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&ys.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return t.context.R16F;case 2:return t.context.RG16F;case 3:return t.context.RGB16F;default:return t.context.RGBA16F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Ay,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension(&quot;OES_texture_float&quot;),o=n.getExtension(&quot;OES_texture_half_float&quot;),a=n.getExtension(&quot;WEBGL_debug_renderer_info&quot;),i=n.getExtension(&quot;WEBGL_draw_buffers&quot;),s=n.getExtension(&quot;EXT_texture_filter_anisotropic&quot;)||n.getExtension(&quot;WEBKIT_EXT_texture_filter_anisotropic&quot;),l=[[&quot;Max Vertex Attributes&quot;,&quot;MAX_VERTEX_ATTRIBS&quot;,n.getParameter(n.MAX_VERTEX_ATTRIBS)],[&quot;Max Varying Vectors&quot;,&quot;MAX_VARYING_VECTORS&quot;,n.getParameter(n.MAX_VARYING_VECTORS)],[&quot;Max Vertex Uniform Vectors&quot;,&quot;MAX_VERTEX_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],[&quot;Max Fragment Uniform Vectors&quot;,&quot;MAX_FRAGMENT_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],[&quot;Max Fragment Texture Image Units&quot;,&quot;MAX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],[&quot;Max Vertex Texture Image Units&quot;,&quot;MAX_VERTEX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],[&quot;Max Combined Texture Image Units&quot;,&quot;MAX_COMBINED_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],[&quot;Max 2D Texture Size&quot;,&quot;MAX_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_TEXTURE_SIZE)],[&quot;Max Cube Texture Size&quot;,&quot;MAX_CUBE_MAP_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],[&quot;Max Texture Anisotropy&quot;,&quot;MAX_TEXTURE_MAX_ANISOTROPY_EXT&quot;,s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],[&quot;Point Size Range&quot;,&quot;ALIASED_POINT_SIZE_RANGE&quot;,n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(&quot; - &quot;)],[&quot;Line Width Range&quot;,&quot;ALIASED_LINE_WIDTH_RANGE&quot;,n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(&quot; - &quot;)],[&quot;Max Viewport Dimensions&quot;,&quot;MAX_VIEWPORT_DIMS&quot;,n.getParameter(n.MAX_VIEWPORT_DIMS).join(&quot; - &quot;)],[&quot;Max Renderbuffer Size&quot;,&quot;MAX_RENDERBUFFER_SIZE&quot;,n.getParameter(n.MAX_RENDERBUFFER_SIZE)],[&quot;Framebuffer Red Bits&quot;,&quot;RED_BITS&quot;,n.getParameter(n.RED_BITS)],[&quot;Framebuffer Green Bits&quot;,&quot;GREEN_BITS&quot;,n.getParameter(n.GREEN_BITS)],[&quot;Framebuffer Blue Bits&quot;,&quot;BLUE_BITS&quot;,n.getParameter(n.BLUE_BITS)],[&quot;Framebuffer Alpha Bits&quot;,&quot;ALPHA_BITS&quot;,n.getParameter(n.ALPHA_BITS)],[&quot;Framebuffer Depth Bits&quot;,&quot;DEPTH_BITS&quot;,n.getParameter(n.DEPTH_BITS)],[&quot;Framebuffer Stencil Bits&quot;,&quot;STENCIL_BITS&quot;,n.getParameter(n.STENCIL_BITS)],[&quot;Framebuffer Subpixel Bits&quot;,&quot;SUBPIXEL_BITS&quot;,n.getParameter(n.SUBPIXEL_BITS)],[&quot;MSAA Samples&quot;,&quot;SAMPLES&quot;,n.getParameter(n.SAMPLES)],[&quot;MSAA Sample Buffers&quot;,&quot;SAMPLE_BUFFERS&quot;,n.getParameter(n.SAMPLE_BUFFERS)],[&quot;Supported Formats for UByte Render Targets     &quot;,&quot;UNSIGNED_BYTE RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.UNSIGNED_BYTE)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.UNSIGNED_BYTE)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.UNSIGNED_BYTE)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Half Float Render Targets&quot;,&quot;HALF FLOAT RENDER TARGET FORMATS&quot;,[o&&Iy(n,n.RGBA,o.HALF_FLOAT_OES)?&quot;RGBA&quot;:&quot;&quot;,o&&Iy(n,n.RGB,o.HALF_FLOAT_OES)?&quot;RGB&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?&quot;LUMINANCE&quot;:&quot;&quot;,o&&Iy(n,n.ALPHA,o.HALF_FLOAT_OES)?&quot;ALPHA&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Full Float Render Targets&quot;,&quot;FLOAT RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.FLOAT)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.FLOAT)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.FLOAT)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.FLOAT)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.FLOAT)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Max Multiple Render Targets Buffers&quot;,&quot;MAX_DRAW_BUFFERS_WEBGL&quot;,i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],[&quot;High Float Precision in Vertex Shader&quot;,&quot;HIGH_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Vertex Shader&quot;,&quot;MEDIUM_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Vertex Shader&quot;,&quot;LOW_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Float Precision in Fragment Shader&quot;,&quot;HIGH_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Fragment Shader&quot;,&quot;MEDIUM_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Fragment Shader&quot;,&quot;LOW_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Vertex Shader&quot;,&quot;HIGH_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Vertex Shader&quot;,&quot;MEDIUM_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Vertex Shader&quot;,&quot;LOW_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Fragment Shader&quot;,&quot;HIGH_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Fragment Shader&quot;,&quot;MEDIUM_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Fragment Shader&quot;,&quot;LOW_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Supported Extensions&quot;,&quot;EXTENSIONS&quot;,n.getSupportedExtensions().join(&quot;<br/>\\t\\t\\t\\t\\t    &quot;)],[&quot;WebGL Renderer&quot;,&quot;RENDERER&quot;,n.getParameter(n.RENDERER)],[&quot;WebGL Vendor&quot;,&quot;VENDOR&quot;,n.getParameter(n.VENDOR)],[&quot;WebGL Version&quot;,&quot;VERSION&quot;,n.getParameter(n.VERSION)],[&quot;Shading Language Version&quot;,&quot;SHADING_LANGUAGE_VERSION&quot;,n.getParameter(n.SHADING_LANGUAGE_VERSION)],[&quot;Unmasked Renderer&quot;,&quot;UNMASKED_RENDERER&quot;,a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],[&quot;Unmasked Vendor&quot;,&quot;UNMASKED_VENDOR&quot;,a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],[&quot;WebGL Version&quot;,&quot;WEBGL_VERSION&quot;,t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}()},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=df.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((function(){t.canvas.removeEventListener(&quot;webglcontextlost&quot;,My),t.canvas.removeEventListener(&quot;webglcontextrestored&quot;,e.restoreContext)}),e.delete,e.setViewStream,Ry),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.getGraphicsResourceForObject=e=>e?{vtkObj:t._graphicsResources.get(e),hash:t._graphicsResourceHash.get(e)}:null,e.setGraphicsResourceForObject=(e,n,r)=>{e&&(t._graphicsResources.set(e,n),t._graphicsResourceHash.set(e,r))},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach(((t,n)=>{e+=t.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResourcesForObject=n=>!!n&&(t._graphicsResources.get(n)?.releaseGraphicsResources(e),t._graphicsResources.delete(n)&&t._graphicsResourceHash.delete(n)),e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach(((t,n)=>{t.releaseGraphicsResources(e)})),t._graphicsResources.clear(),t._graphicsResourceHash.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))}}const Ey={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1};const Vy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),xy.extend(e,t,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,Oy(),t.selector||(t.selector=df.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,t._textureResourceIds=new Map,t._graphicsResources=new Map,t._graphicsResourceHash=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Vy),t.shaderCache=py.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=ay.newInstance(),jt.event(e,t,&quot;imageReady&quot;),jt.get(e,t,[&quot;shaderCache&quot;,&quot;textureUnitManager&quot;,&quot;webgl2&quot;,&quot;useBackgroundImage&quot;,&quot;activeFramebuffer&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;defaultToWebgl2&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Dy(e,t)}),&quot;vtkOpenGLRenderWindow&quot;);function Ly(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderModule&quot;),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}ev(&quot;WebGL&quot;,Vy);const By={device:null,handle:null};function Ny(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,By,n),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;handle&quot;]),Ly(e,t)}var _y={newInstance:jt.newInstance(Ny,&quot;vtkWebGPUShaderModule&quot;),extend:Ny};function Fy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderCache&quot;),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=_y.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const ky={shaderModules:null,device:null,window:null};function Gy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ky,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;,&quot;window&quot;]),Fy(e,t)}var Uy={newInstance:jt.newInstance(Gy,&quot;vtkWebGPUShaderCache&quot;),extend:Gy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join(&quot;\\n&quot;):n;let a=!1;-1!==e.search(t)&&(a=!0);let i=&quot;&quot;;r&&(i=&quot;g&quot;);const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function zy(e,t){t.classHierarchy.push(&quot;vtkWebGPUBindGroup&quot;),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join(&quot;\\n&quot;)}}const Wy={device:null,handle:null,label:null};function Hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;label&quot;,&quot;device&quot;,&quot;arrayInformation&quot;]),zy(e,t)}var jy={newInstance:jt.newInstance(Hy),extend:Hy};function Ky(e,t){t.classHierarchy.push(&quot;vtkWebGPUPipeline&quot;),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);&quot;vertex&quot;===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint=&quot;main&quot;),&quot;fragment&quot;===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint=&quot;main&quot;)}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const $y={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$y,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,[&quot;handle&quot;,&quot;pipelineDescription&quot;]),At(e,t,[&quot;device&quot;,&quot;renderEncoder&quot;,&quot;topology&quot;,&quot;vertexState&quot;]),Ky(e,t)}var Xy={newInstance:Et(qy,&quot;vtkWebGPUPipeline&quot;),extend:qy};function Yy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderDescription&quot;),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push(&quot;};&quot;),o=n,r[r.length-1]+=&quot;,&quot;,r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Input&quot;,r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push(&quot;};&quot;),o=o.concat(e),t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Output&quot;,[`-> ${t.type}Output`]).result}t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Dec&quot;,o).result}}const Zy={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function Qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zy,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,[&quot;type&quot;,&quot;hash&quot;,&quot;code&quot;]),jt.getArray(e,t,[&quot;outputTypes&quot;,&quot;outputNames&quot;,&quot;outputInterpolations&quot;]),Yy(e,t)}var Jy={newInstance:jt.newInstance(Qy,&quot;vtkWebGPUShaderDescription&quot;),extend:Qy};const eT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;sint&quot;},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;uint&quot;},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:&quot;sint&quot;},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:&quot;float&quot;},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;uint&quot;},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;sint&quot;},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:&quot;uint&quot;},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:&quot;sint&quot;},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:&quot;uint&quot;},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:&quot;sint&quot;},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:&quot;float&quot;},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;rgba8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;uint&quot;},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;sint&quot;},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;bgra8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:&quot;float&quot;},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:&quot;uint&quot;},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:&quot;sint&quot;},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:&quot;uint&quot;},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:&quot;sint&quot;},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:&quot;float&quot;},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:&quot;uint&quot;},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:&quot;sint&quot;},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:&quot;unfilterable-float&quot;},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;depth&quot;},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:&quot;depth&quot;},&quot;depth24plus-stencil8&quot;:{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:&quot;mixed&quot;},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;depth&quot;}};var tT=function(e){return!e||e.length<6?0:e in eT==1?eT[e]:(et(`unknown format ${e}`),null)},nT=function(e){if(!e||e.length<5)return 0;let t=1;&quot;x&quot;===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},rT=function(e){if(!e||e.length<5)return 0;let t;if(&quot;f&quot;===e[0])t=&quot;Float&quot;;else if(&quot;s&quot;===e[0])t=&quot;Int&quot;;else{if(&quot;u&quot;!==e[0])return void et(`unknown format ${e}`);t=&quot;Uint&quot;}const n=e.split(&quot;x&quot;)[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+=&quot;Array&quot;,t;et(`unknown format ${e}`)},oT=function(e){let t;if(&quot;f&quot;===e[0]||&quot;n&quot;===e[1])t=&quot;f32&quot;;else if(&quot;s&quot;===e[0]&&&quot;i&quot;===e[1])t=&quot;i32&quot;;else{if(&quot;u&quot;!==e[0]||&quot;i&quot;!==e[1])return void et(`unknown format ${e}`);t=&quot;u32&quot;}let n=1;return&quot;x&quot;===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},aT=function(e){if(!e)return 0;let t=1;return&quot;vec&quot;===e.substring(0,3)?t=Number(e[3]):&quot;mat&quot;===e.substring(0,3)&&(t=e[3]*e[5]),4*t},iT=function(e){if(e)return e.includes(&quot;f32&quot;)?&quot;Float32Array&quot;:e.includes(&quot;i32&quot;)?&quot;Int32Array&quot;:e.includes(&quot;u32&quot;)?&quot;Uint32Array&quot;:void et(`unknown format ${e}`)};function sT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function lT(e,t){t.classHierarchy.push(&quot;vtkWebGPUVertexInput&quot;),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:&quot;vertex&quot;,o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(sT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e=&quot;&quot;,n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=oT(a.format);n>0&&(e+=&quot;,\\n&quot;),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const cT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function uT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,[&quot;created&quot;,&quot;device&quot;,&quot;handle&quot;,&quot;indexBuffer&quot;]),lT(e,t)}var dT={newInstance:Et(uT,&quot;vtkWebGPUVertexInput&quot;),extend:uT};const pT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  // var vertex: vec4<f32> = vertexBC;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n&quot;,fT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function gT(e,t){t.classHierarchy.push(&quot;vtkWebGPUSimpleMapper&quot;),e.generateShaderDescriptions=(n,r,o)=>{const a=Jy.newInstance({type:&quot;vertex&quot;,hash:n,code:t.vertexShaderTemplate}),i=Jy.newInstance({type:&quot;fragment&quot;,hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp(&quot;//VTK::[^:]*::&quot;,&quot;g&quot;),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];&quot;replaceShaderIOStructs&quot;!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.replaceShaderCode(null,n),t.getShaderDescription(&quot;fragment&quot;).replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set(&quot;replaceShaderRenderEncoder&quot;,e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderRenderer&quot;,e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);s.addBuiltinInput(&quot;bool&quot;,&quot;@builtin(front_facing) frontFacing&quot;),i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderMapper&quot;,e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;    output.Position = rendererUBO.SCPCMatrix*vertexBC;&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription(&quot;vertex&quot;).addOutput(&quot;vec2<f32>&quot;,&quot;tcoordVS&quot;)},t.shaderReplacements.set(&quot;replaceShaderTCoord&quot;,e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=Xy.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const mT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:&quot;triangle-list&quot;,UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function hT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=dT.newInstance(),t.bindGroup=jy.newInstance({label:&quot;mapperBG&quot;}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||fT,t.vertexShaderTemplate=t.vertexShaderTemplate||pT,t.shaderReplacements=new Map,jt.get(e,t,[&quot;pipeline&quot;,&quot;vertexInput&quot;]),jt.setGet(e,t,[&quot;additionalBindables&quot;,&quot;device&quot;,&quot;fragmentShaderTemplate&quot;,&quot;interpolate&quot;,&quot;numberOfInstances&quot;,&quot;numberOfVertices&quot;,&quot;pipelineHash&quot;,&quot;shaderReplacements&quot;,&quot;SSBO&quot;,&quot;textureViews&quot;,&quot;topology&quot;,&quot;UBO&quot;,&quot;vertexShaderTemplate&quot;,&quot;WebGPURenderer&quot;]),gT(e,t)}var vT={newInstance:jt.newInstance(hT,&quot;vtkWebGPUSimpleMapper&quot;),extend:hT};function yT(e,t){t.classHierarchy.push(&quot;vtkWebGPUFullScreenQuad&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;),r.addOutput(&quot;vec4<f32>&quot;,&quot;vertexVC&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;,&quot;output.vertexVC = vec4<f32>(vertexBC, 1);&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,[&quot;vertexBC&quot;]),t.numberOfVertices=6}}const TT={};function bT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,TT,n),vT.extend(e,t,n),yT(e,t)}var xT={newInstance:jt.newInstance(bT,&quot;vtkWebGPUFullScreenQuad&quot;),extend:bT};const CT=[&quot;setBindGroup&quot;,&quot;setIndexBuffer&quot;,&quot;setVertexBuffer&quot;,&quot;draw&quot;,&quot;drawIndexed&quot;];function ST(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderEncoder&quot;),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!(&quot;depthStencil&quot;in n))console.log(&quot;mismatched depth attachments&quot;),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\\n${o}\\n versus pipeline\\n${a}\\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<CT.length;n++)e[CT[n]]=function(){return t.handle[CT[n]](...arguments)}}const AT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function IT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}],depthStencilAttachment:{view:void 0,depthLoadOp:&quot;clear&quot;,depthClearValue:0,depthStoreOp:&quot;store&quot;}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = computedColor;&quot;]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater-equal&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}},t.colorTextureViews=[],bt(e,t,[&quot;boundPipeline&quot;,&quot;colorTextureViews&quot;]),At(e,t,[&quot;depthTextureView&quot;,&quot;description&quot;,&quot;handle&quot;,&quot;label&quot;,&quot;pipelineHash&quot;,&quot;pipelineSettings&quot;,&quot;replaceShaderCodeFunction&quot;]),ST(e,t)}var wT={newInstance:Et(IT,&quot;vtkWebGPURenderEncoder&quot;),extend:IT},PT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const OT=[&quot;getMappedRange&quot;,&quot;mapAsync&quot;,&quot;unmap&quot;];function RT(e,t){t.classHierarchy.push(&quot;vtkWebGPUBuffer&quot;),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<OT.length;n++)e[OT[n]]=function(){return t.handle[OT[n]](...arguments)}}const MT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;strideInBytes&quot;,&quot;device&quot;,&quot;arrayInformation&quot;,&quot;label&quot;,&quot;sourceTime&quot;]),RT(e,t)}var ET={newInstance:jt.newInstance(DT),extend:DT,...PT};const{Representation:VT}=ds,{PrimitiveTypes:LT}=PT;class BT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function NT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function _T(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=NT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=NT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=NT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=NT(n,o,t),n.ibo[n.iboId++]=a}function FT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let kT;const GT=new Uint32Array(1),UT=new Uint32Array(2),zT=new Uint32Array(3),WT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)GT[0]=t[n+a],kT(GT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)UT[0]=t[n+a],UT[1]=t[n+(a+1)%e],kT(UT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o);for(let a=0;a<e-2;a++)UT[0]=t[n+a],UT[1]=t[n+a+2],kT(UT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n],zT[1]=t[n+a+1],zT[2]=t[n+a+2],kT(zT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n+a],zT[1]=t[n+a+1+a%2],zT[2]=t[n+a+1+(a+1)%2],kT(zT,r,o)}};function HT(e,t){t.classHierarchy.push(&quot;vtkWebGPUIndexBuffer&quot;),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case LT.Points:return&quot;points&quot;;case LT.Lines:return&quot;lines&quot;;case LT.Triangles:case LT.TriangleEdges:return&quot;polys&quot;;case LT.TriangleStripEdges:case LT.TriangleStrips:return&quot;strips&quot;;default:return&quot;&quot;}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new BT};let d=null;d=o===VT.POINTS||r===LT.Points?WT.anythingToPoints:o===VT.WIREFRAME||r===LT.Lines?WT[`${l}ToWireframe`]:WT[`${l}ToSurface`],kT=FT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format=&quot;uint16&quot;):(u.ibo=new Uint32Array(u.iboSize),e.format=&quot;uint32&quot;),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),kT=_T,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const jT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function KT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jT,n),ET.extend(e,t,n),jt.setGet(e,t,[&quot;flatIdToPointId&quot;,&quot;flatIdToCellId&quot;,&quot;flatSize&quot;,&quot;indexCount&quot;]),HT(e,t)}var $T={newInstance:jt.newInstance(KT),extend:KT,...PT};const{BufferUsage:qT}=PT,{vtkErrorMacro:XT}=Kt,{VtkDataTypes:YT}=Es;function ZT(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,&quot;packExtra&quot;)&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function QT(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function JT(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===qT.Index&&(n=$T.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=ET.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===qT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===qT.PointArray){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=ZT(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?&quot;flat&quot;:&quot;perspective&quot;}])}if(e.usage===qT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=QT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=ZT(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:&quot;flat&quot;}])}return e.usage===qT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push(&quot;vtkWebGPUBufferManager&quot;),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case YT.UNSIGNED_CHAR:t=&quot;uint8&quot;;break;case YT.FLOAT:t=&quot;float32&quot;;break;case YT.UNSIGNED_INT:t=&quot;uint32&quot;;break;case YT.INT:t=&quot;sint32&quot;;break;case YT.DOUBLE:t=&quot;float32&quot;;break;case YT.UNSIGNED_SHORT:t=&quot;uint16&quot;;break;case YT.SHORT:t=&quot;sin16&quot;;break;default:t=&quot;float32&quot;}switch(e.getNumberOfComponents()){case 2:t+=&quot;x2&quot;;break;case 3:t.includes(&quot;32&quot;)||XT(`unsupported x3 type for ${t}`),t+=&quot;x3&quot;;break;case 4:t+=&quot;x4&quot;}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:qT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=ET.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:&quot;float32x3&quot;}]),t.fullScreenQuadBuffer}}const eb={device:null,fullScreenQuadBuffer:null};function tb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eb,n),yt(e,t),At(e,t,[&quot;device&quot;]),JT(e,t)}var nb={newInstance:Et(tb),extend:tb,...PT};function rb(e,t){t.classHierarchy.push(&quot;vtkWebGPUSampler&quot;),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:&quot;clamp-to-edge&quot;,t.options.addressModeV=n.addressModeV?n.addressModeV:&quot;clamp-to-edge&quot;,t.options.addressModeW=n.addressModeW?n.addressModeW:&quot;clamp-to-edge&quot;,t.options.magFilter=n.magFilter?n.magFilter:&quot;nearest&quot;,t.options.minFilter=n.minFilter?n.minFilter:&quot;nearest&quot;,t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:&quot;nearest&quot;,t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const ob={device:null,handle:null,label:null,options:null};function ab(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ob,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;options&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;]),rb(e,t)}var ib={newInstance:jt.newInstance(ab),extend:ab};function sb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTextureView&quot;),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r=&quot;f32&quot;;&quot;sint&quot;===t.bindGroupLayoutEntry.texture.sampleType?r=&quot;i32&quot;:&quot;uint&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(r=&quot;u32&quot;);let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return&quot;depth&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=ib.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const lb={texture:null,handle:null,sampler:null,label:null};function cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:&quot;float&quot;,viewDimension:&quot;2d&quot;}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;texture&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;sampler&quot;]),sb(e,t)}var ub={newInstance:jt.newInstance(cb),extend:cb};const{BufferUsage:db}=nb;function pb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTexture&quot;),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?&quot;2d&quot;:&quot;3d&quot;;t.format=n.format?n.format:&quot;rgba8unorm&quot;,t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:&quot;rgba8unorm&quot;,t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format=&quot;rgba8unorm&quot;,n.flip=!0,n.nativeArray=n.jsImageData.data);const o=tT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&&quot;float&quot;===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?&quot;Uint16Array&quot;:i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Ad.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement(&quot;canvas&quot;);e.width=n.image.width,e.height=n.image.height;const t=e.getContext(&quot;2d&quot;);t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Tu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:db.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:db.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=tT(t.format);return 2===e.elementSize&&&quot;float&quot;===e.sampleType?1:255},e.getNumberOfComponents=()=>tT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?&quot;2d&quot;:&quot;3d&quot;);const o=ub.newInstance({label:n});return o.create(e,r),o}}const fb={device:null,handle:null,buffer:null,ready:!1,label:null};function gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fb,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;ready&quot;,&quot;width&quot;,&quot;height&quot;,&quot;depth&quot;,&quot;format&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;label&quot;]),pb(e,t)}var mb={newInstance:jt.newInstance(gb),extend:gb};function hb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOpaquePass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;opaquePassColor&quot;}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView(&quot;opaquePassColorTexture&quot;);t.renderEncoder.setColorTextureView(0,n),t.depthFormat=&quot;depth32float&quot;,t.depthTexture=mb.newInstance({label:&quot;opaquePassDepth&quot;}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;opaquePassDepthTexture&quot;);t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;opaquePass&quot;),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=wT.newInstance({label:&quot;OpaquePass&quot;}),t.renderEncoder.setPipelineHash(&quot;op&quot;)}}const vb={renderEncoder:null,colorTexture:null,depthTexture:null};function yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vb,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),hb(e,t)}var Tb={newInstance:jt.newInstance(yb,&quot;vtkWebGPUOpaquePass&quot;),extend:yb};function bb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=mb.newInstance({label:&quot;translucentPassColor&quot;}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView(&quot;oitpColorTexture&quot;);t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=mb.newInstance({label:&quot;translucentPassAccumulate&quot;}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView(&quot;oitpAccumTexture&quot;);t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=xT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash(&quot;oitpfsq&quot;),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\\n  if (reveal == 1.0) { discard; }\\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\\n  var total: f32 = max(tcolor.a, 0.01);\\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;)}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;translucentPass&quot;),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=wT.newInstance({label:&quot;translucentRender&quot;});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:void 0,clearValue:[1,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}],e.depthStencilAttachment={view:void 0,depthLoadOp:&quot;load&quot;,depthStoreOp:&quot;store&quot;},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addOutput(&quot;f32&quot;,&quot;outAccum&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);&quot;,&quot;output.outColor = vec4<f32>(computedColor.rgb*w, w);&quot;,&quot;output.outAccum = computedColor.a;&quot;]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash(&quot;oitpr&quot;),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!1,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;zero&quot;,dstFactor:&quot;one-minus-src&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=wT.newInstance({label:&quot;translucentFinal&quot;}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash(&quot;oitpf&quot;),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})}}const xb={colorTextureView:null,depthTextureView:null};function Cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),bb(e,t)}var Sb={newInstance:jt.newInstance(Cb,&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),extend:Cb};const{BufferUsage:Ab}=nb,{vtkErrorMacro:Ib}=jt;function wb(e,t){t.classHierarchy.push(&quot;vtkWebGPUUniformBuffer&quot;),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Ib(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:aT(n),offset:-1,nativeType:iT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Ab.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join(&quot;\\n&quot;)}}const Pb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function Ob(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;uniform&quot;}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,[&quot;binding&quot;,&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;,&quot;sizeInBytes&quot;]),wb(e,t)}var Rb={newInstance:jt.newInstance(Ob,&quot;vtkWebGPUUniformBuffer&quot;),extend:Ob};const{BufferUsage:Mb}=nb,{vtkErrorMacro:Db}=jt;function Eb(e,t){t.classHierarchy.push(&quot;vtkWebGPUStorageBuffer&quot;),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void Db(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=aT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:iT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Mb.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\\n};\\nstruct ${t.label}Struct\\n{\\n  values: array<${t.label}StructEntry>,\\n};\\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\\n`),r.join(&quot;\\n&quot;)},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Vb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function Lb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;read-only-storage&quot;}},jt.get(e,t,[&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;numberOfInstances&quot;,&quot;sizeInBytes&quot;]),Eb(e,t)}var Bb={newInstance:jt.newInstance(Lb,&quot;vtkWebGPUStorageBuffer&quot;),extend:Lb};const Nb=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Volume::TraverseDec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\\n{\\n  // todo multicomponent support\\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\\n}\\n\\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\\n{\\n  var result: vec4<f32>;\\n\\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\\n  result.w = 0.0;\\n\\n  // divide by spacing as that is our delta\\n  result = result / volumeSSBO.values[vNum].spacing;\\n  // now we have a gradient in unit tcoords\\n\\n  var grad: f32 = length(result.xyz);\\n  if (grad > 0.0)\\n  {\\n    // rotate to View Coords, needed for lighting and shading\\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\\n    result = nMat * result;\\n    result = result / length(result);\\n  }\\n\\n  // store gradient magnitude in .w\\n  result.w = grad;\\n\\n  return result;\\n}\\n\\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\\n{\\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n\\n  // convert to tcoords and reject if outside the volume\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\\n\\n  var scalar: f32 = getTextureValue(vTex, tpos);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n\\n  var gofactor: f32 = 1.0;\\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    normal = getGradient(vTex, tpos, vNum, scalar);\\n    if (componentSSBO.values[cNum].gomin <  1.0)\\n    {\\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\\n    }\\n  }\\n\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n\\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    color = color*abs(normal.z);\\n  }\\n\\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\\n\\n  return outColor;\\n}\\n\\n// adjust the start and end point of a raycast such that it intersects the unit cube.\\n// This function is used to take a raycast starting point and step vector\\n// and numSteps and return the startijng and ending steps for intersecting the\\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\\n// and bound it to intersecting the texture.\\n//\\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\\n{\\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\\n\\n  // move tpos to the start of the volume\\n  var adjust: f32 =\\n    min(\\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\\n      min(\\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\\n  if (adjust < 0.0)\\n  {\\n    result.x = result.x - adjust;\\n  }\\n\\n  // adjust length to the end\\n  adjust =\\n    max(\\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\\n      max(\\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\\n  if (adjust > 0.0)\\n  {\\n    result.y = result.y - adjust;\\n  }\\n\\n  return result;\\n}\\n\\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\\n{\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n  return vec4<f32>(color.rgb, opacity);\\n}\\n\\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var maxVal: f32 = -1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar > maxVal)\\n    {\\n      maxVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\\n}\\n\\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var minVal: f32 = 1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar < minVal)\\n    {\\n      minVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\\n}\\n\\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var avgVal: f32 = 0.0;\\n  var sampleCount: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      avgVal = avgVal + sample;\\n      sampleCount = sampleCount + 1.0;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  if (sampleCount <= 0.0)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\\n}\\n\\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var sumVal: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      sumVal = sumVal + sample;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\\n}\\n\\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\\n{\\n  // initial ray position is at the beginning\\n  var rayPosSC: vec4<f32> = minPosSC;\\n\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var curDist: f32 = 0.0;\\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n  var sampleColor: vec4<f32>;\\n//VTK::Volume::TraverseCalls\\n\\n  loop\\n  {\\n    // for each volume, sample and accumulate color\\n//VTK::Volume::CompositeCalls\\n\\n    // increment position\\n    curDist = curDist + mapperUBO.SampleDistance;\\n    rayPosSC = rayPosSC + rayStepSC;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayLengthSC) { break; }\\n    if (computedColor.a > 0.98) { break; }\\n  }\\n  return computedColor;\\n}\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\\n\\n  // discard empty rays\\n  if (rayMax <= rayMin) { discard; }\\n  else\\n  {\\n    // compute start and end ray positions in view coordinates\\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\\n\\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\\n    rayStepSC.w = 0.0;\\n\\n    var computedColor: vec4<f32>;\\n\\n//VTK::Volume::Loop\\n\\n//VTK::RenderEncoder::Impl\\n  }\\n\\n  return output;\\n}\\n&quot;,_b=new Float64Array(16),Fb=new Float64Array(16);function kb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePassFSQ&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;]).result,r.setCode(o),t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription(&quot;fragment&quot;);let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===Rg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push(&quot;    computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;)):(s.push(`  sampleColor = traverseVals[${e}];`),s.push(&quot;  computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;));a=Uy.substitute(a,&quot;//VTK::Volume::CompositeCalls&quot;,i).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseCalls&quot;,s).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseDec&quot;,[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===Rg.COMPOSITE_BLEND?l=!0:n===Rg.MAXIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.MINIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.AVERAGE_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.ADDITIVE_INTENSITY_BLEND&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result)}l&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[&quot;    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);&quot;]).result),o.setCode(a)},t.shaderReplacements.set(&quot;replaceShaderVolume&quot;,e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8Array(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;rgba8unorm&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;tfunTexture&quot;);t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;r16float&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;ofunTexture&quot;);t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(_b),b(_b,_b,o);const p=n.getMatrix();m(Fb,p),h(Fb,Fb),T(_b,Fb,_b);const f=d.getWorldToIndex();T(_b,f,_b);const v=d.getDimensions();g(Fb),x(Fb,Fb,[1/v[0],1/v[1],1/v[2]]),T(_b,Fb,_b);for(let t=0;t<16;t++)a[16*e+t]=_b[t];h(_b,_b);for(let t=0;t<4;t++)i[16*e+4*t]=_b[4*t],i[16*e+4*t+1]=_b[4*t+1],i[16*e+4*t+2]=_b[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry(&quot;SCTCMatrix&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;planeNormals&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;shade&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;tstep&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;spacing&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;ipScalarRange&quot;,&quot;vec4<f32>&quot;),t.SSBO.setAllInstancesFromArray(&quot;SCTCMatrix&quot;,a),t.SSBO.setAllInstancesFromArray(&quot;planeNormals&quot;,i),t.SSBO.setAllInstancesFromArray(&quot;shade&quot;,l),t.SSBO.setAllInstancesFromArray(&quot;tstep&quot;,s),t.SSBO.setAllInstancesFromArray(&quot;spacing&quot;,c),t.SSBO.setAllInstancesFromArray(&quot;ipScalarRange&quot;,u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=tT(l),u={scale:[255],offset:[0]};2===c.elementSize&&&quot;float&quot;===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry(&quot;cScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;cShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomin&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomax&quot;,&quot;f32&quot;),t.componentSSBO.setAllInstancesFromArray(&quot;cScale&quot;,d),t.componentSSBO.setAllInstancesFromArray(&quot;cShift&quot;,p),t.componentSSBO.setAllInstancesFromArray(&quot;oScale&quot;,f),t.componentSSBO.setAllInstancesFromArray(&quot;oShift&quot;,v),t.componentSSBO.setAllInstancesFromArray(&quot;goScale&quot;,A),t.componentSSBO.setAllInstancesFromArray(&quot;goShift&quot;,S),t.componentSSBO.setAllInstancesFromArray(&quot;gomin&quot;,y),t.componentSSBO.setAllInstancesFromArray(&quot;gomax&quot;,C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue(&quot;SampleDistance&quot;,r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=ib.newInstance({label:&quot;clampSampler&quot;}),t.clampSampler.create(t.device,{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}))},e.computePipelineHash=()=>{t.pipelineHash=&quot;volfsq&quot;;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Gb={volumes:null,rowLength:1024,lastVolumeLength:0};function Ub(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gb,n),xT.extend(e,t,n),t.fragmentShaderTemplate=Nb,t.UBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t.UBO.addEntry(&quot;SampleDistance&quot;,&quot;f32&quot;),t.SSBO=Bb.newInstance({label:&quot;volumeSSBO&quot;}),t.componentSSBO=Bb.newInstance({label:&quot;componentSSBO&quot;}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),kb(e,t)}var zb={newInstance:jt.newInstance(Ub,&quot;vtkWebGPUVolumePassFSQ&quot;),extend:Ub};const{Representation:Wb}=ds,{BufferUsage:Hb,PrimitiveTypes:jb}=nb,Kb=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],$b=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::VolumePass::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::VolumePass::Impl\\n\\n  // use the maximum (closest) of the current value and the zbuffer\\n  // the blend func will then take the min to find the farthest stop value\\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function qb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePass&quot;),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=zb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=xT.newInstance(),t._volumeCopyQuad.setPipelineHash(&quot;volpassfsq&quot;),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._copyUBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t._copyUBO.addEntry(&quot;tscale&quot;,&quot;vec2<f32>&quot;),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray(&quot;tscale&quot;,[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray(&quot;tscale&quot;,[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:Hb.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:jb.Triangles,representation:Wb.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:Hb.PointArray,format:&quot;float32x4&quot;,hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,[&quot;vertexBC&quot;]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+Kb[e][0],l[n++]=r+Kb[e][1],l[n++]=r+Kb[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation(&quot;volumeDepthRangePass&quot;),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=wT.newInstance({label:&quot;VolumePass DepthRange&quot;}),t._depthRangeEncoder.setPipelineHash(&quot;volr&quot;),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor1&quot;),t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor2&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);&quot;,&quot;output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);&quot;]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:null,clearValue:[1,1,1,1],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;}}}]}}),t._depthRangeTexture=mb.newInstance({label:&quot;volumePassMaxDepth&quot;}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView(&quot;maxTexture&quot;);t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=mb.newInstance({label:&quot;volumePassDepthMin&quot;}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView(&quot;minTexture&quot;);t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=mb.newInstance({label:&quot;volumePassColor&quot;}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;bgra8unorm&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView(&quot;volumePassColorTexture&quot;),t._colorTextureView.addSampler(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._clearEncoder=wT.newInstance({label:&quot;VolumePass Clear&quot;}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._clearEncoder.setPipelineHash(&quot;volpf&quot;),t._clearEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=wT.newInstance({label:&quot;volumePassCopy&quot;}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._copyEncoder.setPipelineHash(&quot;volcopypf&quot;),t._copyEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=wT.newInstance({label:&quot;volumePassMerge&quot;}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash(&quot;volpf&quot;),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const Xb={colorTextureView:null,depthTextureView:null,volumes:null};function Yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xb,n),qv.extend(e,t,n),t._mapper=vT.newInstance(),t._mapper.setFragmentShaderTemplate($b),t._mapper.getShaderReplacements().set(&quot;replaceShaderVolumePass&quot;,((e,t,n)=>{t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)})),t._boundsPoly=gu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),qb(e,t)}var Zb={newInstance:jt.newInstance(Yb,&quot;vtkWebGPUVolumePass&quot;),extend:Yb};function Qb(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e),t.opaquePass||(t.opaquePass=Tb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Sb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=Zb.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=wT.newInstance({label:&quot;forwardPassBlit&quot;}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._finalBlitEncoder.setPipelineHash(&quot;fpf&quot;),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}}),t._fsqSampler=ib.newInstance({label:&quot;finalPassSampler&quot;}),t._fsqSampler.create(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._fullScreenQuad=xT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash(&quot;fpfsq&quot;),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0),vec4<f32>(0.0),vec4<f32>(1.0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._finalBlitOutputTextureView=ub.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const Jb={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;opaquePass&quot;,&quot;translucentPass&quot;,&quot;volumePass&quot;]),Qb(e,t)}var tx={newInstance:jt.newInstance(ex,&quot;vtkForwardPass&quot;),extend:ex};const{VtkDataTypes:nx}=Es;function rx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format=&quot;r&quot;;break;case 2:e.format=&quot;rg&quot;;break;default:e.format=&quot;rgba&quot;}switch(e.dataArray.getDataType()){case nx.UNSIGNED_CHAR:e.format+=&quot;8unorm&quot;;break;case nx.FLOAT:case nx.UNSIGNED_INT:case nx.INT:case nx.DOUBLE:case nx.UNSIGNED_SHORT:case nx.SHORT:default:e.format+=&quot;16float&quot;}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format=&quot;rgba8unorm&quot;),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=mb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push(&quot;vtkWebGPUTextureManager&quot;),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const ox={handle:null,device:null};function ax(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ox,n),jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;]),rx(e,t)}var ix={newInstance:jt.newInstance(ax),extend:ax};class sx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&&quot;object&quot;==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function lx(e,t){t.classHierarchy.push(&quot;vtkWebGPUDevice&quot;),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro(&quot;layout not found&quot;),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro(&quot;attempt to cache an object without a hash&quot;),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const cx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cx,n),yt(e,t),At(e,t,[&quot;handle&quot;]),bt(e,t,[&quot;bufferManager&quot;,&quot;shaderCache&quot;,&quot;textureManager&quot;]),t.objectCache=new sx,t.shaderCache=Uy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=nb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=ix.newInstance(),t.textureManager.setDevice(e),t.pipelines={},lx(e,t)}var dx={newInstance:Et(ux,&quot;vtkWebGPUDevice&quot;),extend:ux};function px(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelectionPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;hardwareSelectorColor&quot;}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;rgba32uint&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView(&quot;hardwareSelectColorTexture&quot;);t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=mb.newInstance({label:&quot;hardwareSelectorDepth&quot;}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;depth32float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;hardwareSelectDepthTexture&quot;);t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation(&quot;cameraPass&quot;),r.traverse(e),e.setCurrentOperation(&quot;opaquePass&quot;),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=wT.newInstance({label:&quot;HardwareSelectionPass&quot;}),t.selectionRenderEncoder.setPipelineHash(&quot;sel&quot;),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<u32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);&quot;]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba32uint&quot;,blend:void 0}]}})}}const fx={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function gx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fx,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),px(e,t)}var mx={newInstance:jt.newInstance(gx,&quot;vtkWebGPUHardwareSelectionPass&quot;),extend:gx};const{SelectionContent:hx,SelectionField:vx}=qp,{FieldAssociations:yx}=ol,{vtkErrorMacro:Tx}=jt;function bx(e){return`${e.propID} ${e.compositeID}`}function xx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Cx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=xx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=xx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Cx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Cx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Cx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Cx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Cx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Sx(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelector&quot;),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Tx(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=ET.newInstance({label:&quot;hardwareSelectColorBuffer&quot;});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=ET.newInstance({label:&quot;hardwareSelectDepthBuffer&quot;}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:&quot;depth-only&quot;},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Cx(e,[n,t],0,u);if(r){const t=bx(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=qp.newInstance();switch(i.setContentType(hx.INDICES),e){case yx.FIELD_ASSOCIATION_CELLS:i.setFieldType(vx.CELL);break;case yx.FIELD_ASSOCIATION_POINTS:i.setFieldType(vx.POINT);break;default:Tx(&quot;Unknown field association&quot;)}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Ax={};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),Gp.extend(e,t,n),t._selectionPass=mx.newInstance(),jt.setGet(e,t,[&quot;_WebGPURenderWindow&quot;]),jt.moveToProtected(e,t,[&quot;WebGPURenderWindow&quot;]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,&quot;vtkWebGPUHardwareSelector&quot;),extend:Ix};const Px=Object.create(null);function Ox(e,t){t.classHierarchy.push(&quot;vtkWebGPUViewNodeFactory&quot;)}const Rx={};function Mx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rx,n),t.overrides=Px,tn.extend(e,t,n),Ox(0,t)}var Dx={newInstance:jt.newInstance(Mx,&quot;vtkWebGPUViewNodeFactory&quot;),extend:Mx};const{vtkErrorMacro:Ex}=jt,Vx={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Lx(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderWindow&quot;),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:&quot;premultiplied&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Ex(&quot;WebGPU is not enabled.&quot;);e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Ex(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:&quot;high-performance&quot;}),t.deleted||(t.device=dx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext(&quot;webgpu&quot;))},e.releaseGraphicsResources=()=>{const n=qv.newInstance();n.setCurrentOperation(&quot;Release&quot;),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Vx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=ET.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Ad.fromHalf(r.colorValues[o]),s[n+1]=255*Ad.fromHalf(r.colorValues[o+1]),s[n+2]=255*Ad.fromHalf(r.colorValues[o+2]),s[n+3]=255*Ad.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=wx.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Bx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Nx=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,xy.extend(e,t,n),t.myFactory=Dx.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Nx),t.renderPasses[0]=tx.newInstance(),t.selector||(t.selector=wx.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,&quot;imageReady&quot;),jt.event(e,t,&quot;initialized&quot;),jt.get(e,t,[&quot;commandEncoder&quot;,&quot;device&quot;,&quot;presentationFormat&quot;,&quot;useBackgroundImage&quot;,&quot;xrSupported&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;device&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Lx(e,t)}),&quot;vtkWebGPURenderWindow&quot;);ev(&quot;WebGPU&quot;,Nx);const _x=Hv(),Fx={margin:&quot;0&quot;,padding:&quot;0&quot;,position:&quot;absolute&quot;,top:&quot;0&quot;,left:&quot;0&quot;,width:&quot;100%&quot;,height:&quot;100%&quot;,overflow:&quot;hidden&quot;},kx={position:&quot;absolute&quot;,left:&quot;25px&quot;,top:&quot;25px&quot;,backgroundColor:&quot;white&quot;,borderRadius:&quot;5px&quot;,listStyle:&quot;none&quot;,padding:&quot;5px 10px&quot;,margin:&quot;0&quot;,display:&quot;block&quot;,border:&quot;solid 1px black&quot;,maxWidth:&quot;calc(100% - 70px)&quot;,maxHeight:&quot;calc(100% - 60px)&quot;,overflow:&quot;auto&quot;};function Gx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Ux(e,t){t.classHierarchy.push(&quot;vtkFullScreenRenderWindow&quot;);const n=document.querySelector(&quot;body&quot;);t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement(&quot;div&quot;),Gx(t.container,t.containerStyle||Fx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height=&quot;100%&quot;,n.style.height=&quot;100%&quot;,n.style.padding=&quot;0&quot;,n.style.margin=&quot;0&quot;),t.renderWindow=av.newInstance(),t.renderer=Qh.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(_x.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Sv.newInstance(),t.interactor.setInteractorStyle(Uv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?&quot;block&quot;:&quot;none&quot;)},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement(&quot;div&quot;),Gx(t.controlContainer,t.controlPanelStyle||kx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener(&quot;keypress&quot;,(t=>{&quot;c&quot;===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}))},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener(&quot;resize&quot;,e.resize),e.resize()}const zx={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Wx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zx,n),jt.obj(e,t),jt.get(e,t,[&quot;renderWindow&quot;,&quot;renderer&quot;,&quot;apiSpecificRenderWindow&quot;,&quot;interactor&quot;,&quot;rootContainer&quot;,&quot;container&quot;,&quot;controlContainer&quot;]),Ux(e,t)}var Hx={newInstance:jt.newInstance(Wx),extend:Wx},jx={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:Kx,Scale:$x}=jx,{ScalarMappingTarget:qx}=Pl,{vtkDebugMacro:Xx,vtkErrorMacro:Yx,vtkWarningMacro:Zx}=jt;function Qx(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Jx(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function eC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];Qx(o,i),Qx(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Jx(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Jx(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function tC(e,t){t.classHierarchy.push(&quot;vtkColorTransferFunction&quot;),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Yx(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(s<0||s>1)return Yx(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===$x.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Do(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===Kx.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===Kx.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;,t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===Kx.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===Kx.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;);for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Yx(&quot;Attempting to lookup a value with no points in the function&quot;),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Yx(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Yx(&quot;Index out of range!&quot;),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>t.indexedLookup&&e.getSize()?e.getSize():t.tableSize?t.tableSize:16777216,e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void Yx(&quot;attempt to set zero width color range&quot;);const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):Xx(&quot;Transfer Function Has No Points!&quot;)},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void Zx(&quot;Transfer Function Has No Points!&quot;);const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===qx.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===qx.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===qx.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===qx.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=Kx[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Yx(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=Kx.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const nC={clamping:!0,colorSpace:Kx.RGB,hSVWrap:!0,scale:$x.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function rC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nC,n),Pl.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,[&quot;buildTime&quot;,&quot;mappingRange&quot;]),jt.setGet(e,t,[&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;,&quot;colorSpace&quot;,&quot;discretize&quot;,&quot;numberOfValues&quot;]),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),tC(e,t)}var oC={newInstance:jt.newInstance(rC,&quot;vtkColorTransferFunction&quot;),extend:rC,...jx},aC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:iC,ScaleModes:sC}=aC,{vtkErrorMacro:lC}=jt;function cC(e,t){t.classHierarchy.push(&quot;vtkGlyph3DMapper&quot;),e.getOrientationModeAsString=()=>jt.enumToString(iC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(iC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(iC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(iC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(sC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(sC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(sC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(sC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===sC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(lC(&quot;Cannot scale by components since scale array does not have 3 components.&quot;),a=null);const l=r.getBounds(),c=[];ki.getCorners(l,c),t.bounds[0]=ki.INIT_BOUNDS[0],t.bounds[1]=ki.INIT_BOUNDS[1],t.bounds[2]=ki.INIT_BOUNDS[2],t.bounds[3]=ki.INIT_BOUNDS[3],t.bounds[4]=ki.INIT_BOUNDS[4],t.bounds[5]=ki.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case iC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case iC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case iC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case sC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case sC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case sC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const uC={orient:!0,orientationMode:iC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:sC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function dC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uC,n),nc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,[&quot;orient&quot;,&quot;orientationMode&quot;,&quot;orientationArray&quot;,&quot;scaleArray&quot;,&quot;scaleFactor&quot;,&quot;scaleMode&quot;,&quot;scaling&quot;]),jt.get(e,t,[&quot;colorArray&quot;,&quot;matrixArray&quot;,&quot;normalArray&quot;,&quot;buildTime&quot;]),cC(e,t)}var pC={newInstance:jt.newInstance(dC,&quot;vtkGlyph3DMapper&quot;),extend:dC,...aC};const{vtkErrorMacro:fC}=jt;function gC(e,t){t.classHierarchy.push(&quot;vtkPiecewiseFunction&quot;),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return&quot;Constant&quot;;case 1:return&quot;NonDecreasing&quot;;case 2:return&quot;NonIncreasing&quot;;default:return&quot;Varied&quot;}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(fC(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return fC(&quot;Index out of range!&quot;),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return fC(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(a<0||a>1)return fC(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const mC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function hC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,[&quot;allowDuplicateScalars&quot;,&quot;clamping&quot;]),jt.setArray(e,t,[&quot;range&quot;],2),jt.getArray(e,t,[&quot;range&quot;]),gC(e,t)}var vC={newInstance:jt.newInstance(hC,&quot;vtkPiecewiseFunction&quot;),extend:hC};const{InterpolationType:yC,OpacityMode:TC}=Og,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push(&quot;vtkVolumeProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(bC(&quot;Bad index - must be between 0 and 3&quot;),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=vC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=oC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=vC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return bC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(bC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(yC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(yC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(yC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(yC,t.interpolationType),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const CC={independentComponents:!0,interpolationType:yC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,CC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:TC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;shade&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,&quot;vtkVolumeProperty&quot;),extend:SC,...Og};const{vtkDebugMacro:IC}=jt;function wC(e,t){t.classHierarchy.push(&quot;vtkVolume&quot;),e.getVolumes=()=>e,e.makeProperty=AC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){IC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e));const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const PC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),wC(e,t)}var RC={newInstance:jt.newInstance(OC,&quot;vtkVolume&quot;),extend:OC};const{BlendMode:MC,FilterMode:DC}=Mg,EC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=vC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function VC(e,t){t.classHierarchy.push(&quot;vtkVolumeMapper&quot;);const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(MC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(MC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(MC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(MC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(MC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(MC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(MC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn(&quot;setAverageIPScalarRange is deprecated use setIpScalarRange&quot;),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(DC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(DC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(DC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(DC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Do(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const LC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:MC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:DC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LC,n),Bs(e,t,n),jt.setGet(e,t,[&quot;sampleDistance&quot;,&quot;imageSampleDistance&quot;,&quot;maximumSamplesPerRay&quot;,&quot;autoAdjustSampleDistances&quot;,&quot;initialInteractionScale&quot;,&quot;interactionSampleDistanceFactor&quot;,&quot;blendMode&quot;,&quot;filterMode&quot;,&quot;preferSizeOverAccuracy&quot;,&quot;computeNormalFromOpacity&quot;,&quot;volumetricScatteringBlending&quot;,&quot;globalIlluminationReach&quot;,&quot;volumeShadowSamplingDistFactor&quot;,&quot;anisotropy&quot;,&quot;localAmbientOcclusion&quot;,&quot;LAOKernelSize&quot;,&quot;LAOKernelRadius&quot;]),jt.setGetArray(e,t,[&quot;ipScalarRange&quot;],2),jt.event(e,t,&quot;lightingActivated&quot;),VC(e,t)}var NC={newInstance:jt.newInstance(BC,&quot;vtkVolumeMapper&quot;),extend:BC,...EC};const{InterpolationType:_C}=eg,{vtkErrorMacro:FC}=jt;function kC(e,t){t.classHierarchy.push(&quot;vtkImageProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return FC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(FC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(_C.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(_C.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(_C,t.interpolationType)}const GC={independentComponents:!1,interpolationType:_C.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function UC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,GC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;colorWindow&quot;,&quot;colorLevel&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;opacity&quot;,&quot;useLookupTableScalarRange&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),kC(e,t)}var zC={newInstance:jt.newInstance(UC,&quot;vtkImageProperty&quot;),extend:UC};const{vtkDebugMacro:WC}=jt;function HC(e,t){t.classHierarchy.push(&quot;vtkImageSlice&quot;),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=zC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){WC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),ki.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!ki.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),ki.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const jC={mapper:null,property:null,bounds:[...ki.INIT_BOUNDS]};function KC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),HC(e,t)}var $C={newInstance:jt.newInstance(KC,&quot;vtkImageSlice&quot;),extend:KC};function qC(e,t){t.classHierarchy.push(&quot;vtkAbstractImageMapper&quot;),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro(&quot;vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED&quot;),Fa())}const XC={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var YC=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,XC,n),Fs(e,t,n),jt.setGet(e,t,[&quot;slice&quot;,&quot;useCustomExtents&quot;]),jt.setGetArray(e,t,[&quot;customDisplayExtent&quot;],6),jt.setGetArray(e,t,[&quot;backgroundColor&quot;],4),qC(e,t)};function ZC(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA(&quot;vtkImageArrayMapper&quot;)?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ni.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:QC,otherStaticMethods:JC}=Ul,{SlicingMode:eS}=sg;function tS(e,t){function n(){let n;switch(t.slicingMode){case eS.X:n=0;break;case eS.Y:n=1;break;case eS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push(&quot;vtkImageMapper&quot;),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case eS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case eS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case eS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case eS.I:l=Ma(a[0],i[0],i[1]);break;case eS.J:l=Ma(a[1],i[2],i[3]);break;case eS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case eS.I:case eS.J:case eS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case eS.X:e.setSlice(r[0]);break;case eS.Y:e.setSlice(r[1]);break;case eS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(eS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(eS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(eS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(eS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(eS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(eS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case eS.X:n[0]=1;break;case eS.Y:n[1]=1;break;case eS.Z:n[2]=1;break;case eS.I:ea(r,[1,0,0],n);break;case eS.J:ea(r,[0,1,0],n);break;case eS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==eS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case eS.I:r[0]=a,r[1]=a;break;case eS.J:r[2]=a,r[3]=a;break;case eS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case eS.I:a[0]=s-r,a[1]=s+r;break;case eS.J:a[2]=s-r,a[3]=s+r;break;case eS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const nS={slicingMode:eS.NONE,closestIJKAxis:{ijkMode:eS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function rS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nS,n),YC(e,t,n),jt.get(e,t,[&quot;slicingMode&quot;]),jt.setGet(e,t,[&quot;closestIJKAxis&quot;,&quot;renderToRectangle&quot;,&quot;sliceAtFocalPoint&quot;,&quot;preferSizeOverAccuracy&quot;]),Ul.implementCoincidentTopologyMethods(e,t),tS(e,t)}var oS={newInstance:jt.newInstance(rS,&quot;vtkImageMapper&quot;),extend:rS,...QC,...JC,...sg};const{vtkErrorMacro:aS}=jt;function iS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function sS(e,t){t.classHierarchy.push(&quot;vtkAppendPolyData&quot;),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void aS(&quot;No input specified.&quot;);if(1===o)return void(r[0]=n[0]);const a=gu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===js.SINGLE?s=ys.FLOAT:t.outputPointsPrecision===js.DOUBLE&&(s=ys.DOUBLE);const v=mc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Es.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Es.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Es.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),iS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),iS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),iS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),iS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const lS={outputPointsPrecision:js.DEFAULT};function cS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lS,n),jt.setGet(e,t,[&quot;outputPointsPrecision&quot;]),jt.obj(e,t),jt.algo(e,t,1,1),sS(e,t)}var uS={newInstance:jt.newInstance(cS,&quot;vtkAppendPolyData&quot;),extend:cS};function dS(e,t){t.classHierarchy.push(&quot;vtkConeSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Nf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=gu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const pS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:&quot;Float64Array&quot;};function fS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),dS(e,t)}var gS={newInstance:jt.newInstance(fS,&quot;vtkConeSource&quot;),extend:fS};function mS(e,t){t.classHierarchy.push(&quot;vtkCylinderSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Es.newInstance({numberOfComponents:3,values:u,name:&quot;Normals&quot;}),p=new Float32Array(2*a),f=Es.newInstance({numberOfComponents:2,values:p,name:&quot;TCoords&quot;}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Nf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=gu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const hS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:&quot;Float64Array&quot;};function vS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;initAngle&quot;,&quot;otherRadius&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),mS(e,t)}var yS={newInstance:jt.newInstance(vS,&quot;vtkCylinderSource&quot;),extend:vS};function TS(e,t){t.classHierarchy.push(&quot;vtkArrowSource&quot;),e.requestData=function(e,n){if(t.deleted)return;const r=yS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Bf().rotateZ(-90).apply(a).apply(i);const s=gS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Nf().translate(1-.5*t.tipLength,0,0).apply(c);const u=uS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Nf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Nf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Nf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const bS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:&quot;Float64Array&quot;};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;tipResolution&quot;,&quot;tipRadius&quot;,&quot;tipLength&quot;,&quot;shaftResolution&quot;,&quot;shaftRadius&quot;,&quot;invert&quot;]),jt.setGetArray(e,t,[&quot;direction&quot;],3),jt.algo(e,t,0,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,&quot;vtkArrowSource&quot;),extend:xS};function SS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Bf().translate(...n).apply(e.getPoints().getData())}function AS(e,t){const n=e.getPoints().getBounds(),r=[0,0,0];r[t]=-n[2*t],Bf().translate(...r).apply(e.getPoints().getData())}function IS(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8Array(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Es.newInstance({name:&quot;color&quot;,numberOfComponents:3,values:a}))}function wS(e,t){t.classHierarchy.push(&quot;vtkAxesActor&quot;);const n=nc.newInstance();e.setMapper(n),e.update=()=>{const e=CS.newInstance({direction:[1,0,0],...t.config}).getOutputData();t.config.recenter?SS(e):AS(e,0),IS(e,...t.xAxisColor);const r=CS.newInstance({direction:[0,1,0],...t.config}).getOutputData();t.config.recenter?SS(r):AS(r,1),IS(r,...t.yAxisColor);const o=CS.newInstance({direction:[0,0,1],...t.config}).getOutputData();t.config.recenter?SS(o):AS(o,2),IS(o,...t.zAxisColor);const a=uS.newInstance();a.setInputData(e),a.addInputData(r),a.addInputData(o),n.setInputConnection(a.getOutputPort())},e.update();const r=jt.debounce(e.update,0),{setConfig:o,setXAxisColor:a,setYAxisColor:i,setZAxisColor:s}=e;e.setConfig=e=>!!o(e)&&(r(),!0),e.setXAxisColor=e=>!!a(e)&&(r(),!0),e.setYAxisColor=e=>!!i(e)&&(r(),!0),e.setZAxisColor=e=>!!s(e)&&(r(),!0)}const PS={config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1},xAxisColor:[255,0,0],yAxisColor:[255,255,0],zAxisColor:[0,128,0]};function OS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PS,n),hs.extend(e,t,n),jt.setGet(e,t,[&quot;config&quot;]),jt.setGetArray(e,t,[&quot;xAxisColor&quot;,&quot;yAxisColor&quot;,&quot;zAxisColor&quot;],3,255),wS(e,t)}var RS={newInstance:jt.newInstance(OS,&quot;vtkAxesActor&quot;),extend:OS};const MS=&quot;resetcamera&quot;,DS=&quot;orientation&quot;,ES={MODE_RESET_CAMERA:MS,MODE_ORIENTATION:DS,MODE_SAME:&quot;same&quot;};function VS(e,t){t.classHierarchy.push(&quot;vtkCameraSynchronizer&quot;);const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName(&quot;position&quot;),s=e.getReferenceByName(&quot;focalPoint&quot;),l=e.getReferenceByName(&quot;viewUp&quot;),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===DS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===MS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const LS={mode:DS,focalPoint:[0,0,0],distance:6.8,active:!0};function BS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LS,n),yt(e,t),At(e,t,[&quot;mode&quot;,&quot;active&quot;,&quot;srcRenderer&quot;,&quot;dstRenderer&quot;,&quot;distance&quot;]),Pt(e,t,[&quot;focalPoint&quot;],3,0),VS(e,t)}var NS={newInstance:Et(BS,&quot;vtkCameraSynchronizer&quot;),extend:BS,SynchronizationMode:ES};const _S={},FS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=NS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:NS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var kS=function(e,t,n){const r=e.get(&quot;synchronizedViewId&quot;).synchronizedViewId;if(!t.behaviors||!r)return;_S[r]||(_S[r]={});const o=_S[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=NS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];FS[e.type]?o[r]=new FS[e.type](n,e):console.log(&quot;No mapping for&quot;,e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const GS={},US=/instance:\\${([^}]+)}/,zS={},WS=[],HS={},jS={vtkPoints:mc,vtkCellArray:cc,vtkDataArray:Es};function KS(e){return e.map((e=>US.exec(e))).filter((e=>e)).map((e=>e[1]))}function $S(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),$S(e,t)})),t}function qS(e,t,n,r){if(!t)return Promise.reject(new Error(&quot;No instance provided.&quot;));const o=GS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function XS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=GS[e];return n&&n.build?n.build(t):(console.log(&quot;No builder for&quot;,e),null)}function YS(){Object.keys(GS).forEach((e=>{delete GS[e]}))}function ZS(){Object.keys(zS).forEach((e=>{delete zS[e]}))}function QS(e){if(1===e[1].length)return-1===WS.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===WS.indexOf(e[1][n]);return t}function JS(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(HS[r]){const{key:n,value:o}=HS[r];if(!n||e.properties[n]===o)return void WS.push((e=>`instance:\\${${e}}`)(t))}let o=n.getInstance(t);o||(o=XS(r,{managedInstanceId:t}),n.registerInstance(t,o)),qS(r,o,e,n)})),t.calls&&t.calls.filter(QS).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=US.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:&quot;addArray&quot;,a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:&quot;vtkDataArray&quot;,l=jS[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log(&quot;Error fetching array&quot;,JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error(&quot;Error in array handling for state&quot;,JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function eA(e,t,n){zS[t.id]||JS(e,t,n),zS[t.id]=!0}function tA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function nA(e){const t=e.name?`_${e.name}`:&quot;&quot;;return`${e.hash}_${e.dataType}${t}`}function rA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=nA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=nA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),tA(t.getPointData(),i.pointData),tA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=JS(t,s,r);return r.end(),l}}const oA=rA([&quot;points&quot;,&quot;polys&quot;,&quot;verts&quot;,&quot;lines&quot;,&quot;strips&quot;]),aA=rA([]);function iA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:JS;XS||qS?GS[e]={build:t,update:n}:delete GS[e]}const sA={vtkMapper:[&quot;vtkOpenGLPolyDataMapper&quot;,&quot;vtkCompositePolyDataMapper2&quot;,&quot;vtkDataSetMapper&quot;],vtkProperty:[&quot;vtkOpenGLProperty&quot;],vtkRenderer:[&quot;vtkOpenGLRenderer&quot;],vtkCamera:[&quot;vtkOpenGLCamera&quot;],vtkColorTransferFunction:[&quot;vtkPVDiscretizableColorTransferFunction&quot;],vtkActor:[&quot;vtkOpenGLActor&quot;,&quot;vtkPVLODActor&quot;],vtkLight:[&quot;vtkOpenGLLight&quot;,&quot;vtkPVLight&quot;],vtkTexture:[&quot;vtkOpenGLTexture&quot;],vtkImageMapper:[&quot;vtkOpenGLImageSliceMapper&quot;],vtkVolumeMapper:[&quot;vtkFixedPointVolumeRayCastMapper&quot;]},lA={vtkAxesActor:{build:RS.newInstance,update:JS},vtkRenderWindow:{build:av.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(QS).filter((e=>&quot;removeRenderer&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),JS(e,t,n),kS(e,t,n)}},vtkRenderer:{build:Qh.newInstance,update:function(e,t,n){JS(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=$S(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(QS).filter((e=>&quot;removeViewProp&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{const t=n.getInstance(e).get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:El.newInstance,update:JS},vtkCamera:{build:Bh.newInstance,update:eA},vtkPolyData:{build:gu.newInstance,update:oA},vtkImageData:{build:fl.newInstance,update:aA},vtkMapper:{build:nc.newInstance,update:JS},vtkGlyph3DMapper:{build:pC.newInstance,update:JS},vtkProperty:{build:ds.newInstance,update:JS},vtkActor:{build:hs.newInstance,update:JS},vtkLight:{build:kh.newInstance,update:JS},vtkColorTransferFunction:{build:oC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Tu.newInstance,update:JS},vtkVolume:{build:RC.newInstance,update:JS},vtkVolumeMapper:{build:NC.newInstance,update:JS},vtkVolumeProperty:{build:AC.newInstance,update:JS},vtkImageSlice:{build:$C.newInstance,update:JS},vtkImageMapper:{build:oS.newInstance,update:JS},vtkImageProperty:{build:zC.newInstance,update:JS},vtkPiecewiseFunction:{build:vC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:Fu.newInstance,update:JS},vtkScalarBarActor:{build:Op.newInstance,update:JS}};function cA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&YS(),Object.keys(lA).forEach((e=>{const t=lA[e];iA(e,t.build,t.update)}))}function uA(){Object.keys(sA).forEach((e=>{sA[e].forEach((t=>{GS[t]=GS[e]}))}))}cA(),uA(),HS.vtkPVLight={};var dA={build:XS,update:qS,genericUpdater:JS,oneTimeGenericUpdater:eA,setTypeMapping:iA,clearTypeMapping:YS,getSupportedTypes:function(){return Object.keys(GS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return ZS();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete zS[e]})),r},updateRenderWindow:function(e,t,n){return qS(&quot;vtkRenderWindow&quot;,e,t,n)},excludeInstance:function(e,t,n){HS[e]={key:t,value:n}},setDefaultMapping:cA,applyDefaultAliases:uA,alwaysUpdateCamera:function(){iA(&quot;vtkCamera&quot;,Bh.newInstance),uA()}};const pA={};function fA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if(&quot;string&quot;==typeof t&&(i=Dm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log(&quot;Error getting data array:&quot;),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use &quot;setArrayFetcher&quot; to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function gA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function mA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Dt(t,n,&quot;progressEvent&quot;),Dt(t,n,&quot;progressDone&quot;),t}function hA(){const e={};let t=&quot;default&quot;;return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function vA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;default&quot;,t=pA[e];return t||(t={...fA(),...gA(),...mA(),...hA()},pA[e]=t),t}function yA(e,t){let n=-1,r=100;const o=e=>e.get(&quot;managedInstanceId&quot;).managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get(&quot;synchronizedViewId&quot;).synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),dA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){dA.clearOneTimeUpdaters(a())}}}function TA(e,t){t.classHierarchy.push(&quot;vtkSynchronizableRenderWindow&quot;),t.synchronizerContext||(t.synchronizerContext=vA(t.synchronizerContextName));const n=yA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const bA={synchronizerContextName:&quot;default&quot;,synchronizerContext:null,synchronizedViewId:null};function xA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bA,n),av.extend(e,t),bt(e,t,[&quot;synchronizerContext&quot;]),TA(e,t)}var CA={newInstance:Et(xA,&quot;vtkSynchronizableRenderWindow&quot;),extend:xA,getSynchronizerContext:vA,setSynchronizerContext:function(e,t){pA[e]=t},clearSynchronizerContext:function(e){if(e&&pA[e]&&delete pA[e],!e){const e=Object.keys(pA);for(let t=0;t<e.length;t++)delete pA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;default&quot;;const n=yA(e,vA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:gA,createArrayHandler:fA,createProgressHandler:mA,createSceneMtimeHandler:hA,vtkObjectManager:dA};const{vtkErrorMacro:SA,vtkDebugMacro:AA}=jt;let IA=0;function wA(e){const t=document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`);return t?t.innerHTML:null}function PA(e){return&quot;/&quot;===e[0]?e.substr(1):e}const OA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=wA(PA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=wA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=PA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;)),s=wA(i);if(null===s)a(new Error(`No such array ${i}`));else{if(&quot;string&quot;===n.dataType){let e=atob(s);r.compression&&(e=yh(mh(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Dm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(AA(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&SA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--IA&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};Vm(&quot;html&quot;,(e=>OA));const{vtkErrorMacro:RA,vtkDebugMacro:MA}=jt;function DA(e){return function(e){return&quot;/&quot;===e[0]?e.substr(1):e}(function(e){return new URL(e,&quot;http://any&quot;).pathname}(e))}const EA=function(e){let t=!1,n=0,r=null,o=&quot;&quot;;var a;return(a=e.zipContent,new Promise(((e,t)=>{&quot;string&quot;==typeof a?e(function(e,t){if(t){for(var n=new Bm(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(hh)return hh.encode(e);var o=e.length,a=new Bm(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new Bm(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return oh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error(&quot;Invalid datatype to unpack.&quot;))}))).then((n=>{r=Ch(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith(&quot;index.json&quot;)&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\\.json$/,&quot;&quot;),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||RA(&quot;ERROR!!! zip not ready...&quot;);const u=DA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join(&quot;/&quot;));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if(&quot;string&quot;!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&(&quot;string&quot;===e.dataType||&quot;JSON&quot;===e.dataType?e.buffer=yh(mh(new Uint8Array(e.buffer))):e.buffer=mh(new Uint8Array(e.buffer)).buffer),&quot;JSON&quot;===e.ref.encode?e.values=JSON.parse(e.buffer):(Ah!==e.ref.encode&&Ah&&(MA(`Swap bytes of ${e.name}`),Ih(e.buffer,vs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&RA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(yh(mh(r))):JSON.parse(r),n()}}(i,s.compression,d);e(yh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];if(a.compression){if(&quot;gz&quot;===a.compression){const e=yh(mh(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error(&quot;Invalid compression&quot;))}return Promise.resolve(JSON.parse(yh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(yh(Ch(s))):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(yh(s))},fetchImage(e,n){const a=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=Mm(i.buffer);n.src=`data:image/${function(e){const t=e.split(&quot;.&quot;).pop().toLowerCase();return&quot;jpg&quot;===t?&quot;jpeg&quot;:t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(mh(s).buffer):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(s.buffer)}}};Vm(&quot;zip&quot;,(e=>EA(e)));var VA=n(892),LA=n.n(VA),BA=n(760),NA=n.n(BA),_A=n(311),FA=n.n(_A),kA=n(192),GA=n.n(kA),UA=n(60),zA=n.n(UA),WA=n(865),HA=n.n(WA),jA=n(34),KA={};KA.styleTagTransform=HA(),KA.setAttributes=GA(),KA.insert=FA().bind(null,&quot;head&quot;),KA.domAPI=NA(),KA.insertStyleElement=zA(),LA()(jA.Z,KA);var $A=jA.Z&&jA.Z.locals?jA.Z.locals:void 0;let qA=!0;function XA(e){e.preventDefault(),e.stopPropagation()}function YA(e,t){qA=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=Hx.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:&quot;100%&quot;,width:&quot;100%&quot;,position:&quot;absolute&quot;}}).getRenderWindow(),o=CA.getSynchronizerContext(),a=CA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement(&quot;div&quot;);n.setAttribute(&quot;class&quot;,$A.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?Mh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Lm(&quot;zip&quot;,{zipContent:t,callback:e=>{r.fetchJSON(null,&quot;index.json&quot;).then(i)}})})):Mh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Lm(&quot;zip&quot;,{zipContent:t.file,callback:t=>{e.fetchJSON(null,&quot;index.json&quot;).then(i)}})}else if(t.base64Str){const e=Dm(t.base64Str),n=Lm(&quot;zip&quot;,{zipContent:e,callback:e=>{n.fetchJSON(null,&quot;index.json&quot;).then(i)}})}}function ZA(e){qA=!1;const t=document.querySelector(&quot;.content&quot;),n=document.querySelector(&quot;body&quot;),r=e||t||n;r!==e?(r.classList.add($A.fullScreen),n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;):(n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;);const o=document.createElement(&quot;div&quot;);o.innerHTML=`<div class=&quot;${$A.bigFileDrop}&quot;/><input type=&quot;file&quot; accept=&quot;.zip,.vtksz&quot; style=&quot;display: none;&quot;/>`,r.appendChild(o);const a=o.querySelector(&quot;input&quot;);function i(e){XA(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(&quot;.&quot;).slice(-1)[0];YA(r,{file:n[0],ext:e})}}a.addEventListener(&quot;change&quot;,i),o.addEventListener(&quot;drop&quot;,i),o.addEventListener(&quot;click&quot;,(e=>a.click())),o.addEventListener(&quot;dragover&quot;,XA)}const QA=Hv();if(QA.url||QA.fileURL){const e=document.querySelector(&quot;.content&quot;),t=document.querySelector(&quot;body&quot;),n=e||t;n&&(n.classList.add($A.fullScreen),t.style.margin=&quot;0&quot;,t.style.padding=&quot;0&quot;),qA=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>YA(n,QA)))}setTimeout((()=>{qA&&ZA()}),100),window.OfflineLocalView={initLocalFileLoader:ZA,load:YA}},793:function(e){&quot;use strict&quot;;e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=&quot;&quot;,r=void 0!==t[5];return t[4]&&(n+=&quot;@supports (&quot;.concat(t[4],&quot;) {&quot;)),t[2]&&(n+=&quot;@media &quot;.concat(t[2],&quot; {&quot;)),r&&(n+=&quot;@layer&quot;.concat(t[5].length>0?&quot; &quot;.concat(t[5]):&quot;&quot;,&quot; {&quot;)),n+=e(t),r&&(n+=&quot;}&quot;),t[2]&&(n+=&quot;}&quot;),t[4]&&(n+=&quot;}&quot;),n})).join(&quot;&quot;)},t.i=function(e,n,r,o,a){&quot;string&quot;==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]=&quot;@layer&quot;.concat(u[5].length>0?&quot; &quot;.concat(u[5]):&quot;&quot;,&quot; {&quot;).concat(u[1],&quot;}&quot;)),u[5]=a),n&&(u[2]?(u[1]=&quot;@media &quot;.concat(u[2],&quot; {&quot;).concat(u[1],&quot;}&quot;),u[2]=n):u[2]=n),o&&(u[4]?(u[1]=&quot;@supports (&quot;.concat(u[4],&quot;) {&quot;).concat(u[1],&quot;}&quot;),u[4]=o):u[4]=&quot;&quot;.concat(o)),t.push(u))}},t}},490:function(e){&quot;use strict&quot;;e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['&quot;].*['&quot;]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/[&quot;'() \\t\\n]|(%20)/.test(e)||t.needQuotes?'&quot;'.concat(e.replace(/&quot;/g,'\\\\&quot;').replace(/\\n/g,&quot;\\\\n&quot;),'&quot;'):e):e}},22:function(e){&quot;use strict&quot;;e.exports=function(e){return e[1]}},145:function(e,t,n){&quot;use strict&quot;;var r=n(426),o=&quot;function&quot;==typeof Symbol&&&quot;symbol&quot;==typeof Symbol(&quot;foo&quot;),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,&quot;x&quot;,{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||&quot;function&quot;==typeof(o=r)&&&quot;[object Function]&quot;===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){&quot;use strict&quot;;e.exports=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;var e;try{e=this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window;if(&quot;object&quot;==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){&quot;use strict&quot;;e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&&quot;object&quot;==typeof t&&&quot;object&quot;==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){&quot;use strict&quot;;&quot;undefined&quot;!=typeof self?e.exports=self:&quot;undefined&quot;!=typeof window?e.exports=window:e.exports=Function(&quot;return this&quot;)()},177:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){&quot;use strict&quot;;var r=n(491);e.exports=function(){return&quot;object&quot;==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,&quot;globalThis&quot;);t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,&quot;globalThis&quot;,{configurable:!0,enumerable:!1,value:e,writable:!0})}else&quot;object&quot;==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){&quot;use strict&quot;;var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},&quot;toString&quot;),c=s.call((function(){}),&quot;prototype&quot;),u=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if(&quot;undefined&quot;==typeof window)return!1;for(var e in window)try{if(!p[&quot;$&quot;+e]&&o.call(window,e)&&null!==window[e]&&&quot;object&quot;==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&&quot;object&quot;==typeof e,n=&quot;[object Function]&quot;===a.call(e),r=i(e),s=t&&&quot;[object String]&quot;===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError(&quot;Object.keys called on a non-object&quot;);var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&&quot;prototype&quot;===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if(&quot;undefined&quot;==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&&quot;constructor&quot;===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){&quot;use strict&quot;;var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){&quot;use strict&quot;;var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r=&quot;[object Arguments]&quot;===n;return r||(r=&quot;[object Array]&quot;!==n&&null!==e&&&quot;object&quot;==typeof e&&&quot;number&quot;==typeof e.length&&e.length>=0&&&quot;[object Function]&quot;===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(&quot; &quot;),n.s1=r(&quot; &quot;),n.s2=r(&quot; &quot;),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+=&quot;\\0&quot;,r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=&quot;&quot;+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,&quot;global&quot;in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&&quot;object&quot;==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:&quot;string&quot;==o?e:e+&quot;\\0&quot;}function v(e,t){for(var n,r=e+&quot;&quot;,o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}(&quot;undefined&quot;!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){&quot;use strict&quot;;var t=[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r=&quot;&quot;;for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join(&quot;&quot;)}function l(e){return/[\\u0080-\\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a(&quot;hello&quot;)),&quot;undefined&quot;==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff=&quot;&quot;,this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){&quot;use strict&quot;;var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,&quot;.viewer-module-fullScreen_bbk9Y {\\n  position: absolute;\\n  width: 100vw;\\n  height: 100vh;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  z-index: -1;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\n\\n.viewer-module-fullParentSize_ETopO {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n}\\n\\n.viewer-module-bigFileDrop_aqCgh {\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  background-color: white;\\n  background-image: url(&quot;+d+&quot;);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n  background-size: contain;\\n  border-radius: 10px;\\n  width: 50px;\\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\\n  cursor: pointer;\\n}\\n\\n.viewer-module-progress_cYjQJ {\\n  flex: none;\\n  font-size: 50px;\\n  color: black;\\n  z-index: 1;\\n  background: rgba(128,128,128,.5);\\n  padding: 20px;\\n  border-radius: 10px;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\n&quot;,&quot;&quot;]),u.locals={fullScreen:&quot;viewer-module-fullScreen_bbk9Y&quot;,fullParentSize:&quot;viewer-module-fullParentSize_ETopO&quot;,bigFileDrop:&quot;viewer-module-bigFileDrop_aqCgh&quot;,progress:&quot;viewer-module-progress_cYjQJ&quot;},t.Z=u},396:function(e,t,n){var r=n(13),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){&quot;use strict&quot;;var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d=&quot;&quot;.concat(c,&quot; &quot;).concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){&quot;use strict&quot;;var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error(&quot;Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.&quot;);r.appendChild(n)}},60:function(e){&quot;use strict&quot;;e.exports=function(e){var t=document.createElement(&quot;style&quot;);return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){&quot;use strict&quot;;e.exports=function(e){var t=n.nc;t&&e.setAttribute(&quot;nonce&quot;,t)}},760:function(e){&quot;use strict&quot;;e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r=&quot;&quot;;n.supports&&(r+=&quot;@supports (&quot;.concat(n.supports,&quot;) {&quot;)),n.media&&(r+=&quot;@media &quot;.concat(n.media,&quot; {&quot;));var o=void 0!==n.layer;o&&(r+=&quot;@layer&quot;.concat(n.layer.length>0?&quot; &quot;.concat(n.layer):&quot;&quot;,&quot; {&quot;)),r+=n.css,o&&(r+=&quot;}&quot;),n.media&&(r+=&quot;}&quot;),n.supports&&(r+=&quot;}&quot;);var a=n.sourceMap;a&&&quot;undefined&quot;!=typeof btoa&&(r+=&quot;\\n/*# sourceMappingURL=data:application/json;base64,&quot;.concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))),&quot; */&quot;)),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){&quot;use strict&quot;;e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){&quot;use strict&quot;;e.exports=n.p+&quot;138e7b1469f64156810a.jpg&quot;},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error(&quot;define cannot be used indirect&quot;)},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;try{return this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){&quot;undefined&quot;!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p=&quot;&quot;,n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();\n<\/script>\n<script>\nvar container = document.querySelector('.content');\nvar base64Str = &quot;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&quot;;\n\nOfflineLocalView.load(container, { base64Str });\n<\/script>\n</body>\n</html>\n\" class=\"pyvista\" style=\"width: 99%; height: 600px; border: 1px solid rgb(221,221,221);\"></iframe>"}}, "cf66e838c0ab4227b4bd9e5defb3e8c9": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}, "fb5ce73bbed541409d4d176ece2db857": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {}}}, "version_major": 2, "version_minor": 0}
</script></section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="TEAM_13_geometry.html" class="btn btn-neutral float-left" title="Creating the 3D geometry for TEAM problem 13" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="magnetostatics.html" class="btn btn-neutral float-right" title="Magnetostatics solution" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>
   
  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   
</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>