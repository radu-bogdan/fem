

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Computing the current density j in the coil &mdash; FEM  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
      <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
      <script src="../_static/jquery.js"></script>
      <script src="../_static/underscore.js"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script src="../_static/doctools.js"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../_static/iframe_stuff.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Magnetostatics solution (linear case)" href="magnetostatics.html" />
    <link rel="prev" title="Creating the 3D geometry for TEAM problem 13" href="TEAM_13_geometry.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            FEM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">TEAM 13</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="TEAM_13_geometry.html">Creating the 3D geometry for TEAM problem 13</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Computing the current density j in the coil</a></li>
<li class="toctree-l1"><a class="reference internal" href="magnetostatics.html">Magnetostatics solution (linear case)</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEAM_13_nonlinearity.html">Nonlinear material laws</a></li>
<li class="toctree-l1"><a class="reference internal" href="magnetostatics_nl.html">Magnetostatics solution (nonlinear case)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">2D electric motor</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="createMesh.html">Geometry and mesh for motor</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">FEM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Computing the current density j in the coil</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/notebooks/current_density.ipynb" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Computing-the-current-density-j-in-the-coil">
<h1>Computing the current density j in the coil<a class="headerlink" href="#Computing-the-current-density-j-in-the-coil" title="Permalink to this heading">¶</a></h1>
<p><span class="math notranslate nohighlight">\(\def\curl{\operatorname{curl}}\def\Curl{\operatorname{Curl}}\def\div{\operatorname{div}}\)</span> Before we solve the non-linear magnetostatic problem, we first need to find the current <span class="math notranslate nohighlight">\(j\)</span> flowing inside the coil <span class="math notranslate nohighlight">\(\Omega_c\)</span>.</p>
<p>The first property is that <span class="math notranslate nohighlight">\(j\)</span> is solenoidal, i.e. <span class="math notranslate nohighlight">\(\div(j)=0\)</span>. Further, we presume the existence of a potential <span class="math notranslate nohighlight">\(\phi\)</span> with <span class="math notranslate nohighlight">\(j=-\sigma\nabla\phi\)</span>, where <span class="math notranslate nohighlight">\(\sigma\)</span> denotes the connectivity. As for the boundary conditions, we prescribe <span class="math notranslate nohighlight">\(n\cdot j = -\sigma\partial_n\phi=0\)</span> on the exterior boundary <span class="math notranslate nohighlight">\(\Gamma_{ex}\)</span>, and <span class="math notranslate nohighlight">\(\phi=1\)</span> and <span class="math notranslate nohighlight">\(\phi=0\)</span> on the inflow <span class="math notranslate nohighlight">\(\Gamma_{in}\)</span> and outflow boundary <span class="math notranslate nohighlight">\(\Gamma_{out}\)</span>, respectively. Altogether, we
have</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
j + \sigma\nabla\phi &amp;= 0 \qquad\text{on }\Omega_c \\
\div j &amp;=0  \qquad\text{on }\Omega_c \\
n\cdot j = \sigma\partial_n\phi &amp;= 0 \qquad\text{on }\Gamma_{ex} \\
\phi &amp;= 0 \qquad\text{on }\Gamma_{out} \\
\phi &amp;= 1 \qquad\text{on }\Gamma_{in}
\end{align}\end{split}\]</div>
<p>However, in our case, the coil is a loop with no inflow or outflow boundary. This is where the face “coil_cut_1” we defined in the geometry comes into play. For this purpose, we have to introduce “fictitious” points and introduce a clone of the face “coil_cut_1” in order to be able to prescribe the necessary boundary conditions.</p>
<p>Ok so how do we even solve this? Weak formulation leads to</p>
<div class="math notranslate nohighlight">
\[\begin{align}
-\Delta(\sigma\phi)=0
\end{align}\]</div>
<p>The boundary condition <span class="math notranslate nohighlight">\(\partial_n\phi=0\)</span> on <span class="math notranslate nohighlight">\(\Gamma_{ex}\)</span> is natural, while the Dirichlet conditions are essential and have to included in the space. Further, since we solve the problem only on the coil, the other DOFs have to be eliminated from the final system.</p>
<p>We begin by loading the geometry and the mesh generated in the previous document</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%capture</span>
<span class="o">%</span><span class="n">run</span> <span class="n">TEAM_13_geometry</span><span class="o">.</span><span class="n">ipynb</span>
</pre></div>
</div>
</div>
<p>Create the MESH object from the mesh generated by netgen</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;../../../&#39;</span><span class="p">)</span> <span class="c1"># adds parent directory</span>
<span class="kn">import</span> <span class="nn">pde</span>
<span class="n">MESH</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">mesh3</span><span class="o">.</span><span class="n">netgen</span><span class="p">(</span><span class="n">geoOCCmesh</span><span class="p">)</span>
<span class="n">MESH</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
np:4132, nt:23369, nf:3059, ne:720, nf_all:46966, ne_all:27728
</pre></div></div>
</div>
<p>The piece of code below duplicates the face, as described above, and generates a new MESH object.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">face_index</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">getIndices</span><span class="p">(</span><span class="n">MESH</span><span class="o">.</span><span class="n">regions_2d</span><span class="p">,</span><span class="s1">&#39;coil_cut_1&#39;</span><span class="p">)</span>
<span class="n">faces</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">MESH</span><span class="o">.</span><span class="n">BoundaryFaces_Region</span> <span class="o">==</span> <span class="n">face_index</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">new_faces</span> <span class="o">=</span> <span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">points_to_duplicate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
<span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">MESH</span><span class="o">.</span><span class="n">np</span><span class="p">,</span> <span class="n">MESH</span><span class="o">.</span><span class="n">np</span><span class="o">+</span><span class="n">points_to_duplicate</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

<span class="n">actual_points</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">points_to_duplicate</span><span class="p">,:]</span>

<span class="n">t_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">t</span><span class="p">[:,:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">f_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">f</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">p_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">pnt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points_to_duplicate</span><span class="p">):</span>

    <span class="c1"># append point to list</span>
    <span class="n">p_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">p_new</span><span class="p">,</span><span class="n">p_new</span><span class="p">[</span><span class="n">pnt</span><span class="p">,:]])</span>

    <span class="c1"># finding tets coordinates containing the ith point to duplicate</span>
    <span class="n">tets_containing_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">t_new</span><span class="p">[:,:</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="n">pnt</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tets_containing_points</span><span class="p">):</span>
        <span class="c1">#check if tet is left</span>
        <span class="k">if</span> <span class="n">MESH</span><span class="o">.</span><span class="n">mp_tet</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">t_new</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">t_new</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">==</span><span class="n">pnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">np</span> <span class="o">+</span> <span class="n">i</span>

    <span class="c1"># finding faces containing the points</span>
    <span class="n">faces_containing_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">f_new</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="n">pnt</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">faces_containing_points</span><span class="p">):</span>
        <span class="c1">#check if face is left</span>
        <span class="k">if</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">p_new</span><span class="p">[</span><span class="n">f_new</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_new</span><span class="p">[</span><span class="n">f_new</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_new</span><span class="p">[</span><span class="n">f_new</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">f_new</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">f_new</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">==</span><span class="n">pnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">np</span> <span class="o">+</span> <span class="n">i</span>


    <span class="c1"># print(faces_containing_points)</span>

<span class="n">t_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">t_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">t</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">faces</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
    <span class="n">new_faces</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_points</span><span class="p">[</span><span class="n">points_to_duplicate</span><span class="o">==</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="n">new_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">new_faces</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">MESH</span><span class="o">.</span><span class="n">f</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,(</span><span class="n">new_faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))]</span>
<span class="n">f_new</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">f_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">f</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]],</span><span class="n">new_faces</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

<span class="n">regions_2d_new</span> <span class="o">=</span> <span class="n">MESH</span><span class="o">.</span><span class="n">regions_2d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">regions_2d_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;new&#39;</span><span class="p">)</span>

<span class="n">identifications</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">points_to_duplicate</span><span class="p">,</span><span class="n">new_points</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="c1"># stop</span>
<span class="n">MESH</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">mesh3</span><span class="p">(</span><span class="n">p_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">e</span><span class="p">,</span><span class="n">f_new</span><span class="p">,</span><span class="n">t_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">regions_3d</span><span class="p">,</span><span class="n">regions_2d_new</span><span class="p">,</span><span class="n">MESH</span><span class="o">.</span><span class="n">regions_1d</span><span class="p">,</span><span class="n">identifications</span> <span class="o">=</span> <span class="n">identifications</span><span class="p">)</span>
<span class="n">MESH</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
np:4149, nt:23369, nf:3076, ne:720, nf_all:47028, ne_all:27806
</pre></div></div>
</div>
<p>As we can see, additional points and faces have been created to accommodate the additional interface.</p>
<p>Next, we proceed to solve the problem in <span class="math notranslate nohighlight">\(H^1\)</span>. In weak form, we have:</p>
<p>Find <span class="math notranslate nohighlight">\(\phi\in V^* = \{u\in H^1\;:\; u|_{\Gamma_{out}}=0 \text{ and } u|_{\Gamma_{in}}=1\}\)</span> such that <span class="math notranslate nohighlight">\((\sigma\nabla\phi,\nabla v) = 0\)</span>, for all <span class="math notranslate nohighlight">\(v\in H^1\)</span></p>
<p>After homogenization, which involves splitting the solution <span class="math notranslate nohighlight">\(\phi = \phi_* + \phi_0\)</span>, where <span class="math notranslate nohighlight">\(\phi_*\in V^*\)</span>, we can instead solve:</p>
<p>Find <span class="math notranslate nohighlight">\(\phi_0\in H^1\setminus\Gamma_{in,out}\)</span> such that <span class="math notranslate nohighlight">\((\sigma\nabla\phi_0,\nabla v) = -(\sigma\nabla\phi_*,\nabla v)\)</span>, for all <span class="math notranslate nohighlight">\(v\in H^1\setminus\Gamma_{in,out}\)</span></p>
<p>After using conforming <span class="math notranslate nohighlight">\(P_1\)</span> continuous finite elements, we solve the discretized system in the following way: we split the discrete solution <span class="math notranslate nohighlight">\(\phi = R^T_{in}\phi_{in} + R^T_{out}\phi_{out} + R^T_{int}\phi_{int} = R^T_{in}\phi_{in} + R^T_{int}\phi_{int}\)</span>, where <span class="math notranslate nohighlight">\(R^T_*\)</span> matrices which assign the correct indices to the boundaries and the interior degrees of freedom. Assume the stiffness matrix is denoted by <span class="math notranslate nohighlight">\(K\)</span> and the right-hand side is <span class="math notranslate nohighlight">\(r\)</span>. Then, purely in
<span class="math notranslate nohighlight">\(H^1\)</span>, the system is of the form <span class="math notranslate nohighlight">\(K\phi=f\)</span>. Plugging in the splitting for <span class="math notranslate nohighlight">\(\phi\)</span> leads to the system <span class="math notranslate nohighlight">\(KR_{int}^T\phi_{int} = -KR_{in}^T\phi_{in}\)</span>. By multiplying from the left with <span class="math notranslate nohighlight">\(R_{int}\)</span>, we obtain the square system</p>
<div class="math notranslate nohighlight">
\[\begin{align}
R_{int}KR_{int}^T\phi_{int} = -R_{int}KR_{in}^T\phi_{in}
\end{align}\]</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">DB</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assembleB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="c1"># N1,N2,N3 = pde.int.assembleN3(MESH, order = order)</span>
<span class="n">unit_coil</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluate3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">regions</span> <span class="o">=</span> <span class="s1">&#39;coil&#39;</span><span class="p">)</span>

<span class="c1">###########################################################################</span>

<span class="n">phi_H1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">dphix_H1</span><span class="p">,</span> <span class="n">dphiy_H1</span><span class="p">,</span> <span class="n">dphiz_H1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">phiB_H1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assembleB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">phi_H1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>

<span class="n">R0</span><span class="p">,</span> <span class="n">RS0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assembleR3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;new,coil_cut_1&#39;</span><span class="p">)</span>
<span class="n">R1</span><span class="p">,</span> <span class="n">RS1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assembleR3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;coil_cut_1&#39;</span><span class="p">)</span>

<span class="n">M</span> <span class="o">=</span> <span class="n">phi_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">phi_H1</span><span class="o">.</span><span class="n">T</span>

<span class="n">K</span> <span class="o">=</span> <span class="n">dphix_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">dphix_H1</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>\
    <span class="n">dphiy_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">dphiy_H1</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>\
    <span class="n">dphiz_H1</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">dphiz_H1</span><span class="o">.</span><span class="n">T</span>

<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">RS0</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">R1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">R1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">RS0</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">RS0</span><span class="o">.</span><span class="n">T</span>


<span class="n">RZ</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">removeZeros</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">RZ</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">RZ</span><span class="o">.</span><span class="n">T</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">RZ</span> <span class="o">@</span> <span class="n">r</span>

<span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span><span class="c1">#58.7e6</span>
<span class="kn">from</span> <span class="nn">sksparse.cholmod</span> <span class="kn">import</span> <span class="n">cholesky</span> <span class="k">as</span> <span class="n">chol</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">chol</span><span class="p">(</span><span class="n">sigma</span><span class="o">*</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">solve_A</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">potential_H1</span> <span class="o">=</span> <span class="n">RS0</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">RZ</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">p</span> <span class="o">+</span> <span class="n">R1</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">R1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="n">jx_L2</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphix_H1</span><span class="o">.</span><span class="n">T</span><span class="nd">@potential_H1</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jy_L2</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphiy_H1</span><span class="o">.</span><span class="n">T</span><span class="nd">@potential_H1</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jz_L2</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphiz_H1</span><span class="o">.</span><span class="n">T</span><span class="nd">@potential_H1</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

<span class="n">dphix_H1_P0</span><span class="p">,</span> <span class="n">dphiy_H1_P0</span><span class="p">,</span> <span class="n">dphiz_H1_P0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">h1</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P1&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">unit_coil_P0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluate3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">regions</span> <span class="o">=</span> <span class="s1">&#39;coil&#39;</span><span class="p">)</span>
<span class="n">jx_L2_P0</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphix_H1_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@potential_H1</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jy_L2_P0</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphiy_H1_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@potential_H1</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jz_L2_P0</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dphiz_H1_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@potential_H1</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Instead of solving in <span class="math notranslate nohighlight">\(H^1\)</span>, we can instead solve the mixed problem directly by employing <span class="math notranslate nohighlight">\(H(\div)\)</span> conforming finite elements.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">phix_Hdiv</span><span class="p">,</span> <span class="n">phiy_Hdiv</span><span class="p">,</span> <span class="n">phiz_Hdiv</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">hdiv</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;RT0&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">divphi_Hdiv</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">hdiv</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;RT0&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>

<span class="n">phi_L2</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">l2</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;P0&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>

<span class="n">D</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>

<span class="n">M_Hdiv_coil_full</span> <span class="o">=</span> <span class="n">phix_Hdiv</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">phix_Hdiv</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>\
                   <span class="n">phiy_Hdiv</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">phiy_Hdiv</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span>\
                   <span class="n">phiz_Hdiv</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">phiz_Hdiv</span><span class="o">.</span><span class="n">T</span>

<span class="n">C_Hdiv_L2</span> <span class="o">=</span> <span class="n">divphi_Hdiv</span> <span class="o">@</span> <span class="n">D</span> <span class="o">@</span> <span class="n">unit_coil</span> <span class="o">@</span> <span class="n">phi_L2</span><span class="o">.</span><span class="n">T</span>
<span class="n">R1</span><span class="p">,</span> <span class="n">RS1</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">hdiv</span><span class="o">.</span><span class="n">assembleR3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;RT0&#39;</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;coil_face&#39;</span><span class="p">)</span>

<span class="n">M_Hdiv_coil_full</span> <span class="o">=</span> <span class="n">RS1</span> <span class="o">@</span> <span class="n">M_Hdiv_coil_full</span> <span class="nd">@RS1</span><span class="o">.</span><span class="n">T</span>
<span class="n">C_Hdiv_L2</span> <span class="o">=</span> <span class="n">RS1</span> <span class="o">@</span> <span class="n">C_Hdiv_L2</span>

<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="n">AA</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">bmat</span><span class="p">([[</span><span class="n">M_Hdiv_coil_full</span><span class="p">,</span> <span class="o">-</span><span class="n">C_Hdiv_L2</span><span class="p">],</span>
              <span class="p">[</span><span class="n">C_Hdiv_L2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="kc">None</span><span class="p">]])</span>

<span class="n">RZdiv</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">removeZeros</span><span class="p">(</span><span class="n">AA</span><span class="p">)</span>
<span class="n">AA</span> <span class="o">=</span> <span class="n">RZdiv</span> <span class="o">@</span> <span class="n">AA</span> <span class="o">@</span> <span class="n">RZdiv</span><span class="o">.</span><span class="n">T</span>

<span class="n">phiB_Hdiv</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">hdiv</span><span class="o">.</span><span class="n">assembleB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;RT0&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">phix_Hdiv</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
<span class="n">unit_coil_B</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluateB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="s1">&#39;coil_cut_1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">DB</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">assembleB3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>

<span class="n">rhs</span> <span class="o">=</span> <span class="n">unit_coil_B</span> <span class="o">@</span> <span class="n">DB</span> <span class="o">@</span> <span class="n">phiB_Hdiv</span><span class="o">.</span><span class="n">T</span>
<span class="n">rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">RS1</span><span class="nd">@rhs</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">MESH</span><span class="o">.</span><span class="n">nt</span><span class="p">)]</span>
<span class="n">rhs</span> <span class="o">=</span> <span class="n">RZdiv</span> <span class="o">@</span> <span class="n">rhs</span>

<span class="c1"># Here: -rhs because the &quot;normal&quot; points in the wrong direction!</span>
<span class="n">xx</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">AA</span><span class="p">,</span><span class="o">-</span><span class="n">rhs</span><span class="p">)</span>

<span class="n">potential_L2</span> <span class="o">=</span> <span class="p">(</span><span class="n">RZdiv</span><span class="o">.</span><span class="n">T</span><span class="nd">@xx</span><span class="p">)[</span><span class="o">-</span><span class="n">MESH</span><span class="o">.</span><span class="n">nt</span><span class="p">:]</span>
<span class="n">j_hdiv</span> <span class="o">=</span> <span class="n">RS1</span><span class="o">.</span><span class="n">T</span><span class="o">@</span><span class="p">(</span><span class="n">RZdiv</span><span class="o">.</span><span class="n">T</span><span class="nd">@xx</span><span class="p">)[:</span><span class="o">-</span><span class="n">MESH</span><span class="o">.</span><span class="n">nt</span><span class="p">]</span>

<span class="n">jx_hdiv</span> <span class="o">=</span> <span class="p">(</span><span class="n">phix_Hdiv</span><span class="o">.</span><span class="n">T</span><span class="nd">@j_hdiv</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jy_hdiv</span> <span class="o">=</span> <span class="p">(</span><span class="n">phiy_Hdiv</span><span class="o">.</span><span class="n">T</span><span class="nd">@j_hdiv</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jz_hdiv</span> <span class="o">=</span> <span class="p">(</span><span class="n">phiz_Hdiv</span><span class="o">.</span><span class="n">T</span><span class="nd">@j_hdiv</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

<span class="c1">##############################################################################</span>
<span class="n">unit_coil_P0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">evaluate3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">regions</span> <span class="o">=</span> <span class="s1">&#39;coil&#39;</span><span class="p">)</span>

<span class="n">phix_Hdiv_P0</span><span class="p">,</span> <span class="n">phiy_Hdiv_P0</span><span class="p">,</span> <span class="n">phiz_Hdiv_P0</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">hdiv</span><span class="o">.</span><span class="n">assemble3</span><span class="p">(</span><span class="n">MESH</span><span class="p">,</span> <span class="n">space</span> <span class="o">=</span> <span class="s1">&#39;RT0&#39;</span><span class="p">,</span> <span class="n">matrix</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">jx_hdiv_P0</span> <span class="o">=</span> <span class="p">(</span><span class="n">phix_Hdiv_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@j_hdiv</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jy_hdiv_P0</span> <span class="o">=</span> <span class="p">(</span><span class="n">phiy_Hdiv_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@j_hdiv</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="n">jz_hdiv_P0</span> <span class="o">=</span> <span class="p">(</span><span class="n">phiz_Hdiv_P0</span><span class="o">.</span><span class="n">T</span><span class="nd">@j_hdiv</span><span class="p">)</span><span class="o">*</span><span class="n">unit_coil_P0</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>

<span class="c1">##############################################################################</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">createVTK</span><span class="p">(</span><span class="n">MESH</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">add_H1_Scalar</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">potential_H1</span><span class="p">,</span> <span class="s1">&#39;potential_H1&#39;</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">add_L2_Scalar</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">potential_L2</span><span class="p">,</span> <span class="s1">&#39;potential_L2&#39;</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">add_L2_Vector</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">jx_L2_P0</span><span class="p">,</span><span class="n">jy_L2_P0</span><span class="p">,</span><span class="n">jz_L2_P0</span><span class="p">,</span><span class="s1">&#39;J_L2&#39;</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">add_L2_Vector</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">jx_hdiv_P0</span><span class="p">,</span><span class="n">jy_hdiv_P0</span><span class="p">,</span><span class="n">jz_hdiv_P0</span><span class="p">,</span><span class="s1">&#39;J_HDIV&#39;</span><span class="p">)</span>
<span class="n">pde</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">vtklib</span><span class="o">.</span><span class="n">writeVTK</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="s1">&#39;current_density.vtu&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;current_density.vtu&#39;</span><span class="p">)</span>
<span class="n">mesh</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<table style='width: 100%;'><tr><th>Header</th><th>Data Arrays</th></tr><tr><td>
<table style='width: 100%;'>
<tr><th>UnstructuredGrid</th><th>Information</th></tr>
<tr><td>N Cells</td><td>23369</td></tr>
<tr><td>N Points</td><td>4149</td></tr>
<tr><td>X Bounds</td><td>-2.000e+02, 2.000e+02</td></tr>
<tr><td>Y Bounds</td><td>-2.000e+02, 2.000e+02</td></tr>
<tr><td>Z Bounds</td><td>-1.000e+02, 1.000e+02</td></tr>
<tr><td>N Arrays</td><td>5</td></tr>
</table>

</td><td>
<table style='width: 100%;'>
<tr><th>Name</th><th>Field</th><th>Type</th><th>N Comp</th><th>Min</th><th>Max</th></tr>
<tr><td>potential_H1</td><td>Points</td><td>float32</td><td>1</td><td>0.000e+00</td><td>1.000e+00</td></tr>
<tr><td><b>Scalars_</b></td><td>Cells</td><td>float64</td><td>1</td><td>0.000e+00</td><td>5.000e+00</td></tr>
<tr><td>potential_L2</td><td>Cells</td><td>float32</td><td>1</td><td>0.000e+00</td><td>9.973e-01</td></tr>
<tr><td>J_L2</td><td>Cells</td><td>float32</td><td>3</td><td>-2.110e-03</td><td>2.123e-03</td></tr>
<tr><td>J_HDIV</td><td>Cells</td><td>float32</td><td>3</td><td>-1.902e-03</td><td>1.931e-03</td></tr>
</table>

</td></tr> </table></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;Scalars_&quot;</span><span class="p">)</span>
<span class="n">threshed</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">threshold</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
<span class="n">threshed</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;potential_H1&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">threshed</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;surface&#39;</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="n">mesh</span><span class="o">.</span><span class="n">set_active_vectors</span><span class="p">(</span><span class="s2">&quot;J_L2&quot;</span><span class="p">)</span>
<span class="n">arrows</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">glyph</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="s2">&quot;J_L2&quot;</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">9500.0</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">arrows</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">camera_position</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">600</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="n">p</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">jupyter_backend</span><span class="o">=</span><span class="s1">&#39;html&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "c8da0b965bda4808b6a894d3e68a1242", "version_major": 2, "version_minor": 0}</script></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;Scalars_&quot;</span><span class="p">)</span>
<span class="n">threshed</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">threshold</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
<span class="n">threshed</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;potential_L2&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">threshed</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;surface&#39;</span><span class="p">,</span> <span class="n">opacity</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="n">mesh</span><span class="o">.</span><span class="n">set_active_vectors</span><span class="p">(</span><span class="s2">&quot;J_HDIV&quot;</span><span class="p">)</span>
<span class="n">arrows</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">glyph</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="s2">&quot;J_HDIV&quot;</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">9500.0</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">arrows</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">camera_position</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">600</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="n">p</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">jupyter_backend</span><span class="o">=</span><span class="s1">&#39;html&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "34842c5e34bb4f1ca5d8f11738417909", "version_major": 2, "version_minor": 0}</script></div>
</div>
<script type="application/vnd.jupyter.widget-state+json">
{"state": {"0669ace4c27647f3b691f8a4079cfaa4": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}, "34842c5e34bb4f1ca5d8f11738417909": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_96d18187666041edb5c2d88aa9e95135", "style": "IPY_MODEL_0669ace4c27647f3b691f8a4079cfaa4", "value": "<iframe srcdoc=\"<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;/>\n    <meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;>\n  </head>\n  <body>\n    <div class=&quot;content&quot;></div>\n<script type=&quot;text/javascript&quot;>\n!function(){var e={334:function(){const e=document.querySelector(&quot;head&quot;);e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement(&quot;link&quot;);n.setAttribute(&quot;rel&quot;,&quot;icon&quot;),n.setAttribute(&quot;href&quot;,`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute(&quot;sizes&quot;,`${t}x${t}`),n.setAttribute(&quot;type&quot;,&quot;image/png&quot;),e.appendChild(n)}))},13:function(e,t,n){&quot;use strict&quot;;n.r(t),n.d(t,{initLocalFileLoader:function(){return ZA},load:function(){return YA}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return E},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return D},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ee},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return De},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i=&quot;undefined&quot;!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],D=r[2],E=Math.hypot(R,M,D);return E<a?null:(R*=E=1/E,M*=E,D*=E,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+D*o,C=D*R*s-M*o,S=R*M*s-D*o,A=M*M*s+i,I=D*M*s+R*o,w=R*D*s+M*o,P=M*D*s-R*o,O=D*D*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),E(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,D=(1-(p+v))*C,E=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=D,e[6]=E,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+D*I+L*w),e[14]=n[2]+w-(R*A+E*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return&quot;mat4(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;, &quot;+e[9]+&quot;, &quot;+e[10]+&quot;, &quot;+e[11]+&quot;, &quot;+e[12]+&quot;, &quot;+e[13]+&quot;, &quot;+e[14]+&quot;, &quot;+e[15]+&quot;)&quot;}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],D=t[12],E=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-D)<=a*Math.max(1,Math.abs(m),Math.abs(D))&&Math.abs(h-E)<=a*Math.max(1,Math.abs(h),Math.abs(E))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return&quot;mat3(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;)&quot;}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function De(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=De,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error(&quot;Invalid VTK object&quot;),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&&quot;object&quot;==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol(&quot;void&quot;),$e={};function qe(){}[&quot;log&quot;,&quot;debug&quot;,&quot;info&quot;,&quot;warn&quot;,&quot;error&quot;,&quot;time&quot;,&quot;timeEnd&quot;,&quot;group&quot;,&quot;groupEnd&quot;].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty(&quot;log&quot;)?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st(&quot;_&quot;===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=[&quot;TB&quot;,&quot;GB&quot;,&quot;MB&quot;,&quot;KB&quot;];let o=Number(e),a=&quot;B&quot;;for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot; &quot;;const n=[];let r=e;for(;r>1e3;)n.push((&quot;000&quot;+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),&quot;classHierarchy&quot;in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He(&quot;vtkObject&quot;);function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==[&quot;mtime&quot;].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||&quot;_&quot;===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(&quot;, &quot;)}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if(&quot;object&quot;==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(&quot;string&quot;==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError(&quot;Set Enum with invalid string argument&quot;)}if(&quot;number&quot;==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError(&quot;Set Enum outside numeric range&quot;)}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError(&quot;Set Enum with invalid argument (String/Number)&quot;)}},object(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(!ke()(t[n.name],o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}return!1}}};function Ct(e){if(&quot;object&quot;==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError(&quot;No setter for field&quot;)}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{&quot;object&quot;==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et(&quot;instance deleted - cannot call any method&quot;);else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=&quot; input ports. To add more input ports, use addInputConnection()&quot;,void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et(&quot;instance deleted - cannot call any method&quot;),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):o(e,i())},e.addInputConnection=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:&quot;Scalars&quot;;for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol(&quot;Event abort&quot;);function Dt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et(&quot;instance deleted - cannot call any method&quot;);const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA(&quot;vtkObject&quot;)}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt=&quot;__root__&quot;;function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=&quot;&quot;+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,[&quot;proxyId&quot;,&quot;proxyGroup&quot;,&quot;proxyName&quot;]),At(e,t,[&quot;proxyManager&quot;]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if(&quot;application&quot;===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,&quot;application&quot;),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return&quot;detail&quot;in e&&(n=e.detail),&quot;wheelDelta&quot;in e&&(n=-e.wheelDelta/120),&quot;wheelDeltaY&quot;in e&&(n=-e.wheelDeltaY/120),&quot;wheelDeltaX&quot;in e&&(t=-e.wheelDeltaX/120),&quot;axis&quot;in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,&quot;deltaY&quot;in e&&(o=e.deltaY),&quot;deltaX&quot;in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Dt,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Et,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Dt,newInstance:Et,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push(&quot;vtkViewNode&quot;),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)r.setVisited(!0);else{const r=e.createViewNode(n);r&&(r.setParent(e),r.setVisited(!0),t._renderableChildMap.set(n,r),t.children.push(r))}},e.addMissingNodes=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r],a=t._renderableChildMap.get(o);if(void 0!==a)a.setVisited(!0);else{const n=e.createViewNode(o);n&&(n.setParent(e),n.setVisited(!0),t._renderableChildMap.set(o,n),t.children.push(n))}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];-1===t.children.indexOf(o)&&(o.setParent(e),t.children.push(o)),o.setVisited(!0)}},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t(&quot;Cannot create view nodes without my own factory&quot;),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),t._renderableChildMap=new Map,jt.get(e,t,[&quot;visited&quot;]),jt.setGet(e,t,[&quot;_parent&quot;,&quot;renderable&quot;,&quot;myFactory&quot;]),jt.getArray(e,t,[&quot;children&quot;]),jt.moveToProtected(e,t,[&quot;parent&quot;]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,&quot;vtkViewNode&quot;),extend:Yt,PASS_TYPES:[&quot;Build&quot;,&quot;Render&quot;]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push(&quot;vtkViewNodeFactory&quot;),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s},e.registerOverride=(e,n)=>{t.overrides[e]=n}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,&quot;vtkViewNodeFactory&quot;),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push(&quot;vtkOpenGLViewNodeFactory&quot;)}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,&quot;vtkOpenGLViewNodeFactory&quot;),extend:sn};function cn(e,t){t.classHierarchy.push(&quot;vtkOpenGLCamera&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,[&quot;context&quot;,&quot;keyMatrixTime&quot;]),cn(e,t)}));rn(&quot;vtkCamera&quot;,dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderer&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn(&quot;No lights are on, creating one.&quot;),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();t.context.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,[&quot;shaderCache&quot;]),At(e,t,[&quot;selector&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),fn(e,t)}),&quot;vtkOpenGLRenderer&quot;);function hn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor&quot;),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkRenderer&quot;,mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor2D&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn(&quot;vtkActor&quot;,yn);const bn={context:null,activeTextures:null};const xn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function Dn(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function En(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn(&quot;vtkActor2D&quot;,xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn=&quot;\\\\s*([+-]?\\\\d+)\\\\s*&quot;,Jn=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*&quot;,er=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*&quot;,tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\\\(${Qn},${Qn},${Qn}\\\\)$`),rr=new RegExp(`^rgb\\\\(${er},${er},${er}\\\\)$`),or=new RegExp(`^rgba\\\\(${Qn},${Qn},${Qn},${Jn}\\\\)$`),ar=new RegExp(`^rgba\\\\(${er},${er},${er},${Jn}\\\\)$`),ir=new RegExp(`^hsl\\\\(${Jn},${er},${er}\\\\)$`),sr=new RegExp(`^hsla\\\\(${Jn},${er},${er},${Jn}\\\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+&quot;&quot;).trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):&quot;transparent&quot;===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?&quot;rgb(&quot;:&quot;rgba(&quot;}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?&quot;)&quot;:`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?&quot;0&quot;:&quot;&quot;)+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?&quot;hsl(&quot;:&quot;hsla(&quot;}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?&quot;)&quot;:`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Dr=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+&quot;&quot;}}return r.gamma=e,r}(1);function Er(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+&quot;&quot;}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&&quot;object&quot;==typeof e||(e={}),null!==t&&&quot;object&quot;==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Er((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Er((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,Fr=new RegExp(_r.source,&quot;g&quot;);function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+=&quot;&quot;,t+=&quot;&quot;;(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+&quot;&quot;}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join(&quot;&quot;)})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||&quot;boolean&quot;===r?Rr(t):(&quot;number&quot;===r?Br:&quot;string&quot;===r?(n=dr(t))?(t=n,Dr):kr:t instanceof dr?Dr:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:&quot;function&quot;!=typeof t.valueOf&&&quot;function&quot;!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error(&quot;invalid format: &quot;+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?&quot; &quot;:e.fill+&quot;&quot;,this.align=void 0===e.align?&quot;>&quot;:e.align+&quot;&quot;,this.sign=void 0===e.sign?&quot;-&quot;:e.sign+&quot;&quot;,this.symbol=void 0===e.symbol?&quot;&quot;:e.symbol+&quot;&quot;,this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?&quot;&quot;:e.type+&quot;&quot;}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf(&quot;e&quot;))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1];return o<0?&quot;0.&quot;+new Array(-o).join(&quot;0&quot;)+r:r.length>o+1?r.slice(0,o+1)+&quot;.&quot;+r.slice(o+1):r+new Array(o-r.length+2).join(&quot;0&quot;)}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?&quot;0&quot;:&quot;&quot;)+(void 0===this.width?&quot;&quot;:Math.max(1,0|this.width))+(this.comma?&quot;,&quot;:&quot;&quot;)+(void 0===this.precision?&quot;&quot;:&quot;.&quot;+Math.max(0,0|this.precision))+(this.trim?&quot;~&quot;:&quot;&quot;)+this.type};var ao={&quot;%&quot;:(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+&quot;&quot;,d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString(&quot;en&quot;).replace(/,/g,&quot;&quot;):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join(&quot;0&quot;):a>0?r.slice(0,a)+&quot;.&quot;+r.slice(a):&quot;0.&quot;+new Array(1-a).join(&quot;0&quot;)+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=[&quot;y&quot;,&quot;z&quot;,&quot;a&quot;,&quot;f&quot;,&quot;p&quot;,&quot;n&quot;,&quot;\u00b5&quot;,&quot;m&quot;,&quot;&quot;,&quot;k&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;,&quot;Z&quot;,&quot;Y&quot;];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?&quot;,f&quot;:r)).type){case&quot;s&quot;:var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case&quot;&quot;:case&quot;e&quot;:case&quot;g&quot;:case&quot;p&quot;:case&quot;r&quot;:null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-(&quot;e&quot;===r.type));break;case&quot;f&quot;:case&quot;%&quot;:null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*(&quot;%&quot;===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+&quot;&quot;,function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?&quot;&quot;:e.currency[0]+&quot;&quot;,a=void 0===e.currency?&quot;&quot;:e.currency[1]+&quot;&quot;,i=void 0===e.decimal?&quot;.&quot;:e.decimal+&quot;&quot;,s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?&quot;%&quot;:e.percent+&quot;&quot;,c=void 0===e.minus?&quot;\u2212&quot;:e.minus+&quot;&quot;,u=void 0===e.nan?&quot;NaN&quot;:e.nan+&quot;&quot;;function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;&quot;n&quot;===y?(m=!0,y=&quot;g&quot;):ao[y]||(void 0===h&&(h=12),v=!0,y=&quot;g&quot;),(f||&quot;0&quot;===t&&&quot;=&quot;===n)&&(f=!0,t=&quot;0&quot;,n=&quot;=&quot;);var T=&quot;$&quot;===p?o:&quot;#&quot;===p&&/[boxX]/.test(y)?&quot;0&quot;+y.toLowerCase():&quot;&quot;,b=&quot;$&quot;===p?a:/[%p]/.test(y)?l:&quot;&quot;,x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if(&quot;c&quot;===y)S=x(e)+S,e=&quot;&quot;;else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case&quot;.&quot;:o=t=r;break;case&quot;0&quot;:0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&&quot;+&quot;!==d&&(A=!1),p=(A?&quot;(&quot;===d?d:c:&quot;-&quot;===d||&quot;(&quot;===d?&quot;&quot;:d)+p,S=(&quot;s&quot;===y?po[8+Qr/3]:&quot;&quot;)+S+(A&&&quot;(&quot;===d?&quot;)&quot;:&quot;&quot;),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):&quot;&quot;;switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=&quot;&quot;),n){case&quot;<&quot;:e=p+e+S+w;break;case&quot;=&quot;:e=p+w+e+S;break;case&quot;^&quot;:e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+&quot;&quot;},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type=&quot;f&quot;,e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:&quot;,&quot;,grouping:[3],currency:[&quot;$&quot;,&quot;&quot;]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Do,ceil:Eo,min:Vo,max:Lo}=Math;const Bo=Ao(&quot;ceilLog2&quot;),No=Ao(&quot;factorial&quot;);function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao(&quot;gaussian&quot;);function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes(&quot;e&quot;))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split(&quot;e&quot;);let r=&quot;&quot;;return+n[1]+t>0&&(r=&quot;+&quot;),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co(&quot;vtkMath::Jacobi: Error extracting eigenfunctions&quot;),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co(&quot;Unable to factor linear system&quot;),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co(&quot;Unable to factor linear system&quot;),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Da(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Ea=Ao(&quot;GetScalarTypeFittingRange&quot;),Va=Ao(&quot;GetAdjustedScalarRange&quot;);const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Do,ceil:Eo,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo(&quot;Number of columns of A must match number of rows of B.&quot;);const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co(&quot;Matrix has 0 determinant&quot;),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co(&quot;Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()&quot;),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Da,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Ea,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;#&quot;;return`${t}${e.map(Ga).join(&quot;&quot;)}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(&quot;, &quot;)})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};const Wa=1e-6,Ha=&quot;coincide&quot;,ja=&quot;disjoint&quot;;function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?&quot;x&quot;:i[1]>i[2]?&quot;y&quot;:&quot;z&quot;;const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case&quot;x&quot;:l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case&quot;y&quot;:l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case&quot;z&quot;:l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha};function Ja(e,t){t.classHierarchy.push(&quot;vtkPlane&quot;),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}const ei={normal:[0,0,1],origin:[0,0,0]};function ti(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ei,n),jt.obj(e,t),jt.setGetArray(e,t,[&quot;normal&quot;,&quot;origin&quot;],3),Ja(e,t)}var ni={newInstance:jt.newInstance(ti,&quot;vtkPlane&quot;),extend:ti,...Qa};const ri=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function oi(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ai(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ii(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function si(e){return ii(e,ri)}function li(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function ci(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)li(e,...t[n]);else for(let n=0;n<t.length;n+=3)li(e,...t.slice(n,n+3));return e}function ui(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function fi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function gi(e,t,n,r){return!!ai(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function mi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function hi(e,t){return e[2*t+1]-e[2*t]}function vi(e){return[hi(e,0),hi(e,1),hi(e,2)]}function yi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function bi(e){return e.slice(4,6)}function xi(e){const t=vi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function Ci(e){if(ai(e)){const t=vi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Si(e){return[e[0],e[2],e[4]]}function Ai(e){return[e[1],e[3],e[5]]}function Ii(e,t){return e<=0&&t>=0||e>=0&&t<=0}function wi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Pi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=wi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return si(n),ci(n,r)}function Ri(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Mi(e,t,n,r){const o=[].concat(ri),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Di(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ni.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!ai(e)||!ai(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Li(e,t){if(!ai(e)||!ai(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Bi(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Ni(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ni.evaluate(n,t,l)}let i=2;for(;i--&&!(Ii(o[r[i][0]],o[r[i][4]])&&Ii(o[r[i][1]],o[r[i][5]])&&Ii(o[r[i][2]],o[r[i][6]])&&Ii(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class _i{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ri))}getBounds(){return this.bounds}equals(e){return oi(this.bounds,e)}isValid(){return ai(this.bounds)}setBounds(e){return ii(this.bounds,e)}reset(){return si(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return li(this.bounds,...t)}addPoints(e){return ci(this.bounds,e)}addBounds(e,t,n,r,o,a){return ui(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return di(this.bounds,e,t,n)}setMaxPoint(e,t,n){return pi(this.bounds,e,t,n)}inflate(e){return fi(this.bounds,e)}scale(e,t,n){return gi(this.bounds,e,t,n)}getCenter(){return mi(this.bounds)}getLength(e){return hi(this.bounds,e)}getLengths(){return vi(this.bounds)}getMaxLength(){return xi(this.bounds)}getDiagonalLength(){return Ci(this.bounds)}getMinPoint(){return Si(this.bounds)}getMaxPoint(){return Ai(this.bounds)}getXRange(){return yi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return bi(this.bounds)}getCorners(e){return wi(this.bounds,e)}computeCornerPoints(e,t){return Pi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Mi(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Ri(this.bounds,e)}cutWithPlane(e,t){return Ni(this.bounds,e,t)}intersectBox(e,t,n,r){return Di(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Li(this.bounds,e)}containsPoint(e,t,n){return Bi(this.bounds,e,t,n)}contains(e){return Li(this.bounds,e)}}var Fi,ki={newInstance:function(e){const t=e&&e.bounds;return new _i(t)},equals:oi,isValid:ai,setBounds:ii,reset:si,addPoint:li,addPoints:ci,addBounds:ui,setMinPoint:di,setMaxPoint:pi,inflate:fi,scale:gi,scaleAboutCenter:function(e,t,n,r){if(!ai(e))return!1;const o=mi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],gi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:mi,getLength:hi,getLengths:vi,getMaxLength:xi,getDiagonalLength:Ci,getMinPoint:Si,getMaxPoint:Ai,getXRange:yi,getYRange:Ti,getZRange:bi,getCorners:wi,computeCornerPoints:Pi,computeLocalBounds:Mi,transformBounds:Oi,computeScale3:Ri,cutWithPlane:Ni,intersectBox:Di,intersectPlane:Ei,intersect:Vi,intersects:Li,containsPoint:Bi,contains:function(e,t){return!!Li(e,t)&&!!Bi(e,...Si(t))&&!!Bi(e,...Ai(t))},INIT_BOUNDS:ri};function Gi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Ui(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function zi(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function Wi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Fi=new i(4),i!=Float32Array&&(Fi[0]=0,Fi[1]=0,Fi[2]=0,Fi[3]=0);var Hi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),Ui(),Ui(),ie();var ji={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Ki}=ji;function $i(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function qi(e,t){t.classHierarchy.push(&quot;vtkProp&quot;),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=$i(&quot;pick&quot;),e.hasKey=$i(&quot;hasKey&quot;),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Ki.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Ki.DISPLAY)}const Xi={allocatedRenderTime:10,coordinateSystem:Ki.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function Yi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xi,n),jt.obj(e,t),jt.get(e,t,[&quot;estimatedRenderTime&quot;,&quot;allocatedRenderTime&quot;]),jt.setGet(e,t,[&quot;_parentProp&quot;,&quot;coordinateSystem&quot;,&quot;dragable&quot;,&quot;pickable&quot;,&quot;renderTimeMultiplier&quot;,&quot;useBounds&quot;,&quot;visibility&quot;]),jt.moveToProtected(e,t,[&quot;parentProp&quot;]),qi(e,t)}var Zi={newInstance:jt.newInstance(Yi,&quot;vtkProp&quot;),extend:Yi,...ji};function Qi(e,t){t.classHierarchy.push(&quot;vtkProp3D&quot;),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Ui();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=Ui();zi(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>ki.getCenter(t.bounds),e.getLength=()=>ki.getLength(t.bounds),e.getXRange=()=>ki.getXRange(t.bounds),e.getYRange=()=>ki.getYRange(t.bounds),e.getZRange=()=>ki.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const Ji={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Zi.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,[&quot;bounds&quot;,&quot;isIdentity&quot;]),jt.getArray(e,t,[&quot;orientation&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;position&quot;,&quot;scale&quot;],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,Qi(e,t)}var ts={newInstance:jt.newInstance(es,&quot;vtkProp3D&quot;),extend:es};const ns={FLAT:0,GOURAUD:1,PHONG:2},rs={POINTS:0,WIREFRAME:1,SURFACE:2};var os={Shading:ns,Representation:rs,Interpolation:ns};const{Representation:as,Interpolation:is}=os;function ss(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ls(e,t){t.classHierarchy.push(&quot;vtkProperty&quot;),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ss(&quot;ComputeCompositeColor&quot;),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ss(&quot;AddShaderVariable&quot;),e.setInterpolationToFlat=()=>e.setInterpolation(is.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(is.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(is.PHONG),e.getInterpolationAsString=()=>jt.enumToString(is,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(as.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(as.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(as.POINTS),e.getRepresentationAsString=()=>jt.enumToString(as,t.representation)}const cs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:is.GOURAUD,representation:as.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function us(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cs,n),jt.obj(e,t),jt.setGet(e,t,[&quot;lighting&quot;,&quot;interpolation&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;metallic&quot;,&quot;roughness&quot;,&quot;normalStrength&quot;,&quot;emission&quot;,&quot;baseIOR&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;opacity&quot;,&quot;edgeVisibility&quot;,&quot;lineWidth&quot;,&quot;pointSize&quot;,&quot;backfaceCulling&quot;,&quot;frontfaceCulling&quot;,&quot;representation&quot;,&quot;diffuseTexture&quot;,&quot;metallicTexture&quot;,&quot;roughnessTexture&quot;,&quot;normalTexture&quot;,&quot;ambientOcclusionTexture&quot;,&quot;emissionTexture&quot;]),jt.setGetArray(e,t,[&quot;ambientColor&quot;,&quot;specularColor&quot;,&quot;diffuseColor&quot;,&quot;edgeColor&quot;],3),ls(e,t)}var ds={newInstance:jt.newInstance(us,&quot;vtkProperty&quot;),extend:us,...os};const{vtkDebugMacro:ps}=jt;function fs(e,t){t.classHierarchy.push(&quot;vtkActor&quot;);const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ds.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){ps(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.concat();const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const gs={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gs,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;backfaceProperty&quot;,&quot;forceOpaque&quot;,&quot;forceTranslucent&quot;,&quot;mapper&quot;]),fs(e,t)}var hs={newInstance:jt.newInstance(ms,&quot;vtkActor&quot;),extend:ms};const vs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},ys={VOID:&quot;&quot;,CHAR:&quot;Int8Array&quot;,SIGNED_CHAR:&quot;Int8Array&quot;,UNSIGNED_CHAR:&quot;Uint8Array&quot;,SHORT:&quot;Int16Array&quot;,UNSIGNED_SHORT:&quot;Uint16Array&quot;,INT:&quot;Int32Array&quot;,UNSIGNED_INT:&quot;Uint32Array&quot;,FLOAT:&quot;Float32Array&quot;,DOUBLE:&quot;Float64Array&quot;};var Ts={DefaultDataType:ys.FLOAT,DataTypeByteSize:vs,VtkDataTypes:ys};const{vtkErrorMacro:bs}=Kt,{DefaultDataType:xs}=Ts,Cs=1e-6;function Ss(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function As(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ss(r,0,1)}return Ss(e,t<0?0:t,n)}function Is(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function ws(e){return Object.prototype.toString.call(e).slice(8,-1)}const Ps={computeRange:As,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ss,getDataType:ws,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Os(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push(&quot;vtkDataArray&quot;),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=As(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Cs;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Ds({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=ws(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||bs(&quot;numberOfComponents must match&quot;);const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Rs={name:&quot;&quot;,numberOfComponents:1,dataType:xs,rangeTuple:[0,0]};function Ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Rs,n),!t.empty&&!t.values&&!t.size)throw new TypeError(&quot;Cannot create vtkDataArray object without: size > 0, values&quot;);if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=ws(t.values)),yt(e,t),St(e,t,[&quot;name&quot;,&quot;numberOfComponents&quot;]),t.size%t.numberOfComponents!=0)throw new RangeError(&quot;model.size is not a multiple of model.numberOfComponents&quot;);Os(e,t)}const Ds=Et(Ms,&quot;vtkDataArray&quot;);var Es={newInstance:Ds,extend:Ms,...Ps,...Ts};function Vs(e,t){t.classHierarchy.push(&quot;vtkAbstractMapper&quot;),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA(&quot;vtkPlane&quot;)&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Ls={clippingPlanes:[]};var Bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ls,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),Vs(e,t)};function Ns(e,t){e.getBounds=()=>(jt.vtkErrorMacro(&quot;vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED&quot;),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=ki.isValid(n)?ki.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return ki.getDiagonalLength(t)}}const _s=e=>({bounds:[...ki.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var Fs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_s(n)),Bs(e,t,n),jt.setGet(e,t,[&quot;viewSpecificProperties&quot;]),Ns(e,t)};const{vtkErrorMacro:ks,vtkWarningMacro:Gs}=jt;function Us(e,t){t.classHierarchy.push(&quot;vtkFieldData&quot;);const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>&quot;number&quot;==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():&quot;&quot;},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else ks(&quot;Unhandled case in passData&quot;);else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Es.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Gs(&quot;Unexpected case in interpolateData&quot;)}else t.insertTuples(s.getTuples());else ks(&quot;Unhandled case in interpolateData&quot;);else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Es.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const zs={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Ws(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zs,n),jt.obj(e,t),Us(e,t)}var Hs={newInstance:jt.newInstance(Ws,&quot;vtkFieldData&quot;),extend:Ws};const js={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ks={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:js,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:&quot;vtkGhostType&quot;};const{AttributeTypes:$s,AttributeCopyOperations:qs}=Ks,{vtkWarningMacro:Xs}=jt;function Ys(e,t){const n=[&quot;Scalars&quot;,&quot;Vectors&quot;,&quot;Normals&quot;,&quot;TCoords&quot;,&quot;Tensors&quot;,&quot;GlobalIds&quot;,&quot;PedigreeIds&quot;];function r(e){let t=n.find((t=>$s[t.toUpperCase()]===e||&quot;number&quot;!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push(&quot;vtkDataSetAttributes&quot;);const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&&quot;PEDIGREEIDS&quot;===a.toUpperCase()&&!n.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if(&quot;PEDIGREEIDS&quot;!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(qs).filter((e=>&quot;ALLCOPY&quot;!==e)).forEach((e=>{t.copyAttributeFlags[qs[e]]=Object.keys($s).filter((e=>&quot;NUM_ATTRIBUTES&quot;!==e)).reduce(((e,t)=>(e[$s[t]]=!0,e)),[])})),t.copyAttributeFlags[qs.COPYTUPLE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.INTERPOLATE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.COPYTUPLE][$s.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||&quot;vtkDataArray&quot;!==t.dataArrays[n].type||e.addArray(Es.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const Zs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Qs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zs,n),Hs.extend(e,t,n),jt.setGet(e,t,[&quot;activeScalars&quot;,&quot;activeNormals&quot;,&quot;activeTCoords&quot;,&quot;activeVectors&quot;,&quot;activeTensors&quot;,&quot;activeGlobalIds&quot;,&quot;activePedigreeIds&quot;]),t.arrays||(t.arrays={}),Ys(e,t)}var Js={newInstance:jt.newInstance(Qs,&quot;vtkDataSetAttributes&quot;),extend:Qs,...Ks};const el=[&quot;pointData&quot;,&quot;cellData&quot;,&quot;fieldData&quot;];function tl(e,t){t.classHierarchy.push(&quot;vtkDataSet&quot;),el.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Js.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),el.forEach((n=>{t[n]=Js.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const nl={};function rl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nl,n),jt.obj(e,t),jt.setGet(e,t,el),tl(e,t)}var ol={newInstance:jt.newInstance(rl,&quot;vtkDataSet&quot;),extend:rl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const al={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var il={StructuredType:al};const{StructuredType:sl}=il;var ll={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?sl.EMPTY:3===t?sl.XYZ_GRID:2===t?e[0]===e[1]?sl.YZ_PLANE:e[2]===e[3]?sl.XZ_PLANE:sl.XY_PLANE:1===t?e[0]<e[1]?sl.X_LINE:e[2]<e[3]?sl.Y_LINE:sl.Z_LINE:sl.SINGLE_POINT},...il};const{vtkErrorMacro:cl}=jt;function ul(e,t){t.classHierarchy.push(&quot;vtkImageData&quot;),e.setExtent=function(){if(t.deleted)return cl(&quot;instance deleted - cannot call any method&quot;),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=ll.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)cl(&quot;instance deleted - cannot call any method&quot;);else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void cl(&quot;Bad dimension specification&quot;);n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return cl(&quot;Requesting a point from an empty image.&quot;),null;const o=new Float64Array(3);switch(t.dataDescription){case al.EMPTY:return null;case al.SINGLE_POINT:break;case al.X_LINE:o[0]=n;break;case al.Y_LINE:o[1]=n;break;case al.Z_LINE:o[2]=n;break;case al.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case al.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case al.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case al.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:cl(&quot;Invalid dataDescription&quot;)}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>ki.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>ki.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>ki.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];ki.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Da(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Da(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return cl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return cl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const dl={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:al.EMPTY};function pl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dl,n),ol.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,[&quot;indexToWorld&quot;,&quot;worldToIndex&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;spacing&quot;],3),jt.setGetArray(e,t,[&quot;direction&quot;],9),jt.getArray(e,t,[&quot;extent&quot;],6),ul(e,t)}var fl={newInstance:jt.newInstance(pl,&quot;vtkImageData&quot;),extend:pl};const gl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var ml={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:gl},hl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:vl,VectorMode:yl}=ml,{VtkDataTypes:Tl}=Es,{ColorMode:bl}=hl,{vtkErrorMacro:xl}=jt;function Cl(e){return e}function Sl(e){return Math.floor(255*e+.5)}function Al(e,t){t.classHierarchy.push(&quot;vtkScalarsToColors&quot;),e.setVectorModeToMagnitude=()=>e.setVectorMode(yl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(yl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(yl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)xl(&quot;Values and annotations do not have the same number of tuples so ignoring&quot;);else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===bl.DEFAULT&&t.getDataType()===Tl.UNSIGNED_CHAR||n===bl.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:&quot;vtkDataArray&quot;,name:&quot;temp&quot;,numberOfComponents:4,dataType:Tl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Es.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,vl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,vl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===yl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==yl.MAGNITUDE||1!==c&&1!==s||(i=yl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case yl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case yl.RGBCOLORS:break;case yl.MAGNITUDE:default:{const o=Es.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Sl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Tl.UNSIGNED_CHAR)return n;const i=Es.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Tl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=Cl;switch(n.getDataType()!==Tl.FLOAT&&n.getDataType()!==Tl.DOUBLE||(s=Sl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return xl(&quot;Cannot convert colors&quot;),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==bl.DEFAULT||n.getDataType()!==Tl.UNSIGNED_CHAR)&&r!==bl.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Il={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:yl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function wl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Il,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,[&quot;vectorSize&quot;,&quot;vectorComponent&quot;,&quot;vectorMode&quot;,&quot;alpha&quot;,&quot;indexedLookup&quot;]),jt.setArray(e,t,[&quot;mappingRange&quot;],2),jt.getArray(e,t,[&quot;mappingRange&quot;]),Al(e,t)}var Pl={newInstance:jt.newInstance(wl,&quot;vtkScalarsToColors&quot;),extend:wl,...ml};const{vtkErrorMacro:Ol}=jt;function Rl(e,t){t.classHierarchy.push(&quot;vtkLookupTable&quot;),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Ol(&quot;Expected 4 components for RGBA colors&quot;),!1;if(n.getDataType()!==ys.UNSIGNED_CHAR)return Ol(&quot;Expected unsigned char values for RGBA colors&quot;),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ml={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Dl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ml,n),Pl.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,[&quot;buildTime&quot;]),jt.setGet(e,t,[&quot;numberOfColors&quot;,&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;]),jt.setArray(e,t,[&quot;alphaRange&quot;,&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;],2),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;,&quot;alphaRange&quot;,&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),Rl(e,t)}var El={newInstance:jt.newInstance(Dl,&quot;vtkLookupTable&quot;),extend:Dl};let Vl=1,Ll=0;const Bl=[&quot;VTK_RESOLVE_OFF&quot;,&quot;VTK_RESOLVE_POLYGON_OFFSET&quot;];function Nl(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;Ll=e}var _l={getResolveCoincidentTopologyAsString:function(){return Bl[Ll]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Vl},getResolveCoincidentTopology:function(){return Ll},setResolveCoincidentTopology:Nl,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){Vl=e},setResolveCoincidentTopologyToDefault:function(){Nl(0)},setResolveCoincidentTopologyToOff:function(){Nl(0)},setResolveCoincidentTopologyToPolygonOffset:function(){Nl(1)}};function Fl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=(e,r)=>{t[n.key]={factor:e,offset:r}}}))}const kl=[&quot;Polygon&quot;,&quot;Line&quot;,&quot;Point&quot;],Gl={};Fl(Gl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},kl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Ul={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,[&quot;resolveCoincidentTopology&quot;]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(_l).forEach((t=>{e[t]=_l[t]})),Object.keys(Gl).forEach((t=>{e[t]=Gl[t]})),Fl(e,t.topologyOffset,kl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=Gl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:Gl,otherStaticMethods:_l,CATEGORIES:kl};const zl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Wl={PassTypes:zl};const{FieldAssociations:Hl}=ol,{staticOffsetAPI:jl,otherStaticMethods:Kl}=Ul,{ColorMode:$l,ScalarMode:ql,GetArray:Xl}=hl,{VectorMode:Yl}=ml,{VtkDataTypes:Zl}=Es;function Ql(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Jl(e,t){t.classHierarchy.push(&quot;vtkMapper&quot;),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString($l,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(ql,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===ql.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===ql.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===ql.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===ql.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_FIELD_DATA){const t=e.getFieldData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==a){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(n))e.mapScalarsToTexture(o,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},e.scalarToTextureCoordinate=(e,t,n)=>{let r=.5,o=1;return _a(e)||(o=.49,r=(e-t)*n,r>1e3?r=1e3:r<-1e3&&(r=-1e3)),{texCoordS:r,texCoordT:o}},e.createColorTextureCoordinates=(t,n,r,o,a,i,s,l,c)=>{const u=(i[1]-i[0])/l,d=[];d[0]=i[0]-u,d[1]=i[1]+u;const p=1/(d[1]-d[0]),f=n.getData(),g=t.getData();let m=0,h=0;if(a<0||a>=o)for(let t=0;t<r;++t){let t=0;for(let e=0;e<o;++e)t+=g[m]*g[m],m++;let n=Math.sqrt(t);c&&(n=El.applyLogScale(n,s,i));const r=e.scalarToTextureCoordinate(n,d[0],p);f[h]=r.texCoordS,f[h+1]=r.texCoordT,h+=2}else{m+=a;for(let t=0;t<r;++t){let t=g[m];c&&(t=El.applyLogScale(t,s,i));const n=e.scalarToTextureCoordinate(t,d[0],p);f[h]=n.texCoordS,f[h+1]=n.texCoordT,h+=2,m+=o}}},e.mapScalarsToTexture=(n,r)=>{const o=t.lookupTable.getRange(),a=t.lookupTable.usingLogScale();a&&El.getLogRange(o,o);const i=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==r){t.lookupTable.setAlpha(r),t.colorTextureMap=null,t.lookupTable.build();let e=t.lookupTable.getNumberOfAvailableColors();e>4094&&(e=4094),e<64&&(e=64),e+=2;const n=(o[1]-o[0])/(e-2),s=new Float64Array(2*e);for(let t=0;t<e;++t)s[t]=o[0]+t*n-n/2,a&&(s[t]=10**s[t]);for(let t=0;t<e;++t)s[t+e]=NaN;t.colorTextureMap=fl.newInstance(),t.colorTextureMap.setExtent(0,e-1,0,1,0,0);const l=Es.newInstance({numberOfComponents:1,values:s});t.colorTextureMap.getPointData().setScalars(t.lookupTable.mapScalars(l,t.colorMode,0)),t.lookupTable.setAlpha(i)}if(!t.colorCoordinates||e.getMTime()>t.colorCoordinates.getMTime()||e.getInputData(0).getMTime()>t.colorCoordinates.getMTime()||t.lookupTable.getMTime()>t.colorCoordinates.getMTime()){t.colorCoordinates=null;const r=n.getNumberOfComponents(),i=n.getNumberOfTuples();t.colorCoordinates=Es.newInstance({numberOfComponents:2,values:new Float32Array(2*i)});let s=t.lookupTable.getVectorComponent();t.lookupTable.getVectorMode()===Yl.MAGNITUDE&&n.getNumberOfComponents()>1&&(s=-1),e.createColorTextureCoordinates(n,t.colorCoordinates,i,r,s,o,t.lookupTable.getRange(),t.colorTextureMap.getPointData().getScalars().getNumberOfTuples()/2-2,a)}},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=n=>{if(!t.interpolateScalarsBeforeMapping)return!1;if(t.lookupTable&&t.lookupTable.getIndexedLookup())return!1;const r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName),o=r.scalars;return!(!o||r.cellFlag||t.colorMode===$l.DEFAULT&&o.getDataType()===Zl.UNSIGNED_CHAR||t.colorMode===$l.DIRECT_SCALARS)},e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=Ql(&quot;AcquireInvertibleLookupTable&quot;),e.valueToColor=Ql(&quot;ValueToColor&quot;),e.colorToValue=Ql(&quot;ColorToValue&quot;),e.useInvertibleColorFor=Ql(&quot;UseInvertibleColorFor&quot;),e.clearInvertibleColor=Ql(&quot;ClearInvertibleColor&quot;),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(zl.ID_LOW24),o=e.getRawPixelBuffer(zl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Hl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Hl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===zl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(zl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===zl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t],n*=256,n+=r[t+1],n*=256,n+=r[t+2];const a=s[n];e.getPixelBuffer(zl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const ec={colorMapColors:null,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function tc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ec,n),Fs(e,t,n),jt.get(e,t,[&quot;colorCoordinates&quot;,&quot;colorMapColors&quot;,&quot;colorTextureMap&quot;,&quot;selectionWebGLIdsToVTKIds&quot;]),jt.setGet(e,t,[&quot;colorByArrayName&quot;,&quot;arrayAccessMode&quot;,&quot;colorMode&quot;,&quot;fieldDataTupleId&quot;,&quot;interpolateScalarsBeforeMapping&quot;,&quot;lookupTable&quot;,&quot;populateSelectionSettings&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;useLookupTableScalarRange&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),Ul.implementCoincidentTopologyMethods(e,t),Jl(e,t)}var nc={newInstance:jt.newInstance(tc,&quot;vtkMapper&quot;),extend:tc,...jl,...Kl,...hl};function rc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function oc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const ac={extractCellSizes:rc,getNumberOfCells:oc};function ic(e,t){t.classHierarchy.push(&quot;vtkCellArray&quot;);const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=oc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=rc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function sc(e){return{empty:!0,numberOfComponents:1,dataType:ys.UNSIGNED_INT,...e}}function lc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Es.extend(e,t,sc(n)),ic(e,t)}var cc={newInstance:jt.newInstance(lc,&quot;vtkCellArray&quot;),extend:lc,...ac};const{vtkErrorMacro:uc}=jt,dc=[1,-1,1,-1,1,-1];function pc(e,t){t.classHierarchy.push(&quot;vtkPoints&quot;),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return uc(`getBounds called on an array with components of\\n        ${e.getNumberOfComponents()}`),dc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const fc={empty:!0,numberOfComponents:3,dataType:ys.FLOAT,bounds:[1,-1,1,-1,1,-1]};function gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fc,n),Es.extend(e,t,n),pc(e,t)}var mc={newInstance:jt.newInstance(gc,&quot;vtkPoints&quot;),extend:gc};function hc(e,t){t.classHierarchy.push(&quot;vtkCell&quot;),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro(&quot;vtkCell.evaluatePosition is not implemented.&quot;)}}const vc={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function yc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vc,n),jt.obj(e,t),t.points||(t.points=mc.newInstance()),jt.get(e,t,[&quot;points&quot;,&quot;pointsIds&quot;]),hc(e,t)}var Tc={newInstance:jt.newInstance(yc,&quot;vtkCell&quot;),extend:yc};function bc(e,t){t.classHierarchy.push(&quot;vtkCellLinks&quot;),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA(&quot;vtkPolyData&quot;)){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Tc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Tc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const xc={array:null,maxId:0,extend:0};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),jt.obj(e,t),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,&quot;vtkCellLinks&quot;),extend:Cc};const Ac=0,Ic=1,wc=2,Pc=3,Oc=4,Rc=5,Mc=6,Dc=7,Ec=9,Vc=21,Lc=41,Bc=42,Nc=[&quot;vtkEmptyCell&quot;,&quot;vtkVertex&quot;,&quot;vtkPolyVertex&quot;,&quot;vtkLine&quot;,&quot;vtkPolyLine&quot;,&quot;vtkTriangle&quot;,&quot;vtkTriangleStrip&quot;,&quot;vtkPolygon&quot;,&quot;vtkPixel&quot;,&quot;vtkQuad&quot;,&quot;vtkTetra&quot;,&quot;vtkVoxel&quot;,&quot;vtkHexahedron&quot;,&quot;vtkWedge&quot;,&quot;vtkPyramid&quot;,&quot;vtkPentagonalPrism&quot;,&quot;vtkHexagonalPrism&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkQuadraticEdge&quot;,&quot;vtkQuadraticTriangle&quot;,&quot;vtkQuadraticQuad&quot;,&quot;vtkQuadraticTetra&quot;,&quot;vtkQuadraticHexahedron&quot;,&quot;vtkQuadraticWedge&quot;,&quot;vtkQuadraticPyramid&quot;,&quot;vtkBiQuadraticQuad&quot;,&quot;vtkTriQuadraticHexahedron&quot;,&quot;vtkQuadraticLinearQuad&quot;,&quot;vtkQuadraticLinearWedge&quot;,&quot;vtkBiQuadraticQuadraticWedge&quot;,&quot;vtkBiQuadraticQuadraticHexahedron&quot;,&quot;vtkBiQuadraticTriangle&quot;,&quot;vtkCubicLine&quot;,&quot;vtkQuadraticPolygon&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkConvexPointSet&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkParametricCurve&quot;,&quot;vtkParametricSurface&quot;,&quot;vtkParametricTriSurface&quot;,&quot;vtkParametricQuadSurface&quot;,&quot;vtkParametricTetraRegion&quot;,&quot;vtkParametricHexRegion&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkHigherOrderEdge&quot;,&quot;vtkHigherOrderTriangle&quot;,&quot;vtkHigherOrderQuad&quot;,&quot;vtkHigherOrderPolygon&quot;,&quot;vtkHigherOrderTetrahedron&quot;,&quot;vtkHigherOrderWedge&quot;,&quot;vtkHigherOrderPyramid&quot;,&quot;vtkHigherOrderHexahedron&quot;],_c={getClassNameFromTypeId:function(e){return e<Nc.length?Nc[e]:&quot;UnknownClass&quot;},getTypeIdFromClassName:function(e){return Nc.findIndex(e)},isLinear:function(e){return e<Vc||e===Lc||e===Bc},hasSubCells:function(e){return e===Mc||e===Oc||e===wc}};function Fc(e,t){t.classHierarchy.push(&quot;vtkCellTypes&quot;),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Ac},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const kc={size:0,maxId:-1,extend:1e3};function Gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kc,n),jt.obj(e,t),jt.get(e,t,[&quot;size&quot;,&quot;maxId&quot;,&quot;extend&quot;]),jt.getArray(e,t,[&quot;typeArray&quot;,&quot;locationArray&quot;]),Fc(e,t)}var Uc={newInstance:jt.newInstance(Gc,&quot;vtkCellTypes&quot;),extend:Gc,..._c},zc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Wc}=zc;function Hc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Hc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Wc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Wc.YES_INTERSECTION:Wc.NO_INTERSECTION}const Kc={distanceToLine:Hc,intersection:jc};function $c(e,t){t.classHierarchy.push(&quot;vtkLine&quot;),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Wc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Hc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Hc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Hc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Hc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const qc={orientations:null};function Xc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qc,n),Tc.extend(e,t,n),jt.setGet(e,t,[&quot;orientations&quot;]),$c(e,t)}var Yc={newInstance:jt.newInstance(Xc,&quot;vtkLine&quot;),extend:Xc,...Kc,...zc};function Zc(e,t){t.classHierarchy.push(&quot;vtkPointSet&quot;),t.points?t.points=We(t.points):t.points=mc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=mc.newInstance(),t.points.shallowCopy(e.getPoints())}}const Qc={};function Jc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qc,n),ol.extend(e,t,n),jt.setGet(e,t,[&quot;points&quot;]),Zc(e,t)}var eu={newInstance:jt.newInstance(Jc,&quot;vtkPointSet&quot;),extend:Jc};function tu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function nu(e,t,n,r){tu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const ru={computeNormalDirection:tu,computeNormal:nu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];nu(e,t,n,d),nu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,D=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ni.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ni.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(D=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[D],P[D]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function ou(e,t){t.classHierarchy.push(&quot;vtkTriangle&quot;),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(nu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ni.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=Yc.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),tu(l,c,u,d),ni.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=Yc.distanceToLine(e,c,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Yc.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Yc.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Yc.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const au={};function iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,au,n),Tc.extend(e,t,n),ou(e,t)}var su={newInstance:jt.newInstance(iu,&quot;vtkTriangle&quot;),extend:iu,...ru};const lu=[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;],{vtkWarningMacro:cu}=jt,uu={[Pc]:Yc,[Oc]:Yc,[Rc]:su};function du(e,t){t.classHierarchy.push(&quot;vtkPolyData&quot;),lu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\\w|[A-Z]|\\b\\w)/g,(e=>e.toUpperCase())).replace(/\\s+/g,&quot;&quot;)}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=cc.newInstance()})),e.getNumberOfCells=()=>lu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),lu.forEach((n=>{t[n]=cc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?wc:Ic,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Oc:Pc,1===t&&cu(&quot;Building VTK_LINE &quot;,n,&quot; with only one point, but VTK_LINE needs at least two points. Check the input.&quot;),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=Rc;break;case 4:l[n]=Ec;break;default:l[n]=Dc}t<3&&cu(&quot;Building VTK_TRIANGLE &quot;,n,&quot; with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.&quot;),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Mc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Uc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Sc.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Ic:case wc:o=t.verts;break;case Pc:case Oc:o=t.lines;break;case Rc:case Ec:case Dc:o=t.polys;break;case Mc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||uu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const pu={};function fu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pu,n),eu.extend(e,t,n),jt.get(e,t,[&quot;cells&quot;,&quot;links&quot;]),jt.setGet(e,t,[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;]),du(e,t)}var gu={newInstance:jt.newInstance(fu,&quot;vtkPolyData&quot;),extend:fu};function mu(e,t){t.classHierarchy.push(&quot;vtkTexture&quot;),e.imageLoaded=()=>{t.image.removeEventListener(&quot;load&quot;,e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener(&quot;load&quot;,e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext(&quot;2d&quot;).getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement(&quot;canvas&quot;);e.width=t.image.width,e.height=t.image.height;const n=e.getContext(&quot;2d&quot;);return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const hu={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hu,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,[&quot;canvas&quot;,&quot;image&quot;,&quot;jsImageData&quot;,&quot;imageLoaded&quot;,&quot;resizable&quot;]),jt.setGet(e,t,[&quot;repeat&quot;,&quot;edgeClamp&quot;,&quot;interpolate&quot;,&quot;mipLevel&quot;]),mu(e,t)}const yu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Tu={newInstance:jt.newInstance(vu,&quot;vtkTexture&quot;),extend:vu,...yu};const bu=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],xu=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Cu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Su=[0,1,0,1,0,1,0,1,2,2,2,2],Au=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Iu=new Float64Array(3),wu=new Float64Array(3),Pu=new Float64Array(3),Ou=new Float64Array(3),Ru=new Float64Array(3),Mu=new Float64Array(3),Du=new Float64Array(16);function Eu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Vu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],Vn(Pu,Iu,r),Pu[0]+=.1,Vn(wu,Pu,o),Pn(Ru,wu,Iu),Pu[0]-=.1,Pu[1]+=.1,Vn(wu,Pu,o),Pn(Mu,wu,Iu);for(let e=0;e<3;e++)Ru[e]/=.05*u[0],Mu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],a[0]<-.5?On(Pu,Ru,a[0]*i-l.width):a[0]>.5?On(Pu,Ru,a[0]*i):On(Pu,Ru,a[0]*i-l.width/2),wn(Iu,Iu,Pu),On(Pu,Mu,a[1]*i-l.height/2),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Pu,Ru,l.width),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Pu,Mu,l.height),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Pu,Ru,l.width),Pn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(Du,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Iu[0]=f[3*u],Iu[1]=f[3*u+1],Iu[2]=f[3*u+2],Vn(Pu,Iu,n),Iu[0]=f[3*u+3],Iu[1]=f[3*u+4],Iu[2]=f[3*u+5],Vn(Ou,Iu,n),Pn(Pu,Pu,Ou);const r=[Pu[0],Pu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Lu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,[&quot;renderable&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;tmActor&quot;,&quot;ticks&quot;]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],Vu(e,t)}),&quot;vtkCubeAxesActorHelper&quot;);function Bu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActor&quot;),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=ki.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Iu[s]=t.dataBounds[a]-.1*r*bu[a][s],Iu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Iu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Pu,Iu,e),Iu[s]=t.dataBounds[a],Vn(Ou,Iu,e),Pn(Pu,Ou,Pu),Mn(Pu,Pu),i=Pu[2]>o,t.camera.getParallelProjection()||(Mn(Ou,Ou),i=Dn(Ou,Pu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Au[t][0]].length+2*r[Au[t][1]].length,a+=r[Au[t][0]].length+r[Au[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Cu[e][0],l[3*u+2]=Cu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Au[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Au[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Su[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=xu[a][e];if(1===n[d]){const e=Su[d],n=3*Cu[d][0],p=3*Cu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Au[a][0]]=.5*(t.dataBounds[2*Au[a][0]]+t.dataBounds[2*Au[a][0]+1]),s[3*l+Au[a][1]]=.5*(t.dataBounds[2*Au[a][1]]+t.dataBounds[2*Au[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[xu[e][t]]++;const a=[],i=[];for(let e=0;e<3;e++){const n=go().domain([t.dataBounds[2*e],t.dataBounds[2*e+1]]);a[e]=n.ticks(5);const r=n.tickFormat(5);i[e]=a[e].map(r)}e.updatePolyData(r,n,a),e.updateTextData(r,n,a,i),(o||t.forceUpdate)&&e.updateTextureAtlas(i)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Eu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Eu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Eu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),ki.setBounds(t.bounds,t.gridActor.getBounds()),ki.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function Nu(e){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...ki.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:12,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},...e}}function _u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nu(n)),hs.extend(e,t,n),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=[&quot;X-Axis&quot;,&quot;Y-Axis&quot;,&quot;Z-Axis&quot;],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.tmTexture=Tu.newInstance(),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=nc.newInstance(),t.polyData=gu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=hs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=gu.newInstance(),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;boundsScaleFactor&quot;,&quot;faceVisibilityAngle&quot;,&quot;gridLines&quot;,&quot;tickLabelPixelOffset&quot;]),jt.setGetArray(e,t,[&quot;dataBounds&quot;],6),jt.setGetArray(e,t,[&quot;axisLabels&quot;],3),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;camera&quot;,&quot;tmTexture&quot;,&quot;textValues&quot;,&quot;textPolyData&quot;,&quot;tickCounts&quot;,&quot;gridActor&quot;]),Bu(e,t)}var Fu={newInstance:jt.newInstance(_u,&quot;vtkCubeAxesActor&quot;),extend:_u,newCubeAxesActorHelper:Lu};function ku(e,t){t.classHierarchy.push(&quot;vtkOpenGLCubeAxesActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gu={};const Uu=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=Fu.newCubeAxesActorHelper(),ku(e,t)}),&quot;vtkOpenGLCubeAxesActor&quot;);rn(&quot;vtkCubeAxesActor&quot;,Uu);const zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Wu={ObjectType:zu};const{ObjectType:Hu}=Wu;function ju(e,t){function n(e){switch(e){case Hu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Hu.TEXTURE_BUFFER:if(&quot;TEXTURE_BUFFER&quot;in t.context)return t.context.TEXTURE_BUFFER;case Hu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push(&quot;vtkOpenGLBufferObject&quot;);let r=null,o=null,a=!0,i=&quot;&quot;;e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i=&quot;Trying to upload array buffer to incompatible buffer.&quot;,!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const Ku={objectType:Hu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function $u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ku,n),jt.obj(e,t),jt.get(e,t,[&quot;_openGLRenderWindow&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),ju(e,t)}var qu={newInstance:jt.newInstance($u),extend:$u,...Wu};const{vtkErrorMacro:Xu}=jt;function Yu(e,t){t.classHierarchy.push(&quot;vtkOpenGLCellArrayBufferObject&quot;),e.setType(zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=qu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n){for(let r=0;r<e;++r)f(t[n+r])},linesToWireframe(e,t,n){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1])},polysToWireframe(e,t,n){if(e>2)for(let r=0;r<e;++r)f(t[n+r]),f(t[n+(r+1)%e])},stripsToWireframe(e,t,n){if(e>2){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1]);for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+2])}},polysToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+0]),f(t[n+r+1]),f(t[n+r+2])},stripsToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+1+r%2]),f(t[n+r+1+(r+1)%2])}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===rs.POINTS||&quot;verts&quot;===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===rs.WIREFRAME||&quot;lines&quot;===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,D=0,E=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];D+=n*n;const r=.5*(t[1]+t[0]);E+=r*r}const V=D>0&&(Math.abs(E)/D>1e6||Math.abs(Math.log10(D))>3||0===D&&E>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;)C(A[e],A,e+1),e+=A[e]+1,T++;return t.elementCount=w,e.upload(O,zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,Ui(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):Xu(&quot;Wrong type for coordScale, expected vec3 or null&quot;):Xu(&quot;Wrong type for coordShift, expected vec3 or null&quot;)}}const Zu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function Qu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zu,n),qu.extend(e,t,n),jt.setGet(e,t,[&quot;colorBO&quot;,&quot;elementCount&quot;,&quot;stride&quot;,&quot;colorBOStride&quot;,&quot;vertexOffset&quot;,&quot;normalOffset&quot;,&quot;tCoordOffset&quot;,&quot;tCoordComponents&quot;,&quot;colorOffset&quot;,&quot;colorComponents&quot;,&quot;customData&quot;]),jt.get(e,t,[&quot;coordShift&quot;,&quot;coordScale&quot;,&quot;coordShiftAndScaleEnabled&quot;,&quot;inverseShiftAndScaleMatrix&quot;]),Yu(e,t)}var Ju={newInstance:jt.newInstance(Qu),extend:Qu};const{vtkErrorMacro:ed}=jt;function td(e,t){t.classHierarchy.push(&quot;vtkShader&quot;),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||&quot;Unknown&quot;===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e=&quot;Fragment&quot;===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return ed(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const nd={shaderType:&quot;Unknown&quot;,source:&quot;&quot;,error:&quot;&quot;,handle:0,dirty:!1,context:null};function rd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nd,n),jt.obj(e,t),jt.setGet(e,t,[&quot;shaderType&quot;,&quot;source&quot;,&quot;error&quot;,&quot;handle&quot;,&quot;context&quot;]),td(e,t)}var od={newInstance:jt.newInstance(rd,&quot;vtkShader&quot;),extend:rd};const{vtkErrorMacro:ad}=jt;function id(e,t){t.classHierarchy.push(&quot;vtkShaderProgram&quot;),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(ad(`Links failed: ${t.error}`),0):(ad(t.error),0):(ad(t.fragmentShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.fragmentShader.getError()),0):(ad(t.vertexShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.vertexShader.getError()),0),e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error=&quot;Program has not been initialized, and/or does not have shaders.&quot;,!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return ad(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error=&quot;Shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===n.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error=&quot;Could not create shader program.&quot;,!1;t.handle=e,t.linked=!1}return&quot;Vertex&quot;===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),&quot;Fragment&quot;===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error=&quot;shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===e.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;switch(0===t.handle&&(t.error=&quot;This shader program has not been initialized yet.&quot;),e.getShaderType()){case&quot;Vertex&quot;:return t.vertexShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case&quot;Fragment&quot;:return t.fragmentShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const sd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:&quot;&quot;,handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=od.newInstance(),t.vertexShader.setShaderType(&quot;Vertex&quot;),t.fragmentShader=od.newInstance(),t.fragmentShader.setShaderType(&quot;Fragment&quot;),t.geometryShader=od.newInstance(),t.geometryShader.setShaderType(&quot;Geometry&quot;),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;error&quot;,&quot;handle&quot;,&quot;compiled&quot;,&quot;bound&quot;,&quot;md5Hash&quot;,&quot;vertexShader&quot;,&quot;fragmentShader&quot;,&quot;geometryShader&quot;,&quot;linked&quot;]),id(e,t)}var cd={newInstance:jt.newInstance(ld,&quot;vtkShaderProgram&quot;),extend:ld,substitute:function(e,t,n,r){const o=&quot;string&quot;==typeof n?n:n.join(&quot;\\n&quot;),a=!1===r?t:new RegExp(t,&quot;g&quot;),i=e.replace(a,o);return{replace:i!==o,result:i}}};function ud(e,t){t.classHierarchy.push(&quot;vtkOpenGLVertexArrayObject&quot;),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;)),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension(&quot;OES_vertex_array_object&quot;),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const dd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,[&quot;supported&quot;]),jt.setGet(e,t,[&quot;forceEmulation&quot;]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,&quot;vtkOpenGLVertexArrayObject&quot;),extend:pd};const gd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function md(e,t){t.classHierarchy.push(&quot;vtkOpenGLHelper&quot;),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===rs.POINTS||n===gd.Points?t.context.POINTS:e===rs.WIREFRAME||n===gd.Lines||n===gd.TrisEdges||n===gd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f(&quot;viewportSize&quot;,o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf(&quot;lineWidthStepSize&quot;,t/Math.ceil(t)),e.getProgram().setUniformf(&quot;halfLineWidth&quot;,n)}t.primitiveType===gd.Points||r.getProperty().getRepresentation()===rs.POINTS?e.getProgram().setUniformf(&quot;pointSize&quot;,r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf(&quot;pointSize&quot;,e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform float pointSize;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot;  gl_PointSize = pointSize;&quot;],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform vec2 viewportSize;&quot;,&quot;uniform float lineWidthStepSize;&quot;,&quot;uniform float halfLineWidth;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot; if (halfLineWidth > 0.0)&quot;,&quot;   {&quot;,&quot;   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;&quot;,&quot;   vec4 tmpPos = gl_Position;&quot;,&quot;   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;&quot;,&quot;   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];&quot;,&quot;   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];&quot;,&quot;   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);&quot;,&quot;   }&quot;]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===gd.Points?2:t.primitiveType===gd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const hd={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,[&quot;program&quot;,&quot;shaderSourceTime&quot;,&quot;VAO&quot;,&quot;attributeUpdateTime&quot;,&quot;CABO&quot;,&quot;primitiveType&quot;,&quot;pointPicking&quot;]),t.program=cd.newInstance(),t.VAO=fd.newInstance(),t.CABO=Ju.newInstance(),md(e,t)}var yd={newInstance:jt.newInstance(vd),extend:vd,primTypes:gd};const Td={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},bd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var xd={Wrap:Td,Filter:bd};const Cd=new Float32Array(1),Sd=new Int32Array(Cd.buffer);var Ad={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Cd[0]=e;const t=Sd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};const{Wrap:Id,Filter:wd}=xd,{VtkDataTypes:Pd}=Es,{vtkDebugMacro:Od,vtkErrorMacro:Rd,vtkWarningMacro:Md}=Kt,{toHalf:Dd}=Ad;function Ed(e,t){function n(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==Pd.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==Pd.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Dd(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o}function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension(&quot;OES_texture_half_float&quot;),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Ad.toHalf(Ad.fromHalf(e[u][l+s+t])*h*(1-v)+Ad.fromHalf(e[u][l+p+t])*h*v+Ad.fromHalf(e[u][c+s+t])*m*(1-v)+Ad.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&t.oglNorm16Ext)||e!==Pd.UNSIGNED_SHORT&&e!==Pd.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}const s=i&&(function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a);t.useHalfFloat=s}(a,c.offset,c.scale,r),t.useHalfFloat||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}t.classHierarchy.push(&quot;vtkOpenGLTexture&quot;),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent()),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(wd.LINEAR),e.setMagnificationFilter(wd.LINEAR)):(e.setMinificationFilter(wd.NEAREST),e.setMagnificationFilter(wd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Id.REPEAT),e.setWrapS(Id.REPEAT),e.setWrapT(Id.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()},e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Md(&quot;impossible case&quot;),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Od(`Unable to find suitable internal format for T=${n} NC= ${r}`),t.internalFormat),e.getDefaultInternalFormat=(e,n)=>{let r=0;return r=t._openGLRenderWindow.getDefaultTextureInternalFormat(e,n,t.oglNorm16Ext,t.useHalfFloat),r||(r||(Od(&quot;Unsupported internal texture type!&quot;),Od(`Unable to find suitable internal format for T=${e} NC= ${n}`)),r)},e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=e=>{if(t._openGLRenderWindow.getWebgl2())switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.SHORT:return t.context.SHORT;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case t.useHalfFloat&&Pd.SHORT:case t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case Pd.FLOAT:case Pd.VOID:default:return t.context.FLOAT}switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case Pd.FLOAT:case Pd.VOID:default:if(t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))return t.context.FLOAT;{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);if(e&&t.context.getExtension(&quot;OES_texture_half_float_linear&quot;))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case wd.NEAREST:return t.context.NEAREST;case wd.LINEAR:return t.context.LINEAR;case wd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case wd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case wd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case wd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Id.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Id.REPEAT:return t.context.REPEAT;case Id.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=n(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(n(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createDepthFromRaw=(n,r,a,i)=>(e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===Pd.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=r,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0):(Rd(&quot;Failed to determine texture parameters.&quot;),!1)),e.create2DFromImage=n=>{if(e.getOpenGLDataType(Pd.UNSIGNED_CHAR),e.getInternalFormat(Pd.UNSIGNED_CHAR,4),e.getFormat(Pd.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const r=!(t._openGLRenderWindow.getWebgl2()||Fo(n.width)&&Fo(n.height)),a=document.createElement(&quot;canvas&quot;);a.width=r?_o(n.width):n.width,a.height=r?_o(n.height):n.height,t.width=a.width,t.height=a.height;const i=a.getContext(&quot;2d&quot;);i.translate(0,a.height),i.scale(1,-1),i.drawImage(n,0,0,n.width,n.height,0,0,a.width,a.height);const s=a;return o(Pd.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Pd.UNSIGNED_CHAR,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Es.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.create3DFromRaw=(a,i,s,l,c,u)=>{if(e.getOpenGLDataType(c),e.getInternalFormat(c,l),e.getFormat(c,l),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=r(n(c,[u],!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(c)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=d[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,d[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,d[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(c,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Es.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=n*r*i,g=[],m=[];for(let e=0;e<c;++e)g[e]=0,m[e]=1;t.volumeInfo={scale:m,offset:g,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i};const h=structuredClone(p);if(t._openGLRenderWindow.getWebgl2()){if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=32767;return e.create3DFromRaw(n,r,i,c,u,d)}if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.UNSIGNED_SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=65535;return e.create3DFromRaw(n,r,i,c,u,d)}if(u===Pd.FLOAT||t.useHalfFloat&&(u===Pd.SHORT||u===Pd.UNSIGNED_SHORT))return e.create3DFromRaw(n,r,i,c,u,d);if(u===Pd.UNSIGNED_CHAR){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=255;return e.create3DFromRaw(n,r,i,c,u,d)}const o=new Float32Array(f*c);t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;let a=0;const s=h.scale.map((e=>1/e));for(let e=0;e<f;e++)for(let e=0;e<c;e++)o[a]=(d[a]-h.offset[e])*s[e],a++;return e.create3DFromRaw(n,r,i,c,Pd.FLOAT,o)}let v=(e,t,n,r,o)=>{e[t]=n},y=Pd.UNSIGNED_CHAR;if(u===Pd.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)?(y=Pd.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=Pd.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===Pd.FLOAT||c>=3)&&(T=4096);let b=1,x=1;f>T*T&&(b=Math.ceil(Math.sqrt(f/(T*T))),x=b);let C=Math.sqrt(f)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===Pd.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1}const Vd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Id.CLAMP_TO_EDGE,wrapT:Id.CLAMP_TO_EDGE,wrapR:Id.CLAMP_TO_EDGE,minificationFilter:wd.NEAREST,magnificationFilter:wd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,useHalfFloat:!0,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0};function Ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,[&quot;format&quot;,&quot;openGLDataType&quot;]),At(e,t,[&quot;keyMatrixTime&quot;,&quot;minificationFilter&quot;,&quot;magnificationFilter&quot;,&quot;wrapS&quot;,&quot;wrapT&quot;,&quot;wrapR&quot;,&quot;generateMipmap&quot;,&quot;oglNorm16Ext&quot;]),bt(e,t,[&quot;width&quot;,&quot;height&quot;,&quot;volumeInfo&quot;,&quot;components&quot;,&quot;handle&quot;,&quot;target&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),Ed(e,t)}const Bd=Et(Ld,&quot;vtkOpenGLTexture&quot;);var Nd={newInstance:Bd,extend:Ld,...xd};rn(&quot;vtkTexture&quot;,Bd);var _d=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexMC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\nvoid main()\\n{\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::PrimID::Impl\\n\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,Fd=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the polydata mappers fragment shader\\n\\nuniform int PrimitiveIDOffset;\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// optional color passed in from the vertex shader, vertexColor\\n//VTK::Color::Dec\\n\\n// optional surface normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// Depth Peeling Support\\n//VTK::DepthPeeling::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// label outline \\n//VTK::LabelOutline::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n//VTK::LabelOutlineHelperFunction\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::Color::Impl\\n\\n  // Generate the normal if we are not passed in one\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Light::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,kd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::Coincident::Dec&quot;,[&quot;uniform float cfactor;&quot;,&quot;uniform float coffset;&quot;]).result,t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;&quot;).result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;&quot;).result),n.Fragment=e}}},Gd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=cd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&&quot;&quot;!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&&quot;&quot;!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Ud}=ol,{primTypes:zd}=yd,{Representation:Wd,Shading:Hd}=ds,{ScalarMode:jd}=nc,{Filter:Kd,Wrap:$d}=Nd,{vtkErrorMacro:qd}=Kt,Xd={type:&quot;StartEvent&quot;},Yd={type:&quot;EndEvent&quot;},{CoordinateSystem:Zd}=Zi;function Qd(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType(&quot;vtkOpenGLActor&quot;),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=zd.Start;e<zd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let l=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;,&quot;uniform vec3 ambientColorUniform;&quot;,&quot;uniform vec3 diffuseColorUniform;&quot;];s&&(l=l.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let c=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];s&&(c=c.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),c=c.concat([&quot;  ambientColor = ambientColorUniform;&quot;,&quot;  diffuseColor = diffuseColorUniform;&quot;,&quot;  opacity = opacityUniform;&quot;]),s&&(c=c.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 scalarColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput =  scalarColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?t.renderable.getInterpolateScalarsBeforeMapping()&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);&quot;,&quot;  diffuseColor = texColor.rgb;&quot;,&quot;  ambientColor = texColor.rgb;&quot;,&quot;  opacity = opacity*texColor.a;&quot;])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat([&quot;uniform float opacityUniformBF; // the fragment opacity&quot;,&quot;uniform float ambientIntensityBF; // the material ambient&quot;,&quot;uniform float diffuseIntensityBF; // the material diffuse&quot;,&quot;uniform vec3 ambientColorUniformBF; // ambient material color&quot;,&quot;uniform vec3 diffuseColorUniformBF; // diffuse material color&quot;]),s?(l=l.concat([&quot;uniform float specularIntensityBF; // the material specular intensity&quot;,&quot;uniform vec3 specularColorUniformBF; // intensity weighted color&quot;,&quot;uniform float specularPowerUniformBF;&quot;]),c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  specularColor = specularIntensityBF * specularColorUniformBF;&quot;,&quot;  specularPower = specularPowerUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])):c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat([&quot;uniform samplerBuffer texture1;&quot;])),i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c).result):i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),i=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);let s=[];switch(a){case 0:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 1:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  float df = max(0.0, normalVCVSOutput.z);&quot;,&quot;  float sf = pow(df, specularPower);&quot;,&quot;  vec3 diffuseL = df * diffuseColor;&quot;,&quot;  vec3 specularL = sf * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,&quot;    {&quot;,`    float sf = sign(df)*pow(max(1e-5,\\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\\n                                                  normalize(-vertexVC.xyz))),\\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  vec3 vertLightDirectionVC;&quot;,&quot;  float attenuation;&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([&quot;  attenuation = 1.0;&quot;,`  if (lightPositional${e} == 0)`,&quot;    {&quot;,`      vertLightDirectionVC = lightDirectionVC${e};`,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,&quot;    float distanceVC = length(vertLightDirectionVC);&quot;,&quot;    vertLightDirectionVC = normalize(vertLightDirectionVC);&quot;,&quot;    attenuation = 1.0 /&quot;,`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,&quot;    // per OpenGL standard cone angle is 90 or less for a spot light&quot;,`    if (lightConeAngle${e} <= 90.0)`,&quot;      {&quot;,`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,&quot;      // if inside the cone&quot;,`      if (coneDot >= cos(radians(lightConeAngle${e})))`,&quot;        {&quot;,`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,&quot;        }&quot;,&quot;      else&quot;,&quot;        {&quot;,&quot;        attenuation = 0.0;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));&quot;,`    diffuseL += ((df) * lightColor${e});`,&quot;    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)&quot;,&quot;      {&quot;,`      float sf = sign(df)*attenuation*pow(max(1e-5,\\n                                                           dot(reflect(lightDirectionVC${e},\\n                                                                       normalVCVSOutput),\\n                                                               normalize(-vertexVC.xyz))),\\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;default:qd(&quot;bad light complexity&quot;)}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * normalMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Dec&quot;,[&quot;in vec3 normalVCVSOutput[];&quot;,&quot;out vec3 normalVCGSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCGSOutput = normalVCVSOutput[i];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;varying vec3 normalVCVSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalVCVSOutput);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.haveCellNormals?(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform mat3 normalMatrix;&quot;,&quot;uniform samplerBuffer textureN;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalMatrix *&quot;,&quot;    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput;&quot;,&quot;  if (abs(fdx.x) > 0.0)&quot;,&quot;    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }&quot;,&quot;  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}&quot;]).result):(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;&quot;]).result,a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;  fdx = normalize(fdx);&quot;,&quot;  fdy = normalize(fdy);&quot;,&quot;  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));&quot;,&quot;  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;,&quot;  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(o=cd.substitute(o,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCVSOutput = MCVCMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;in vec4 vertexVCVSOutput[];&quot;,&quot;out vec4 vertexVCGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCGSOutput = vertexVCVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;&quot;]).result):(o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,a&&a.length>=1)switch(i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}}else switch(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec3 tcoordVCVSOutput[];&quot;,&quot;out vec3 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec3 tcoordVCVSOutput;&quot;,&quot;uniform samplerCube texture1;&quot;]).result,i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`varying float clipDistancesVSOutput[${e}];`]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()||o.getEdgeVisibility()&&o.getRepresentation()===Wd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===zd.Points||o.getRepresentation()===Wd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===zd.Lines||o.getRepresentation()===Wd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==zd.Tris&&e!==zd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==zd.TrisEdges&&e!==zd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform int picking;&quot;,&quot;//VTK::Picking::Dec&quot;]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==zl.ID_LOW24&&t.lastSelectionState!==zl.ID_HIGH24||(a=cd.substitute(a,&quot;//VTK::Picking::Dec&quot;,[&quot;flat out int vertexIDVSOutput;\\n&quot;,&quot;uniform int VertexIDOffset;\\n&quot;]).result,a=cd.substitute(a,&quot;//VTK::Picking::Impl&quot;,&quot;  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;flat in int vertexIDVSOutput;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,[&quot;  int idx = vertexIDVSOutput;&quot;,&quot;//VTK::Picking::Impl&quot;]).result),t.lastSelectionState){case zl.ID_LOW24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);&quot;).result;break;case zl.ID_HIGH24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);&quot;).result;break;default:o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;uniform vec3 mapperIndex;&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===Hd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),h=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&n.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),n.getProgram().isUniformUsed(&quot;VertexIDOffset&quot;)&&n.getProgram().setUniformi(&quot;VertexIDOffset&quot;,t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;normalMC&quot;)&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;normalMC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting normalMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;normalMC&quot;),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||qd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||qd(&quot;Error setting tcoordMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),n.getProgram().isAttributeUsed(&quot;scalarColor&quot;)&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),&quot;scalarColor&quot;,n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||qd(&quot;Error setting scalarColor in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;scalarColor&quot;),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,r)}t.internalColorTexture&&n.getProgram().isUniformUsed(&quot;texture1&quot;)&&n.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi(&quot;picking&quot;,i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===Zd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4)}else s.setUniformMatrix(&quot;MCPCMatrix&quot;,n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed(&quot;MCVCMatrix&quot;)&&s.setUniformMatrix(&quot;MCVCMatrix&quot;,n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed(&quot;normalMatrix&quot;)&&s.setUniformMatrix3x3(&quot;normalMatrix&quot;,n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf(&quot;opacityUniform&quot;,i),o.setUniform3fArray(&quot;ambientColorUniform&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniform&quot;,l),o.setUniformf(&quot;ambient&quot;,c),o.setUniformf(&quot;diffuse&quot;,u);const f=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray(&quot;specularColorUniform&quot;,g),o.setUniformf(&quot;specularPowerUniform&quot;,p),o.setUniformf(&quot;specular&quot;,d),o.isUniformUsed(&quot;ambientIntensityBF&quot;)){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf(&quot;ambientIntensityBF&quot;,c),o.setUniformf(&quot;diffuseIntensityBF&quot;,u),o.setUniformf(&quot;opacityUniformBF&quot;,i),o.setUniform3fArray(&quot;ambientColorUniformBF&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniformBF&quot;,l),f<1)return;o.setUniformf(&quot;specularIntensityBF&quot;,d),o.setUniform3fArray(&quot;specularColorUniformBF&quot;,g),o.setUniformf(&quot;specularPowerUniformBF&quot;,p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():zl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Wd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===zl.ID_LOW24||t.lastSelectionState===zl.ID_HIGH24);for(let i=zd.Start;i<zd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===zd.TrisEdges||i===zd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(Xd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Yd),!t.currentInput)return void qd(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(null===o)return;t.renderable.mapScalars(o,1);const a=t.renderable.getColorMapColors();t.haveCellScalars=!1;const i=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(i!==jd.USE_CELL_DATA&&i!==jd.USE_CELL_FIELD_DATA&&i!==jd.USE_FIELD_DATA&&o.getPointData().getScalars()||i===jd.USE_POINT_FIELD_DATA||!a||(t.haveCellScalars=!0));let s=r.getProperty().getInterpolation()!==Hd.FLAT?o.getPointData().getNormals():null;null===s&&o.getCellData().getNormals()&&(t.haveCellNormals=!0,s=o.getCellData().getNormals());const l=r.getProperty().getRepresentation();let c=o.getPointData().getTCoords();if(t.openGLActor.getActiveTextures()||(c=null),t.renderable.getColorCoordinates()){c=t.renderable.getColorCoordinates(),t.internalColorTexture||(t.internalColorTexture=Nd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Kd.NEAREST),e.setMagnificationFilter(Kd.NEAREST),e.setWrapS($d.CLAMP_TO_EDGE),e.setWrapT($d.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${o.getMTime()}A${l}B${o.getMTime()}C${s?s.getMTime():1}D${a?a.getMTime():1}E${r.getProperty().getEdgeVisibility()}F${c?c.getMTime():1}`;if(t.VBOBuildString!==u){const n={points:o.getPoints(),normals:s,tcoords:c,colors:a,cellOffset:0,vertexOffset:0,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>o.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const i=[{inRep:&quot;verts&quot;,cells:o.getVerts()},{inRep:&quot;lines&quot;,cells:o.getLines()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()}],d=r.getProperty().getEdgeVisibility()&&l===Wd.SURFACE;for(let e=zd.Start;e<zd.End;e++)e!==zd.TrisEdges&&e!==zd.TriStripsEdges?(n.cellOffset+=t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,l,n,t.selectionWebGLIdsToVTKIds),n.vertexOffset+=t.primitives[e].getCABO().getElementCount()):d?t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,Wd.WIREFRAME,{...n,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[e].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&(t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),e.updateMaximumPointCellIds()),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Jd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:zl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function ep(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jd,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=zd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=zd.Start;e<zd.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),Qd(e,t)}const tp=Et(ep,&quot;vtkOpenGLPolyDataMapper&quot;);var np={newInstance:tp,extend:ep};rn(&quot;vtkMapper&quot;,tp);const{ColorMode:rp,ScalarMode:op,GetArray:ap}=hl;function ip(e,t){t.classHierarchy.push(&quot;vtkMapper2D&quot;),e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString(rp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(op,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===op.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===op.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===op.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===op.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_FIELD_DATA){const t=e.getFieldData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const sp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function lp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sp,n),Bs(e,t,n),jt.get(e,t,[&quot;colorMapColors&quot;]),jt.setGet(e,t,[&quot;arrayAccessMode&quot;,&quot;colorByArrayName&quot;,&quot;colorMode&quot;,&quot;lookupTable&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;transformCoordinate&quot;,&quot;useLookupTableScalarRange&quot;,&quot;viewSpecificProperties&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),ip(e,t)}var cp={newInstance:jt.newInstance(lp,&quot;vtkMapper2D&quot;),extend:lp};const up=1,{primTypes:dp}=yd,{ScalarMode:pp}=cp,{vtkErrorMacro:fp}=Kt,gp={type:&quot;StartEvent&quot;},mp={type:&quot;EndEvent&quot;};function hp(e,t){t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper2D&quot;),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType(&quot;vtkOpenGLActor2D&quot;),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model Coordinates\\n// WC - WC world coordinates\\n// VC - View Coordinates\\n// DC - Display Coordinates\\n\\nin vec4 vertexWC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nuniform mat4 WCVCMatrix;  // World to view matrix\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  gl_Position = WCVCMatrix*vertexWC;\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::PositionVC::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nuniform int PrimitiveIDOffset;\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Scalar coloring\\n//VTK::Color::Dec\\n\\n// Depth Peeling\\n//VTK::DepthPeeling::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Color::Impl\\n  //VTK::TCoord::Impl\\n\\n  //VTK::DepthPeeling::Impl\\n  //VTK::Picking::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=dp.Start;e<dp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(gp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(mp),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):fp(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==pp.USE_CELL_DATA&&a!==pp.USE_CELL_FIELD_DATA&&a!==pp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===pp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=mc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[dp.Points].getCABO().createVBO(r.getVerts(),&quot;verts&quot;,i,a),a.cellOffset+=t.primitives[dp.Lines].getCABO().createVBO(r.getLines(),&quot;lines&quot;,i,a),a.cellOffset+=t.primitives[dp.Tris].getCABO().createVBO(r.getPolys(),&quot;polys&quot;,i,a),a.cellOffset+=t.primitives[dp.TriStrips].getCABO().createVBO(r.getStrips(),&quot;strips&quot;,i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=dp.Start;a<dp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform samplerBuffer texture1;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);&quot;]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 diffuseColor;&quot;,&quot;out vec4 fcolorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorVSOutput = diffuseColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput[];\\n&quot;,&quot;out vec4 fcolorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorGSOutput = fcolorVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = fcolorVSOutput;&quot;]).result):(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform vec4 diffuseColor;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = diffuseColor;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordMC;&quot;,&quot;out float tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput[];\\n&quot;,&quot;out float tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,[&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));&quot;]).result):2===a&&(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordMC;&quot;,&quot;out vec2 tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];\\n&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);&quot;]).result),t.haveCellScalars&&(r=cd.substitute(r,&quot;//VTK::PrimID::Impl&quot;,[&quot;gl_PrimitiveID = gl_PrimitiveIDIn;&quot;]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=cd.substitute(r,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&e.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),e.getProgram().isAttributeUsed(&quot;vertexWC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;vertexWC&quot;,e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||fp(&quot;Error setting vertexWC in shader VAO.&quot;)),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||fp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;tcoordMC&quot;,e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||fp(&quot;Error setting tcoordMC in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),t.internalColorTexture&&e.getProgram().isUniformUsed(&quot;texture1&quot;)&&e.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi(&quot;picking&quot;,a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f(&quot;diffuseColor&quot;,i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===up?-1:1,x[15]=1,m(x,x),a.setUniformMatrix(&quot;WCVCMatrix&quot;,(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const vp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const yp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=dp,t.tmpMat4=g(new Float64Array(16));for(let e=dp.Start;e<dp.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),hp(e,t)}),&quot;vtkOpenGLPolyDataMapper2D&quot;);rn(&quot;vtkMapper2D&quot;,yp);const{VectorMode:Tp}=Pl;function bp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function xp(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Cp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Sp(e,t){t.classHierarchy.push(&quot;vtkScalarBarActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;;const n={},r=new Map;let o=0,a=1;bp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,bp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),&quot;NaN&quot;,&quot;Below&quot;,&quot;Above&quot;];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{bp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s(&quot;NaN&quot;,[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s(&quot;Below&quot;,[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s(&quot;ticks&quot;,t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s(&quot;Above&quot;,[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p=&quot;vertical&quot;===a?[1,0]:[0,1];&quot;vertical&quot;===a?(d[0]=l.width,d[1]=-l.height,&quot;middle&quot;===o[0]?n[1]-=l.width/2:&quot;right&quot;===o[0]&&(n[1]-=l.width),&quot;middle&quot;===o[1]?n[0]+=l.height/2:&quot;top&quot;===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,&quot;middle&quot;===o[0]?n[0]-=l.width/2:&quot;right&quot;===o[0]&&(n[0]-=l.width),&quot;middle&quot;===o[1]?n[1]-=l.height/2:&quot;top&quot;===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?[&quot;right&quot;,&quot;middle&quot;]:[&quot;middle&quot;,&quot;bottom&quot;];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;top&quot;],&quot;vertical&quot;,[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];&quot;ticks&quot;===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,&quot;horizontal&quot;,g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,&quot;horizontal&quot;,g,c)}const b=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Tp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Es.newInstance({numberOfComponents:i,values:c,name:&quot;Scalars&quot;});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Ap=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;tickLabelPixelOffset&quot;,&quot;renderable&quot;,&quot;topTitle&quot;,&quot;ticks&quot;,&quot;tickStrings&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;lastTickBounds&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;barActor&quot;,&quot;tmActor&quot;]),jt.getArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.barMapper=nc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=gu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=hs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Tu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Sp(e,t)}),&quot;vtkScalarBarActorHelper&quot;);function Ip(e,t){t.classHierarchy.push(&quot;vtkScalarBarActor&quot;),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(xp(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Cp())}}function wp(e){return{automated:!0,autoLayout:null,axisLabel:&quot;Scalar Value&quot;,barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:14,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function Pp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wp(n)),t.autoLayout||(t.autoLayout=xp(0,t)),t.generateTicks||(t.generateTicks=Cp()),hs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,[&quot;automated&quot;,&quot;autoLayout&quot;,&quot;axisTitlePixelOffset&quot;,&quot;axisLabel&quot;,&quot;scalarsToColors&quot;,&quot;tickLabelPixelOffset&quot;,&quot;generateTicks&quot;,&quot;drawNanAnnotation&quot;,&quot;drawBelowRangeSwatch&quot;,&quot;drawAboveRangeSwatch&quot;]),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;]),jt.getArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;],2),Ip(e,t)}var Op={newInstance:jt.newInstance(Pp,&quot;vtkScalarBarActor&quot;),extend:Pp,newScalarBarActorHelper:Ap};function Rp(e,t){t.classHierarchy.push(&quot;vtkOpenGLScalarBarActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Mp={};const Dp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Op.newScalarBarActorHelper(),Rp(e,t)}),&quot;vtkOpenGLScalarBarActor&quot;);rn(&quot;vtkScalarBarActor&quot;,Dp);const{vtkErrorMacro:Ep}=Kt;function Vp(e,t){t.classHierarchy.push(&quot;vtkOpenGLSkybox&quot;),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi(&quot;sbtexture&quot;,n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix(&quot;IMCPCMatrix&quot;,a),&quot;box&quot;===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f(&quot;camPos&quot;,e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Es.newInstance({numberOfComponents:3,values:e});n.setName(&quot;points&quot;);const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),&quot;box&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec3 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = wpos.xyz/wpos.w;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec3 TexCoords;\\n             uniform samplerCube sbtexture;\\n             uniform vec3 camPos;\\n             void main () {\\n               // skybox looks from inside out\\n               // which means we have to adjust\\n               // our tcoords. Otherwise text would\\n               // be flipped\\n               vec3 tc = normalize(TexCoords - camPos);\\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\\n               {\\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\\n               }\\n               else\\n               {\\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\\n               }\\n               gl_FragData[0] = textureCube(sbtexture, tc);\\n             }&quot;,&quot;&quot;)),&quot;background&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec2 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec2 TexCoords;\\n             uniform sampler2D sbtexture;\\n             void main () {\\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\\n             }&quot;,&quot;&quot;)),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),&quot;vertexMC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Ep(&quot;Error setting vertexMC in shader VAO.&quot;));const e=t.renderable.getTextures();e.length||Ep(&quot;vtkSkybox requires a texture map&quot;),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Lp={context:null};const Bp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lp,n),Zt.extend(e,t,n),t.openGLTexture=Nd.newInstance(),t.tris=yd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Vp(e,t)}));rn(&quot;vtkSkybox&quot;,Bp);const{FieldAssociations:Np}=ol;function _p(e,t){t.classHierarchy.push(&quot;vtkHardwareSelector&quot;),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const Fp={fieldAssociation:Np.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function kp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fp,n),jt.obj(e,t),jt.setGet(e,t,[&quot;fieldAssociation&quot;,&quot;captureZValues&quot;]),_p(e,t)}var Gp={newInstance:jt.newInstance(kp,&quot;vtkHardwareSelector&quot;),extend:kp};function Up(e,t){t.classHierarchy.push(&quot;vtkFramebuffer&quot;),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling saveCurrentBindings&quot;);const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling restorePreviousBindings&quot;);const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et(&quot;you must set the OpenGLRenderWindow before calling create&quot;)},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et(&quot;you must set the OpenGLRenderWindow before calling setColorBuffer&quot;);let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et(&quot;you must set the OpenGLRenderWindow before calling removeColorBuffer&quot;);let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et(&quot;Attaching depth buffer textures to fbo requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling setDepthBuffer&quot;)},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et(&quot;Attaching depth buffer textures to framebuffers requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling removeDepthBuffer&quot;)},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>{const e=[0,0];return null!==t.glFramebuffer&&(e[0]=t.glFramebuffer.width,e[1]=t.glFramebuffer.height),e},e.populateFramebuffer=()=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling populateFrameBuffer&quot;);e.bind();const n=t.context,r=Nd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(bd.LINEAR),r.setMagnificationFilter(bd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,ys.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const zp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Wp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zp,n),yt(e,t),t.colorBuffers&&et(&quot;you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.&quot;),t.colorBuffers=[],It(e,t,[&quot;colorBuffers&quot;]),Up(e,t)}var Hp={newInstance:Et(Wp,&quot;vtkFramebuffer&quot;),extend:Wp};function jp(e,t){t.classHierarchy.push(&quot;vtkSelectionNode&quot;),e.getBounds=()=>t.points.getBounds()}const Kp={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function $p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kp,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,[&quot;contentType&quot;,&quot;fieldType&quot;,&quot;properties&quot;,&quot;selectionList&quot;]),jp(e,t)}var qp={newInstance:jt.newInstance($p,&quot;vtkSelectionNode&quot;),extend:$p,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Xp}=Wl,{SelectionContent:Yp,SelectionField:Zp}=qp,{FieldAssociations:Qp}=ol,{vtkErrorMacro:Jp}=jt;function ef(e){return`${e.propID} ${e.compositeID}`}function tf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function nf(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function rf(e,t){let n=t;return n<<=24,n|=e,n}function of(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=nf(n[0],n[1],e.pixBuffer[Xp.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=nf(n[0],n[1],e.pixBuffer[Xp.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Xp.ID_LOW24]&&0===tf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area))return a;const s=nf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area),l=nf(n[0],n[1],e.pixBuffer[Xp.ID_HIGH24],e.area);return a.attributeID=rf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=of(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=of(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=of(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function af(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=qp.newInstance();switch(l.setContentType(Yp.INDICES),e){case Qp.FIELD_ASSOCIATION_CELLS:l.setFieldType(Zp.CELL);break;case Qp.FIELD_ASSOCIATION_POINTS:l.setFieldType(Zp.POINT);break;default:Jp(&quot;Unknown field association&quot;)}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function sf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=of(e,[n,t],0,u);if(r&&r.valid){const t=ef(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return af(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function lf(e,t){t.classHierarchy.push(&quot;vtkOpenGLHardwareSelector&quot;),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e[0]!==n[0]||e[1]!==n[1]?(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer()):t.framebuffer.bind()}else t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return sf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return Jp(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:&quot;StartEvent&quot;}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();for(e.beginSelection(),t.currentPass=Xp.MIN_KNOWN_PASS;t.currentPass<=Xp.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Xp.ACTOR_PASS&&&quot;function&quot;==typeof n[0].requestDepth&&&quot;function&quot;==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),e.processPixelBuffers());return e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:&quot;EndEvent&quot;}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Xp.ID_HIGH24){if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Xp.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if(&quot;function&quot;==typeof e[0].requestDepth&&&quot;function&quot;==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=nf(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Xp.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Xp.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(Xp,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=nf(e[0],e[1],t.pixBuffer[Xp.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=nf(e[0],e[1],t.pixBuffer[Xp.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Xp.ID_LOW24]&&0===tf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area))return a;const s=nf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area),l=nf(e[0],e[1],t.pixBuffer[Xp.ID_HIGH24],t.area);return a.attributeID=rf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=ef(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return af(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const cf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cf,n),Gp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,[&quot;area&quot;],4),jt.setGet(e,t,[&quot;_renderer&quot;,&quot;currentPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;maximumPointId&quot;,&quot;maximumCellId&quot;]),jt.setGetArray(e,t,[&quot;propColorValue&quot;],3),jt.moveToProtected(e,t,[&quot;renderer&quot;,&quot;openGLRenderWindow&quot;]),jt.event(e,t,&quot;event&quot;),lf(e,t)}var df={newInstance:jt.newInstance(uf,&quot;vtkOpenGLHardwareSelector&quot;),extend:uf,...Wl};const{vtkErrorMacro:pf}=Kt,{Representation:ff}=ds,{ObjectType:gf}=qu,{PassTypes:mf}=df,hf={type:&quot;StartEvent&quot;},vf={type:&quot;EndEvent&quot;};function yf(e,t){t.classHierarchy.push(&quot;vtkOpenGLGlyph3DMapper&quot;);const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(hf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(vf),!t.currentInput)return void pf(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;attribute mat3 gNormal;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * gNormal * normalMC;&quot;]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;];a&&(i=i.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let s=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];a&&(s=s.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),s=s.concat([&quot;  opacity = opacityUniform;&quot;]),a&&(s=s.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),t.drawingEdges||(i=i.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),n=cd.substitute(n,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 gColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput = gColor;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result,s=s.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])),o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,s).result,o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;vertexVCVSOutput = MCVCMatrix * gVertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result):(n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;]).result,n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=cd.substitute(n,&quot;//VTK::Picking::Dec&quot;,[&quot;attribute vec3 mapperIndexVS;&quot;,&quot;varying vec3 mapperIndexVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Picking::Impl&quot;,&quot;  mapperIndexVSOutput = mapperIndexVS;&quot;).result,e.Vertex=n,t=cd.substitute(t,&quot;//VTK::Picking::Dec&quot;,[&quot;varying vec3 mapperIndexVSOutput;&quot;,&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,t=cd.substitute(t,&quot;//VTK::Picking::Impl&quot;,[&quot;  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);&quot;,&quot;  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];&quot;]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3(&quot;normalMatrix&quot;,t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix(&quot;MCVCMatrix&quot;,t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray(&quot;ambientColorUniform&quot;,t.tmpColor),u.setUniform3fArray(&quot;diffuseColorUniform&quot;,t.tmpColor)}c&&u.setUniform3fArray(&quot;mapperIndex&quot;,c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===ff.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===mf.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed(&quot;normalMatrix&quot;),v=g.isUniformUsed(&quot;MCVCMatrix&quot;);if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed(&quot;gMatrix&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,&quot;gMatrix&quot;,0,64,t.context.FLOAT,4,!1,1)||pf(&quot;Error setting gMatrix in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gMatrix&quot;),e.getProgram().isAttributeUsed(&quot;gNormal&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,&quot;gNormal&quot;,0,36,t.context.FLOAT,3,!1,1)||pf(&quot;Error setting gNormal in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gNormal&quot;),e.getProgram().isAttributeUsed(&quot;gColor&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,&quot;gColor&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting gColor in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gColor&quot;),e.getProgram().isAttributeUsed(&quot;mapperIndexVS&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,&quot;mapperIndexVS&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting mapperIndexVS in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;mapperIndexVS&quot;),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=qu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=qu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=qu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=qu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,gf.ARRAY_BUFFER),t.normalBuffer.upload(n,gf.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),gf.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,gf.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Tf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const bf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),np.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),yf(e,t)}),&quot;vtkOpenGLGlyph3DMapper&quot;);rn(&quot;vtkGlyph3DMapper&quot;,bf);const{vtkErrorMacro:xf}=jt;class Cf{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Sf(e,t){t.classHierarchy.push(&quot;vtkClosedPolyLineToSurfaceFilter&quot;),e.requestData=(e,t)=>{const n=e[0];if(!n)return void xf(&quot;Invalid or missing input&quot;);const r=gu.newInstance();r.shallowCopy(n);const o=new Cf,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(cc.newInstance({values:c,name:&quot;faces&quot;})),t[0]=r}}const Af={};function If(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Af,n),jt.obj(e,t),jt.algo(e,t,1,1),Sf(e,t)}var wf={newInstance:jt.newInstance(If,&quot;vtkClosedPolyLineToSurfaceFilter&quot;),extend:If};const{vtkErrorMacro:Pf}=Kt;function Of(e,t){t.classHierarchy.push(&quot;vtkCutter&quot;);const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Pf(&quot;Invalid or missing input&quot;);if(!t.cutFunction)return void Pf(&quot;Missing cut function&quot;);const o=gu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error(&quot;Iterator is done&quot;);r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const Rf={cutFunction:null,cutScalars:null,cutValue:0};function Mf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),yt(e,t),Rt(e,t,1,1),At(e,t,[&quot;cutFunction&quot;,&quot;cutValue&quot;]),Of(e,t)}var Df={newInstance:Et(Mf,&quot;vtkCutter&quot;),extend:Mf};const Ef=e=>e,Vf=1e-6;class Lf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Ef}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=Dn(n,r);return a>=1||(En(this.tmp,n,r),Sn(this.tmp)<Vf&&(En(this.tmp,[1,0,0],e),Sn(this.tmp)<Vf&&En(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Bf=function(){return new Lf(!0)},Nf=function(){return new Lf(!1)};const _f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],Ff=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function kf(e,t){t.classHierarchy.push(&quot;vtkCubeSource&quot;),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=gu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Es.newInstance({name:&quot;Normals&quot;,values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Es.newInstance({name:&quot;TextureCoordinates&quot;,values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Bf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Nf().translate(...t.center).apply(o),t.matrix){Nf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Nf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Gf={xLength:1,yLength:1,zLength:1,pointType:&quot;Float64Array&quot;,generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;xLength&quot;,&quot;yLength&quot;,&quot;zLength&quot;,&quot;generate3DTextureCoordinates&quot;,&quot;generateFaces&quot;,&quot;generateLines&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;rotations&quot;],3),jt.setGetArray(e,t,[&quot;matrix&quot;],16),t._polys=cc.newInstance({values:Uint16Array.from(Ff)}),t._lineCells=cc.newInstance({values:Uint16Array.from(_f)}),jt.moveToProtected(e,t,[&quot;polys&quot;,&quot;lineCells&quot;]),jt.algo(e,t,0,1),kf(e,t)}var zf={newInstance:jt.newInstance(Uf,&quot;vtkCubeSource&quot;),extend:Uf};const{vtkErrorMacro:Wf}=jt;function Hf(e,t){t.classHierarchy.push(&quot;vtkImageDataOutlineFilter&quot;);const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA(&quot;vtkImageData&quot;))return void Wf(&quot;Invalid or missing input&quot;);const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Wf(&quot;Unable to fetch spatial extents of input image.&quot;)},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const jf={};function Kf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jf,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=zf.newInstance(),jt.moveToProtected(e,t,[&quot;cubeSource&quot;,&quot;tmpOut&quot;]),Hf(e,t)}var $f={newInstance:jt.newInstance(Kf,&quot;vtkImageDataOutlineFilter&quot;),extend:Kf};let qf;function Xf(e,t){t.classHierarchy.push(&quot;vtkAbstractTransform&quot;,&quot;vtkHomogeneousTransform&quot;,&quot;vtkTransform&quot;),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>qf({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const Yf={preMultiplyFlag:!1,matrix:[...vo]};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;preMultiplyFlag&quot;]),jt.setGetArray(e,t,[&quot;matrix&quot;],16),Xf(e,t)}qf=jt.newInstance(Zf,&quot;vtkTransform&quot;);var Qf={newInstance:qf,extend:Zf};const Jf={NEAREST:0,LINEAR:1};var eg={InterpolationType:Jf};const{vtkErrorMacro:tg}=Kt;function ng(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function rg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function og(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageResliceMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:&quot;EndEvent&quot;})):tg(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Jf.NEAREST?(t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.openGLTexture.setMinificationFilter(bd.LINEAR),t.openGLTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime(),e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(!r)return;const o=r.getPointData()?.getScalars();if(!o)return;t._scalars!==o&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=o);const a=o.getNumberOfComponents();let i=`${r.getMTime()}A${o.getMTime()}`;const s=t._openGLRenderWindow.getGraphicsResourceForObject(o);if(s?.vtkObj&&s?.hash===i&&t.openGLTextureString===i)t.openGLTexture=s.vtkObj,t.openGLTextureString=s.hash;else{t.openGLTexture||(t.openGLTexture=Nd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const e=r.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],o),t.openGLTextureString=i,o&&t._openGLRenderWindow.setGraphicsResourceForObject(o,t.openGLTexture,t.openGLTextureString)}const l=n.getProperty(),c=l.getIndependentComponents(),u=c?a:1,d=c?2*u:1,p=l.getRGBTransferFunction();i=ng(l,p,u);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===i&&t.colorTextureString===i)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(e*d*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),p){const r=new Float32Array(3*e);for(let t=0;t<u;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),c)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=i,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}const g=l.getPiecewiseFunction();i=ng(l,g,u);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(m?.vtkObj&&m?.hash===i&&t.pwfTextureString===i)t.pwfTexture=m.vtkObj,t.pwfTextureString=m.hash;else{const e=1024,n=e*d,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),g){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<u;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=i,g&&t._openGLRenderWindow.setGraphicsResourceForObject(g,t.pwfTexture,t.pwfTextureString)}const h=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==h){const e=Es.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName(&quot;points&quot;);const n=Es.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:tg(&quot;Slab mode requested without normals&quot;)}t.tris.getCABO().createVBO(n,&quot;polys&quot;,rs.SURFACE,r)}t.VBOBuildString=h,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed(&quot;texture1&quot;)&&a.setUniformi(&quot;texture1&quot;,t.openGLTexture.getTextureUnit()),a.isAttributeUsed(&quot;vertexWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexWC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting vertexWC in shader VAO.&quot;)),a.isAttributeUsed(&quot;normalWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;normalWC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting normalWC in shader VAO.&quot;)),a.isUniformUsed(&quot;slabThickness&quot;)&&a.setUniformf(&quot;slabThickness&quot;,t.renderable.getSlabThickness()),a.isUniformUsed(&quot;spacing&quot;)&&a.setUniform3fv(&quot;spacing&quot;,t.currentInput.getSpacing()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabTrapezoid&quot;)&&a.setUniformi(&quot;slabTrapezoid&quot;,t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed(&quot;WCTCMatrix&quot;)){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix(&quot;WCTCMatrix&quot;,t.tmpMat4)}a.isUniformUsed(&quot;vboScaling&quot;)&&a.setUniform3fv(&quot;vboScaling&quot;,n.getCABO().getCoordScale()),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed(&quot;MCPCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCPCMatrix&quot;,rg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed(&quot;MCVCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCVCMatrix&quot;,rg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d),o.setUniform4fv(&quot;backgroundColor&quot;,t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model coordinates\\n// WC - World coordinates\\n// VC - View coordinates\\n// DC - Display coordinates\\n// TC - Texture coordinates\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvoid main()\\n{\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the gpu image mapper fragment shader\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  //VTK::TCoord::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform mat4 WCTCMatrix;&quot;,&quot;out vec3 fragTexCoord;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;fragTexCoord = (WCTCMatrix * vertexWC).xyz;&quot;]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=[&quot;in vec3 fragTexCoord;&quot;,&quot;uniform highp sampler3D texture1;&quot;,&quot;uniform mat4 WCTCMatrix;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}s>0&&(u=u.concat([&quot;uniform vec3 spacing;&quot;,&quot;uniform float slabThickness;&quot;,&quot;uniform int slabType;&quot;,&quot;uniform int slabTrapezoid;&quot;,&quot;uniform vec3 vboScaling;&quot;]),u=u.concat([&quot;vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)&quot;,&quot;{&quot;,&quot;  vec4 retVal = vec4(1.0);&quot;,&quot;  if (slabType == 0) // min&quot;,&quot;  {&quot;,&quot;    retVal = min(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 1) // max&quot;,&quot;  {&quot;,&quot;    retVal = max(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 3) // sum&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  else // mean&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  return retVal;&quot;,&quot;}&quot;])),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,u).result;let d=[&quot;if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(texture1, fragTexCoord);&quot;];if(s>0&&(d=d.concat([&quot;// Get the first and last samples&quot;,&quot;int numSlices = 1;&quot;,&quot;float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;&quot;,&quot;vec3 normalxspacing = scaling * normalWCVSOutput;&quot;,&quot;float distTraveled = length(normalxspacing);&quot;,&quot;int trapezoid = 0;&quot;,&quot;while (distTraveled < slabThickness * 0.5)&quot;,&quot;{&quot;,&quot;  distTraveled += length(normalxspacing);&quot;,&quot;  float fnumSlices = float(numSlices);&quot;,&quot;  if (distTraveled > slabThickness * 0.5)&quot;,&quot;  {&quot;,&quot;    // Before stepping outside the slab, sample at the boundaries&quot;,&quot;    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;&quot;,&quot;    trapezoid = slabTrapezoid;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordNeg);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordPos);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;}&quot;,&quot;// Finally, if slab type is *mean*, divide the sum by the numSlices&quot;,&quot;if (slabType == 2)&quot;,&quot;{&quot;,&quot;  tvalue = tvalue / float(numSlices);&quot;,&quot;}&quot;])),c){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(l){case 1:d=d.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:d=d.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=[&quot;attribute vec4 vertexWC;&quot;];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat([&quot;attribute vec3 normalWC;&quot;,&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,c).result;let u=[&quot;gl_Position = MCPCMatrix * vertexWC;&quot;];l>0&&(u=u.concat([&quot;normalWCVSOutput = normalWC;&quot;,&quot;vertexWCVSOutput = vertexWC;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,u).result,a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result;let d=[];l>0&&(d=d.concat([&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),s=cd.substitute(s,&quot;//VTK::PositionVC::Dec&quot;,d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e=&quot;&quot;;const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`));const t=ue(n?.getDirection());ge(t,t);const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999||o>.999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ni.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getDimensions(),l=[0,i[0]-1,0,i[1]-1,0,i[2]-1];let c=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[c+a]=r[a],e[c+o[0]]=l[2*o[0]+n],e[c+o[1]]=l[2*o[1]+t],c+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const u=new Uint16Array(8);u[0]=3,u[1]=0,u[2]=1,u[3]=3,u[4]=3,u[5]=0,u[6]=3,u[7]=2;const d=s.getNormal();za.normalize(d);const p=new Float32Array(12);for(let e=0;e<4;++e)p[3*e]=d[0],p[3*e+1]=d[1],p[3*e+2]=d[2];t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(u,1);const f=Es.newInstance({numberOfComponents:3,values:p,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(f)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=gu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Es.newInstance({numberOfComponents:3,values:a,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(i)}else tg(&quot;Something went wrong.&quot;,&quot;A default slice plane should have been created in the beginning of&quot;,&quot;updateResliceGeometry.&quot;);t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)}}const ag={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,openGLTextureString:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1,_scalars:null};const ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ag,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=$f.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=gu.newInstance(),t.cutter=Df.newInstance(),t.lineToSurfaceFilter=wf.newInstance(),t.transform=Qf.newInstance(),bt(e,t,[&quot;openGLTexture&quot;]),og(e,t)}),&quot;vtkOpenGLImageResliceMapper&quot;);rn(&quot;vtkImageResliceMapper&quot;,ig);var sg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:lg}=Kt,{SlicingMode:cg}=sg;function ug(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function dg(e){const t=e.split(&quot;\\n&quot;),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function pg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t.renderable.isA(&quot;vtkImageMapper&quot;)&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(n.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,a=cd.substitute(a,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result,a=cd.substitute(a,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform sampler2D labelOutlineTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform float outlineOpacity;&quot;];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}}if(i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,c).result,!0===o.getProperty().getUseLabelOutline()&&(i=cd.substitute(i,&quot;//VTK::LabelOutline::Dec&quot;,[&quot;uniform int outlineThickness;&quot;,&quot;uniform float vpWidth;&quot;,&quot;uniform float vpHeight;&quot;,&quot;uniform float vpOffsetX;&quot;,&quot;uniform float vpOffsetY;&quot;,&quot;uniform mat4 PCWCMatrix;&quot;,&quot;uniform mat4 vWCtoIDX;&quot;,&quot;uniform ivec3 imageDimensions;&quot;]).result,i=cd.substitute(i,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result,i=cd.substitute(i,&quot;//VTK::LabelOutlineHelperFunction&quot;,[&quot;#ifdef vtkImageLabelOutlineOn&quot;,&quot;vec3 fragCoordToIndexSpace(vec4 fragCoord) {&quot;,&quot;  vec4 pcPos = vec4(&quot;,&quot;    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,&quot;,&quot;    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,&quot;,&quot;    (fragCoord.z - 0.5) * 2.0,&quot;,&quot;    1.0);&quot;,&quot;&quot;,&quot;  vec4 worldCoord = PCWCMatrix * pcPos;&quot;,&quot;  vec4 vertex = (worldCoord/worldCoord.w);&quot;,&quot;&quot;,&quot;  vec3 index = (vWCtoIDX * vertex).xyz;&quot;,&quot;&quot;,&quot;  // half voxel fix for labelmapOutline&quot;,&quot;  return (index + vec3(0.5)) / vec3(imageDimensions);&quot;,&quot;}&quot;,&quot;#endif&quot;]).result),l){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];let t=[&quot;vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);&quot;];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, opacity);&quot;]);break;case 2:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,t).result}else switch(s){case 1:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[...dg(&quot;\\n                #ifdef vtkImageLabelOutlineOn\\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); \\n                  float centerValue = texture2D(texture1, centerPosIS.xy).r;\\n                  bool pixelOnBorder = false;\\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\\n                  float opacityToUse = scalarOpacity * opacity;\\n                  int segmentIndex = int(centerValue * 255.0);\\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\\n                  int actualThickness = int(textureValue * 255.0);\\n\\n                  if (actualThickness == 0) {\\n                    gl_FragData[0] = vec4(0.0, 0.0, 1.0, 1.0);\\n                    return;\\n                  }\\n                  if (opacityToUse > 0.01) {\\n                    for (int i = -actualThickness; i <= actualThickness; i++) {\\n                      for (int j = -actualThickness; j <= actualThickness; j++) {\\n                        if (i == 0 || j == 0) {\\n                          continue;\\n                        }\\n                        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n                          gl_FragCoord.y + float(j),\\n                          gl_FragCoord.z, gl_FragCoord.w);\\n                        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n                        float value = texture2D(texture1, neighborPosIS.xy).r;\\n                        if (value != centerValue) {\\n                          pixelOnBorder = true;\\n                          break;\\n                        }\\n                      }\\n                      if (pixelOnBorder == true) {\\n                        break;\\n                      }\\n                    }\\n                    if (pixelOnBorder == true) {\\n                      gl_FragData[0] = vec4(tColor, outlineOpacity);\\n                    }\\n                    else {\\n                      gl_FragData[0] = vec4(tColor, opacityToUse);\\n                    }\\n                  }\\n                #else\\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\\n                #endif\\n                &quot;)]).result;break;case 2:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;float intensity = tcolor.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);&quot;]).result;break;case 3:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]).result;break;default:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;]).result}t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||lg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||lg(&quot;Error setting tcoordMC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi(&quot;texture1&quot;,a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi(&quot;colorTexture1&quot;,c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi(&quot;pwfTexture1&quot;,u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;labelOutlineTexture1&quot;,p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf(&quot;outlineOpacity&quot;,e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();a.setUniform3i(&quot;imageDimensions&quot;,o[0],o[1],1),a.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const i=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,i.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const l=e.getRenderTargetSize();a.setUniformf(&quot;vpWidth&quot;,l[0]),a.setUniformf(&quot;vpHeight&quot;,l[1]);const c=e.getRenderTargetOffset();a.setUniformf(&quot;vpOffsetX&quot;,c[0]/l[0]),a.setUniformf(&quot;vpOffsetY&quot;,c[1]/l[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf(&quot;opacity&quot;,o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):lg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=ug(l,f,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.vtkObj&&m?.hash===g&&t.colorTextureString===g)t.colorTexture=m.vtkObj,t.colorTextureString=m.hash;else{const e=1024,n=new Uint8Array(e*p*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST)):(t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR)),f){const r=new Float32Array(3*e);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),u)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,p,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=g,f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,t.colorTextureString)}const h=l.getPiecewiseFunction(),v=ug(l,h,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.vtkObj&&y?.hash===v&&t.pwfTextureString===v)t.pwfTexture=y.vtkObj,t.pwfTextureString=y.hash;else{const e=1024,n=e*p,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),h){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<d;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),u)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,p,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=v,h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,t.pwfTextureString)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA(&quot;vtkImageArrayMapper&quot;)?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===cg.I&&(S=x-C[0]),T===cg.J&&(S=x-C[2]),T!==cg.K&&T!==cg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Nd.newInstance({resizable:!0}),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(new Set([1,3,4]).has(s)&&i===ys.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.NEAREST)):t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST)):(4!==s||i!==ys.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(bd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(bd.LINEAR)),t.openGLTexture.setWrapS(Td.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Td.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[cg.X,cg.Y,cg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===cg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===cg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===cg.K||T===cg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):lg(&quot;Reformat slicing not yet supported.&quot;);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);m?.vtkObj?(t.openGLTexture=m.vtkObj,t.VBOBuildString=m.hash):(t._scalars!==g&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=g),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t._openGLRenderWindow.setGraphicsResourceForObject(g,t.openGLTexture,t.VBOBuildString)),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Es.newInstance({numberOfComponents:3,values:r});h.setName(&quot;points&quot;);const v=Es.newInstance({numberOfComponents:2,values:l});v.setName(&quot;tcoords&quot;);const y=new Uint16Array(8);y[0]=3,y[1]=0,y[2]=1,y[3]=3,y[4]=3,y[5]=0,y[6]=3,y[7]=2;const C=Es.newInstance({numberOfComponents:1,values:y});t.tris.getCABO().createVBO(C,&quot;polys&quot;,rs.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=e=>{t.labelOutlineThicknessTexture||(t.labelOutlineThicknessTexture=Nd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]}}const fg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,_scalars:null};const gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fg,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),pg(e,t)}),&quot;vtkOpenGLImageMapper&quot;);rn(&quot;vtkAbstractImageMapper&quot;,gg);const{vtkErrorMacro:mg}=jt;function hg(e,t,n){if(t.apply(e)){const t=e.getIndependentComponents();return`${e.getMTime()}-${t}-${n}`}return&quot;0&quot;}function vg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageCPRMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow))},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentImageDataInput,o=t.currentCenterlineInput;n.getProperty().getInterpolationType()===Jf.NEAREST?(t.volumeTexture.setMinificationFilter(bd.NEAREST),t.volumeTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.volumeTexture.setMinificationFilter(bd.LINEAR),t.volumeTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR));const a=r.getMTime();if(t.volumeTextureTime!==a){const e=r.getDimensions(),n=r.getPointData().getScalars();if(!n)return;t.volumeTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.volumeTexture.releaseGraphicsResources(t._openGLRenderWindow),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromRaw(e[0],e[1],e[2],n.getNumberOfComponents(),n.getDataType(),n.getData(),t.renderable.getPreferSizeOverAccuracy()),t.volumeTextureTime=a}const i=r.getPointData()&&r.getPointData().getScalars();if(!i)return;const s=i.getNumberOfComponents(),l=n.getProperty(),c=l.getIndependentComponents(),u=c?s:1,d=c?2*u:1,p=hg(l,l.getRGBTransferFunction,u);if(t.colorTextureString!==p){const e=1024,n=new Uint8Array(e*d*3);let r=l.getRGBTransferFunction();if(r){const o=new Float32Array(3*e);for(let t=0;t<u;t++){r=l.getRGBTransferFunction(t);const a=r.getRange();if(r.getTable(a[0],a[1],e,o,1),c)for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r],n[t*e*6+r+3*e]=255*o[r];else for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=p}const f=hg(l,l.getPiecewiseFunction,u);if(t.pwfTextureString!==f){const e=1024,n=e*d,r=new Uint8Array(n);let o=l.getPiecewiseFunction();if(t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),o){const r=new Float32Array(n),a=new Float32Array(e);for(let t=0;t<u;++t)if(o=l.getPiecewiseFunction(t),null===o)r.fill(1);else{const n=o.getRange();if(o.getTable(n[0],n[1],e,a,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=a[n],r[t*e*2+n+e]=a[n];else for(let n=0;n<e;n++)r[t*e*2+n]=a[n]}t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=f}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<o.getMTime()){const e=o.getNumberOfPoints(),n=e<=1?0:e-1,r=o.getDistancesToFirstPoint(),a=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,a-r[e],0],t),t+=3,s.set([l,a-r[e],0],t),t+=3,s.set([l,a-r[e+1],0],t),t+=3,s.set([0,a-r[e+1],0],t),t+=3;const c=Es.newInstance({numberOfComponents:3,values:s});c.setName(&quot;points&quot;);const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Es.newInstance({numberOfComponents:1,values:u}),p=o.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Es.newInstance({numberOfComponents:3,values:f,name:&quot;centerlinePosition&quot;}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Es.newInstance({numberOfComponents:1,values:v,name:&quot;quadIndex&quot;})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getCenterlineTangentDirections(),r=new Float32Array(3*i),o=new Float32Array(3*i);for(let t=0,a=0;t<n;++t){const n=3*t;for(let t=0;t<4;++t)r[a+0]=e[n+0],r[a+1]=e[n+1],r[a+2]=e[n+2],o[a+0]=e[n+3],o[a+1]=e[n+4],o[a+2]=e[n+5],a+=3}const a=Es.newInstance({numberOfComponents:3,values:r,name:&quot;centerlineTopDirection&quot;}),s=Es.newInstance({numberOfComponents:3,values:o,name:&quot;centerlineBotDirection&quot;});y.push(a,s)}t.tris.getCABO().createVBO(d,&quot;polys&quot;,rs.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result;const s=[&quot;attribute vec3 centerlinePosition;&quot;,&quot;attribute float quadIndex;&quot;,&quot;uniform float width;&quot;,&quot;out vec2 quadOffsetVSOutput;&quot;,&quot;out vec3 centerlinePosVSOutput;&quot;],l=t.renderable.getUseUniformOrientation();l?s.push(&quot;out vec3 centerlineDirVSOutput;&quot;,&quot;uniform vec3 centerlineDirection;&quot;):s.push(&quot;out vec3 centerlineTopDirVSOutput;&quot;,&quot;out vec3 centerlineBotDirVSOutput;&quot;,&quot;out float centerlineAngleVSOutput;&quot;,&quot;attribute vec3 centerlineTopDirection;&quot;,&quot;attribute vec3 centerlineBotDirection;&quot;),a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,s).result;const c=[&quot;quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);&quot;,&quot;centerlinePosVSOutput = centerlinePosition;&quot;];l?c.push(&quot;centerlineDirVSOutput = centerlineDirection;&quot;):c.push(&quot;vec3 sumVec = centerlineTopDirection + centerlineBotDirection;&quot;,&quot;float sumLen2 = dot(sumVec, sumVec);&quot;,&quot;float diffLen2 = 4.0 - sumLen2;&quot;,&quot;if (diffLen2 < 0.001) {&quot;,&quot;  // vectors are too close to each other, use lerp&quot;,&quot;  centerlineAngleVSOutput = -1.0; // use negative angle as a flag for lerp&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection;&quot;,&quot;} else if (sumLen2 == 0.0) {&quot;,&quot;  // vector are opposite to each other, don't make a choice for the user&quot;,&quot;  // use slerp without direction, it will display the centerline color on each row of pixel&quot;,&quot;  centerlineAngleVSOutput = 0.0;&quot;,&quot;  centerlineTopDirVSOutput = vec3(0.0);&quot;,&quot;  centerlineBotDirVSOutput = vec3(0.0);&quot;,&quot;} else {&quot;,&quot;  // use slerp&quot;,&quot;  centerlineAngleVSOutput = 2.0 * atan(sqrt(diffLen2/sumLen2));&quot;,&quot;  float sinAngle = sin(centerlineAngleVSOutput);&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection / sinAngle;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection / sinAngle;&quot;,&quot;}&quot;),a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,c).result;const u=t.volumeTexture.getComponents(),d=o.getProperty().getIndependentComponents();let p=[&quot;uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates&quot;,&quot;in vec2 quadOffsetVSOutput;&quot;,&quot;in vec3 centerlinePosVSOutput;&quot;,&quot;uniform highp sampler3D volumeTexture;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;];l?p.push(&quot;in vec3 centerlineDirVSOutput;&quot;):p.push(&quot;in vec3 centerlineTopDirVSOutput;&quot;,&quot;in vec3 centerlineBotDirVSOutput;&quot;,&quot;in float centerlineAngleVSOutput;&quot;);const f=t.renderable.getCenterPoint();if(f&&p.push(&quot;uniform vec3 globalCenterPoint;&quot;),d){for(let e=1;e<u;e++)p=p.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(u){case 1:p=p.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,p).result;let g=[];if(l?g.push(&quot;vec3 interpolatedCenterlineDir = centerlineDirVSOutput;&quot;):g.push(&quot;vec3 interpolatedCenterlineDir;&quot;,&quot;if (centerlineAngleVSOutput < 0.0) {&quot;,&quot;  // Lerp&quot;,&quot;  interpolatedCenterlineDir = quadOffsetVSOutput.y * centerlineTopDirVSOutput + (1.0 - quadOffsetVSOutput.y) * centerlineBotDirVSOutput;&quot;,&quot;} else {&quot;,&quot;  // Slerp&quot;,&quot;  float topInterpolationAngle = quadOffsetVSOutput.y * centerlineAngleVSOutput;&quot;,&quot;  float botInterpolationAngle = centerlineAngleVSOutput - topInterpolationAngle;&quot;,&quot;  interpolatedCenterlineDir = sin(topInterpolationAngle) * centerlineTopDirVSOutput + sin(botInterpolationAngle) * centerlineBotDirVSOutput;&quot;,&quot;}&quot;,&quot;// Slerp should give a normalized vector but when sin(angle) is small, rounding error occurs&quot;,&quot;// Normalize for both lerp and slerp&quot;,&quot;interpolatedCenterlineDir = normalize(interpolatedCenterlineDir);&quot;),f?g.push(&quot;float baseOffset = dot(interpolatedCenterlineDir, globalCenterPoint - centerlinePosVSOutput);&quot;,&quot;float horizontalOffset = quadOffsetVSOutput.x + baseOffset;&quot;):g.push(&quot;float horizontalOffset = quadOffsetVSOutput.x;&quot;),g.push(&quot;vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * interpolatedCenterlineDir;&quot;,&quot;vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;&quot;,&quot;if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(volumeTexture, volumePosTC);&quot;),d){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<u;++t)g=g.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(u){case 1:g=g.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(u){case 1:g=g.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:g=g.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,g).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||mg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getCABO().getCustomData().forEach((e=>{e&&n.getProgram().isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),e.name,e.offset,n.getCABO().getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&mg(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const a=t.volumeTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;volumeTexture&quot;,a),n.getProgram().setUniformf(&quot;width&quot;,t.renderable.getWidth()),n.getProgram().setUniform4f(&quot;backgroundColor&quot;,...t.renderable.getBackgroundColor()),n.getProgram().isUniformUsed(&quot;centerlineDirection&quot;)){const e=t.renderable.getUniformDirection();n.getProgram().setUniform3fArray(&quot;centerlineDirection&quot;,e)}if(n.getProgram().isUniformUsed(&quot;globalCenterPoint&quot;)){const e=t.renderable.getCenterPoint();n.getProgram().setUniform3fArray(&quot;globalCenterPoint&quot;,e)}const i=t.currentImageDataInput,s=i.getWorldToIndex(),l=P(new Float32Array(16),Rn([],i.getDimensions())),c=oe(l,l,s);if(n.getProgram().setUniformMatrix(&quot;MCTCMatrix&quot;,c),t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)}}const yg={currentRenderPass:null,volumeTexture:null,volumeTextureTime:0,colorTexture:null,colorTextureString:null,pwfTexture:null,pwfTextureString:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Tg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yg,n),Zt.extend(e,t,n),kd(e,t,n),jt.algo(e,t,2,0),t.tris=yd.newInstance(),t.volumeTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.pwfTexture=Nd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),vg(e,t)}),&quot;vtkOpenGLImageCPRMapper&quot;);function bg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageSlice&quot;),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkImageCPRMapper&quot;,Tg);const xg={context:null,keyMatrixTime:null,keyMatrices:null};const Cg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bg(e,t)}),&quot;vtkOpenGLImageSlice&quot;);function Sg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolume&quot;),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn(&quot;vtkImageSlice&quot;,Cg);const Ag={};const Ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ag,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,[&quot;context&quot;]),Sg(e,t)}),&quot;vtkOpenGLVolume&quot;);rn(&quot;vtkVolume&quot;,Ig);const wg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},Pg={FRACTIONAL:0,PROPORTIONAL:1};var Og={InterpolationType:wg,OpacityMode:Pg};const Rg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5};var Mg={BlendMode:Rg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Dg,vtkErrorMacro:Eg}=Kt;function Vg(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function Lg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolumeMapper&quot;),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType(&quot;vtkOpenGLVolume&quot;);const n=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const r=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera()),e.renderPiece(r,n)}},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\n\\nvarying vec3 vertexVCVSOutput;\\nuniform mat4 PCVCMatrix;\\n\\nuniform float dcxmin;\\nuniform float dcxmax;\\nuniform float dcymin;\\nuniform float dcymax;\\n\\nvoid main()\\n{\\n  // dcsmall is the device coords reduced to the\\n  // x y area covered by the volume\\n  vec4 dcsmall = vec4(\\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\\n    vertexDC.z,\\n    vertexDC.w);\\n  vec4 vcpos = PCVCMatrix * dcsmall;\\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\\n  gl_Position = dcsmall;\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkVolumeFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the volume mappers fragment shader\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvarying vec3 vertexVCVSOutput;\\n\\n// first declare the settings from the mapper\\n// that impact the code paths in here\\n\\n// always set vtkNumComponents 1,2,3,4\\n//VTK::NumComponents\\n\\n// possibly define vtkTrilinearOn\\n//VTK::TrilinearOn\\n\\n// possibly define vtkIndependentComponents\\n//VTK::IndependentComponentsOn\\n\\n// possibly define any \\&quot;proportional\\&quot; components\\n//VTK::vtkProportionalComponents\\n\\n// Define the blend mode to use\\n#define vtkBlendMode //VTK::BlendMode\\n\\n// Possibly define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n#ifdef vtkImageLabelOutlineOn\\n\\nuniform float outlineOpacity;\\nuniform float vpWidth;\\nuniform float vpHeight;\\nuniform float vpOffsetX;\\nuniform float vpOffsetY;\\nuniform mat4 PCWCMatrix;\\nuniform mat4 vWCtoIDX;\\n#endif\\n\\n// define vtkLightComplexity\\n//VTK::LightComplexity\\n#if vtkLightComplexity > 0\\nuniform float vSpecularPower;\\nuniform float vAmbient;\\nuniform float vDiffuse;\\nuniform float vSpecular;\\n//VTK::Light::Dec\\n#endif\\n\\n//VTK::VolumeShadowOn\\n//VTK::SurfaceShadowOn\\n//VTK::localAmbientOcclusionOn\\n//VTK::LAO::Dec\\n//VTK::VolumeShadow::Dec\\n\\n// define vtkComputeNormalFromOpacity\\n//VTK::vtkComputeNormalFromOpacity\\n\\n// possibly define vtkGradientOpacityOn\\n//VTK::GradientOpacityOn\\n#ifdef vtkGradientOpacityOn\\nuniform float goscale0;\\nuniform float goshift0;\\nuniform float gomin0;\\nuniform float gomax0;\\n#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\nuniform float goscale1;\\nuniform float goshift1;\\nuniform float gomin1;\\nuniform float gomax1;\\n#if vtkNumComponents >= 3\\nuniform float goscale2;\\nuniform float goshift2;\\nuniform float gomin2;\\nuniform float gomax2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float goscale3;\\nuniform float goshift3;\\nuniform float gomin3;\\nuniform float gomax3;\\n#endif\\n#endif\\n#endif\\n\\n// if you want to see the raw tiled\\n// data in webgl1 uncomment the following line\\n// #define debugtile\\n\\n// camera values\\nuniform float camThick;\\nuniform float camNear;\\nuniform float camFar;\\nuniform int cameraParallel;\\n\\n// values describing the volume geometry\\nuniform vec3 vOriginVC;\\nuniform vec3 vSpacing;\\nuniform ivec3 volumeDimensions; // 3d texture dimensions\\nuniform vec3 vPlaneNormal0;\\nuniform float vPlaneDistance0;\\nuniform vec3 vPlaneNormal1;\\nuniform float vPlaneDistance1;\\nuniform vec3 vPlaneNormal2;\\nuniform float vPlaneDistance2;\\nuniform vec3 vPlaneNormal3;\\nuniform float vPlaneDistance3;\\nuniform vec3 vPlaneNormal4;\\nuniform float vPlaneDistance4;\\nuniform vec3 vPlaneNormal5;\\nuniform float vPlaneDistance5;\\n\\n//VTK::ClipPlane::Dec\\n\\n// opacity and color textures\\nuniform sampler2D otexture;\\nuniform float oshift0;\\nuniform float oscale0;\\nuniform sampler2D ctexture;\\nuniform float cshift0;\\nuniform float cscale0;\\n\\n// jitter texture\\nuniform sampler2D jtexture;\\nuniform sampler2D ttexture;\\n\\n\\n// some 3D texture values\\nuniform float sampleDistance;\\nuniform vec3 vVCToIJK;\\n\\n// the heights defined below are the locations\\n// for the up to four components of the tfuns\\n// the tfuns have a height of 2XnumComps pixels so the\\n// values are computed to hit the middle of the two rows\\n// for that component\\n#ifdef vtkIndependentComponentsOn\\n#if vtkNumComponents == 2\\nuniform float mix0;\\nuniform float mix1;\\n#define height0 0.25\\n#define height1 0.75\\n#endif\\n#if vtkNumComponents == 3\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\n#define height0 0.17\\n#define height1 0.5\\n#define height2 0.83\\n#endif\\n#if vtkNumComponents == 4\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\nuniform float mix3;\\n#define height0 0.125\\n#define height1 0.375\\n#define height2 0.625\\n#define height3 0.875\\n#endif\\n#endif\\n\\n#if vtkNumComponents >= 2\\nuniform float oshift1;\\nuniform float oscale1;\\nuniform float cshift1;\\nuniform float cscale1;\\n#endif\\n#if vtkNumComponents >= 3\\nuniform float oshift2;\\nuniform float oscale2;\\nuniform float cshift2;\\nuniform float cscale2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float oshift3;\\nuniform float oscale3;\\nuniform float cshift3;\\nuniform float cscale3;\\n#endif\\n\\nuniform vec4 ipScalarRangeMin;\\nuniform vec4 ipScalarRangeMax;\\n\\n// declaration for intermixed geometry\\n//VTK::ZBuffer::Dec\\n\\n//=======================================================================\\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\\nvec3 rayDirVC;\\nfloat sampleDistanceISVS;\\nfloat sampleDistanceIS;\\n\\n#define SQRT3    1.7321\\n#define INV4PI   0.0796\\n#define EPSILON  0.001\\n#define PI       3.1415\\n#define PI2      9.8696\\n\\n//=======================================================================\\n// Webgl2 specific version of functions\\n#if __VERSION__ == 300\\n\\nuniform highp sampler3D texture1;\\n\\nvec4 getTextureValue(vec3 pos)\\n{\\n  vec4 tmp = texture(texture1, pos);\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.a = tmp.g;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n  return tmp;\\n}\\n\\n//=======================================================================\\n// WebGL1 specific version of functions\\n#else\\n\\nuniform sampler2D texture1;\\n\\nuniform float texWidth;\\nuniform float texHeight;\\nuniform int xreps;\\nuniform int xstride;\\nuniform int ystride;\\n\\n// if computing trilinear values from multiple z slices\\n#ifdef vtkTrilinearOn\\nvec4 getTextureValue(vec3 ijk)\\n{\\n  float zoff = 1.0/float(volumeDimensions.z);\\n  vec4 val1 = getOneTextureValue(ijk);\\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\\n\\n  float indexZ = float(volumeDimensions)*ijk.z;\\n  float zmix =  indexZ - floor(indexZ);\\n\\n  return mix(val1, val2, zmix);\\n}\\n\\nvec4 getOneTextureValue(vec3 ijk)\\n#else // nearest or fast linear\\nvec4 getTextureValue(vec3 ijk)\\n#endif\\n{\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n#ifdef debugtile\\n  vec2 tpos = vec2(ijk.x, ijk.y);\\n  vec4 tmp = texture2D(texture1, tpos);\\n  tmp.a = 1.0;\\n\\n#else\\n  int z = int(ijk.z * tdims.z);\\n  int yz = z / xreps;\\n  int xz = z - yz*xreps;\\n\\n  int tileWidth = volumeDimensions.x/xstride;\\n  int tileHeight = volumeDimensions.y/ystride;\\n\\n  xz *= tileWidth;\\n  yz *= tileHeight;\\n\\n  float ni = float(xz) + (ijk.x*float(tileWidth));\\n  float nj = float(yz) + (ijk.y*float(tileHeight));\\n\\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\\n\\n  vec4 tmp = texture2D(texture1, tpos);\\n\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.g = tmp.a;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n#endif\\n\\n  return tmp;\\n}\\n\\n// End of Webgl1 specific code\\n//=======================================================================\\n#endif\\n\\n//=======================================================================\\n// transformation between VC and IS space\\n\\n// convert vector position from idx to vc\\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\\nvec3 IStoVC(vec3 posIS){\\n  vec3 posVC = posIS / vVCToIJK;\\n  return posVC.x * vPlaneNormal0 +\\n         posVC.y * vPlaneNormal2 +\\n         posVC.z * vPlaneNormal4 +\\n         vOriginVC;\\n}\\n\\n// convert vector position from vc to idx\\nvec3 VCtoIS(vec3 posVC){\\n  posVC = posVC - vOriginVC;\\n  posVC = vec3(\\n    dot(posVC, vPlaneNormal0),\\n    dot(posVC, vPlaneNormal2),\\n    dot(posVC, vPlaneNormal4));\\n  return posVC * vVCToIJK;\\n}\\n#endif\\n\\n//Rotate vector to view coordinate\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\nvoid rotateToViewCoord(inout vec3 dirIS){\\n  dirIS.xyz =\\n    dirIS.x * vPlaneNormal0 +\\n    dirIS.y * vPlaneNormal2 +\\n    dirIS.z * vPlaneNormal4;\\n}\\n\\n//Rotate vector to idx coordinate\\nvec3 rotateToIDX(vec3 dirVC){\\n  vec3 dirIS;\\n  dirIS.xyz = vec3(\\n    dot(dirVC, vPlaneNormal0),\\n    dot(dirVC, vPlaneNormal2),\\n    dot(dirVC, vPlaneNormal4));\\n  return dirIS;\\n}\\n#endif\\n\\n//=======================================================================\\n// Given a normal compute the gradient opacity factors\\nfloat computeGradientOpacityFactor(\\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\\n{\\n#if defined(vtkGradientOpacityOn)\\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\\n#else\\n  return 1.0;\\n#endif\\n}\\n\\n//=======================================================================\\n// compute the normal and gradient magnitude for a position, uses forward difference\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\n#ifdef vtkClippingPlanesOn\\n  void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\\n  {\\n    vec3 g1VC[3];\\n    for (int i = 0; i < 3; ++i)\\n    {\\n      g1VC[i] = IStoVC(texPos[i]);\\n    }\\n    vec3 posVC = IStoVC(pos);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      for (int j = 0; j < 3; ++j)\\n      {\\n        if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\\n        {\\n          g1[j] = 0.0;\\n        }\\n      }\\n    }\\n  }\\n#endif\\n\\n  #ifdef vtkComputeNormalFromOpacity\\n    #ifdef vtkGradientOpacityOn\\n      vec4 computeDensityNormal(float gradientMag, vec3 scalarInterp[2])\\n      {\\n    #else\\n      //if gradient opacity not on but using density gradient\\n      vec4 computeDensityNormal(vec3 scalarInterp[2])\\n      {\\n    #endif\\n        vec3 opacityG1, opacityG2;\\n        opacityG1.x = texture2D(otexture, vec2(scalarInterp[0].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.y = texture2D(otexture, vec2(scalarInterp[0].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.z = texture2D(otexture, vec2(scalarInterp[0].z * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.x = texture2D(otexture, vec2(scalarInterp[1].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.y = texture2D(otexture, vec2(scalarInterp[1].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.z = texture2D(otexture, vec2(scalarInterp[1].z * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n        float gradOpacityFactor = 1.0f;\\n        if (gradientMag >= 0.0){\\n          gradOpacityFactor = computeGradientOpacityFactor(gradientMag, goscale0, goshift0, gomin0, gomax0);\\n        }\\n        opacityG1.xyz *= gradOpacityFactor;\\n        opacityG2.xyz *= gradOpacityFactor;\\n    #endif\\n\\n        vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\\n        // divide by spacing\\n        opacityG.xyz /= vSpacing;\\n        opacityG.w = length(opacityG.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(opacityG.xyz);\\n        if (length(opacityG.xyz) > 0.0) {\\n          return vec4(normalize(opacityG.xyz),opacityG.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n\\n      vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2])\\n      {\\n        vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n        vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n        vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n        vec3 texPosPVec[3];\\n        texPosPVec[0] = pos + xvec;\\n        texPosPVec[1] = pos + yvec;\\n        texPosPVec[2] = pos + zvec;\\n        vec3 texPosNVec[3];\\n        texPosNVec[0] = pos - xvec;\\n        texPosNVec[1] = pos - yvec;\\n        texPosNVec[2] = pos - zvec;\\n        vec3 g1, g2;\\n\\n        scalarInterp[0].x = getTextureValue(texPosPVec[0]).a;\\n        scalarInterp[0].y = getTextureValue(texPosPVec[1]).a;\\n        scalarInterp[0].z = getTextureValue(texPosPVec[2]).a;\\n        scalarInterp[1].x = getTextureValue(texPosNVec[0]).a;\\n        scalarInterp[1].y = getTextureValue(texPosNVec[1]).a;\\n        scalarInterp[1].z = getTextureValue(texPosNVec[2]).a;\\n\\n        #ifdef vtkClippingPlanesOn\\n          adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\\n          adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\\n        #endif\\n        vec4 result;\\n        result.x = scalarInterp[0].x - scalarInterp[1].x;\\n        result.y = scalarInterp[0].y - scalarInterp[1].y;\\n        result.z = scalarInterp[0].z - scalarInterp[1].z;\\n        // divide by spacing\\n        result.xyz /= vSpacing;\\n        result.w = length(result.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(result.xyz);\\n        if (length(result.xyz) > 0.0) {\\n          return vec4(normalize(result.xyz),result.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n  #endif\\n\\n  vec4 computeNormal(vec3 pos, vec3 tstep)\\n  {\\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n    vec3 texPosPVec[3];\\n    texPosPVec[0] = pos + xvec;\\n    texPosPVec[1] = pos + yvec;\\n    texPosPVec[2] = pos + zvec;\\n    vec3 texPosNVec[3];\\n    texPosNVec[0] = pos - xvec;\\n    texPosNVec[1] = pos - yvec;\\n    texPosNVec[2] = pos - zvec;\\n    vec3 g1, g2;\\n    g1.x = getTextureValue(texPosPVec[0]).a;\\n    g1.y = getTextureValue(texPosPVec[1]).a;\\n    g1.z = getTextureValue(texPosPVec[2]).a;\\n    g2.x = getTextureValue(texPosNVec[0]).a;\\n    g2.y = getTextureValue(texPosNVec[1]).a;\\n    g2.z = getTextureValue(texPosNVec[2]).a;\\n    #ifdef vtkClippingPlanesOn\\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\\n    #endif\\n    vec4 result;\\n    result = vec4(g1 - g2, -1.0);\\n    // divide by spacing\\n    result.xyz /= vSpacing;\\n    result.w = length(result.xyz);\\n    if (result.w > 0.0){\\n      // rotate to View Coords\\n      rotateToViewCoord(result.xyz);\\n      return vec4(normalize(result.xyz),result.w);\\n    } else {\\n      return vec4(0.0);\\n    }\\n  }\\n#endif\\n\\n#ifdef vtkImageLabelOutlineOn\\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\\n  vec4 pcPos = vec4(\\n    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\\n    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\\n    (fragCoord.z - 0.5) * 2.0,\\n    1.0);\\n\\n  vec4 worldCoord = PCWCMatrix * pcPos;\\n  vec4 vertex = (worldCoord/worldCoord.w);\\n\\n  vec3 index = (vWCtoIDX * vertex).xyz;\\n\\n  // half voxel fix for labelmapOutline\\n  return (index + vec3(0.5)) / vec3(volumeDimensions);\\n}\\n#endif\\n\\n//=======================================================================\\n// compute the normals and gradient magnitudes for a position\\n// for independent components\\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\\n{\\n  mat4 result;\\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\\n\\n  // divide by spacing\\n  distX /= vSpacing.x;\\n  distY /= vSpacing.y;\\n  distZ /= vSpacing.z;\\n\\n  mat3 rot;\\n  rot[0] = vPlaneNormal0;\\n  rot[1] = vPlaneNormal2;\\n  rot[2] = vPlaneNormal4;\\n\\n#if !defined(vtkComponent0Proportional)\\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\\n  result[0].a = length(result[0].xyz);\\n  result[0].xyz *= rot;\\n  if (result[0].w > 0.0)\\n  {\\n    result[0].xyz /= result[0].w;\\n  }\\n#endif\\n\\n// optionally compute the 2nd component\\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\\n  result[1].a = length(result[1].xyz);\\n  result[1].xyz *= rot;\\n  if (result[1].w > 0.0)\\n  {\\n    result[1].xyz /= result[1].w;\\n  }\\n#endif\\n\\n// optionally compute the 3rd component\\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\\n  result[2].a = length(result[2].xyz);\\n  result[2].xyz *= rot;\\n  if (result[2].w > 0.0)\\n  {\\n    result[2].xyz /= result[2].w;\\n  }\\n#endif\\n\\n// optionally compute the 4th component\\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\\n  result[3].a = length(result[3].xyz);\\n  result[3].xyz *= rot;\\n  if (result[3].w > 0.0)\\n  {\\n    result[3].xyz /= result[3].w;\\n  }\\n#endif\\n\\n  return result;\\n}\\n\\n//=======================================================================\\n// global shadow - secondary ray\\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\\nfloat random()\\n{\\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\\n  uint pcg_state = floatBitsToUint(jitter);\\n  uint state = pcg_state;\\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\\n}\\n#endif\\n\\n#ifdef VolumeShadowOn\\n// henyey greenstein phase function\\nfloat phase_function(float cos_angle)\\n{\\n  // divide by 2.0 instead of 4pi to increase intensity\\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\\n}\\n\\n// Computes the intersection between a ray and a box\\nstruct Hit\\n{\\n  float tmin;\\n  float tmax;\\n};\\n\\nstruct Ray\\n{\\n  vec3 origin;\\n  vec3 dir;\\n  vec3 invDir;\\n};\\n\\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\\n{\\n  vec3 tbot = r.invDir * (boundMin - r.origin);\\n  vec3 ttop = r.invDir * (boundMax - r.origin);\\n  vec3 tmin = min(ttop, tbot);\\n  vec3 tmax = max(ttop, tbot);\\n  vec2 t = max(tmin.xx, tmin.yz);\\n  float t0 = max(t.x, t.y);\\n  t = min(tmax.xx, tmax.yz);\\n  float t1 = min(t.x, t.y);\\n  hit.tmin = t0;\\n  hit.tmax = t1;\\n  return t1 > max(t0,0.0);\\n}\\n\\n// As BBoxIntersect requires the inverse of the ray coords,\\n// this function is used to avoid numerical issues\\nvoid safe_0_vector(inout Ray ray)\\n{\\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\\n}\\n\\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\\n{\\n  float shadow = 1.0;\\n  float opacity = 0.0;\\n\\n  // modify sample distance with a random number between 1.5 and 3.0\\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\\n\\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\\n\\n  // compute the start and end points for the ray\\n  Ray ray;\\n  Hit hit;\\n  ray.origin = posIS;\\n  ray.dir = lightDirNormIS;\\n  safe_0_vector(ray);\\n  ray.invDir = 1.0/ray.dir;\\n\\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\\n  {\\n    return 1.0;\\n  }\\n  float maxdist = hit.tmax;\\n\\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\\n  maxdist = min(maxdist,maxgi);\\n  if(maxdist < EPSILON) {\\n    return 1.0;\\n  }\\n\\n  // support gradient opacity\\n  #ifdef vtkGradientOpacityOn\\n    vec4 normal;\\n  #endif\\n\\n  float current_dist = 0.0;\\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\\n  float clamped_step = 0.0;\\n\\n  vec4 scalar = vec4(0.0);\\n  while(current_dist < maxdist)\\n  {\\n#ifdef vtkClippingPlanesOn\\n    vec3 posVC = IStoVC(posIS);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\\n      {\\n        current_dist = maxdist;\\n      }\\n    }\\n#endif\\n    scalar = getTextureValue(posIS);\\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n      normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    shadow *= 1.0 - opacity;\\n\\n    // optimization: early termination\\n    if (shadow < EPSILON){\\n      return 0.0;\\n    }\\n\\n    clamped_step = min(maxdist - current_dist, current_step);\\n    posIS += clamped_step * lightDirNormIS;\\n    current_dist += current_step;\\n  }\\n\\n  return shadow;\\n}\\n\\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\\n{\\n  vec3 vertLight = vec3(0.0);\\n  vec3 secondary_contrib = vec3(0.0);\\n  // here we assume only positional light, no effect of cones\\n  for (int i = 0; i < lightNum; i++)\\n  {\\n    #if(vtkLightComplexity==3)\\n      if (lightPositional[i] == 1){\\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\\n      }else{\\n        vertLight = - lightDirectionVC[i];\\n      }\\n    #else\\n      vertLight = - lightDirectionVC[i];\\n    #endif\\n    // here we assume achromatic light, only intensity\\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\\n    float phase_attenuation = 0.5;\\n    if (abs(anisotropy) > EPSILON){\\n      phase_attenuation = phase_function(dDotL);\\n    }\\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\\n    secondary_contrib += tColor * vAmbient;\\n  }\\n  return secondary_contrib;\\n}\\n#endif\\n\\n//=======================================================================\\n// local ambient occlusion\\n#ifdef localAmbientOcclusionOn\\nvec3 sample_direction_uniform(int i)\\n{\\n  float rand = random() * 0.5;\\n  float theta = PI2 * (kernelSample[i][0] + rand);\\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\\n}\\n\\n// return a matrix that transform startDir into z axis; startDir should be normalized\\nmat3 zBaseRotationalMatrix(vec3 startDir){\\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\\n  float cosA = startDir.z;\\n  float k = 1.0 / (1.0 + cosA);\\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\\n  return matrix;\\n}\\n\\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\\n  // apply LAO only at selected locations, otherwise return full brightness\\n  if (normal.w > 0.0 && op > 0.05){\\n    float total_transmittance = 0.0;\\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\\n    vec3 currPos, randomDirStep;\\n    float weight, transmittance, opacity;\\n    for (int i = 0; i < kernelSize; i++)\\n    {\\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\\n      currPos = posIS;\\n      transmittance = 1.0;\\n      for (int j = 0; j < kernelRadius ; j++){\\n        currPos += randomDirStep;\\n        // check if it's at clipping plane, if so return full brightness\\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\\n          #ifdef vtkGradientOpacityOn\\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n          #endif\\n          transmittance *= 1.0 - opacity;\\n        }\\n        else{\\n          break;\\n        }\\n      }\\n      total_transmittance += transmittance / float(kernelRadius) * weight;\\n\\n      // early termination if fully translucent\\n      if (total_transmittance > 1.0 - EPSILON){\\n        return 1.0;\\n      }\\n    }\\n    // average transmittance and reduce variance\\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\\n  } else {\\n    return 1.0;\\n  }\\n}\\n#endif\\n\\n//=======================================================================\\n// surface light contribution\\n#if vtkLightComplexity > 0\\n  void applyLighting(inout vec3 tColor, vec4 normal)\\n  {\\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\\n    vec3 specular = vec3(0.0, 0.0, 0.0);\\n    float df, sf = 0.0;\\n    for (int i = 0; i < lightNum; i++){\\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\\n        diffuse += df * lightColor[i];\\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\\n        specular += sf * lightColor[i];\\n    }\\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\\n  }\\n  #ifdef SurfaceShadowOn\\n  #if vtkLightComplexity < 3\\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float ndotL,vdotR;\\n        vertLightDirection = lightDirectionVC[i];\\n        ndotL = dot(normal.xyz, vertLightDirection);\\n        if (ndotL < 0.0 && twoSidedLighting)\\n        {\\n          ndotL = -ndotL;\\n        }\\n        if (ndotL > 0.0)\\n        {\\n          diffuse += ndotL * lightColor[i];\\n          //specular\\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n          if (vdotR > 0.0)\\n          {\\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n          }\\n        }\\n        #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n        #endif\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #else\\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float distance,attenuation,ndotL,vdotR;\\n        vec3 lightDir;\\n        if (lightPositional[i] == 1){\\n          lightDir = lightDirectionVC[i];\\n          vertLightDirection = posVC - lightPositionVC[i];\\n          distance = length(vertLightDirection);\\n          vertLightDirection = normalize(vertLightDirection);\\n          attenuation = 1.0 / (lightAttenuation[i].x\\n                              + lightAttenuation[i].y * distance\\n                              + lightAttenuation[i].z * distance * distance);\\n          // per OpenGL standard cone angle is 90 or less for a spot light\\n          if (lightConeAngle[i] <= 90.0){\\n            float coneDot = dot(vertLightDirection, lightDir);\\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\\n            }\\n            else {\\n              attenuation = 0.0;\\n            }\\n          }\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * attenuation * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        } else {\\n          vertLightDirection = lightDirectionVC[i];\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        }\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #endif\\n  #endif\\n#endif\\n\\n//=======================================================================\\n// Given a texture value compute the color and opacity\\n//\\nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\\n{\\n#ifdef vtkImageLabelOutlineOn\\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\\n  vec4 centerValue = getTextureValue(centerPosIS);\\n  bool pixelOnBorder = false;\\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\\n\\n  // Get alpha of segment from opacity function.\\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n  int segmentIndex = int(centerValue.r * 255.0);\\n  \\n  // Use texture sampling for outlineThickness\\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\\n\\n  int actualThickness = int(textureValue * 255.0);\\n\\n  if (actualThickness == 0) {\\n    return vec4(0, 0, 1, 1);\\n  }\\n\\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\\n  // Saves a bunch of needless checks on the background.\\n  // TODO define epsilon when building shader?\\n  if (float(tColor.a) > 0.01) {\\n    for (int i = -actualThickness; i <= actualThickness; i++) {\\n      for (int j = -actualThickness; j <= actualThickness; j++) {\\n        if (i == 0 || j == 0) {\\n          continue;\\n        }\\n\\n        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n          gl_FragCoord.y + float(j),\\n          gl_FragCoord.z, gl_FragCoord.w);\\n\\n        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n        vec4 value = getTextureValue(neighborPosIS);\\n\\n        // If any of my neighbours are not the same value as I\\n        // am, this means I am on the border of the segment.\\n        // We can break the loops\\n        if (any(notEqual(value, centerValue))) {\\n          pixelOnBorder = true;\\n          break;\\n        }\\n      }\\n\\n      if (pixelOnBorder == true) {\\n        break;\\n      }\\n    }\\n\\n    // If I am on the border, I am displayed at full opacity\\n    if (pixelOnBorder == true) {\\n      tColor.a = outlineOpacity;\\n    }\\n  }\\n\\n#else\\n  // compute the normal and gradient magnitude if needed\\n  // We compute it as a vec4 if possible otherwise a mat4\\n  //\\n  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);\\n\\n  // compute the normal vectors as needed\\n  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\\n      #if !defined(vtkComponent0Proportional)\\n        vec4 normal0 = normalMat[0];\\n      #endif\\n      #if !defined(vtkComponent1Proportional)\\n        vec4 normal1 = normalMat[1];\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          vec4 normal2 = normalMat[2];\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            vec4 normal3 = normalMat[3];\\n          #endif\\n        #endif\\n      #endif\\n    #else\\n      vec4 normalLight;\\n      #ifdef vtkComputeNormalFromOpacity\\n        vec3 scalarInterp[2];\\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp);\\n        if (length(normal0)>0.0){\\n          #ifdef vtkGradientOpacityOn\\n            normalLight = computeDensityNormal(normal0.w, scalarInterp);\\n          #else\\n            normalLight = computeDensityNormal(scalarInterp);\\n          #endif\\n          if (length(normalLight) == 0.0){\\n            normalLight = normal0;\\n          }\\n        }\\n      #else\\n        vec4 normal0 = computeNormal(posIS, tstep);\\n        normalLight = normal0;\\n      #endif\\n    #endif\\n  #endif\\n\\n  // compute gradient opacity factors as needed\\n  #if defined(vtkGradientOpacityOn)\\n    #if !defined(vtkComponent0Proportional)\\n      goFactor.x =\\n        computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      #if !defined(vtkComponent1Proportional)\\n        goFactor.y =\\n          computeGradientOpacityFactor(normal1.a, goscale1, goshift1, gomin1, gomax1);\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          goFactor.z =\\n            computeGradientOpacityFactor(normal2.a, goscale2, goshift2, gomin2, gomax2);\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            goFactor.w =\\n              computeGradientOpacityFactor(normal3.a, goscale3, goshift3, gomin3, gomax3);\\n          #endif\\n        #endif\\n      #endif\\n    #endif\\n  #endif\\n\\n  // single component is always independent\\n  #if vtkNumComponents == 1\\n    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n    if (tColor.a < EPSILON){\\n      return vec4(0.0);\\n    }\\n  #endif\\n\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));\\n    #if !defined(vtkComponent0Proportional)\\n      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n      tColor *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));\\n    #endif\\n\\n    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\\n    #if !defined(vtkComponent1Proportional)\\n      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n      tColor1 *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));\\n    #endif\\n\\n    #if vtkNumComponents >= 3\\n      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\\n      #if !defined(vtkComponent2Proportional)\\n        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n      #else\\n        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n        tColor2 *= pwfValue;\\n        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));\\n      #endif\\n\\n      #if vtkNumComponents >= 4\\n        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\\n        #if !defined(vtkComponent3Proportional)\\n          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n        #else\\n          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n          tColor3 *= pwfValue;\\n          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));\\n        #endif\\n      #endif\\n    #endif\\n  #else // then not independent\\n\\n  #if vtkNumComponents == 2\\n    float lum = tValue.r * cscale0 + cshift0;\\n    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\\n    vec4 tColor = vec4(lum, lum, lum, alpha);\\n  #endif\\n  #if vtkNumComponents == 3\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\\n  #endif\\n  #if vtkNumComponents == 4\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\\n  #endif\\n  #endif // dependent\\n\\n  // apply lighting if requested as appropriate\\n  #if vtkLightComplexity > 0\\n    #if !defined(vtkComponent0Proportional)\\n      #if vtkNumComponents == 1\\n        #ifdef SurfaceShadowOn\\n            #if vtkLightComplexity < 3\\n                vec3 tColorS = applyLightingDirectional(posIS, tColor, normalLight);\\n            #else\\n                vec3 tColorS = applyLightingPositional(posIS, tColor, normalLight, IStoVC(posIS));\\n            #endif\\n        #endif\\n\\n        #ifdef VolumeShadowOn\\n          vec3 tColorVS = applyShadowRay(tColor.rgb, posIS, rayDirVC);\\n          #ifdef SurfaceShadowOn\\n            float vol_coef = volumetricScatteringBlending * (1.0 - tColor.a / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\\n            tColor.rgb = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\\n          #else\\n            tColor.rgb = tColorVS;\\n          #endif\\n        #else\\n            tColor.rgb = tColorS;\\n        #endif\\n\\n      #else\\n        applyLighting(tColor.rgb, normal0);\\n      #endif\\n    #endif\\n\\n    #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n      #if !defined(vtkComponent1Proportional)\\n        applyLighting(tColor1, normal1);\\n      #endif\\n    #if vtkNumComponents >= 3\\n      #if !defined(vtkComponent2Proportional)\\n        applyLighting(tColor2, normal2);\\n      #endif\\n    #if vtkNumComponents >= 4\\n      #if !defined(vtkComponent3Proportional)\\n        applyLighting(tColor3, normal3);\\n      #endif\\n    #endif\\n    #endif\\n    #endif\\n  #endif\\n\\n// perform final independent blend as needed\\n#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n  tColor.rgb += tColor1;\\n#if vtkNumComponents >= 3\\n  tColor.rgb += tColor2;\\n#if vtkNumComponents >= 4\\n  tColor.rgb += tColor3;\\n#endif\\n#endif\\n#endif\\n\\n#endif\\nreturn tColor;\\n}\\n\\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\\n  bool withinRange = false;\\n  #if vtkNumComponents == 1\\n    if (val.r >= min.r && val.r <= max.r) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2\\n     if (val.r >= min.r && val.r <= max.r &&\\n        val.g >= min.g && val.g <= max.g) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3\\n    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\\n        all(lessThanEqual(val, ipScalarRangeMax))) {\\n      withinRange = true;\\n    }\\n  #endif\\n  return withinRange;\\n}\\n\\n//=======================================================================\\n// Apply the specified blend mode operation along the ray's path.\\n//\\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\\n{\\n  vec3 tstep = 1.0/tdims;\\n\\n  // start slightly inside and apply some jitter\\n  vec3 delta = endIS - posIS;\\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\\n  float raySteps = length(delta)/sampleDistanceIS;\\n\\n  // avoid 0.0 jitter\\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\\n  float stepsTraveled = jitter;\\n\\n  // local vars for the loop\\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\\n  vec4 tValue;\\n  vec4 tColor;\\n\\n  // if we have less than one step then pick the middle point\\n  // as our value\\n  // if (raySteps <= 1.0)\\n  // {\\n  //   posIS = (posIS + endIS)*0.5;\\n  // }\\n\\n  // Perform initial step at the volume boundary\\n  // compute the scalar\\n  tValue = getTextureValue(posIS);\\n\\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\\n    // now map through opacity and color\\n    tColor = getColorForValue(tValue, posIS, tstep);\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\\n      gl_FragData[0] = tColor;\\n      return;\\n    }\\n\\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n\\n      float mix = (1.0 - color.a);\\n\\n      // this line should not be needed but nvidia seems to not handle\\n      // the break correctly on windows/chrome 58 angle\\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\\n\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n      stepsTraveled++;\\n      posIS += stepIS;\\n      if (color.a > 0.99) { color.a = 1.0; break; }\\n    }\\n\\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\\n    {\\n      posIS = endIS;\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\\n\\n      float mix = (1.0 - color.a);\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n    }\\n\\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\\n  #endif\\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\\n    // Find maximum/minimum intensity along the ray.\\n\\n    // Define the operation we will use (min or max)\\n    #if vtkBlendMode == 1\\n    #define OP max\\n    #else\\n    #define OP min\\n    #endif\\n\\n    // If the clipping range is shorter than the sample distance\\n    // we can skip the sampling loop along the ray.\\n    if (raySteps <= 1.0)\\n    {\\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\\n      return;\\n    }\\n\\n    vec4 value = tValue;\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // Update the maximum value if necessary\\n      value = OP(tValue, value);\\n\\n      // Otherwise, continue along the ray\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n    tValue = getTextureValue(posIS);\\n    value = OP(tValue, value);\\n\\n    // Now map through opacity and color\\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\\n    vec4 sum = vec4(0.);\\n\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n    }\\n\\n    if (raySteps <= 1.0) {\\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\\n      // Notes:\\n      // - We are comparing all values in the texture to see if any of them\\n      //   are outside of the scalar range. In the future we might want to allow\\n      //   scalar ranges for each component.\\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n        // Sum the values across each step in the path\\n        sum += tValue;\\n      }\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n\\n    // compute the scalar\\n    tValue = getTextureValue(posIS);\\n\\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n\\n      stepsTraveled++;\\n    }\\n\\n    #if vtkBlendMode == 3 // Average\\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\\n    #endif\\n\\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 5 // RADON\\n    float normalizedRayIntensity = 1.0;\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tValue = getTextureValue(posIS);\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar value\\n      tValue = getTextureValue(posIS);\\n\\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n      posIS += stepIS;\\n      stepsTraveled++;\\n    }\\n\\n    // map normalizedRayIntensity to color\\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\\n\\n  #endif\\n}\\n\\n//=======================================================================\\n// Compute a new start and end point for a given ray based\\n// on the provided bounded clipping plane (aka a rectangle)\\nvoid getRayPointIntersectionBounds(\\n  vec3 rayPos, vec3 rayDir,\\n  vec3 planeDir, float planeDist,\\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\\n  float vSize1, float vSize2)\\n{\\n  float result = dot(rayDir, planeDir);\\n  if (abs(result) < 1e-6)\\n  {\\n    return;\\n  }\\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\\n  vec3 xposVC = rayPos + rayDir*result;\\n  vec3 vxpos = xposVC - vOriginVC;\\n  vec2 vpos = vec2(\\n    dot(vxpos, vPlaneX),\\n    dot(vxpos, vPlaneY));\\n\\n  // on some apple nvidia systems this does not work\\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\\n  //     vpos.y < 0.0 || vpos.y > vSize2)\\n  // even just\\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\\n  // fails\\n  // so instead we compute a value that represents in and out\\n  //and then compute the return using this value\\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\\n\\n  tbounds = mix(\\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\\n   tbounds, // out value\\n   check);  // 0 in 1 out\\n}\\n\\n//=======================================================================\\n// given a\\n// - ray direction (rayDir)\\n// - starting point (vertexVCVSOutput)\\n// - bounding planes of the volume\\n// - optionally depth buffer values\\n// - far clipping plane\\n// compute the start/end distances of the ray we need to cast\\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\\n{\\n  vec2 dists = vec2(100.0*camFar, -1.0);\\n\\n  vec3 vSize = vSpacing*tdims;\\n\\n  // all this is in View Coordinates\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n\\n  //VTK::ClipPlane::Impl\\n\\n  // do not go behind front clipping plane\\n  dists.x = max(0.0,dists.x);\\n\\n  // do not go PAST far clipping plane\\n  float farDist = -camThick/rayDir.z;\\n  dists.y = min(farDist,dists.y);\\n\\n  // Do not go past the zbuffer value if set\\n  // This is used for intermixing opaque geometry\\n  //VTK::ZBuffer::Impl\\n\\n  return dists;\\n}\\n\\n//=======================================================================\\n// Compute the index space starting position (pos) and end\\n// position\\n//\\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\\n{\\n  // compute starting and ending values in volume space\\n  pos = vertexVCVSOutput + dists.x*rayDir;\\n  pos = pos - vOriginVC;\\n  // convert to volume basis and origin\\n  pos = vec3(\\n    dot(pos, vPlaneNormal0),\\n    dot(pos, vPlaneNormal2),\\n    dot(pos, vPlaneNormal4));\\n\\n  endPos = vertexVCVSOutput + dists.y*rayDir;\\n  endPos = endPos - vOriginVC;\\n  endPos = vec3(\\n    dot(endPos, vPlaneNormal0),\\n    dot(endPos, vPlaneNormal2),\\n    dot(endPos, vPlaneNormal4));\\n\\n  float delta = length(endPos - pos);\\n\\n  pos *= vVCToIJK;\\n  endPos *= vVCToIJK;\\n\\n  float delta2 = length(endPos - pos);\\n  sampleDistanceIS = sampleDistance*delta2/delta;\\n  #ifdef VolumeShadowOn\\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\\n  #endif\\n}\\n\\nvoid main()\\n{\\n\\n  if (cameraParallel == 1)\\n  {\\n    // Camera is parallel, so the rayDir is just the direction of the camera.\\n    rayDirVC = vec3(0.0, 0.0, -1.0);\\n  } else {\\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\\n    rayDirVC = normalize(vertexVCVSOutput);\\n  }\\n\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n  // compute the start and end points for the ray\\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\\n\\n  // do we need to composite? aka does the ray have any length\\n  // If not, bail out early\\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\\n  {\\n    discard;\\n  }\\n\\n  // IS = Index Space\\n  vec3 posIS;\\n  vec3 endIS;\\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\\n\\n  // Perform the blending operation along the ray\\n  applyBlend(posIS, endIS, tdims);\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Fragment;o.getProperty().getInterpolationType()===wg.LINEAR&&(a=cd.substitute(a,&quot;//VTK::TrilinearOn&quot;,&quot;#define vtkTrilinearOn&quot;).result),!0===o.getProperty().getUseLabelOutline()&&(a=cd.substitute(a,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result);const i=t.scalarTexture.getComponents();a=cd.substitute(a,&quot;//VTK::NumComponents&quot;,`#define vtkNumComponents ${i}`).result;const s=o.getProperty().getIndependentComponents();if(s){a=cd.substitute(a,&quot;//VTK::IndependentComponentsOn&quot;,&quot;#define vtkIndependentComponentsOn&quot;).result;const e=[];for(let t=0;t<i;t++)o.getProperty().getOpacityMode(t)===Pg.PROPORTIONAL&&e.push(`#define vtkComponent${t}Proportional`);e.length>0&&(a=cd.substitute(a,&quot;//VTK::vtkProportionalComponents&quot;,e.join(&quot;\\n&quot;)).result)}const l=t.currentInput.getSpatialExtent(),c=t.currentInput.getSpacing(),u=new Float64Array(3);In(u,(l[1]-l[0])*c[0],(l[3]-l[2])*c[1],(l[5]-l[4])*c[2]);const d=Sn(u)/e.getCurrentSampleDistance(r);a=cd.substitute(a,&quot;//VTK::MaximumSamplesValue&quot;,`${Math.ceil(d)}`).result,a=cd.substitute(a,&quot;//VTK::LightComplexity&quot;,`#define vtkLightComplexity ${t.lastLightComplexity}`).result,t.lastLightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(a=cd.substitute(a,&quot;//VTK::VolumeShadowOn&quot;,&quot;#define VolumeShadowOn&quot;).result),t.renderable.getVolumetricScatteringBlending()<1&&(a=cd.substitute(a,&quot;//VTK::SurfaceShadowOn&quot;,&quot;#define SurfaceShadowOn&quot;).result),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0&&(a=cd.substitute(a,&quot;//VTK::localAmbientOcclusionOn&quot;,&quot;#define localAmbientOcclusionOn&quot;).result)),t.gopacity=o.getProperty().getUseGradientOpacity(0);for(let e=1;s&&!t.gopacity&&e<i;++e)o.getProperty().getUseGradientOpacity(e)&&(t.gopacity=!0);t.gopacity&&(a=cd.substitute(a,&quot;//VTK::GradientOpacityOn&quot;,&quot;#define vtkGradientOpacityOn&quot;).result),t.renderable.getComputeNormalFromOpacity()&&(a=cd.substitute(a,&quot;//VTK::vtkComputeNormalFromOpacity&quot;,&quot;#define vtkComputeNormalFromOpacity&quot;).result),null!==t.zBufferTexture&&(a=cd.substitute(a,&quot;//VTK::ZBuffer::Dec&quot;,[&quot;uniform sampler2D zBufferTexture;&quot;,&quot;uniform float vpZWidth;&quot;,&quot;uniform float vpZHeight;&quot;]).result,a=cd.substitute(a,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));&quot;,&quot;float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;&quot;,&quot;zdepth = zdepth * 2.0 - 1.0;&quot;,&quot;if (cameraParallel == 0) {&quot;,&quot;zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}&quot;,&quot;else {&quot;,&quot;zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\\n&quot;,&quot;zdepth = -zdepth/rayDir.z;&quot;,&quot;dists.y = min(zdepth,dists.y);&quot;]).result),a=cd.substitute(a,&quot;//VTK::BlendMode&quot;,`${t.renderable.getBlendMode()}`).result,n.Fragment=a,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lastLightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[&quot;uniform int lightNum;&quot;,&quot;uniform bool twoSidedLighting;&quot;,`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,&quot;//VTK::Light::Dec&quot;],!1).result,3===t.lastLightComplexity&&(o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=cd.substitute(o,&quot;//VTK::VolumeShadow::Dec&quot;,[&quot;uniform float volumetricScatteringBlending;&quot;,&quot;uniform float giReach;&quot;,&quot;uniform float volumeShadowSamplingDistFactor;&quot;,&quot;uniform float anisotropy;&quot;,&quot;uniform float anisotropy2;&quot;],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=cd.substitute(o,&quot;//VTK::LAO::Dec&quot;,[&quot;uniform int kernelRadius;&quot;,`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,&quot;uniform int kernelSize;&quot;],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=cd.substitute(o,&quot;//VTK::ClipPlane::Dec&quot;,[&quot;uniform vec3 vClipPlaneNormals[6];&quot;,&quot;uniform float vClipPlaneDistances[6];&quot;,&quot;uniform vec3 vClipPlaneOrigins[6];&quot;,&quot;uniform int clip_numPlanes;&quot;,&quot;//VTK::ClipPlane::Dec&quot;,&quot;#define vtkClippingPlanesOn&quot;],!1).result,o=cd.substitute(o,&quot;//VTK::ClipPlane::Impl&quot;,[`for(int i = 0; i < ${e}; i++) {`,&quot;  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);&quot;,&quot;  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];&quot;,&quot;  if (rayDirRatio == 0.0)&quot;,&quot;  {&quot;,&quot;    if (equationResult < 0.0) dists.x = dists.y;&quot;,&quot;    continue;&quot;,&quot;  }&quot;,&quot;  float result = -1.0 * equationResult / rayDirRatio;&quot;,&quot;  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);&quot;,&quot;  else dists.x = max(dists.x, result);&quot;,&quot;}&quot;,&quot;//VTK::ClipPlane::Impl&quot;],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{let a=0;o.getProperty().getShade()&&t.renderable.getBlendMode()===Rg.COMPOSITE_BLEND&&(a=0,t.numberOfLights=0,r.getLights().forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===a&&(a=1)),1===a&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(a=2),a<3&&e.getPositional()&&(a=3)})));let i=!1;t.lastLightComplexity!==a&&(t.lastLightComplexity=a,i=!0);const s=t.scalarTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=!1;const u=[];if(l){for(let e=0;e<s;e++)u.push(o.getProperty().getOpacityMode(e));u.length>0&&(c=!0)}const d=t.currentInput.getSpatialExtent(),p=t.currentInput.getSpacing(),f=new Float64Array(3);In(f,(d[1]-d[0])*p[0],(d[3]-d[2])*p[1],(d[5]-d[4])*p[2]);const g=Sn(f)/e.getCurrentSampleDistance(r),m={interpolationType:o.getProperty().getInterpolationType(),useLabelOutline:o.getProperty().getUseLabelOutline(),numComp:s,usesProportionalComponents:c,iComps:l,maxSamples:g,useGradientOpacity:o.getProperty().getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),proportionalComponents:u};return t.previousState&&t.previousState.interpolationType===m.interpolationType&&t.previousState.useLabelOutline===m.useLabelOutline&&t.previousState.numComp===m.numComp&&t.previousState.usesProportionalComponents===m.usesProportionalComponents&&t.previousState.iComps===m.iComps&&t.previousState.maxSamples===m.maxSamples&&t.previousState.useGradientOpacity===m.useGradientOpacity&&t.previousState.blendMode===m.blendMode&&function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(t.previousState.proportionalComponents,m.proportionalComponents)?!!(0===n.getProgram()?.getHandle()||i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||!!t.lastZBufferTexture!=!!t.zBufferTexture||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime())&&(t.lastZBufferTexture=t.zBufferTexture,!0):(t.previousState={...m},!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed(&quot;vertexDC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexDC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified()),a.setUniformi(&quot;texture1&quot;,t.scalarTexture.getTextureUnit()),a.setUniformf(&quot;sampleDistance&quot;,e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange(),l=[],c=[];for(let e=0;e<4;e++)l[e]=s[0]*i.dataComputedScale[e]+i.dataComputedOffset[e],c[e]=s[1]*i.dataComputedScale[e]+i.dataComputedOffset[e],l[e]=(l[e]-i.offset[e])/i.scale[e],c[e]=(c[e]-i.offset[e])/i.scale[e];if(a.setUniform4f(&quot;ipScalarRangeMin&quot;,l[0],l[1],l[2],l[3]),a.setUniform4f(&quot;ipScalarRangeMax&quot;,c[0],c[1],c[2],c[3]),null!==t.zBufferTexture){a.setUniformi(&quot;zBufferTexture&quot;,t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf(&quot;vpZWidth&quot;,e[0]),a.setUniformf(&quot;vpZHeight&quot;,e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf(&quot;camThick&quot;,c[1]-c[0]),s.setUniformf(&quot;camNear&quot;,c[0]),s.setUniformf(&quot;camFar&quot;,c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf(&quot;dcxmin&quot;,g),s.setUniformf(&quot;dcxmax&quot;,m),s.setUniformf(&quot;dcymin&quot;,v),s.setUniformf(&quot;dcymax&quot;,y),s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f(&quot;vSpacing&quot;,x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f(&quot;vOriginVC&quot;,p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Dg(`The number of steps required ${Math.ceil(A)} is larger than the\\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\\n        Please either change the\\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f(&quot;vVCToIJK&quot;,I[0],I[1],I[2]),s.setUniform3i(&quot;volumeDimensions&quot;,d[0],d[1],d[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf(&quot;texWidth&quot;,t.scalarTexture.getWidth()),s.setUniformf(&quot;texHeight&quot;,t.scalarTexture.getHeight()),s.setUniformi(&quot;xreps&quot;,e.xreps),s.setUniformi(&quot;xstride&quot;,e.xstride),s.setUniformi(&quot;ystride&quot;,e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*Dn(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(o.getProperty().getUseLabelOutline()){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf(&quot;vpWidth&quot;,u[0]),s.setUniformf(&quot;vpHeight&quot;,u[1]);const d=e.getRenderTargetOffset();s.setUniformf(&quot;vpOffsetX&quot;,d[0]/u[0]),s.setUniformf(&quot;vpOffsetY&quot;,d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix(&quot;PCVCMatrix&quot;,t.projectionToView),0===t.lastLightComplexity)return;let O=0;const R=[],M=[],D=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],D[0+3*O]=-.5*w[0],D[1+3*O]=-.5*w[1],D[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi(&quot;twoSidedLighting&quot;,r.getTwoSidedLighting()),s.setUniformi(&quot;lightNum&quot;,O),s.setUniform3fv(&quot;lightColor&quot;,R),s.setUniform3fv(&quot;lightDirectionVC&quot;,M),s.setUniform3fv(&quot;lightHalfAngleVC&quot;,D),3===t.lastLightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv(&quot;lightPositionVC&quot;,e),s.setUniform3fv(&quot;lightAttenuation&quot;,n),s.setUniformfv(&quot;lightConeAngle&quot;,o),s.setUniformfv(&quot;lightExponent&quot;,a),s.setUniformiv(&quot;lightPositional&quot;,i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf(&quot;giReach&quot;,t.renderable.getGlobalIlluminationReach()),s.setUniformf(&quot;volumetricScatteringBlending&quot;,t.renderable.getVolumetricScatteringBlending()),s.setUniformf(&quot;volumeShadowSamplingDistFactor&quot;,t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf(&quot;anisotropy&quot;,t.renderable.getAnisotropy()),s.setUniformf(&quot;anisotropy2&quot;,t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi(&quot;kernelSize&quot;,e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv(&quot;kernelSample&quot;,n),s.setUniformi(&quot;kernelRadius&quot;,t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi(&quot;ctexture&quot;,t.colorTexture.getTextureUnit()),o.setUniformi(&quot;otexture&quot;,t.opacityTexture.getTextureUnit()),o.setUniformi(&quot;jtexture&quot;,t.jitterTexture.getTextureUnit()),o.setUniformi(&quot;ttexture&quot;,t.labelOutlineThicknessTexture.getTextureUnit());const a=t.scalarTexture.getVolumeInfo(),i=r.getProperty(),s=t.scalarTexture.getComponents(),l=r.getProperty().getIndependentComponents();if(l&&s>=2)for(let e=0;e<s;e++)o.setUniformf(`mix${e}`,r.getProperty().getComponentWeight(e));for(let e=0;e<s;e++){const t=l?e:0,n=a.scale[e],r=i.getScalarOpacity(t).getRange(),s=n/(r[1]-r[0]),c=(a.offset[e]-r[0])/(r[1]-r[0]);o.setUniformf(`oshift${e}`,c),o.setUniformf(`oscale${e}`,s);const u=i.getRGBTransferFunction(t).getRange(),d=(a.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);o.setUniformf(`cshift${e}`,d),o.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(l)for(let e=0;e<s;++e){const t=a.scale[e];if(i.getUseGradientOpacity(e)){const n=i.getGradientOpacityMinimumOpacity(e),r=i.getGradientOpacityMaximumOpacity(e);o.setUniformf(`gomin${e}`,n),o.setUniformf(`gomax${e}`,r);const a=[i.getGradientOpacityMinimumValue(e),i.getGradientOpacityMaximumValue(e)];o.setUniformf(`goscale${e}`,t*(r-n)/(a[1]-a[0])),o.setUniformf(`goshift${e}`,-a[0]*(r-n)/(a[1]-a[0])+n)}else o.setUniformf(`gomin${e}`,1),o.setUniformf(`gomax${e}`,1),o.setUniformf(`goscale${e}`,0),o.setUniformf(`goshift${e}`,1)}else{const e=a.scale[s-1],t=i.getGradientOpacityMinimumOpacity(0),n=i.getGradientOpacityMaximumOpacity(0);o.setUniformf(&quot;gomin0&quot;,t),o.setUniformf(&quot;gomax0&quot;,n);const r=[i.getGradientOpacityMinimumValue(0),i.getGradientOpacityMaximumValue(0)];o.setUniformf(&quot;goscale0&quot;,e*(n-t)/(r[1]-r[0])),o.setUniformf(&quot;goshift0&quot;,-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===r.getProperty().getUseLabelOutline()){const e=r.getProperty().getLabelOutlineOpacity();o.setUniformf(&quot;outlineOpacity&quot;,e)}t.lastLightComplexity>0&&(o.setUniformf(&quot;vAmbient&quot;,i.getAmbient()),o.setUniformf(&quot;vDiffuse&quot;,i.getDiffuse()),o.setUniformf(&quot;vSpecular&quot;,i.getSpecular()),o.setUniformf(&quot;vSpecularPower&quot;,i.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*Dn(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv(&quot;vClipPlaneNormals&quot;,o),c.setUniformfv(&quot;vClipPlaneDistances&quot;,a),c.setUniform3fv(&quot;vClipPlaneOrigins&quot;,i),c.setUniformi(&quot;clip_numPlanes&quot;,l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===wg.NEAREST?(t.scalarTexture.setMinificationFilter(bd.NEAREST),t.scalarTexture.setMagnificationFilter(bd.NEAREST)):(t.scalarTexture.setMinificationFilter(bd.LINEAR),t.scalarTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null,null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;uniform vec2 tfactor;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),[&quot;//VTK::System::Dec&quot;,&quot;//VTK::Output::Dec&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { gl_FragData[0] = texture2D(texture1,tcoord); }&quot;].join(&quot;\\n&quot;),&quot;&quot;);const e=t.copyShader;t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in copy shader VAO.&quot;)}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi(&quot;texture&quot;,n.getTextureUnit()),t.copyShader.setUniform2f(&quot;tfactor&quot;,t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Eg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;t._scalars!==a&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=a);const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(bd.LINEAR),t.jitterTexture.setMagnificationFilter(bd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,ys.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=i.getIndependentComponents()?s:1,c=i.getScalarOpacity(),u=t._openGLRenderWindow.getGraphicsResourceForObject(c);let d=Vg(i,c,l);if(u.vtkObj&&u.hash===d&&t.opacityTextureString===d)t.opacityTexture=u.vtkObj,t.opacityTextureString=u.hash;else{const r=1024,o=2*r*l,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<l;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.releaseGraphicsResources(t._openGLRenderWindow),t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(bd.LINEAR),t.opacityTexture.setMagnificationFilter(bd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))t.opacityTexture.create2DFromRaw(r,2*l,1,ys.FLOAT,a);else{const e=new Uint8Array(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*l,1,ys.UNSIGNED_CHAR,e)}t.opacityTextureString=d,c&&t._openGLRenderWindow.setGraphicsResourceForObject(c,t.opacityTexture,t.opacityTextureString)}const p=i.getRGBTransferFunction();d=Vg(i,p,l);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===d&&t.colorTextureString===d)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(2*e*l*3),r=new Float32Array(3*e);for(let t=0;t<l;++t){const o=i.getRGBTransferFunction(t),a=o.getRange();o.getTable(a[0],a[1],e,r,1);for(let o=0;o<3*e;++o)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.create2DFromRaw(e,2*l,3,ys.UNSIGNED_CHAR,n),t.colorTextureString=d,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}e.updateLabelOutlineThicknessTexture(r);const g=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(d=`${o.getMTime()}A${a.getMTime()}`,g?.vtkObj&&g?.hash===d&&t.scalarTextureString===d)t.scalarTexture=g.vtkObj,t.scalarTextureString=g.hash;else{const e=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.scalarTexture.releaseGraphicsResources(t._openGLRenderWindow),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],a,t.renderable.getPreferSizeOverAccuracy()),t.scalarTextureString=d,a&&t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,t.scalarTextureString)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Es.newInstance({numberOfComponents:3,values:e});r.setName(&quot;points&quot;);const o=Es.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=e=>{const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}}}const Bg={context:null,VBOBuildTime:null,scalarTexture:null,scalarTextureString:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lastLightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0,_scalars:null};const Ng=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bg,n),Zt.extend(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),t.scalarTexture=Nd.newInstance(),t.opacityTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.jitterTexture=Nd.newInstance(),t.jitterTexture.setWrapS(Td.REPEAT),t.jitterTexture.setWrapT(Td.REPEAT),t.labelOutlineThicknessTexture=Nd.newInstance(),t.framebuffer=Hp.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,[&quot;context&quot;]),Lg(e,t)}),&quot;vtkOpenGLVolumeMapper&quot;);rn(&quot;vtkVolumeMapper&quot;,Ng);const{vtkDebugMacro:_g}=Kt;function Fg(e,t){t.classHierarchy.push(&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent();const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():_g(&quot;No framebuffer to save/restore&quot;);const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const kg={};const Gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kg,n),Zt.extend(e,t,n),Fg(e,t)}),&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;);rn(&quot;vtkPixelSpaceCallbackMapper&quot;,Gg);var Ug=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtktextureObjectVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\nattribute vec2 tcoordDC;\\nvarying vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  tcoordVC = tcoordDC;\\n  gl_Position = vertexDC;\\n}\\n&quot;;const{Representation:zg}=ds;function Wg(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Nd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,&quot;Float32Array&quot;,null),s.activate(),s.sendParameters(),s.deactivate(),s}function Hg(e,t){return Wg(e,t,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE)}function jg(e,t){t.classHierarchy.push(&quot;vtkLICPingPongBufferManager&quot;),t._openGLRenderWindow?(t.quad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,zg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=Hg(t._openGLRenderWindow,t.size),t.seedTexture0=Hg(t._openGLRenderWindow,t.size),t.licTexture1=Hg(t._openGLRenderWindow,t.size),t.seedTexture1=Hg(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?Wg(t._openGLRenderWindow,t.size,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return Wg(e,t,Nd.Filter.LINEAR,Nd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error(&quot;Pass renderwindow to ping pong manager&quot;)}const Kg={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function $g(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kg,n),jt.obj(e,t),jt.get(e,t,[&quot;readIndex&quot;]),jt.setGet(e,t,[&quot;doEEPass&quot;,&quot;doVTPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;vectorTexture&quot;,&quot;maskVectorTexture&quot;,&quot;noiseTexture&quot;,&quot;framebuffer&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),jg(e,t)}var qg={newInstance:jt.newInstance($g,&quot;vtkLICPingPongBufferManager&quot;),extend:$g};const Xg=0,Yg=1,Zg=2,Qg=3,Jg=1;function em(e,t){function n(e,t){e.setUniformi(&quot;texLIC&quot;,t.getLICTextureUnit()),e.setUniformi(&quot;texSeedPts&quot;,t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push(&quot;vtkLineIntegralConvolution2D&quot;),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Hp.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t=&quot;xyzw&quot;;return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n/**\\nThis shader initializes the convolution for the LIC computation.\\n*/\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texMaskVectors;\\nuniform sampler2D texNoise;\\nuniform sampler2D texLIC;\\n\\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the *whole* domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value. this\\n// depends on the pass number.\\nvec2 getNoiseTC(vec2 vectc)\\n{\\n  // in pass 1 : convert from vector tc to noise tc\\n  // in pass 2 : use vector tc\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(vectc);\\n    }\\n  else\\n    {\\n    return vectc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the\\n// need to convert to noise texture coordinates.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 vectc = tcoordVC.st;\\n\\n  // lic => (convolution, mask, 0, step count)\\n  if (uStepNo == 0)\\n    {\\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\\n    float maskFlag;\\n    if (maskCriteria <= uMaskThreshold)\\n      {\\n      maskFlag = 1.0;\\n      }\\n    else\\n      {\\n      maskFlag = 0.0;\\n      }\\n    float noise = getNoise(vectc);\\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = texture2D(texLIC, vectc);\\n    }\\n\\n  // initial seed\\n  SeedOutput = vec4(vectc, 0.0, 1.0);\\n}\\n&quot;);const n=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// move vector field to normalized image space\\n// pre-processing for vtkLineIntegralConvolution2D\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Fragment shader used by the gaussian blur filter render pass.\\n\\nuniform sampler2D texVectors; // input texture\\nuniform vec2      uTexSize;   // size of texture\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  //VTK::LICComponentSelection::Impl\\n  V = V/uTexSize;\\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\\n}\\n&quot;,&quot;//VTK::LICComponentSelection::Impl&quot;,`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D  texVectors;\\nuniform sampler2D  texNoise;\\nuniform sampler2D  texLIC;\\nuniform sampler2D  texSeedPts;\\n\\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\\nuniform float uStepSize;        // step size in parametric space\\n\\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n//VTK::LICVectorLookup::Impl\\n\\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\\n// are very poorly supported in webgl\\nvec2 clampToBorder(vec2 uv){\\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\\n  {\\n    return vec2(0.0, 0.0);\\n  }\\n  return getVector(uv);\\n}\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the whole domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value.\\n// in pass 1 repeatedly tile the noise texture across\\n// the computational domain.\\nvec2 getNoiseTC(vec2 tc)\\n{\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(tc);\\n    }\\n  else\\n    {\\n    return tc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the need\\n// to convert to either noise or lic texture coordinates in\\n// pass 1 and 2 respectively.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\n// fourth-order Runge-Kutta streamline integration\\n// no bounds checks are made, therefore it's essential\\n// to have the entire texture initialized to 0\\n// and set clamp to border and have border color 0\\n// an integer is set if the step was taken, keeping\\n// an accurate step count is necessary to prevent\\n// boundary artifacts. Don't count the step if\\n// all vector lookups are identically 0. This is\\n// a proxy for \\&quot;stepped outside valid domain\\&quot;\\nvec2 rk4(vec2 pt0, float dt, out bool count)\\n{\\n  count=true;\\n  float dtHalf = dt * 0.5;\\n  vec2 pt1;\\n\\n  vec2 v0 = clampToBorder(pt0);\\n  pt1 = pt0 + v0 * dtHalf;\\n\\n  vec2 v1 = clampToBorder(pt1);\\n  pt1 = pt0 + v1 * dtHalf;\\n\\n  vec2 v2 = clampToBorder(pt1);\\n  pt1 = pt0 + v2 * dt;\\n\\n  vec2 v3 = clampToBorder(pt1);\\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\\n\\n  if (vSum == vec2(0.0, 0.0))\\n    {\\n      count = false;\\n    }\\n\\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\\n\\n return pt1;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic = texture2D(texLIC, lictc);\\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\\n\\n  bool count;\\n  vec2 pt1 = rk4(pt0, uStepSize, count);\\n\\n  if (count)\\n    {\\n    // accumulate lic step\\n    // (lic, mask, 0, step count)\\n    float noise = getNoise(pt1);\\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\\n    SeedOutput = vec4(pt1, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    // keep existing values\\n    LICOutput = lic;\\n    SeedOutput = vec4(pt0, 0.0, 1.0);\\n    }\\n}\\n&quot;,&quot;//VTK::LICVectorLookup::Impl&quot;,function(){const e=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      vec2 V = texture2D( texVectors, vectc ).xy;\\n\\n      // normalize if |V| not 0\\n\\n      float lenV = length( V );\\n\\n      if ( lenV > 1.0e-8 )\\n\\n        {\\n\\n        return V/lenV;\\n\\n        }\\n\\n      else\\n\\n        {\\n\\n        return vec2( 0.0, 0.0 );\\n\\n        }\\n\\n      }\\n\\n    &quot;,t=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      return texture2D( texVectors, vectc ).xy;\\n\\n      }\\n\\n    &quot;;return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(&quot; //VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n/**\\nThis shader finalizes the convolution for the LIC computation\\napplying the normalization. eg. if box kernel is used the this\\nis the number of steps taken.\\n*/\\n\\nuniform sampler2D texLIC;\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\\n  conv.r = conv.r/conv.a;\\n  // lic => (convolution, mask, 0, 1)\\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.CEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// gray scale contrast enhance stage implemented via histogram stretching\\n// if the min and max are tweaked it can generate out-of-range values\\n// these will be clamped in 0 to 1\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n\\nuniform sampler2D texLIC;  // most recent lic pass\\nuniform float uMin;        // min gray scale color value\\nuniform float uMaxMinDiff; // max-min\\n\\nin vec2 tcoordVC;\\n\\nvoid main( void )\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g!=0.0)\\n    {\\n    LICOutput = lic;\\n    }\\n  else\\n    {\\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\\n    LICOutput = vec4(CElic, lic.gb, 1.0);\\n    }\\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.EEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\\n// noise for pass2.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 EEOutput;\\n\\nuniform sampler2D texLIC; // most recent lic pass\\nuniform float     uDx;    // fragment size\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// kernel for simple laplace edge enhancement.\\n// p=Laplace(p)+p\\nfloat K[9] = float[9](\\n  -1.0, -1.0, -1.0,\\n  -1.0,  9.0, -1.0,\\n  -1.0, -1.0, -1.0\\n  );\\n\\n// determine if the fragment was masked\\nbool Masked(float val) { return val != 0.0; }\\n\\nvoid main(void)\\n{\\n  // tex coord neighbor offsets\\n  vec2 fragDx[9] = vec2[9](\\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\\n    );\\n\\n  vec2 lictc = tcoordVC.st;\\n\\n  // compute the convolution but don't use convovled values if\\n  // any masked fragments on the stencil. Fragments outside\\n  // the valid domain are masked during initialization, and\\n  // texture wrap parameters are clamp to border with border\\n  // color that contains masked flag\\n  float conv = 0.0;\\n  bool dontUse = false;\\n  for (int i=0; i<9; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    vec4 lic = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic.g);\\n    conv = conv + K[i] * lic.r;\\n    }\\n\\n  if (dontUse)\\n    {\\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    conv = clamp(conv, 0.0, 1.0);\\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\\n    }\\n\\n}\\n&quot;),t.AAHProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// horizontal pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDx;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.AAVProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// vertical pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\\n\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDy[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;)},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;f&&o[0]===f.getSize()[0]&&o[1]===f.getSize()[1]||(f=Hp.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=qg.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const g=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],m=1/o[0],h=1/o[1],v=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;v.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f(&quot;uTexSize&quot;,...o),e.setUniformi(&quot;texVectors&quot;,t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,0),y.setUniformf(&quot;uMaskThreshold&quot;,t.maskThreshold),y.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),y.setUniformi(&quot;texMaskVectors&quot;,t.bufs.getMaskVectorTextureUnit()),y.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:T}=t;v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,0),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),T.setUniformi(&quot;texVectors&quot;,t.bufs.getImageVectorTextureUnit()),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:b}=t;if(v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),r(t.bufs,o,b),t.enhancedLIC){t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDx&quot;,m),a.setUniformf(&quot;uDy&quot;,h),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,1),n(y,t.bufs),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,1),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),b.setUniformi(&quot;texSeedPts&quot;,t.bufs.getSeedTextureUnit()),r(t.bufs,o,b)}if(t.antiAlias){const e=t.AAHProgram;v.readyShaderProgram(e),e.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),e.setUniformf(&quot;uDx&quot;,m);const a=t.AAVProgram;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDy&quot;,h);for(let i=0;i<t.antiAlias;++i)v.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),v.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error(&quot;Invalid color range: &quot;,i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),c.setUniformf(&quot;uMin&quot;,i),c.setUniformf(&quot;uMaxMinDiff&quot;,l),r(t.bufs,o,c)}}const tm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function nm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tm,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;nuberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;componentIds&quot;,&quot;isComposite&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),em(e,t)}var rm={newInstance:jt.newInstance(nm,&quot;vtkLineIntegralConvolution2D&quot;),extend:nm};function om(e,t){t.classHierarchy.push(&quot;vtkSurfaceLICInterface&quot;)}const am={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Xg,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:Jg,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function im(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,am,n),jt.obj(e,t),jt.setGet(e,t,[&quot;enableLIC&quot;,&quot;numberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;transformVectors&quot;,&quot;maskOnSurface&quot;,&quot;maskThreshold&quot;,&quot;maskColor&quot;,&quot;maskIntensity&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;noiseTextureSize&quot;,&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;noiseGeneratorSeed&quot;,&quot;viewPortScale&quot;,&quot;rebuildNoiseTexture&quot;]),om(0,t)}var sm={newInstance:jt.newInstance(im,&quot;vtkSurfaceLICInterface&quot;),extend:im};const{Representation:lm}=ds;function cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICInterface&quot;),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get(&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;);n=r===Jg?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Nd.newInstance({wrapS:Nd.Wrap.REPEAT,wrapT:Nd.Wrap.REPEAT,minificationFilter:Nd.Filter.NEAREST,magnificationFilter:Nd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,&quot;Float32Array&quot;,d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.allocateTextures=()=>{const n=Nd.Filter.NEAREST,r=Nd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Nd.newInstance({wrapS:Nd.Wrap.CLAMP_TO_EDGE,wrapT:Nd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,&quot;Float32Array&quot;,null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Nd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,&quot;Float32Array&quot;,null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=Hp.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader combines surface geometry, LIC, and  scalar colors.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 RGBOutput;\\nlayout(location = 1) out vec4 HSLOutput;\\n\\nuniform sampler2D texVectors;       // vectors, depth\\nuniform sampler2D texGeomColors;    // scalar colors + lighting\\nuniform sampler2D texLIC;           // image lic\\nuniform int       uScalarColorMode; // select between blend, and map shader\\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\\nuniform float     uMaskIntensity;   // blending factor for mask color\\nuniform vec3      uMaskColor;       // color for the masked out fragments\\n\\nin vec2 tcoordVC;\\n\\n/**\\nConvert from RGB color space into HSL colorspace.\\n*/\\nvec3 RGBToHSL(vec3 RGB)\\n{\\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\\n\\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\\n  float RGBMaxMinDiff = RGBMax - RGBMin;\\n\\n  HSL.z = (RGBMax + RGBMin) / 2.0;\\n\\n  if (RGBMaxMinDiff == 0.0)\\n    {\\n    // Gray scale\\n    HSL.x = 0.0;\\n    HSL.y = 0.0;\\n    }\\n  else\\n    {\\n    // Color\\n    if (HSL.z < 0.5)\\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\\n    else\\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\\n\\n    float dR\\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dG\\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dB\\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n\\n    if (RGB.r == RGBMax)\\n      HSL.x = dB - dG;\\n    else\\n    if (RGB.g == RGBMax)\\n      HSL.x = (1.0 / 3.0) + dR - dB;\\n    else\\n    if (RGB.b == RGBMax)\\n      HSL.x = (2.0 / 3.0) + dG - dR;\\n\\n    if (HSL.x < 0.0)\\n      HSL.x += 1.0;\\n\\n    if (HSL.x > 1.0)\\n      HSL.x -= 1.0;\\n    }\\n\\n  return HSL;\\n}\\n\\n/**\\nHelper for HSL to RGB conversion.\\n*/\\nfloat Util(float v1, float v2, float vH)\\n{\\n  if (vH < 0.0)\\n    vH += 1.0;\\n\\n  if (vH > 1.0)\\n     vH -= 1.0;\\n\\n  if ((6.0 * vH) < 1.0)\\n    return (v1 + (v2 - v1) * 6.0 * vH);\\n\\n  if ((2.0 * vH) < 1.0)\\n    return (v2);\\n\\n  if ((3.0 * vH) < 2.0)\\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\\n\\n  return v1;\\n}\\n\\n/**\\nConvert from HSL space into RGB space.\\n*/\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  if (HSL.y == 0.0)\\n    {\\n    // Gray\\n    RGB.r = HSL.z;\\n    RGB.g = HSL.z;\\n    RGB.b = HSL.z;\\n    }\\n  else\\n    {\\n    // Chromatic\\n    float v2;\\n    if (HSL.z < 0.5)\\n      v2 = HSL.z * (1.0 + HSL.y);\\n    else\\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\\n\\n    float v1 = 2.0 * HSL.z - v2;\\n\\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\\n    RGB.g = Util(v1, v2, HSL.x);\\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\\n    }\\n\\n  return RGB.rgb;\\n}\\n\\nvoid main()\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n\\n  // depth is used to determine which fragment belong to us\\n  // and we can change\\n  float depth = texture2D(texVectors, tcoordVC.st).a;\\n\\n  vec3 fragColorRGB;\\n  float valid;\\n  if (depth > 1.0e-3)\\n    {\\n    // we own it\\n    // shade LIC'ed geometry, or apply mask\\n    if (lic.g!=0.0)\\n      {\\n      // it's masked\\n      // apply fragment mask\\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\\n      valid = 0.0;\\n      }\\n    else\\n      {\\n      if (uScalarColorMode==0)\\n        {\\n        // blend with scalars\\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\\n        }\\n      else\\n        {\\n        // multiply with scalars\\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\\n        }\\n      if (lic.b != 0.0)\\n        {\\n        // didn't have the required guard pixels\\n        // don't consider it in min max estimation\\n        // for histpgram stretching\\n        valid = 0.0;\\n        }\\n      else\\n        {\\n        // ok to use in min/max estimates for histogram\\n        // stretching\\n        valid = 1.0;\\n        }\\n      }\\n    }\\n  else\\n    {\\n    // we don't own it\\n    // pass through scalars\\n    fragColorRGB = geomColor.rgb;\\n    valid = 0.0;\\n    }\\n\\n  // if no further stages this texture is\\n  // copied to the screen\\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\\n\\n  // if further stages, move to hsl space for contrast\\n  // enhancement. encoding validity saves moving a texture to the cpu\\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\\n  HSLOutput = vec4(fragColorHSL, valid);\\n}\\n&quot;),t.licCopyPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader copies fragments and depths to the output buffer\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texDepth;     // z values from vertex shader\\nuniform sampler2D texRGBColors; // final rgb LIC colors\\n\\nin vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\\n\\n  // since we render a screen aligned quad\\n  // we're going to be writing fragments\\n  // not touched by the original geometry\\n  // it's critical not to modify those\\n  // fragments.\\n  if (gl_FragDepth == 1.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;),t.enhanceContrastPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// color contrast enhance stage implemented via histogram stretching\\n// on lightness channel. if the min and max are tweaked it can generate\\n// out-of-range values these will be clamped in 0 to 1\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texGeomColors; // scalars + lighting\\nuniform sampler2D texLIC;        // image lic, mask\\nuniform sampler2D texHSLColors;  // hsla colors\\n\\nuniform float     uLMin;         // min lightness over all fragments\\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\\n\\nin vec2 tcoordVC;\\n\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  float v;\\n  float h = HSL.x;\\n  float sl = HSL.y;\\n  float l = HSL.z;\\n\\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\\n  if (v <= 0.0) {\\n    RGB = vec3(0.0,0.0,0.0);\\n  } else {\\n    float m;\\n    int sextant;\\n    float fract, vsf, mid1, mid2;\\n\\n    m = l + l - v;\\n    h *= 6.0;\\n    sextant = int(h);\\n    fract = h - float(sextant);\\n\\n    vsf = (v - m) * fract;\\n    mid1 = m + vsf;\\n    mid2 = v - vsf;\\n    switch (sextant) {\\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\\n    }\\n  }\\n  return RGB;\\n}\\n\\nvoid main()\\n{\\n  // lookup hsl color , mask\\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\\n\\n  // don't modify masked fragments (masked => lic.g==1)\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g==0.0)\\n    {\\n    // normalize lightness channel\\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\\n    }\\n\\n  // back into rgb space\\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\\n\\n  // add alpha\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n  fragColor.a = geomColor.a;\\n\\n  gl_FragData[0] = fragColor;\\n}\\n&quot;),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,lm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=rm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi(&quot;texDepth&quot;,t.depthTexture.getTextureUnit()),r.setUniformi(&quot;texRGBColors&quot;,t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi(&quot;texVectors&quot;,t.vectorImage.getTextureUnit()),o.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get(&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;maskIntensity&quot;,&quot;maskColor&quot;,&quot;enhanceContrast&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;);if(o.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),o.setUniformi(&quot;uScalarColorMode&quot;,a),o.setUniformf(&quot;uLICIntensity&quot;,i),o.setUniformf(&quot;uMapBias&quot;,s),o.setUniformf(&quot;uMaskIntensity&quot;,l),o.setUniform3f(&quot;uMaskColor&quot;,...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===Zg||u===Qg){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit()),s.setUniformi(&quot;texHSLColors&quot;,t.HSLColorImage.getTextureUnit()),s.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),s.setUniformf(&quot;uLMin&quot;,o),s.setUniformf(&quot;uLMaxMinDiff&quot;,i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get(&quot;stepSize&quot;,&quot;numberOfSteps&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;transformVectors&quot;),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error(&quot;Failed to compute image LIC&quot;),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const um={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function dm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,um,n),sm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;reallocateTextures&quot;,&quot;licInterface&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cm(e,t)}var pm={newInstance:jt.newInstance(dm,&quot;vtkSurfaceLICInterface&quot;),extend:dm};const{vtkErrorMacro:fm}=Kt;function gm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICMapper&quot;);const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=cd.substitute(s,&quot;//VTK::Output::Dec&quot;,[&quot;//VTK::Output::Dec&quot;,&quot;layout(location = 2) out vec4 vectorTexture;&quot;,&quot;layout(location = 3) out vec4 maskVectorTexture;&quot;]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,[`attribute vec3 ${n};`,&quot;out vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[`licOutput = ${n};`,&quot;//VTK::TCoord::Impl&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform int uMaskOnSurface;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;in vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Impl&quot;,[&quot;// projected vectors&quot;,&quot;  vec3 tcoordLIC = normalMatrix * licOutput;&quot;,&quot;  vec3 normN = normalize(normalVCVSOutput);&quot;,&quot;  float k = dot(tcoordLIC, normN);&quot;,&quot;  vec3 projected = (tcoordLIC - k*normN);&quot;,&quot;  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;// vectors for fragment masking&quot;,&quot;  if (uMaskOnSurface == 0)&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(licOutput, 1.0);&quot;,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;    }&quot;,&quot;//VTK::TCoord::Impl&quot;],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi(&quot;uMaskOnSurface&quot;,t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(fm(&quot;SurfaceLICMapper Requires WebGL 2&quot;),a=!1),t.context.getExtension(&quot;EXT_color_buffer_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)||(fm(&quot;SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions.&quot;),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(fm(&quot;No input&quot;),a=!1);let i=t.renderable.getLicInterface();i||(i=sm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=pm.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(fm(&quot;No vector input array&quot;),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const mm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const hm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mm,n),np.extend(e,t,n),gm(e,t),At(e,t,[&quot;openGLLicInterface&quot;])}),&quot;vtkOpenGLSurfaceLICMapper&quot;);rn(&quot;vtkSurfaceLICMapper&quot;,hm);const{vtkErrorMacro:vm}=Kt;function ym(e,t){t.classHierarchy.push(&quot;vtkOpenGLSphereMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkSphereMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Spheres\\n\\nattribute vec4 vertexMC;\\nattribute vec2 offsetMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\n\\nuniform int cameraParallel;\\nuniform float scaleFactor;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  // compute the projected vertex position\\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\\n\\n  // make the triangle face the camera\\n  if (cameraParallel == 0)\\n    {\\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\\n    vec3 base1 = cross(base2,dir);\\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\\n    }\\n  else\\n    {\\n    // add in the offset\\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\\n    }\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;\\n&quot;]).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform float invertedDepth;\\n&quot;,&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float b = 2.0*dot(EyePos,EyeDir);\\n&quot;,&quot;  float c = dot(EyePos,EyePos) - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t = (-b - invertedDepth*sqrt(d))*0.5;\\n&quot;,&quot;    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\\n&quot;,&quot;    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;offsetMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||vm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isUniformUsed(&quot;invertedDepth&quot;)&&e.getProgram().setUniformf(&quot;invertedDepth&quot;,t.invert?-1:1),e.getProgram().isUniformUsed(&quot;scaleFactor&quot;)){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf(&quot;scaleFactor&quot;,t.renderable.getScaleFactor()):e.getProgram().setUniformf(&quot;scaleFactor&quot;,1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),o.isUniformUsed(&quot;MCVCMatrix&quot;))if(r.getIsIdentity())o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,n)}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Tm={};const bm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tm,n),np.extend(e,t,n),ym(e,t)}),&quot;vtkOpenGLSphereMapper&quot;);rn(&quot;vtkSphereMapper&quot;,bm);const{vtkErrorMacro:xm}=Kt;function Cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLStickMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkStickMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Sticks\\n\\nattribute vec4 vertexMC;\\nattribute vec3 orientMC;\\nattribute vec4 offsetMC;\\nattribute float radiusMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying float lengthVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\nvarying vec3 orientVCVSOutput;\\n\\nuniform int cameraParallel;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = radiusMC;\\n  lengthVCVSOutput = length(orientMC);\\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\\n\\n  // make sure it is pointing out of the screen\\n  if (orientVCVSOutput.z < 0.0)\\n    {\\n    orientVCVSOutput = -orientVCVSOutput;\\n    }\\n\\n  // make the basis\\n  vec3 xbase;\\n  vec3 ybase;\\n  vec3 dir = vec3(0.0,0.0,1.0);\\n  if (cameraParallel == 0)\\n    {\\n    dir = normalize(-vertexVCVSOutput.xyz);\\n    }\\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\\n    {\\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\\n    ybase = cross(xbase,orientVCVSOutput);\\n    }\\n  else\\n    {\\n    xbase = normalize(cross(orientVCVSOutput,dir));\\n    ybase = cross(orientVCVSOutput,xbase);\\n    }\\n\\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\\n    radiusVCVSOutput*offsets.x*xbase +\\n    radiusVCVSOutput*offsets.y*ybase +\\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,&quot;varying vec4 vertexVCVSOutput;&quot;).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,&quot;  vec4 vertexVC = vertexVCVSOutput;\\n&quot;).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 orientVCVSOutput;\\n&quot;,&quot;varying float lengthVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  vec3 base1;\\n&quot;,&quot;  if (abs(orientVCVSOutput.z) < 0.99) {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\\n&quot;,&quot;  vec3 base2 = cross(orientVCVSOutput,base1);\\n&quot;,&quot;  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\\n&quot;,&quot;  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n&quot;,&quot;  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n&quot;,&quot;  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*a*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t =  (-b - sqrt(d))/(2.0*a);\\n&quot;,&quot;    float tz = EyePos.z + t*EyeDir.z;\\n&quot;,&quot;    vec3 iPoint = EyePos + t*EyeDir;\\n&quot;,&quot;    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\\n&quot;,&quot;      float t2 = (-b + sqrt(d))/(2.0*a);\\n&quot;,&quot;      float tz2 = EyePos.z + t2*EyeDir.z;\\n&quot;,&quot;      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\\n&quot;,&quot;      else {\\n&quot;,&quot;        normalVCVSOutput = orientVCVSOutput;\\n&quot;,&quot;        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\\n&quot;,&quot;        iPoint = EyePos + t3*EyeDir;\\n&quot;,&quot;        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;        }\\n&quot;,&quot;      }\\n&quot;,&quot;    else {\\n&quot;,&quot;      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\\n&quot;,&quot;      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;      }\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed(&quot;orientMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;orientMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||xm(&quot;Error setting 'orientMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),&quot;offsetMC&quot;,0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||xm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;radiusMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;radiusMC&quot;,24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||xm(&quot;Error setting 'radiusMC' in shader VAO.&quot;))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),r.getIsIdentity())o.isUniformUsed(&quot;MCVCMatrix&quot;)&&o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc),o.isUniformUsed(&quot;normalMatrix&quot;)&&o.setUniformMatrix3x3(&quot;normalMatrix&quot;,i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed(&quot;MCVCMatrix&quot;)){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,t)}if(o.isUniformUsed(&quot;normalMatrix&quot;)){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3(&quot;normalMatrix&quot;,t)}}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():xm([&quot;Error setting orientationArray.\\n&quot;,&quot;You have to specify the stick orientation&quot;]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,zu.ARRAY_BUFFER),a.getColorBO().upload(g,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Sm={};const Am=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sm,n),np.extend(e,t,n),Cm(e,t)}),&quot;vtkOpenGLStickMapper&quot;);rn(&quot;vtkStickMapper&quot;,Am);const Im=[];Im[&quot;-&quot;.charCodeAt(0)]=62,Im[&quot;_&quot;.charCodeAt(0)]=63;const wm=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;for(let e=0;e<wm.length;e++)Im[wm.charCodeAt(e)]=e;function Pm(e){return void 0!==Im[e.charCodeAt(0)]}function Om(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<18;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<12;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<6;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<10;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<4;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<2;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error(&quot;BASE64: remain 1 should not happen&quot;)}return u}function Rm(e,t,n){const r=(e<<16)+(t<<8)+n;return wm[r>>18]+wm[r>>12&63]+wm[r>>6&63]+wm[63&r]}function Mm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Rm(t[n],t[n+1],t[n+2])}if(n>0){const e=Rm(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join(&quot;&quot;)}var Dm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)Pm(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):&quot;=&quot;===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Om(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Em={};function Vm(e,t){Em[e]=t}var Lm=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;http&quot;,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Em[e](t)},Bm=Uint8Array,Nm=Uint16Array,_m=Uint32Array,Fm=new Bm([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),km=new Bm([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Gm=new Bm([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Um=function(e,t){for(var n=new Nm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new _m(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},zm=Um(Fm,2),Wm=zm[0],Hm=zm[1];Wm[28]=258,Hm[258]=28;for(var jm=Um(km,0),Km=jm[0],$m=(jm[1],new Nm(32768)),qm=0;qm<32768;++qm){var Xm=(43690&qm)>>>1|(21845&qm)<<1;Xm=(61680&(Xm=(52428&Xm)>>>2|(13107&Xm)<<2))>>>4|(3855&Xm)<<4,$m[qm]=((65280&Xm)>>>8|(255&Xm)<<8)>>>1}var Ym=function(e,t,n){for(var r=e.length,o=0,a=new Nm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Nm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Nm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[$m[d]>>>l]=c}else for(i=new Nm(r),o=0;o<r;++o)e[o]&&(i[o]=$m[s[e[o]-1]++]>>>15-e[o]);return i},Zm=new Bm(288);for(qm=0;qm<144;++qm)Zm[qm]=8;for(qm=144;qm<256;++qm)Zm[qm]=9;for(qm=256;qm<280;++qm)Zm[qm]=7;for(qm=280;qm<288;++qm)Zm[qm]=8;var Qm=new Bm(32);for(qm=0;qm<32;++qm)Qm[qm]=5;var Jm=Ym(Zm,9,1),eh=Ym(Qm,5,1),th=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},nh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},rh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},oh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Nm:4==e.BYTES_PER_ELEMENT?_m:Bm)(n-t);return r.set(e.subarray(t,n)),r},ah=[&quot;unexpected EOF&quot;,&quot;invalid block type&quot;,&quot;invalid length/literal&quot;,&quot;invalid distance&quot;,&quot;stream finished&quot;,&quot;no stream handler&quot;,,&quot;no callback&quot;,&quot;invalid UTF-8 data&quot;,&quot;extra field too long&quot;,&quot;date not in range 1980-2099&quot;,&quot;filename too long&quot;,&quot;stream finishing&quot;,&quot;invalid zip data&quot;],ih=function(e,t,n){var r=new Error(t||ah[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,ih),!n)throw r;return r},sh=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new Bm(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new Bm(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new Bm(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=nh(e,c,1);var h=nh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&ih(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=Jm,p=eh,f=9,g=5;else if(2==h){var T=nh(e,c,31)+257,b=nh(e,c+10,15)+4,x=T+nh(e,c+5,31)+1;c+=14;for(var C=new Bm(x),S=new Bm(19),A=0;A<b;++A)S[Gm[A]]=nh(e,c+3*A,7);c+=3*b;var I=th(S),w=(1<<I)-1,P=Ym(S,I,1);for(A=0;A<x;){var O,R=P[nh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,D=0;for(16==O?(D=3+nh(e,c,3),c+=2,M=C[A-1]):17==O?(D=3+nh(e,c,7),c+=3):18==O&&(D=11+nh(e,c,127),c+=7);D--;)C[A++]=M}}var E=C.subarray(0,T),V=C.subarray(T);f=th(E),g=th(V),d=Ym(E,f,1),p=Ym(V,g,1)}else ih(1);if(c>m){a&&ih(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[rh(e,c)&L])>>>4;if((c+=15&M)>m){a&&ih(0);break}if(M||ih(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Fm[A=_-257];F=nh(e,c,(1<<k)-1)+Wm[A],c+=k}var G=p[rh(e,c)&B],U=G>>>4;if(G||ih(3),c+=15&G,V=Km[U],U>3&&(k=km[U],V+=rh(e,c)&(1<<k)-1,c+=k),c>m){a&&ih(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:oh(t,0,u)},lh=new Bm(0),ch=function(e,t){return e[t]|e[t+1]<<8},uh=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},dh=function(e,t){return uh(e,t)+4294967296*uh(e,t+4)};function ph(e,t){return sh(e,t)}function fh(e,t){return sh(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||ih(6,&quot;invalid gzip data&quot;);var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new Bm((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function gh(e,t){return sh(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&ih(6,&quot;invalid zlib data&quot;),32&n[1]&&ih(6,&quot;invalid zlib data: preset dictionaries not supported&quot;),e.subarray(2,-4)),t);var n}function mh(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?fh(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?ph(e,t):gh(e,t)}var hh=&quot;undefined&quot;!=typeof TextEncoder&&new TextEncoder,vh=&quot;undefined&quot;!=typeof TextDecoder&&new TextDecoder;try{vh.decode(lh,{stream:!0})}catch(e){}function yh(e,t){if(t){for(var n=&quot;&quot;,r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(vh)return vh.decode(e);var o=function(e){for(var t=&quot;&quot;,n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,oh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&ih(8),a}var Th=function(e,t){return t+30+ch(e,t+26)+ch(e,t+28)},bh=function(e,t,n){var r=ch(e,t+28),o=yh(e.subarray(t+46,t+46+r),!(2048&ch(e,t+8))),a=t+46+r,i=uh(e,t+20),s=n&&4294967295==i?xh(e,a):[i,uh(e,t+24),uh(e,t+42)],l=s[0],c=s[1],u=s[2];return[ch(e,t+10),l,c,o,a+ch(e,t+30)+ch(e,t+32),u]},xh=function(e,t){for(;1!=ch(e,t);t+=4+ch(e,t+2));return[dh(e,t+12),dh(e,t+4),dh(e,t+20)]};function Ch(e,t){for(var n={},r=e.length-22;101010256!=uh(e,r);--r)(!r||e.length-r>65558)&&ih(13);var o=ch(e,r+8);if(!o)return{};var a=uh(e,r+16),i=4294967295==a;i&&(r=uh(e,r-12),101075792!=uh(e,r)&&ih(13),o=uh(e,r+32),a=uh(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=bh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Th(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=ph(e.subarray(h,h+d),new Bm(p)):ih(14,&quot;unknown compression type &quot;+u):n[f]=oh(e,h,h+d))}return n}function Sh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?&quot;LittleEndian&quot;:2712847316===n[0]?&quot;BigEndian&quot;:null}&quot;function&quot;==typeof queueMicrotask?queueMicrotask:&quot;function&quot;==typeof setTimeout&&setTimeout;var Ah=Sh(),Ih=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:wh,vtkDebugMacro:Ph}=jt;let Oh=0;function Rh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener(&quot;progress&quot;,n.progressCallback),r}const Mh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;);const s=Rh(&quot;GET&quot;,i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(Ph(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&wh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||&quot;string&quot;!==n.dataType?&quot;arraybuffer&quot;:&quot;text&quot;,s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(yh(mh(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&&quot;gz&quot;!==n.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(yh(mh(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&&quot;gz&quot;!==t.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Rh(&quot;GET&quot;,e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(mh(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType=&quot;arraybuffer&quot;,o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};Vm(&quot;http&quot;,(e=>Mh));const{vtkDebugMacro:Dh}=jt;function Eh(e,t){t.classHierarchy.push(&quot;vtkCamera&quot;);const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;);const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Gi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Gi(o,[...t.position,1],n),Gi(a,[...t.focalPoint,1],n),Gi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=Hi(e[0],e[1],e[2],e[3]),n=Ui(),r=Hi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],Wi(r,t,r),Wi(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error(&quot;Off-Axis projection is not supported at this time&quot;);{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=Ui();zi(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const Vh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Lh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vh,n),jt.obj(e,t),jt.get(e,t,[&quot;distance&quot;]),jt.setGet(e,t,[&quot;parallelProjection&quot;,&quot;useHorizontalViewAngle&quot;,&quot;viewAngle&quot;,&quot;parallelScale&quot;,&quot;useOffAxisProjection&quot;,&quot;freezeFocalPoint&quot;,&quot;physicalScale&quot;]),jt.getArray(e,t,[&quot;directionOfProjection&quot;,&quot;viewPlaneNormal&quot;,&quot;position&quot;,&quot;focalPoint&quot;]),jt.setGetArray(e,t,[&quot;clippingRange&quot;,&quot;windowCenter&quot;],2),jt.setGetArray(e,t,[&quot;viewUp&quot;,&quot;screenBottomLeft&quot;,&quot;screenBottomRight&quot;,&quot;screenTopRight&quot;,&quot;physicalTranslation&quot;,&quot;physicalViewUp&quot;,&quot;physicalViewNorth&quot;],3),Eh(e,t)}var Bh={newInstance:jt.newInstance(Lh,&quot;vtkCamera&quot;),extend:Lh};function Nh(e,t){t.classHierarchy.push(&quot;vtkLight&quot;);const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType(&quot;HeadLight&quot;)},e.setLightTypeToCameraLight=()=>{e.setLightType(&quot;CameraLight&quot;)},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType(&quot;SceneLight&quot;)},e.lightTypeIsHeadLight=()=>&quot;HeadLight&quot;===t.lightType,e.lightTypeIsSceneLight=()=>&quot;SceneLight&quot;===t.lightType,e.lightTypeIsCameraLight=()=>&quot;CameraLight&quot;===t.lightType}const _h={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:&quot;SceneLight&quot;,shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_h,n),jt.obj(e,t),jt.setGet(e,t,[&quot;intensity&quot;,&quot;switch&quot;,&quot;positional&quot;,&quot;exponent&quot;,&quot;coneAngle&quot;,&quot;coneFalloff&quot;,&quot;transformMatrix&quot;,&quot;lightType&quot;,&quot;shadowAttenuation&quot;,&quot;attenuationValues&quot;]),jt.setGetArray(e,t,[&quot;color&quot;,&quot;position&quot;,&quot;focalPoint&quot;,&quot;attenuationValues&quot;],3),Nh(e,t)}var kh={newInstance:jt.newInstance(Fh,&quot;vtkLight&quot;),extend:Fh,LIGHT_TYPES:[&quot;HeadLight&quot;,&quot;CameraLight&quot;,&quot;SceneLight&quot;]};const{vtkErrorMacro:Gh}=jt;function Uh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push(&quot;vtkViewport&quot;),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Gh(&quot;call displayToView on your view instead&quot;),e.viewToDisplay=()=>Gh(&quot;callviewtodisplay on your view instead&quot;),e.getSize=()=>Gh(&quot;call getSize on your View instead&quot;),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=(&quot;PickPropFrom&quot;,()=>Gh(&quot;vtkViewport::PickPropFrom - NOT IMPLEMENTED&quot;))}const zh={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function Wh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zh,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),jt.setGetArray(e,t,[&quot;viewport&quot;],4),jt.setGetArray(e,t,[&quot;background&quot;,&quot;background2&quot;],3),Uh(e,t)}var Hh={newInstance:jt.newInstance(Wh,&quot;vtkViewport&quot;),extend:Wh};const{vtkDebugMacro:jh,vtkErrorMacro:Kh,vtkWarningMacro:$h}=Kt;function qh(e){return()=>Kh(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function Xh(e,t){t.classHierarchy.push(&quot;vtkRenderer&quot;);const n={type:&quot;ComputeVisiblePropBoundsEvent&quot;,renderer:e},r={type:&quot;ResetCameraClippingRangeEvent&quot;,renderer:e},o={type:&quot;ResetCameraEvent&quot;,renderer:e};e.updateCamera=()=>(t.activeCamera||(jh(&quot;No cameras are on, creating one.&quot;),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Kh(&quot;light has unknown light type&quot;,e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=qh(&quot;allocateTime&quot;),e.updateGeometry=qh(&quot;updateGeometry&quot;),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{jh(e.getClassName(),e,&quot;setting Layer to &quot;,n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:&quot;ActiveCameraEvent&quot;,camera:n}),!0),e.makeCamera=()=>{const t=Bh.newInstance();return e.invokeEvent({type:&quot;CreateCameraEvent&quot;,camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=kh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;WorldToView: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=ki.INIT_BOUNDS[0],t.allBounds[1]=ki.INIT_BOUNDS[1],t.allBounds[2]=ki.INIT_BOUNDS[2],t.allBounds[3]=ki.INIT_BOUNDS[3],t.allBounds[4]=ki.INIT_BOUNDS[4],t.allBounds[5]=ki.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),jh(&quot;Can't compute bounds, no 3D props are visible&quot;)),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return jh(&quot;Cannot reset camera!&quot;),!1;let i=null;if(!e.getActiveCamera())return Kh(&quot;Trying to reset non-existent camera&quot;),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&($h(&quot;Resetting view-up since view plane normal is parallel&quot;),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return jh(&quot;Cannot reset camera clipping range!&quot;),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Kh(&quot;Trying to reset clipping range of non-existent camera&quot;),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const Yh={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Zh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Yh,n),Hh.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,[&quot;_renderWindow&quot;,&quot;allocatedRenderTime&quot;,&quot;timeFactor&quot;,&quot;lastRenderTimeInSeconds&quot;,&quot;numberOfPropsRendered&quot;,&quot;lastRenderingUsedDepthPeeling&quot;,&quot;selector&quot;]),At(e,t,[&quot;twoSidedLighting&quot;,&quot;lightFollowCamera&quot;,&quot;automaticLightCreation&quot;,&quot;erase&quot;,&quot;draw&quot;,&quot;nearClippingPlaneTolerance&quot;,&quot;clippingRangeExpansion&quot;,&quot;backingStore&quot;,&quot;interactive&quot;,&quot;layer&quot;,&quot;preserveColorBuffer&quot;,&quot;preserveDepthBuffer&quot;,&quot;useDepthPeeling&quot;,&quot;occlusionRatio&quot;,&quot;maximumNumberOfPeels&quot;,&quot;delegate&quot;,&quot;backgroundTexture&quot;,&quot;texturedBackground&quot;,&quot;environmentTexture&quot;,&quot;environmentTextureDiffuseStrength&quot;,&quot;environmentTextureSpecularStrength&quot;,&quot;useEnvironmentTextureAsBackground&quot;,&quot;useShadows&quot;,&quot;pass&quot;]),It(e,t,[&quot;actors&quot;,&quot;volumes&quot;,&quot;lights&quot;]),Pt(e,t,[&quot;background&quot;],4,1),Ot(0,t,[&quot;renderWindow&quot;]),Xh(e,t)}var Qh={newInstance:Et(Zh,&quot;vtkRenderer&quot;),extend:Zh};const Jh=Object.create(null);function ev(e,t){Jh[e]=t}function tv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Jh[e]&&Jh[e](t)}function nv(e,t){t.classHierarchy.push(&quot;vtkRenderWindow&quot;),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return tv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6;const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join(&quot;\\n&quot;),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))}}const rv={defaultViewAPI:&quot;WebGL&quot;,renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1};function ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rv,n),jt.obj(e,t),jt.setGet(e,t,[&quot;interactor&quot;,&quot;numberOfLayers&quot;,&quot;_views&quot;,&quot;defaultViewAPI&quot;]),jt.get(e,t,[&quot;neverRendered&quot;]),jt.getArray(e,t,[&quot;renderers&quot;]),jt.moveToProtected(e,t,[&quot;views&quot;]),jt.event(e,t,&quot;completion&quot;),nv(e,t)}var av={newInstance:jt.newInstance(ov,&quot;vtkRenderWindow&quot;),extend:ov,registerViewConstructor:ev,listViewAPIs:function(){return Object.keys(Jh)},newAPISpecificView:tv};const iv={Unknown:0,LeftController:1,RightController:2},sv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var lv={Device:iv,Input:sv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:cv,Input:uv}=lv,{vtkWarningMacro:dv,vtkErrorMacro:pv,normalizeWheel:fv,vtkOnceErrorMacro:gv}=jt,mv={ctrlKey:!1,altKey:!1,shiftKey:!1},hv={&quot;xr-standard&quot;:[uv.Trigger,uv.Grip,uv.TrackPad,uv.Thumbstick,uv.A,uv.B]},vv=[&quot;StartAnimation&quot;,&quot;Animation&quot;,&quot;EndAnimation&quot;,&quot;PointerEnter&quot;,&quot;PointerLeave&quot;,&quot;MouseEnter&quot;,&quot;MouseLeave&quot;,&quot;StartMouseMove&quot;,&quot;MouseMove&quot;,&quot;EndMouseMove&quot;,&quot;LeftButtonPress&quot;,&quot;LeftButtonRelease&quot;,&quot;MiddleButtonPress&quot;,&quot;MiddleButtonRelease&quot;,&quot;RightButtonPress&quot;,&quot;RightButtonRelease&quot;,&quot;KeyPress&quot;,&quot;KeyDown&quot;,&quot;KeyUp&quot;,&quot;StartMouseWheel&quot;,&quot;MouseWheel&quot;,&quot;EndMouseWheel&quot;,&quot;StartPinch&quot;,&quot;Pinch&quot;,&quot;EndPinch&quot;,&quot;StartPan&quot;,&quot;Pan&quot;,&quot;EndPan&quot;,&quot;StartRotate&quot;,&quot;Rotate&quot;,&quot;EndRotate&quot;,&quot;Button3D&quot;,&quot;Move3D&quot;,&quot;StartPointerLock&quot;,&quot;EndPointerLock&quot;,&quot;StartInteraction&quot;,&quot;Interaction&quot;,&quot;EndInteraction&quot;,&quot;AnimationFrameRateUpdate&quot;];function yv(e){e.cancelable&&e.preventDefault()}function Tv(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function bv(e,t){t.classHierarchy.push(&quot;vtkRenderWindowInteractor&quot;);const n=new Set,r=new Map;let o=1;function a(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{pv(&quot;you want to call setView(view) instead of setRenderWindow on a vtk.js interactor&quot;)},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>dv(&quot;empty event loop&quot;),e.getCurrentRenderer=()=>(t.currentRenderer||a(0,0),t.currentRenderer);const i=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),o=n.getBoundingClientRect(),i=n.width/o.width,s=n.height/o.height,l={x:i*(e.clientX-o.left),y:s*(o.height-e.clientY+o.top),z:0};return(r.size<=1||!t.currentRenderer)&&a(l.x,l.y),l};function s(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function l(e){const t=s(e);return{key:e.key,keyCode:e.charCode,...t}}function c(e){return e.pointerType||&quot;&quot;}function u(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.bindEvents=n=>{t.container=n,n.addEventListener(&quot;contextmenu&quot;,yv),n.addEventListener(&quot;wheel&quot;,e.handleWheel),n.addEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.addEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.addEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.addEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.addEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.addEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.addEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.addEventListener(&quot;keypress&quot;,e.handleKeyPress),document.addEventListener(&quot;keydown&quot;,e.handleKeyDown),document.addEventListener(&quot;keyup&quot;,e.handleKeyUp),document.addEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),n.style.touchAction=&quot;none&quot;,n.style.userSelect=&quot;none&quot;,n.style.webkitTapHighlightColor=&quot;rgba(0,0,0,0)&quot;},e.unbindEvents=()=>{const{container:n}=t;n.removeEventListener(&quot;contextmenu&quot;,yv),n.removeEventListener(&quot;wheel&quot;,e.handleWheel),n.removeEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.removeEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.removeEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.removeEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.removeEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.removeEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.removeEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.removeEventListener(&quot;keypress&quot;,e.handleKeyPress),document.removeEventListener(&quot;keydown&quot;,e.handleKeyDown),document.removeEventListener(&quot;keyup&quot;,e.handleKeyUp),document.removeEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),t.container=null,r.clear()},e.handleKeyPress=t=>{const n=l(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=l(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=l(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerEnterEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerLeaveEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&yv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),r.has(n.pointerId)&&dv(&quot;[RenderWindowInteractor] duplicate pointerId detected&quot;),r.set(n.pointerId,{pointerId:n.pointerId,position:i(n)}),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(r.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&yv(n),r.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(r.has(t.pointerId))switch(r.delete(t.pointerId),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(r.has(t.pointerId)&&(r.get(t.pointerId).position=i(t)),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:pv(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=r=>{void 0!==r?n.has(r)?dv(&quot;requester is already registered for animating&quot;):(n.add(r),t.animationRequest||1!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):pv(&quot;undefined requester, can not start animating&quot;)},e.extendAnimation=r=>{const o=Date.now()+r;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(r){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.has(r))n.delete(r),t.animationRequest&&0===n.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=r&&r.getClassName?r.getClassName():r;dv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==n.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=n.gamepad,s=n.handedness;if(i){i.index in t.lastGamepadValues||(t.lastGamepadValues[i.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<i.buttons.length;++r)r in t.lastGamepadValues[i.index][s].buttons||(t.lastGamepadValues[i.index][s].buttons[r]=!1),t.lastGamepadValues[i.index][s].buttons[r]!==i.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,pressed:i.buttons[r].pressed,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController,input:hv[i.mapping]&&hv[i.mapping][r]?hv[i.mapping][r]:uv.Trigger}),t.lastGamepadValues[i.index][s].buttons[r]=i.buttons[r].pressed),t.lastGamepadValues[i.index][s].buttons[r]&&null!=a&&e.move3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController})}}))},e.handleMouseMove=n=>{const r={...s(n),position:i(n),deviceType:c(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const r=Date.now();t._animationFrameCount++,r-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(r-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=r,t._animationFrameCount=1),e.animationEvent(),u(),n.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{yv(n);const r={...fv(n),...s(n),position:i(n),deviceType:c(n)};0===t.wheelTimeoutID&&(o=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=o,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:pv(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);if(2===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture(&quot;TouchStart&quot;,t)}else if(1===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const o=[...r.values()];if(t.recognizeGestures)if(0===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonReleaseEvent(t)}else if(1===o.length){const t=Tv(r);e.recognizeGesture(&quot;TouchEnd&quot;,t);const a={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonPressEvent(a)}else{const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||u()},vv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void gv(&quot;\\n          Can not forward events without a current renderer on the interactor.\\n        &quot;);const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),&quot;TouchStart&quot;===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture=&quot;Start&quot;);if(&quot;TouchEnd&quot;===n)return&quot;Pinch&quot;===t.currentGesture&&(e.render(),e.endPinchEvent()),&quot;Rotate&quot;===t.currentGesture&&(e.render(),e.endRotateEvent()),&quot;Pan&quot;===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture=&quot;Start&quot;,void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,&quot;TouchMove&quot;===n)if(&quot;Start&quot;===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture=&quot;Pinch&quot;;const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture=&quot;Rotate&quot;;const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture=&quot;Pan&quot;;const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if(&quot;Rotate&quot;===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if(&quot;Pinch&quot;===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if(&quot;Pan&quot;===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e};const d=e.delete;e.delete=()=>{for(;n.size;)e.cancelAnimation(n.values().next().value);void 0!==document.hidden&&document.removeEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange),t.container&&e.unbindEvents(),d()},void 0!==document.hidden&&document.addEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange,!1)}const xv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:&quot;Start&quot;,animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,&quot;RenderEvent&quot;),vv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,[&quot;initialized&quot;,&quot;container&quot;,&quot;interactorStyle&quot;,&quot;lastFrameTime&quot;,&quot;recentAnimationFrameRate&quot;,&quot;_view&quot;]),jt.setGet(e,t,[&quot;lightFollowCamera&quot;,&quot;enabled&quot;,&quot;enableRender&quot;,&quot;recognizeGestures&quot;,&quot;desiredUpdateRate&quot;,&quot;stillUpdateRate&quot;,&quot;picker&quot;,&quot;preventDefaultOnPointerDown&quot;,&quot;preventDefaultOnPointerUp&quot;,&quot;mouseScrollDebounceByPass&quot;]),jt.moveToProtected(e,t,[&quot;view&quot;]),bv(e,t)}var Sv={newInstance:jt.newInstance(Cv,&quot;vtkRenderWindowInteractor&quot;),extend:Cv,handledEvents:vv,...lv};const{vtkErrorMacro:Av,VOID:Iv}=jt;function wv(e,t){t.classHierarchy.push(&quot;vtkInteractorObserver&quot;);const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Sv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):Iv),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Av(&quot;\\n          The interactor must be set before subscribing to events\\n        &quot;)),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const Pv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pv,n),jt.obj(e,t),jt.event(e,t,&quot;InteractionEvent&quot;),jt.event(e,t,&quot;StartInteractionEvent&quot;),jt.event(e,t,&quot;EndInteractionEvent&quot;),jt.get(e,t,[&quot;_interactor&quot;,&quot;enabled&quot;]),jt.setGet(e,t,[&quot;priority&quot;,&quot;processEvents&quot;]),jt.moveToProtected(e,t,[&quot;interactor&quot;]),wv(e,t)}var Rv={newInstance:jt.newInstance(Ov,&quot;vtkInteractorObserver&quot;),extend:Ov,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},Mv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Dv}=Mv,Ev={Rotate:Dv.IS_ROTATE,Pan:Dv.IS_PAN,Spin:Dv.IS_SPIN,Dolly:Dv.IS_DOLLY,CameraPose:Dv.IS_CAMERA_POSE,WindowLevel:Dv.IS_WINDOW_LEVEL,Slice:Dv.IS_SLICE};function Vv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyle&quot;),Object.keys(Ev).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Dv.IS_NONE&&(t.state=Ev[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:&quot;StartInteractionEvent&quot;}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Ev[n]&&(t.state=Dv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:&quot;EndInteractionEvent&quot;}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case&quot;r&quot;:case&quot;R&quot;:e.pokedRenderer.resetCamera(),n.render();break;case&quot;w&quot;:case&quot;W&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case&quot;s&quot;:case&quot;S&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case&quot;v&quot;:case&quot;V&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Lv={state:Dv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function Bv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lv,n),Rv.extend(e,t,n),Vv(e,t)}var Nv={newInstance:jt.newInstance(Bv,&quot;vtkInteractorStyle&quot;),extend:Bv,...Mv};const{States:_v}=Mv;function Fv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyleTrackballCamera&quot;),e.handleMouseMove=n=>{const r=n.position,o=n.pokedRenderer;switch(t.state){case _v.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad?!n||n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad||t.state!==_v.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===_v.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const t=e.pokedRenderer.getActiveCamera(),n=t.getPhysicalTranslation(),r=.025*t.getPhysicalScale(),o=t.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);t.setPhysicalTranslation(n[0]+o[0]*r,n[1]+o[1]*r,n[2]+o[2]*r)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case _v.IS_DOLLY:e.endDolly();break;case _v.IS_PAN:e.endPan();break;case _v.IS_SPIN:e.endSpin();break;case _v.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(n.pokedRenderer,n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=n.pokedRenderer.getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(n.pokedRenderer,o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(n.pokedRenderer,o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(n.pokedRenderer,o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&n.pokedRenderer.updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=e.pokedRenderer.getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(n.pokedRenderer,r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const kv={motionFactor:10,zoomFactor:10};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Nv.extend(e,t,n),jt.setGet(e,t,[&quot;motionFactor&quot;,&quot;zoomFactor&quot;]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,&quot;vtkInteractorStyleTrackballCamera&quot;),extend:Gv};function zv(e){return e}function Wv(e){return null===e||&quot;null&quot;===e?null:&quot;true&quot;===e||&quot;false&quot;!==e&&(void 0!==e&&&quot;undefined&quot;!==e?&quot;[&quot;===e[0]&&&quot;]&quot;===e[e.length-1]?e.substring(1,e.length-1).split(&quot;,&quot;).map((e=>Wv(e.trim()))):&quot;&quot;===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var Hv=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?Wv:zv,o=(t||&quot;&quot;).replace(/#.*/,&quot;&quot;).replace(&quot;?&quot;,&quot;&quot;).split(&quot;&&quot;);return o.forEach((e=>{const[t,o]=e.split(&quot;=&quot;).map((e=>decodeURIComponent(e)));t&&(n[t]=!o||r(o))})),n};function jv(e,t){t.classHierarchy.push(&quot;vtkRenderPass&quot;),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const Kv={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),jt.obj(e,t),jt.get(e,t,[&quot;currentOperation&quot;]),jt.setGet(e,t,[&quot;delegates&quot;,&quot;_currentParent&quot;,&quot;preDelegateOperations&quot;,&quot;postDelegateOperations&quot;]),jt.moveToProtected(e,t,[&quot;currentParent&quot;]),jv(e,t)}var qv={newInstance:jt.newInstance($v,&quot;vtkRenderPass&quot;),extend:$v};const{Representation:Xv}=ds,{vtkErrorMacro:Yv}=jt;function Zv(e){const t=cd.substitute(e.Fragment,&quot;//VTK::RenderPassFragmentShader::Impl&quot;,&quot;\\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\\n      gl_FragData[1].r = weight;\\n    &quot;,!1);e.Fragment=t.result}function Qv(e,t){t.classHierarchy.push(&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Es.newInstance({numberOfComponents:3,values:e});o.setName(&quot;points&quot;);const a=Es.newInstance({numberOfComponents:2,values:n});a.setName(&quot;tcoords&quot;);const i=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,&quot;polys&quot;,Xv.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Nd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,&quot;Float32Array&quot;,null),t.translucentRTexture=Nd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,&quot;Float32Array&quot;,null),t.translucentZTexture=Nd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],&quot;Float32Array&quot;,null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;attribute vec2 tcoordTC;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = tcoordTC; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),&quot;//VTK::System::Dec\\n\\nin vec2 tcoord;\\n\\nuniform sampler2D translucentRTexture;\\nuniform sampler2D translucentRGBATexture;\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\\n  float t2Color = texture(translucentRTexture, tcoord).r;\\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\\n}\\n&quot;,&quot;&quot;)},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;tcoordTC&quot;,t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;)},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension(&quot;EXT_color_buffer_half_float&quot;)&&!i.getExtension(&quot;EXT_color_buffer_float&quot;))return e.setCurrentOperation(&quot;translucentPass&quot;),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation(&quot;opaqueZBufferPass&quot;),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation(&quot;translucentPass&quot;),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi(&quot;translucentRGBATexture&quot;,t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi(&quot;translucentRTexture&quot;,t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate()},e.getShaderReplacement=()=>t._supported?Zv:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const Jv={framebuffer:null,copyShader:null,tris:null};function ey(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jv,n),qv.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),jt.get(e,t,[&quot;framebuffer&quot;]),Qv(e,t)}var ty={newInstance:jt.newInstance(ey,&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),extend:ey};function ny(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];if(s.getDraw()&&s.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=Hp.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation(&quot;zBufferPass&quot;),i.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation(&quot;opaquePass&quot;),i.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=ty.newInstance()),t.translucentPass.traverse(n,i,e)),t.volumeCount>0&&(e.setCurrentOperation(&quot;volumePass&quot;),i.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation(&quot;overlayPass&quot;),i.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const ry={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ry,n),qv.extend(e,t,n),jt.get(e,t,[&quot;framebuffer&quot;,&quot;opaqueActorCount&quot;,&quot;translucentActorCount&quot;,&quot;volumeCount&quot;]),ny(e,t)}var ay={newInstance:jt.newInstance(oy,&quot;vtkForwardPass&quot;),extend:oy},iy=n(594),sy=n.n(iy);const ly=[&quot;lastShaderProgramBound&quot;,&quot;context&quot;,&quot;_openGLRenderWindow&quot;];function cy(e,t){t.classHierarchy.push(&quot;vtkShaderCache&quot;),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=cd.substitute(o,&quot;VSOut&quot;,&quot;GSOut&quot;).result);const a=t._openGLRenderWindow.getWebgl2();let i=&quot;\\n&quot;,s=&quot;#version 100\\n&quot;;a?s=&quot;#version 300 es\\n#define attribute in\\n#define textureCube texture\\n#define texture2D texture\\n#define textureCubeLod textureLod\\n#define texture2DLod textureLod\\n&quot;:(t.context.getExtension(&quot;OES_standard_derivatives&quot;),t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(i=&quot;#extension GL_EXT_frag_depth : enable\\n&quot;),t.context.getExtension(&quot;EXT_shader_texture_lod&quot;)&&(i+=&quot;#extension GL_EXT_shader_texture_lod : enable\\n#define textureCubeLod textureCubeLodEXT\\n#define texture2DLod texture2DLodEXT&quot;)),o=cd.substitute(o,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,a?&quot;&quot;:&quot;#extension GL_OES_standard_derivatives : enable\\n&quot;,i,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;let l=cd.substitute(e,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;if(a){l=cd.substitute(l,&quot;varying&quot;,&quot;out&quot;).result,o=cd.substitute(o,&quot;varying&quot;,&quot;in&quot;).result;let e=&quot;&quot;,t=0;for(;o.includes(`gl_FragData[${t}]`);)o=cd.substitute(o,`gl_FragData\\\\[${t}\\\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\\n`,t++;o=cd.substitute(o,&quot;//VTK::Output::Dec&quot;,e).result}return{VSSource:l,FSSource:o,GSSource:cd.substitute(r,&quot;//VTK::System::Dec&quot;,s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=sy().hash(o);if(!(a in t.shaderPrograms)){const o=cd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const uy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,ly),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cy(e,t)}var py={newInstance:jt.newInstance(dy,&quot;vtkShaderCache&quot;),extend:dy};const{vtkErrorMacro:fy}=jt;function gy(e,t){t.classHierarchy.push(&quot;vtkOpenGLTextureUnitManager&quot;),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&fy(&quot;some texture units  were not properly released&quot;);t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const my={context:null,numberOfTextureUnits:0,textureUnits:0};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,[&quot;numberOfTextureUnits&quot;]),jt.setGet(e,t,[&quot;context&quot;]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,&quot;vtkOpenGLTextureUnitManager&quot;),extend:hy};function yy(e,t){t.classHierarchy.push(&quot;vtkRenderWindowViewNode&quot;),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.createSelector=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)}}const Ty={size:void 0,selector:void 0};function by(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ty,n),t.size||(t.size=[300,300]),jt.getArray(e,t,[&quot;size&quot;],2),jt.get(e,t,[&quot;selector&quot;]),Zt.extend(e,t,n),yy(e,t)}var xy={newInstance:jt.newInstance(by,&quot;vtkRenderWindowViewNode&quot;),extend:by};const{vtkDebugMacro:Cy,vtkErrorMacro:Sy}=jt,Ay={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Iy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let wy=0;const Py=[];function Oy(){wy++,Py.forEach((e=>e(wy)))}function Ry(){wy--,Py.forEach((e=>e(wy)))}function My(e){e.preventDefault()}function Dy(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderWindow&quot;);const n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if(&quot;__getUnderlyingContext&quot;===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}();e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener(&quot;webglcontextlost&quot;,My,!1),t.canvas.addEventListener(&quot;webglcontextrestored&quot;,e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow(e)}))}},e.initialize=()=>{if(!t.initialized){t.context=e.get3DContext(),t.textureUnitManager=vy.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND),t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Sy(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.activeFramebuffer?t.activeFramebuffer.getSize():t.size,e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:&quot;high-performance&quot;},r=null;const o=&quot;undefined&quot;!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext(&quot;webgl2&quot;,e),r&&(t.webgl2=!0,Cy(&quot;using webgl2&quot;))),r||(Cy(&quot;using webgl1&quot;),r=t.canvas.getContext(&quot;webgl&quot;,e)||t.canvas.getContext(&quot;experimental-webgl&quot;,e)),new Proxy(r,n)},e.restoreContext=()=>{const t=qv.newInstance();t.setCurrentOperation(&quot;Release&quot;),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?Sy(&quot;Hardware does not support the number of textures defined.&quot;):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case ys.CHAR:case ys.SIGNED_CHAR:case ys.UNSIGNED_CHAR:return 1;case n:case r:case ys.UNSIGNED_SHORT:case ys.SHORT:case ys.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case ys.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&ys.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&ys.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return t.context.R16F;case 2:return t.context.RG16F;case 3:return t.context.RGB16F;default:return t.context.RGBA16F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Ay,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension(&quot;OES_texture_float&quot;),o=n.getExtension(&quot;OES_texture_half_float&quot;),a=n.getExtension(&quot;WEBGL_debug_renderer_info&quot;),i=n.getExtension(&quot;WEBGL_draw_buffers&quot;),s=n.getExtension(&quot;EXT_texture_filter_anisotropic&quot;)||n.getExtension(&quot;WEBKIT_EXT_texture_filter_anisotropic&quot;),l=[[&quot;Max Vertex Attributes&quot;,&quot;MAX_VERTEX_ATTRIBS&quot;,n.getParameter(n.MAX_VERTEX_ATTRIBS)],[&quot;Max Varying Vectors&quot;,&quot;MAX_VARYING_VECTORS&quot;,n.getParameter(n.MAX_VARYING_VECTORS)],[&quot;Max Vertex Uniform Vectors&quot;,&quot;MAX_VERTEX_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],[&quot;Max Fragment Uniform Vectors&quot;,&quot;MAX_FRAGMENT_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],[&quot;Max Fragment Texture Image Units&quot;,&quot;MAX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],[&quot;Max Vertex Texture Image Units&quot;,&quot;MAX_VERTEX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],[&quot;Max Combined Texture Image Units&quot;,&quot;MAX_COMBINED_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],[&quot;Max 2D Texture Size&quot;,&quot;MAX_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_TEXTURE_SIZE)],[&quot;Max Cube Texture Size&quot;,&quot;MAX_CUBE_MAP_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],[&quot;Max Texture Anisotropy&quot;,&quot;MAX_TEXTURE_MAX_ANISOTROPY_EXT&quot;,s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],[&quot;Point Size Range&quot;,&quot;ALIASED_POINT_SIZE_RANGE&quot;,n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(&quot; - &quot;)],[&quot;Line Width Range&quot;,&quot;ALIASED_LINE_WIDTH_RANGE&quot;,n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(&quot; - &quot;)],[&quot;Max Viewport Dimensions&quot;,&quot;MAX_VIEWPORT_DIMS&quot;,n.getParameter(n.MAX_VIEWPORT_DIMS).join(&quot; - &quot;)],[&quot;Max Renderbuffer Size&quot;,&quot;MAX_RENDERBUFFER_SIZE&quot;,n.getParameter(n.MAX_RENDERBUFFER_SIZE)],[&quot;Framebuffer Red Bits&quot;,&quot;RED_BITS&quot;,n.getParameter(n.RED_BITS)],[&quot;Framebuffer Green Bits&quot;,&quot;GREEN_BITS&quot;,n.getParameter(n.GREEN_BITS)],[&quot;Framebuffer Blue Bits&quot;,&quot;BLUE_BITS&quot;,n.getParameter(n.BLUE_BITS)],[&quot;Framebuffer Alpha Bits&quot;,&quot;ALPHA_BITS&quot;,n.getParameter(n.ALPHA_BITS)],[&quot;Framebuffer Depth Bits&quot;,&quot;DEPTH_BITS&quot;,n.getParameter(n.DEPTH_BITS)],[&quot;Framebuffer Stencil Bits&quot;,&quot;STENCIL_BITS&quot;,n.getParameter(n.STENCIL_BITS)],[&quot;Framebuffer Subpixel Bits&quot;,&quot;SUBPIXEL_BITS&quot;,n.getParameter(n.SUBPIXEL_BITS)],[&quot;MSAA Samples&quot;,&quot;SAMPLES&quot;,n.getParameter(n.SAMPLES)],[&quot;MSAA Sample Buffers&quot;,&quot;SAMPLE_BUFFERS&quot;,n.getParameter(n.SAMPLE_BUFFERS)],[&quot;Supported Formats for UByte Render Targets     &quot;,&quot;UNSIGNED_BYTE RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.UNSIGNED_BYTE)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.UNSIGNED_BYTE)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.UNSIGNED_BYTE)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Half Float Render Targets&quot;,&quot;HALF FLOAT RENDER TARGET FORMATS&quot;,[o&&Iy(n,n.RGBA,o.HALF_FLOAT_OES)?&quot;RGBA&quot;:&quot;&quot;,o&&Iy(n,n.RGB,o.HALF_FLOAT_OES)?&quot;RGB&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?&quot;LUMINANCE&quot;:&quot;&quot;,o&&Iy(n,n.ALPHA,o.HALF_FLOAT_OES)?&quot;ALPHA&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Full Float Render Targets&quot;,&quot;FLOAT RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.FLOAT)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.FLOAT)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.FLOAT)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.FLOAT)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.FLOAT)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Max Multiple Render Targets Buffers&quot;,&quot;MAX_DRAW_BUFFERS_WEBGL&quot;,i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],[&quot;High Float Precision in Vertex Shader&quot;,&quot;HIGH_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Vertex Shader&quot;,&quot;MEDIUM_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Vertex Shader&quot;,&quot;LOW_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Float Precision in Fragment Shader&quot;,&quot;HIGH_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Fragment Shader&quot;,&quot;MEDIUM_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Fragment Shader&quot;,&quot;LOW_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Vertex Shader&quot;,&quot;HIGH_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Vertex Shader&quot;,&quot;MEDIUM_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Vertex Shader&quot;,&quot;LOW_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Fragment Shader&quot;,&quot;HIGH_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Fragment Shader&quot;,&quot;MEDIUM_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Fragment Shader&quot;,&quot;LOW_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Supported Extensions&quot;,&quot;EXTENSIONS&quot;,n.getSupportedExtensions().join(&quot;<br/>\\t\\t\\t\\t\\t    &quot;)],[&quot;WebGL Renderer&quot;,&quot;RENDERER&quot;,n.getParameter(n.RENDERER)],[&quot;WebGL Vendor&quot;,&quot;VENDOR&quot;,n.getParameter(n.VENDOR)],[&quot;WebGL Version&quot;,&quot;VERSION&quot;,n.getParameter(n.VERSION)],[&quot;Shading Language Version&quot;,&quot;SHADING_LANGUAGE_VERSION&quot;,n.getParameter(n.SHADING_LANGUAGE_VERSION)],[&quot;Unmasked Renderer&quot;,&quot;UNMASKED_RENDERER&quot;,a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],[&quot;Unmasked Vendor&quot;,&quot;UNMASKED_VENDOR&quot;,a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],[&quot;WebGL Version&quot;,&quot;WEBGL_VERSION&quot;,t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}()},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=df.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((function(){t.canvas.removeEventListener(&quot;webglcontextlost&quot;,My),t.canvas.removeEventListener(&quot;webglcontextrestored&quot;,e.restoreContext)}),e.delete,e.setViewStream,Ry),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.getGraphicsResourceForObject=e=>e?{vtkObj:t._graphicsResources.get(e),hash:t._graphicsResourceHash.get(e)}:null,e.setGraphicsResourceForObject=(e,n,r)=>{e&&(t._graphicsResources.set(e,n),t._graphicsResourceHash.set(e,r))},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach(((t,n)=>{e+=t.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResourcesForObject=n=>!!n&&(t._graphicsResources.get(n)?.releaseGraphicsResources(e),t._graphicsResources.delete(n)&&t._graphicsResourceHash.delete(n)),e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach(((t,n)=>{t.releaseGraphicsResources(e)})),t._graphicsResources.clear(),t._graphicsResourceHash.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))}}const Ey={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1};const Vy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),xy.extend(e,t,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,Oy(),t.selector||(t.selector=df.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,t._textureResourceIds=new Map,t._graphicsResources=new Map,t._graphicsResourceHash=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Vy),t.shaderCache=py.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=ay.newInstance(),jt.event(e,t,&quot;imageReady&quot;),jt.get(e,t,[&quot;shaderCache&quot;,&quot;textureUnitManager&quot;,&quot;webgl2&quot;,&quot;useBackgroundImage&quot;,&quot;activeFramebuffer&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;defaultToWebgl2&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Dy(e,t)}),&quot;vtkOpenGLRenderWindow&quot;);function Ly(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderModule&quot;),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}ev(&quot;WebGL&quot;,Vy);const By={device:null,handle:null};function Ny(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,By,n),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;handle&quot;]),Ly(e,t)}var _y={newInstance:jt.newInstance(Ny,&quot;vtkWebGPUShaderModule&quot;),extend:Ny};function Fy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderCache&quot;),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=_y.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const ky={shaderModules:null,device:null,window:null};function Gy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ky,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;,&quot;window&quot;]),Fy(e,t)}var Uy={newInstance:jt.newInstance(Gy,&quot;vtkWebGPUShaderCache&quot;),extend:Gy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join(&quot;\\n&quot;):n;let a=!1;-1!==e.search(t)&&(a=!0);let i=&quot;&quot;;r&&(i=&quot;g&quot;);const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function zy(e,t){t.classHierarchy.push(&quot;vtkWebGPUBindGroup&quot;),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join(&quot;\\n&quot;)}}const Wy={device:null,handle:null,label:null};function Hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;label&quot;,&quot;device&quot;,&quot;arrayInformation&quot;]),zy(e,t)}var jy={newInstance:jt.newInstance(Hy),extend:Hy};function Ky(e,t){t.classHierarchy.push(&quot;vtkWebGPUPipeline&quot;),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);&quot;vertex&quot;===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint=&quot;main&quot;),&quot;fragment&quot;===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint=&quot;main&quot;)}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const $y={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$y,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,[&quot;handle&quot;,&quot;pipelineDescription&quot;]),At(e,t,[&quot;device&quot;,&quot;renderEncoder&quot;,&quot;topology&quot;,&quot;vertexState&quot;]),Ky(e,t)}var Xy={newInstance:Et(qy,&quot;vtkWebGPUPipeline&quot;),extend:qy};function Yy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderDescription&quot;),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push(&quot;};&quot;),o=n,r[r.length-1]+=&quot;,&quot;,r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Input&quot;,r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push(&quot;};&quot;),o=o.concat(e),t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Output&quot;,[`-> ${t.type}Output`]).result}t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Dec&quot;,o).result}}const Zy={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function Qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zy,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,[&quot;type&quot;,&quot;hash&quot;,&quot;code&quot;]),jt.getArray(e,t,[&quot;outputTypes&quot;,&quot;outputNames&quot;,&quot;outputInterpolations&quot;]),Yy(e,t)}var Jy={newInstance:jt.newInstance(Qy,&quot;vtkWebGPUShaderDescription&quot;),extend:Qy};const eT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;sint&quot;},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;uint&quot;},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:&quot;sint&quot;},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:&quot;float&quot;},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;uint&quot;},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;sint&quot;},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:&quot;uint&quot;},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:&quot;sint&quot;},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:&quot;uint&quot;},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:&quot;sint&quot;},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:&quot;float&quot;},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;rgba8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;uint&quot;},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;sint&quot;},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;bgra8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:&quot;float&quot;},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:&quot;uint&quot;},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:&quot;sint&quot;},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:&quot;uint&quot;},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:&quot;sint&quot;},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:&quot;float&quot;},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:&quot;uint&quot;},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:&quot;sint&quot;},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:&quot;unfilterable-float&quot;},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;depth&quot;},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:&quot;depth&quot;},&quot;depth24plus-stencil8&quot;:{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:&quot;mixed&quot;},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;depth&quot;}};var tT=function(e){return!e||e.length<6?0:e in eT==1?eT[e]:(et(`unknown format ${e}`),null)},nT=function(e){if(!e||e.length<5)return 0;let t=1;&quot;x&quot;===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},rT=function(e){if(!e||e.length<5)return 0;let t;if(&quot;f&quot;===e[0])t=&quot;Float&quot;;else if(&quot;s&quot;===e[0])t=&quot;Int&quot;;else{if(&quot;u&quot;!==e[0])return void et(`unknown format ${e}`);t=&quot;Uint&quot;}const n=e.split(&quot;x&quot;)[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+=&quot;Array&quot;,t;et(`unknown format ${e}`)},oT=function(e){let t;if(&quot;f&quot;===e[0]||&quot;n&quot;===e[1])t=&quot;f32&quot;;else if(&quot;s&quot;===e[0]&&&quot;i&quot;===e[1])t=&quot;i32&quot;;else{if(&quot;u&quot;!==e[0]||&quot;i&quot;!==e[1])return void et(`unknown format ${e}`);t=&quot;u32&quot;}let n=1;return&quot;x&quot;===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},aT=function(e){if(!e)return 0;let t=1;return&quot;vec&quot;===e.substring(0,3)?t=Number(e[3]):&quot;mat&quot;===e.substring(0,3)&&(t=e[3]*e[5]),4*t},iT=function(e){if(e)return e.includes(&quot;f32&quot;)?&quot;Float32Array&quot;:e.includes(&quot;i32&quot;)?&quot;Int32Array&quot;:e.includes(&quot;u32&quot;)?&quot;Uint32Array&quot;:void et(`unknown format ${e}`)};function sT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function lT(e,t){t.classHierarchy.push(&quot;vtkWebGPUVertexInput&quot;),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:&quot;vertex&quot;,o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(sT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e=&quot;&quot;,n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=oT(a.format);n>0&&(e+=&quot;,\\n&quot;),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const cT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function uT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,[&quot;created&quot;,&quot;device&quot;,&quot;handle&quot;,&quot;indexBuffer&quot;]),lT(e,t)}var dT={newInstance:Et(uT,&quot;vtkWebGPUVertexInput&quot;),extend:uT};const pT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  // var vertex: vec4<f32> = vertexBC;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n&quot;,fT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function gT(e,t){t.classHierarchy.push(&quot;vtkWebGPUSimpleMapper&quot;),e.generateShaderDescriptions=(n,r,o)=>{const a=Jy.newInstance({type:&quot;vertex&quot;,hash:n,code:t.vertexShaderTemplate}),i=Jy.newInstance({type:&quot;fragment&quot;,hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp(&quot;//VTK::[^:]*::&quot;,&quot;g&quot;),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];&quot;replaceShaderIOStructs&quot;!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.replaceShaderCode(null,n),t.getShaderDescription(&quot;fragment&quot;).replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set(&quot;replaceShaderRenderEncoder&quot;,e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderRenderer&quot;,e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);s.addBuiltinInput(&quot;bool&quot;,&quot;@builtin(front_facing) frontFacing&quot;),i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderMapper&quot;,e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;    output.Position = rendererUBO.SCPCMatrix*vertexBC;&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription(&quot;vertex&quot;).addOutput(&quot;vec2<f32>&quot;,&quot;tcoordVS&quot;)},t.shaderReplacements.set(&quot;replaceShaderTCoord&quot;,e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=Xy.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const mT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:&quot;triangle-list&quot;,UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function hT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=dT.newInstance(),t.bindGroup=jy.newInstance({label:&quot;mapperBG&quot;}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||fT,t.vertexShaderTemplate=t.vertexShaderTemplate||pT,t.shaderReplacements=new Map,jt.get(e,t,[&quot;pipeline&quot;,&quot;vertexInput&quot;]),jt.setGet(e,t,[&quot;additionalBindables&quot;,&quot;device&quot;,&quot;fragmentShaderTemplate&quot;,&quot;interpolate&quot;,&quot;numberOfInstances&quot;,&quot;numberOfVertices&quot;,&quot;pipelineHash&quot;,&quot;shaderReplacements&quot;,&quot;SSBO&quot;,&quot;textureViews&quot;,&quot;topology&quot;,&quot;UBO&quot;,&quot;vertexShaderTemplate&quot;,&quot;WebGPURenderer&quot;]),gT(e,t)}var vT={newInstance:jt.newInstance(hT,&quot;vtkWebGPUSimpleMapper&quot;),extend:hT};function yT(e,t){t.classHierarchy.push(&quot;vtkWebGPUFullScreenQuad&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;),r.addOutput(&quot;vec4<f32>&quot;,&quot;vertexVC&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;,&quot;output.vertexVC = vec4<f32>(vertexBC, 1);&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,[&quot;vertexBC&quot;]),t.numberOfVertices=6}}const TT={};function bT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,TT,n),vT.extend(e,t,n),yT(e,t)}var xT={newInstance:jt.newInstance(bT,&quot;vtkWebGPUFullScreenQuad&quot;),extend:bT};const CT=[&quot;setBindGroup&quot;,&quot;setIndexBuffer&quot;,&quot;setVertexBuffer&quot;,&quot;draw&quot;,&quot;drawIndexed&quot;];function ST(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderEncoder&quot;),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!(&quot;depthStencil&quot;in n))console.log(&quot;mismatched depth attachments&quot;),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\\n${o}\\n versus pipeline\\n${a}\\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<CT.length;n++)e[CT[n]]=function(){return t.handle[CT[n]](...arguments)}}const AT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function IT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}],depthStencilAttachment:{view:void 0,depthLoadOp:&quot;clear&quot;,depthClearValue:0,depthStoreOp:&quot;store&quot;}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = computedColor;&quot;]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater-equal&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}},t.colorTextureViews=[],bt(e,t,[&quot;boundPipeline&quot;,&quot;colorTextureViews&quot;]),At(e,t,[&quot;depthTextureView&quot;,&quot;description&quot;,&quot;handle&quot;,&quot;label&quot;,&quot;pipelineHash&quot;,&quot;pipelineSettings&quot;,&quot;replaceShaderCodeFunction&quot;]),ST(e,t)}var wT={newInstance:Et(IT,&quot;vtkWebGPURenderEncoder&quot;),extend:IT},PT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const OT=[&quot;getMappedRange&quot;,&quot;mapAsync&quot;,&quot;unmap&quot;];function RT(e,t){t.classHierarchy.push(&quot;vtkWebGPUBuffer&quot;),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<OT.length;n++)e[OT[n]]=function(){return t.handle[OT[n]](...arguments)}}const MT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;strideInBytes&quot;,&quot;device&quot;,&quot;arrayInformation&quot;,&quot;label&quot;,&quot;sourceTime&quot;]),RT(e,t)}var ET={newInstance:jt.newInstance(DT),extend:DT,...PT};const{Representation:VT}=ds,{PrimitiveTypes:LT}=PT;class BT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function NT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function _T(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=NT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=NT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=NT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=NT(n,o,t),n.ibo[n.iboId++]=a}function FT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let kT;const GT=new Uint32Array(1),UT=new Uint32Array(2),zT=new Uint32Array(3),WT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)GT[0]=t[n+a],kT(GT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)UT[0]=t[n+a],UT[1]=t[n+(a+1)%e],kT(UT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o);for(let a=0;a<e-2;a++)UT[0]=t[n+a],UT[1]=t[n+a+2],kT(UT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n],zT[1]=t[n+a+1],zT[2]=t[n+a+2],kT(zT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n+a],zT[1]=t[n+a+1+a%2],zT[2]=t[n+a+1+(a+1)%2],kT(zT,r,o)}};function HT(e,t){t.classHierarchy.push(&quot;vtkWebGPUIndexBuffer&quot;),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case LT.Points:return&quot;points&quot;;case LT.Lines:return&quot;lines&quot;;case LT.Triangles:case LT.TriangleEdges:return&quot;polys&quot;;case LT.TriangleStripEdges:case LT.TriangleStrips:return&quot;strips&quot;;default:return&quot;&quot;}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new BT};let d=null;d=o===VT.POINTS||r===LT.Points?WT.anythingToPoints:o===VT.WIREFRAME||r===LT.Lines?WT[`${l}ToWireframe`]:WT[`${l}ToSurface`],kT=FT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format=&quot;uint16&quot;):(u.ibo=new Uint32Array(u.iboSize),e.format=&quot;uint32&quot;),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),kT=_T,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const jT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function KT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jT,n),ET.extend(e,t,n),jt.setGet(e,t,[&quot;flatIdToPointId&quot;,&quot;flatIdToCellId&quot;,&quot;flatSize&quot;,&quot;indexCount&quot;]),HT(e,t)}var $T={newInstance:jt.newInstance(KT),extend:KT,...PT};const{BufferUsage:qT}=PT,{vtkErrorMacro:XT}=Kt,{VtkDataTypes:YT}=Es;function ZT(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,&quot;packExtra&quot;)&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function QT(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function JT(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===qT.Index&&(n=$T.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=ET.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===qT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===qT.PointArray){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=ZT(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?&quot;flat&quot;:&quot;perspective&quot;}])}if(e.usage===qT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=QT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=ZT(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:&quot;flat&quot;}])}return e.usage===qT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push(&quot;vtkWebGPUBufferManager&quot;),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case YT.UNSIGNED_CHAR:t=&quot;uint8&quot;;break;case YT.FLOAT:t=&quot;float32&quot;;break;case YT.UNSIGNED_INT:t=&quot;uint32&quot;;break;case YT.INT:t=&quot;sint32&quot;;break;case YT.DOUBLE:t=&quot;float32&quot;;break;case YT.UNSIGNED_SHORT:t=&quot;uint16&quot;;break;case YT.SHORT:t=&quot;sin16&quot;;break;default:t=&quot;float32&quot;}switch(e.getNumberOfComponents()){case 2:t+=&quot;x2&quot;;break;case 3:t.includes(&quot;32&quot;)||XT(`unsupported x3 type for ${t}`),t+=&quot;x3&quot;;break;case 4:t+=&quot;x4&quot;}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:qT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=ET.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:&quot;float32x3&quot;}]),t.fullScreenQuadBuffer}}const eb={device:null,fullScreenQuadBuffer:null};function tb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eb,n),yt(e,t),At(e,t,[&quot;device&quot;]),JT(e,t)}var nb={newInstance:Et(tb),extend:tb,...PT};function rb(e,t){t.classHierarchy.push(&quot;vtkWebGPUSampler&quot;),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:&quot;clamp-to-edge&quot;,t.options.addressModeV=n.addressModeV?n.addressModeV:&quot;clamp-to-edge&quot;,t.options.addressModeW=n.addressModeW?n.addressModeW:&quot;clamp-to-edge&quot;,t.options.magFilter=n.magFilter?n.magFilter:&quot;nearest&quot;,t.options.minFilter=n.minFilter?n.minFilter:&quot;nearest&quot;,t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:&quot;nearest&quot;,t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const ob={device:null,handle:null,label:null,options:null};function ab(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ob,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;options&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;]),rb(e,t)}var ib={newInstance:jt.newInstance(ab),extend:ab};function sb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTextureView&quot;),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r=&quot;f32&quot;;&quot;sint&quot;===t.bindGroupLayoutEntry.texture.sampleType?r=&quot;i32&quot;:&quot;uint&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(r=&quot;u32&quot;);let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return&quot;depth&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=ib.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const lb={texture:null,handle:null,sampler:null,label:null};function cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:&quot;float&quot;,viewDimension:&quot;2d&quot;}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;texture&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;sampler&quot;]),sb(e,t)}var ub={newInstance:jt.newInstance(cb),extend:cb};const{BufferUsage:db}=nb;function pb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTexture&quot;),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?&quot;2d&quot;:&quot;3d&quot;;t.format=n.format?n.format:&quot;rgba8unorm&quot;,t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:&quot;rgba8unorm&quot;,t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format=&quot;rgba8unorm&quot;,n.flip=!0,n.nativeArray=n.jsImageData.data);const o=tT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&&quot;float&quot;===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?&quot;Uint16Array&quot;:i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Ad.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement(&quot;canvas&quot;);e.width=n.image.width,e.height=n.image.height;const t=e.getContext(&quot;2d&quot;);t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Tu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:db.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:db.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=tT(t.format);return 2===e.elementSize&&&quot;float&quot;===e.sampleType?1:255},e.getNumberOfComponents=()=>tT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?&quot;2d&quot;:&quot;3d&quot;);const o=ub.newInstance({label:n});return o.create(e,r),o}}const fb={device:null,handle:null,buffer:null,ready:!1,label:null};function gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fb,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;ready&quot;,&quot;width&quot;,&quot;height&quot;,&quot;depth&quot;,&quot;format&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;label&quot;]),pb(e,t)}var mb={newInstance:jt.newInstance(gb),extend:gb};function hb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOpaquePass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;opaquePassColor&quot;}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView(&quot;opaquePassColorTexture&quot;);t.renderEncoder.setColorTextureView(0,n),t.depthFormat=&quot;depth32float&quot;,t.depthTexture=mb.newInstance({label:&quot;opaquePassDepth&quot;}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;opaquePassDepthTexture&quot;);t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;opaquePass&quot;),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=wT.newInstance({label:&quot;OpaquePass&quot;}),t.renderEncoder.setPipelineHash(&quot;op&quot;)}}const vb={renderEncoder:null,colorTexture:null,depthTexture:null};function yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vb,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),hb(e,t)}var Tb={newInstance:jt.newInstance(yb,&quot;vtkWebGPUOpaquePass&quot;),extend:yb};function bb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=mb.newInstance({label:&quot;translucentPassColor&quot;}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView(&quot;oitpColorTexture&quot;);t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=mb.newInstance({label:&quot;translucentPassAccumulate&quot;}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView(&quot;oitpAccumTexture&quot;);t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=xT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash(&quot;oitpfsq&quot;),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\\n  if (reveal == 1.0) { discard; }\\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\\n  var total: f32 = max(tcolor.a, 0.01);\\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;)}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;translucentPass&quot;),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=wT.newInstance({label:&quot;translucentRender&quot;});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:void 0,clearValue:[1,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}],e.depthStencilAttachment={view:void 0,depthLoadOp:&quot;load&quot;,depthStoreOp:&quot;store&quot;},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addOutput(&quot;f32&quot;,&quot;outAccum&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);&quot;,&quot;output.outColor = vec4<f32>(computedColor.rgb*w, w);&quot;,&quot;output.outAccum = computedColor.a;&quot;]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash(&quot;oitpr&quot;),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!1,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;zero&quot;,dstFactor:&quot;one-minus-src&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=wT.newInstance({label:&quot;translucentFinal&quot;}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash(&quot;oitpf&quot;),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})}}const xb={colorTextureView:null,depthTextureView:null};function Cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),bb(e,t)}var Sb={newInstance:jt.newInstance(Cb,&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),extend:Cb};const{BufferUsage:Ab}=nb,{vtkErrorMacro:Ib}=jt;function wb(e,t){t.classHierarchy.push(&quot;vtkWebGPUUniformBuffer&quot;),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Ib(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:aT(n),offset:-1,nativeType:iT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Ab.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join(&quot;\\n&quot;)}}const Pb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function Ob(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;uniform&quot;}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,[&quot;binding&quot;,&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;,&quot;sizeInBytes&quot;]),wb(e,t)}var Rb={newInstance:jt.newInstance(Ob,&quot;vtkWebGPUUniformBuffer&quot;),extend:Ob};const{BufferUsage:Mb}=nb,{vtkErrorMacro:Db}=jt;function Eb(e,t){t.classHierarchy.push(&quot;vtkWebGPUStorageBuffer&quot;),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void Db(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=aT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:iT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Mb.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\\n};\\nstruct ${t.label}Struct\\n{\\n  values: array<${t.label}StructEntry>,\\n};\\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\\n`),r.join(&quot;\\n&quot;)},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Vb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function Lb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;read-only-storage&quot;}},jt.get(e,t,[&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;numberOfInstances&quot;,&quot;sizeInBytes&quot;]),Eb(e,t)}var Bb={newInstance:jt.newInstance(Lb,&quot;vtkWebGPUStorageBuffer&quot;),extend:Lb};const Nb=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Volume::TraverseDec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\\n{\\n  // todo multicomponent support\\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\\n}\\n\\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\\n{\\n  var result: vec4<f32>;\\n\\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\\n  result.w = 0.0;\\n\\n  // divide by spacing as that is our delta\\n  result = result / volumeSSBO.values[vNum].spacing;\\n  // now we have a gradient in unit tcoords\\n\\n  var grad: f32 = length(result.xyz);\\n  if (grad > 0.0)\\n  {\\n    // rotate to View Coords, needed for lighting and shading\\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\\n    result = nMat * result;\\n    result = result / length(result);\\n  }\\n\\n  // store gradient magnitude in .w\\n  result.w = grad;\\n\\n  return result;\\n}\\n\\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\\n{\\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n\\n  // convert to tcoords and reject if outside the volume\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\\n\\n  var scalar: f32 = getTextureValue(vTex, tpos);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n\\n  var gofactor: f32 = 1.0;\\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    normal = getGradient(vTex, tpos, vNum, scalar);\\n    if (componentSSBO.values[cNum].gomin <  1.0)\\n    {\\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\\n    }\\n  }\\n\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n\\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    color = color*abs(normal.z);\\n  }\\n\\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\\n\\n  return outColor;\\n}\\n\\n// adjust the start and end point of a raycast such that it intersects the unit cube.\\n// This function is used to take a raycast starting point and step vector\\n// and numSteps and return the startijng and ending steps for intersecting the\\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\\n// and bound it to intersecting the texture.\\n//\\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\\n{\\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\\n\\n  // move tpos to the start of the volume\\n  var adjust: f32 =\\n    min(\\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\\n      min(\\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\\n  if (adjust < 0.0)\\n  {\\n    result.x = result.x - adjust;\\n  }\\n\\n  // adjust length to the end\\n  adjust =\\n    max(\\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\\n      max(\\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\\n  if (adjust > 0.0)\\n  {\\n    result.y = result.y - adjust;\\n  }\\n\\n  return result;\\n}\\n\\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\\n{\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n  return vec4<f32>(color.rgb, opacity);\\n}\\n\\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var maxVal: f32 = -1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar > maxVal)\\n    {\\n      maxVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\\n}\\n\\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var minVal: f32 = 1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar < minVal)\\n    {\\n      minVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\\n}\\n\\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var avgVal: f32 = 0.0;\\n  var sampleCount: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      avgVal = avgVal + sample;\\n      sampleCount = sampleCount + 1.0;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  if (sampleCount <= 0.0)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\\n}\\n\\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var sumVal: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      sumVal = sumVal + sample;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\\n}\\n\\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\\n{\\n  // initial ray position is at the beginning\\n  var rayPosSC: vec4<f32> = minPosSC;\\n\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var curDist: f32 = 0.0;\\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n  var sampleColor: vec4<f32>;\\n//VTK::Volume::TraverseCalls\\n\\n  loop\\n  {\\n    // for each volume, sample and accumulate color\\n//VTK::Volume::CompositeCalls\\n\\n    // increment position\\n    curDist = curDist + mapperUBO.SampleDistance;\\n    rayPosSC = rayPosSC + rayStepSC;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayLengthSC) { break; }\\n    if (computedColor.a > 0.98) { break; }\\n  }\\n  return computedColor;\\n}\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\\n\\n  // discard empty rays\\n  if (rayMax <= rayMin) { discard; }\\n  else\\n  {\\n    // compute start and end ray positions in view coordinates\\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\\n\\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\\n    rayStepSC.w = 0.0;\\n\\n    var computedColor: vec4<f32>;\\n\\n//VTK::Volume::Loop\\n\\n//VTK::RenderEncoder::Impl\\n  }\\n\\n  return output;\\n}\\n&quot;,_b=new Float64Array(16),Fb=new Float64Array(16);function kb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePassFSQ&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;]).result,r.setCode(o),t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription(&quot;fragment&quot;);let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===Rg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push(&quot;    computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;)):(s.push(`  sampleColor = traverseVals[${e}];`),s.push(&quot;  computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;));a=Uy.substitute(a,&quot;//VTK::Volume::CompositeCalls&quot;,i).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseCalls&quot;,s).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseDec&quot;,[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===Rg.COMPOSITE_BLEND?l=!0:n===Rg.MAXIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.MINIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.AVERAGE_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.ADDITIVE_INTENSITY_BLEND&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result)}l&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[&quot;    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);&quot;]).result),o.setCode(a)},t.shaderReplacements.set(&quot;replaceShaderVolume&quot;,e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8Array(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;rgba8unorm&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;tfunTexture&quot;);t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;r16float&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;ofunTexture&quot;);t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(_b),b(_b,_b,o);const p=n.getMatrix();m(Fb,p),h(Fb,Fb),T(_b,Fb,_b);const f=d.getWorldToIndex();T(_b,f,_b);const v=d.getDimensions();g(Fb),x(Fb,Fb,[1/v[0],1/v[1],1/v[2]]),T(_b,Fb,_b);for(let t=0;t<16;t++)a[16*e+t]=_b[t];h(_b,_b);for(let t=0;t<4;t++)i[16*e+4*t]=_b[4*t],i[16*e+4*t+1]=_b[4*t+1],i[16*e+4*t+2]=_b[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry(&quot;SCTCMatrix&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;planeNormals&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;shade&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;tstep&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;spacing&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;ipScalarRange&quot;,&quot;vec4<f32>&quot;),t.SSBO.setAllInstancesFromArray(&quot;SCTCMatrix&quot;,a),t.SSBO.setAllInstancesFromArray(&quot;planeNormals&quot;,i),t.SSBO.setAllInstancesFromArray(&quot;shade&quot;,l),t.SSBO.setAllInstancesFromArray(&quot;tstep&quot;,s),t.SSBO.setAllInstancesFromArray(&quot;spacing&quot;,c),t.SSBO.setAllInstancesFromArray(&quot;ipScalarRange&quot;,u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=tT(l),u={scale:[255],offset:[0]};2===c.elementSize&&&quot;float&quot;===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry(&quot;cScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;cShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomin&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomax&quot;,&quot;f32&quot;),t.componentSSBO.setAllInstancesFromArray(&quot;cScale&quot;,d),t.componentSSBO.setAllInstancesFromArray(&quot;cShift&quot;,p),t.componentSSBO.setAllInstancesFromArray(&quot;oScale&quot;,f),t.componentSSBO.setAllInstancesFromArray(&quot;oShift&quot;,v),t.componentSSBO.setAllInstancesFromArray(&quot;goScale&quot;,A),t.componentSSBO.setAllInstancesFromArray(&quot;goShift&quot;,S),t.componentSSBO.setAllInstancesFromArray(&quot;gomin&quot;,y),t.componentSSBO.setAllInstancesFromArray(&quot;gomax&quot;,C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue(&quot;SampleDistance&quot;,r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=ib.newInstance({label:&quot;clampSampler&quot;}),t.clampSampler.create(t.device,{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}))},e.computePipelineHash=()=>{t.pipelineHash=&quot;volfsq&quot;;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Gb={volumes:null,rowLength:1024,lastVolumeLength:0};function Ub(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gb,n),xT.extend(e,t,n),t.fragmentShaderTemplate=Nb,t.UBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t.UBO.addEntry(&quot;SampleDistance&quot;,&quot;f32&quot;),t.SSBO=Bb.newInstance({label:&quot;volumeSSBO&quot;}),t.componentSSBO=Bb.newInstance({label:&quot;componentSSBO&quot;}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),kb(e,t)}var zb={newInstance:jt.newInstance(Ub,&quot;vtkWebGPUVolumePassFSQ&quot;),extend:Ub};const{Representation:Wb}=ds,{BufferUsage:Hb,PrimitiveTypes:jb}=nb,Kb=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],$b=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::VolumePass::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::VolumePass::Impl\\n\\n  // use the maximum (closest) of the current value and the zbuffer\\n  // the blend func will then take the min to find the farthest stop value\\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function qb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePass&quot;),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=zb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=xT.newInstance(),t._volumeCopyQuad.setPipelineHash(&quot;volpassfsq&quot;),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._copyUBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t._copyUBO.addEntry(&quot;tscale&quot;,&quot;vec2<f32>&quot;),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray(&quot;tscale&quot;,[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray(&quot;tscale&quot;,[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:Hb.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:jb.Triangles,representation:Wb.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:Hb.PointArray,format:&quot;float32x4&quot;,hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,[&quot;vertexBC&quot;]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+Kb[e][0],l[n++]=r+Kb[e][1],l[n++]=r+Kb[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation(&quot;volumeDepthRangePass&quot;),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=wT.newInstance({label:&quot;VolumePass DepthRange&quot;}),t._depthRangeEncoder.setPipelineHash(&quot;volr&quot;),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor1&quot;),t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor2&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);&quot;,&quot;output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);&quot;]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:null,clearValue:[1,1,1,1],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;}}}]}}),t._depthRangeTexture=mb.newInstance({label:&quot;volumePassMaxDepth&quot;}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView(&quot;maxTexture&quot;);t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=mb.newInstance({label:&quot;volumePassDepthMin&quot;}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView(&quot;minTexture&quot;);t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=mb.newInstance({label:&quot;volumePassColor&quot;}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;bgra8unorm&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView(&quot;volumePassColorTexture&quot;),t._colorTextureView.addSampler(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._clearEncoder=wT.newInstance({label:&quot;VolumePass Clear&quot;}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._clearEncoder.setPipelineHash(&quot;volpf&quot;),t._clearEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=wT.newInstance({label:&quot;volumePassCopy&quot;}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._copyEncoder.setPipelineHash(&quot;volcopypf&quot;),t._copyEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=wT.newInstance({label:&quot;volumePassMerge&quot;}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash(&quot;volpf&quot;),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const Xb={colorTextureView:null,depthTextureView:null,volumes:null};function Yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xb,n),qv.extend(e,t,n),t._mapper=vT.newInstance(),t._mapper.setFragmentShaderTemplate($b),t._mapper.getShaderReplacements().set(&quot;replaceShaderVolumePass&quot;,((e,t,n)=>{t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)})),t._boundsPoly=gu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),qb(e,t)}var Zb={newInstance:jt.newInstance(Yb,&quot;vtkWebGPUVolumePass&quot;),extend:Yb};function Qb(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e),t.opaquePass||(t.opaquePass=Tb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Sb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=Zb.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=wT.newInstance({label:&quot;forwardPassBlit&quot;}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._finalBlitEncoder.setPipelineHash(&quot;fpf&quot;),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}}),t._fsqSampler=ib.newInstance({label:&quot;finalPassSampler&quot;}),t._fsqSampler.create(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._fullScreenQuad=xT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash(&quot;fpfsq&quot;),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0),vec4<f32>(0.0),vec4<f32>(1.0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._finalBlitOutputTextureView=ub.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const Jb={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;opaquePass&quot;,&quot;translucentPass&quot;,&quot;volumePass&quot;]),Qb(e,t)}var tx={newInstance:jt.newInstance(ex,&quot;vtkForwardPass&quot;),extend:ex};const{VtkDataTypes:nx}=Es;function rx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format=&quot;r&quot;;break;case 2:e.format=&quot;rg&quot;;break;default:e.format=&quot;rgba&quot;}switch(e.dataArray.getDataType()){case nx.UNSIGNED_CHAR:e.format+=&quot;8unorm&quot;;break;case nx.FLOAT:case nx.UNSIGNED_INT:case nx.INT:case nx.DOUBLE:case nx.UNSIGNED_SHORT:case nx.SHORT:default:e.format+=&quot;16float&quot;}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format=&quot;rgba8unorm&quot;),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=mb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push(&quot;vtkWebGPUTextureManager&quot;),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const ox={handle:null,device:null};function ax(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ox,n),jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;]),rx(e,t)}var ix={newInstance:jt.newInstance(ax),extend:ax};class sx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&&quot;object&quot;==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function lx(e,t){t.classHierarchy.push(&quot;vtkWebGPUDevice&quot;),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro(&quot;layout not found&quot;),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro(&quot;attempt to cache an object without a hash&quot;),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const cx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cx,n),yt(e,t),At(e,t,[&quot;handle&quot;]),bt(e,t,[&quot;bufferManager&quot;,&quot;shaderCache&quot;,&quot;textureManager&quot;]),t.objectCache=new sx,t.shaderCache=Uy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=nb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=ix.newInstance(),t.textureManager.setDevice(e),t.pipelines={},lx(e,t)}var dx={newInstance:Et(ux,&quot;vtkWebGPUDevice&quot;),extend:ux};function px(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelectionPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;hardwareSelectorColor&quot;}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;rgba32uint&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView(&quot;hardwareSelectColorTexture&quot;);t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=mb.newInstance({label:&quot;hardwareSelectorDepth&quot;}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;depth32float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;hardwareSelectDepthTexture&quot;);t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation(&quot;cameraPass&quot;),r.traverse(e),e.setCurrentOperation(&quot;opaquePass&quot;),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=wT.newInstance({label:&quot;HardwareSelectionPass&quot;}),t.selectionRenderEncoder.setPipelineHash(&quot;sel&quot;),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<u32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);&quot;]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba32uint&quot;,blend:void 0}]}})}}const fx={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function gx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fx,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),px(e,t)}var mx={newInstance:jt.newInstance(gx,&quot;vtkWebGPUHardwareSelectionPass&quot;),extend:gx};const{SelectionContent:hx,SelectionField:vx}=qp,{FieldAssociations:yx}=ol,{vtkErrorMacro:Tx}=jt;function bx(e){return`${e.propID} ${e.compositeID}`}function xx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Cx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=xx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=xx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Cx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Cx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Cx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Cx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Cx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Sx(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelector&quot;),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Tx(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=ET.newInstance({label:&quot;hardwareSelectColorBuffer&quot;});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=ET.newInstance({label:&quot;hardwareSelectDepthBuffer&quot;}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:&quot;depth-only&quot;},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Cx(e,[n,t],0,u);if(r){const t=bx(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=qp.newInstance();switch(i.setContentType(hx.INDICES),e){case yx.FIELD_ASSOCIATION_CELLS:i.setFieldType(vx.CELL);break;case yx.FIELD_ASSOCIATION_POINTS:i.setFieldType(vx.POINT);break;default:Tx(&quot;Unknown field association&quot;)}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Ax={};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),Gp.extend(e,t,n),t._selectionPass=mx.newInstance(),jt.setGet(e,t,[&quot;_WebGPURenderWindow&quot;]),jt.moveToProtected(e,t,[&quot;WebGPURenderWindow&quot;]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,&quot;vtkWebGPUHardwareSelector&quot;),extend:Ix};const Px=Object.create(null);function Ox(e,t){t.classHierarchy.push(&quot;vtkWebGPUViewNodeFactory&quot;)}const Rx={};function Mx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rx,n),t.overrides=Px,tn.extend(e,t,n),Ox(0,t)}var Dx={newInstance:jt.newInstance(Mx,&quot;vtkWebGPUViewNodeFactory&quot;),extend:Mx};const{vtkErrorMacro:Ex}=jt,Vx={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Lx(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderWindow&quot;),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:&quot;premultiplied&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Ex(&quot;WebGPU is not enabled.&quot;);e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Ex(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:&quot;high-performance&quot;}),t.deleted||(t.device=dx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext(&quot;webgpu&quot;))},e.releaseGraphicsResources=()=>{const n=qv.newInstance();n.setCurrentOperation(&quot;Release&quot;),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Vx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=ET.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Ad.fromHalf(r.colorValues[o]),s[n+1]=255*Ad.fromHalf(r.colorValues[o+1]),s[n+2]=255*Ad.fromHalf(r.colorValues[o+2]),s[n+3]=255*Ad.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=wx.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Bx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Nx=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,xy.extend(e,t,n),t.myFactory=Dx.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Nx),t.renderPasses[0]=tx.newInstance(),t.selector||(t.selector=wx.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,&quot;imageReady&quot;),jt.event(e,t,&quot;initialized&quot;),jt.get(e,t,[&quot;commandEncoder&quot;,&quot;device&quot;,&quot;presentationFormat&quot;,&quot;useBackgroundImage&quot;,&quot;xrSupported&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;device&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Lx(e,t)}),&quot;vtkWebGPURenderWindow&quot;);ev(&quot;WebGPU&quot;,Nx);const _x=Hv(),Fx={margin:&quot;0&quot;,padding:&quot;0&quot;,position:&quot;absolute&quot;,top:&quot;0&quot;,left:&quot;0&quot;,width:&quot;100%&quot;,height:&quot;100%&quot;,overflow:&quot;hidden&quot;},kx={position:&quot;absolute&quot;,left:&quot;25px&quot;,top:&quot;25px&quot;,backgroundColor:&quot;white&quot;,borderRadius:&quot;5px&quot;,listStyle:&quot;none&quot;,padding:&quot;5px 10px&quot;,margin:&quot;0&quot;,display:&quot;block&quot;,border:&quot;solid 1px black&quot;,maxWidth:&quot;calc(100% - 70px)&quot;,maxHeight:&quot;calc(100% - 60px)&quot;,overflow:&quot;auto&quot;};function Gx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Ux(e,t){t.classHierarchy.push(&quot;vtkFullScreenRenderWindow&quot;);const n=document.querySelector(&quot;body&quot;);t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement(&quot;div&quot;),Gx(t.container,t.containerStyle||Fx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height=&quot;100%&quot;,n.style.height=&quot;100%&quot;,n.style.padding=&quot;0&quot;,n.style.margin=&quot;0&quot;),t.renderWindow=av.newInstance(),t.renderer=Qh.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(_x.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Sv.newInstance(),t.interactor.setInteractorStyle(Uv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?&quot;block&quot;:&quot;none&quot;)},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement(&quot;div&quot;),Gx(t.controlContainer,t.controlPanelStyle||kx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener(&quot;keypress&quot;,(t=>{&quot;c&quot;===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}))},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener(&quot;resize&quot;,e.resize),e.resize()}const zx={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Wx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zx,n),jt.obj(e,t),jt.get(e,t,[&quot;renderWindow&quot;,&quot;renderer&quot;,&quot;apiSpecificRenderWindow&quot;,&quot;interactor&quot;,&quot;rootContainer&quot;,&quot;container&quot;,&quot;controlContainer&quot;]),Ux(e,t)}var Hx={newInstance:jt.newInstance(Wx),extend:Wx},jx={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:Kx,Scale:$x}=jx,{ScalarMappingTarget:qx}=Pl,{vtkDebugMacro:Xx,vtkErrorMacro:Yx,vtkWarningMacro:Zx}=jt;function Qx(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Jx(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function eC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];Qx(o,i),Qx(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Jx(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Jx(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function tC(e,t){t.classHierarchy.push(&quot;vtkColorTransferFunction&quot;),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Yx(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(s<0||s>1)return Yx(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===$x.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Do(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===Kx.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===Kx.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;,t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===Kx.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===Kx.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;);for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Yx(&quot;Attempting to lookup a value with no points in the function&quot;),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Yx(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Yx(&quot;Index out of range!&quot;),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>t.indexedLookup&&e.getSize()?e.getSize():t.tableSize?t.tableSize:16777216,e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void Yx(&quot;attempt to set zero width color range&quot;);const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):Xx(&quot;Transfer Function Has No Points!&quot;)},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void Zx(&quot;Transfer Function Has No Points!&quot;);const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===qx.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===qx.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===qx.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===qx.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=Kx[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Yx(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=Kx.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const nC={clamping:!0,colorSpace:Kx.RGB,hSVWrap:!0,scale:$x.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function rC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nC,n),Pl.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,[&quot;buildTime&quot;,&quot;mappingRange&quot;]),jt.setGet(e,t,[&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;,&quot;colorSpace&quot;,&quot;discretize&quot;,&quot;numberOfValues&quot;]),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),tC(e,t)}var oC={newInstance:jt.newInstance(rC,&quot;vtkColorTransferFunction&quot;),extend:rC,...jx},aC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:iC,ScaleModes:sC}=aC,{vtkErrorMacro:lC}=jt;function cC(e,t){t.classHierarchy.push(&quot;vtkGlyph3DMapper&quot;),e.getOrientationModeAsString=()=>jt.enumToString(iC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(iC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(iC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(iC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(sC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(sC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(sC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(sC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===sC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(lC(&quot;Cannot scale by components since scale array does not have 3 components.&quot;),a=null);const l=r.getBounds(),c=[];ki.getCorners(l,c),t.bounds[0]=ki.INIT_BOUNDS[0],t.bounds[1]=ki.INIT_BOUNDS[1],t.bounds[2]=ki.INIT_BOUNDS[2],t.bounds[3]=ki.INIT_BOUNDS[3],t.bounds[4]=ki.INIT_BOUNDS[4],t.bounds[5]=ki.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case iC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case iC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case iC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case sC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case sC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case sC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const uC={orient:!0,orientationMode:iC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:sC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function dC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uC,n),nc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,[&quot;orient&quot;,&quot;orientationMode&quot;,&quot;orientationArray&quot;,&quot;scaleArray&quot;,&quot;scaleFactor&quot;,&quot;scaleMode&quot;,&quot;scaling&quot;]),jt.get(e,t,[&quot;colorArray&quot;,&quot;matrixArray&quot;,&quot;normalArray&quot;,&quot;buildTime&quot;]),cC(e,t)}var pC={newInstance:jt.newInstance(dC,&quot;vtkGlyph3DMapper&quot;),extend:dC,...aC};const{vtkErrorMacro:fC}=jt;function gC(e,t){t.classHierarchy.push(&quot;vtkPiecewiseFunction&quot;),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return&quot;Constant&quot;;case 1:return&quot;NonDecreasing&quot;;case 2:return&quot;NonIncreasing&quot;;default:return&quot;Varied&quot;}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(fC(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return fC(&quot;Index out of range!&quot;),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return fC(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(a<0||a>1)return fC(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const mC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function hC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,[&quot;allowDuplicateScalars&quot;,&quot;clamping&quot;]),jt.setArray(e,t,[&quot;range&quot;],2),jt.getArray(e,t,[&quot;range&quot;]),gC(e,t)}var vC={newInstance:jt.newInstance(hC,&quot;vtkPiecewiseFunction&quot;),extend:hC};const{InterpolationType:yC,OpacityMode:TC}=Og,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push(&quot;vtkVolumeProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(bC(&quot;Bad index - must be between 0 and 3&quot;),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=vC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=oC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=vC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return bC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(bC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(yC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(yC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(yC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(yC,t.interpolationType),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const CC={independentComponents:!0,interpolationType:yC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,CC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:TC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;shade&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,&quot;vtkVolumeProperty&quot;),extend:SC,...Og};const{vtkDebugMacro:IC}=jt;function wC(e,t){t.classHierarchy.push(&quot;vtkVolume&quot;),e.getVolumes=()=>e,e.makeProperty=AC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){IC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e));const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const PC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),wC(e,t)}var RC={newInstance:jt.newInstance(OC,&quot;vtkVolume&quot;),extend:OC};const{BlendMode:MC,FilterMode:DC}=Mg,EC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=vC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function VC(e,t){t.classHierarchy.push(&quot;vtkVolumeMapper&quot;);const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(MC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(MC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(MC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(MC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(MC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(MC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(MC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn(&quot;setAverageIPScalarRange is deprecated use setIpScalarRange&quot;),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(DC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(DC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(DC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(DC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Do(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const LC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:MC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:DC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LC,n),Bs(e,t,n),jt.setGet(e,t,[&quot;sampleDistance&quot;,&quot;imageSampleDistance&quot;,&quot;maximumSamplesPerRay&quot;,&quot;autoAdjustSampleDistances&quot;,&quot;initialInteractionScale&quot;,&quot;interactionSampleDistanceFactor&quot;,&quot;blendMode&quot;,&quot;filterMode&quot;,&quot;preferSizeOverAccuracy&quot;,&quot;computeNormalFromOpacity&quot;,&quot;volumetricScatteringBlending&quot;,&quot;globalIlluminationReach&quot;,&quot;volumeShadowSamplingDistFactor&quot;,&quot;anisotropy&quot;,&quot;localAmbientOcclusion&quot;,&quot;LAOKernelSize&quot;,&quot;LAOKernelRadius&quot;]),jt.setGetArray(e,t,[&quot;ipScalarRange&quot;],2),jt.event(e,t,&quot;lightingActivated&quot;),VC(e,t)}var NC={newInstance:jt.newInstance(BC,&quot;vtkVolumeMapper&quot;),extend:BC,...EC};const{InterpolationType:_C}=eg,{vtkErrorMacro:FC}=jt;function kC(e,t){t.classHierarchy.push(&quot;vtkImageProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return FC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(FC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(_C.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(_C.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(_C,t.interpolationType)}const GC={independentComponents:!1,interpolationType:_C.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function UC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,GC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;colorWindow&quot;,&quot;colorLevel&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;opacity&quot;,&quot;useLookupTableScalarRange&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),kC(e,t)}var zC={newInstance:jt.newInstance(UC,&quot;vtkImageProperty&quot;),extend:UC};const{vtkDebugMacro:WC}=jt;function HC(e,t){t.classHierarchy.push(&quot;vtkImageSlice&quot;),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=zC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){WC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),ki.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!ki.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),ki.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const jC={mapper:null,property:null,bounds:[...ki.INIT_BOUNDS]};function KC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),HC(e,t)}var $C={newInstance:jt.newInstance(KC,&quot;vtkImageSlice&quot;),extend:KC};function qC(e,t){t.classHierarchy.push(&quot;vtkAbstractImageMapper&quot;),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro(&quot;vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED&quot;),Fa())}const XC={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var YC=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,XC,n),Fs(e,t,n),jt.setGet(e,t,[&quot;slice&quot;,&quot;useCustomExtents&quot;]),jt.setGetArray(e,t,[&quot;customDisplayExtent&quot;],6),jt.setGetArray(e,t,[&quot;backgroundColor&quot;],4),qC(e,t)};function ZC(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA(&quot;vtkImageArrayMapper&quot;)?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ni.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:QC,otherStaticMethods:JC}=Ul,{SlicingMode:eS}=sg;function tS(e,t){function n(){let n;switch(t.slicingMode){case eS.X:n=0;break;case eS.Y:n=1;break;case eS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push(&quot;vtkImageMapper&quot;),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case eS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case eS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case eS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case eS.I:l=Ma(a[0],i[0],i[1]);break;case eS.J:l=Ma(a[1],i[2],i[3]);break;case eS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case eS.I:case eS.J:case eS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case eS.X:e.setSlice(r[0]);break;case eS.Y:e.setSlice(r[1]);break;case eS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(eS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(eS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(eS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(eS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(eS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(eS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case eS.X:n[0]=1;break;case eS.Y:n[1]=1;break;case eS.Z:n[2]=1;break;case eS.I:ea(r,[1,0,0],n);break;case eS.J:ea(r,[0,1,0],n);break;case eS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==eS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case eS.I:r[0]=a,r[1]=a;break;case eS.J:r[2]=a,r[3]=a;break;case eS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case eS.I:a[0]=s-r,a[1]=s+r;break;case eS.J:a[2]=s-r,a[3]=s+r;break;case eS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const nS={slicingMode:eS.NONE,closestIJKAxis:{ijkMode:eS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function rS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nS,n),YC(e,t,n),jt.get(e,t,[&quot;slicingMode&quot;]),jt.setGet(e,t,[&quot;closestIJKAxis&quot;,&quot;renderToRectangle&quot;,&quot;sliceAtFocalPoint&quot;,&quot;preferSizeOverAccuracy&quot;]),Ul.implementCoincidentTopologyMethods(e,t),tS(e,t)}var oS={newInstance:jt.newInstance(rS,&quot;vtkImageMapper&quot;),extend:rS,...QC,...JC,...sg};const{vtkErrorMacro:aS}=jt;function iS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function sS(e,t){t.classHierarchy.push(&quot;vtkAppendPolyData&quot;),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void aS(&quot;No input specified.&quot;);if(1===o)return void(r[0]=n[0]);const a=gu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===js.SINGLE?s=ys.FLOAT:t.outputPointsPrecision===js.DOUBLE&&(s=ys.DOUBLE);const v=mc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Es.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Es.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Es.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),iS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),iS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),iS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),iS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const lS={outputPointsPrecision:js.DEFAULT};function cS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lS,n),jt.setGet(e,t,[&quot;outputPointsPrecision&quot;]),jt.obj(e,t),jt.algo(e,t,1,1),sS(e,t)}var uS={newInstance:jt.newInstance(cS,&quot;vtkAppendPolyData&quot;),extend:cS};function dS(e,t){t.classHierarchy.push(&quot;vtkConeSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Nf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=gu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const pS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:&quot;Float64Array&quot;};function fS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),dS(e,t)}var gS={newInstance:jt.newInstance(fS,&quot;vtkConeSource&quot;),extend:fS};function mS(e,t){t.classHierarchy.push(&quot;vtkCylinderSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Es.newInstance({numberOfComponents:3,values:u,name:&quot;Normals&quot;}),p=new Float32Array(2*a),f=Es.newInstance({numberOfComponents:2,values:p,name:&quot;TCoords&quot;}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Nf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=gu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const hS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:&quot;Float64Array&quot;};function vS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;initAngle&quot;,&quot;otherRadius&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),mS(e,t)}var yS={newInstance:jt.newInstance(vS,&quot;vtkCylinderSource&quot;),extend:vS};function TS(e,t){t.classHierarchy.push(&quot;vtkArrowSource&quot;),e.requestData=function(e,n){if(t.deleted)return;const r=yS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Bf().rotateZ(-90).apply(a).apply(i);const s=gS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Nf().translate(1-.5*t.tipLength,0,0).apply(c);const u=uS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Nf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Nf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Nf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const bS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:&quot;Float64Array&quot;};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;tipResolution&quot;,&quot;tipRadius&quot;,&quot;tipLength&quot;,&quot;shaftResolution&quot;,&quot;shaftRadius&quot;,&quot;invert&quot;]),jt.setGetArray(e,t,[&quot;direction&quot;],3),jt.algo(e,t,0,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,&quot;vtkArrowSource&quot;),extend:xS};function SS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Bf().translate(...n).apply(e.getPoints().getData())}function AS(e,t){const n=e.getPoints().getBounds(),r=[0,0,0];r[t]=-n[2*t],Bf().translate(...r).apply(e.getPoints().getData())}function IS(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8Array(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Es.newInstance({name:&quot;color&quot;,numberOfComponents:3,values:a}))}function wS(e,t){t.classHierarchy.push(&quot;vtkAxesActor&quot;);const n=nc.newInstance();e.setMapper(n),e.update=()=>{const e=CS.newInstance({direction:[1,0,0],...t.config}).getOutputData();t.config.recenter?SS(e):AS(e,0),IS(e,...t.xAxisColor);const r=CS.newInstance({direction:[0,1,0],...t.config}).getOutputData();t.config.recenter?SS(r):AS(r,1),IS(r,...t.yAxisColor);const o=CS.newInstance({direction:[0,0,1],...t.config}).getOutputData();t.config.recenter?SS(o):AS(o,2),IS(o,...t.zAxisColor);const a=uS.newInstance();a.setInputData(e),a.addInputData(r),a.addInputData(o),n.setInputConnection(a.getOutputPort())},e.update();const r=jt.debounce(e.update,0),{setConfig:o,setXAxisColor:a,setYAxisColor:i,setZAxisColor:s}=e;e.setConfig=e=>!!o(e)&&(r(),!0),e.setXAxisColor=e=>!!a(e)&&(r(),!0),e.setYAxisColor=e=>!!i(e)&&(r(),!0),e.setZAxisColor=e=>!!s(e)&&(r(),!0)}const PS={config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1},xAxisColor:[255,0,0],yAxisColor:[255,255,0],zAxisColor:[0,128,0]};function OS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PS,n),hs.extend(e,t,n),jt.setGet(e,t,[&quot;config&quot;]),jt.setGetArray(e,t,[&quot;xAxisColor&quot;,&quot;yAxisColor&quot;,&quot;zAxisColor&quot;],3,255),wS(e,t)}var RS={newInstance:jt.newInstance(OS,&quot;vtkAxesActor&quot;),extend:OS};const MS=&quot;resetcamera&quot;,DS=&quot;orientation&quot;,ES={MODE_RESET_CAMERA:MS,MODE_ORIENTATION:DS,MODE_SAME:&quot;same&quot;};function VS(e,t){t.classHierarchy.push(&quot;vtkCameraSynchronizer&quot;);const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName(&quot;position&quot;),s=e.getReferenceByName(&quot;focalPoint&quot;),l=e.getReferenceByName(&quot;viewUp&quot;),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===DS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===MS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const LS={mode:DS,focalPoint:[0,0,0],distance:6.8,active:!0};function BS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LS,n),yt(e,t),At(e,t,[&quot;mode&quot;,&quot;active&quot;,&quot;srcRenderer&quot;,&quot;dstRenderer&quot;,&quot;distance&quot;]),Pt(e,t,[&quot;focalPoint&quot;],3,0),VS(e,t)}var NS={newInstance:Et(BS,&quot;vtkCameraSynchronizer&quot;),extend:BS,SynchronizationMode:ES};const _S={},FS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=NS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:NS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var kS=function(e,t,n){const r=e.get(&quot;synchronizedViewId&quot;).synchronizedViewId;if(!t.behaviors||!r)return;_S[r]||(_S[r]={});const o=_S[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=NS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];FS[e.type]?o[r]=new FS[e.type](n,e):console.log(&quot;No mapping for&quot;,e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const GS={},US=/instance:\\${([^}]+)}/,zS={},WS=[],HS={},jS={vtkPoints:mc,vtkCellArray:cc,vtkDataArray:Es};function KS(e){return e.map((e=>US.exec(e))).filter((e=>e)).map((e=>e[1]))}function $S(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),$S(e,t)})),t}function qS(e,t,n,r){if(!t)return Promise.reject(new Error(&quot;No instance provided.&quot;));const o=GS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function XS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=GS[e];return n&&n.build?n.build(t):(console.log(&quot;No builder for&quot;,e),null)}function YS(){Object.keys(GS).forEach((e=>{delete GS[e]}))}function ZS(){Object.keys(zS).forEach((e=>{delete zS[e]}))}function QS(e){if(1===e[1].length)return-1===WS.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===WS.indexOf(e[1][n]);return t}function JS(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(HS[r]){const{key:n,value:o}=HS[r];if(!n||e.properties[n]===o)return void WS.push((e=>`instance:\\${${e}}`)(t))}let o=n.getInstance(t);o||(o=XS(r,{managedInstanceId:t}),n.registerInstance(t,o)),qS(r,o,e,n)})),t.calls&&t.calls.filter(QS).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=US.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:&quot;addArray&quot;,a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:&quot;vtkDataArray&quot;,l=jS[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log(&quot;Error fetching array&quot;,JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error(&quot;Error in array handling for state&quot;,JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function eA(e,t,n){zS[t.id]||JS(e,t,n),zS[t.id]=!0}function tA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function nA(e){const t=e.name?`_${e.name}`:&quot;&quot;;return`${e.hash}_${e.dataType}${t}`}function rA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=nA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=nA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),tA(t.getPointData(),i.pointData),tA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=JS(t,s,r);return r.end(),l}}const oA=rA([&quot;points&quot;,&quot;polys&quot;,&quot;verts&quot;,&quot;lines&quot;,&quot;strips&quot;]),aA=rA([]);function iA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:JS;XS||qS?GS[e]={build:t,update:n}:delete GS[e]}const sA={vtkMapper:[&quot;vtkOpenGLPolyDataMapper&quot;,&quot;vtkCompositePolyDataMapper2&quot;,&quot;vtkDataSetMapper&quot;],vtkProperty:[&quot;vtkOpenGLProperty&quot;],vtkRenderer:[&quot;vtkOpenGLRenderer&quot;],vtkCamera:[&quot;vtkOpenGLCamera&quot;],vtkColorTransferFunction:[&quot;vtkPVDiscretizableColorTransferFunction&quot;],vtkActor:[&quot;vtkOpenGLActor&quot;,&quot;vtkPVLODActor&quot;],vtkLight:[&quot;vtkOpenGLLight&quot;,&quot;vtkPVLight&quot;],vtkTexture:[&quot;vtkOpenGLTexture&quot;],vtkImageMapper:[&quot;vtkOpenGLImageSliceMapper&quot;],vtkVolumeMapper:[&quot;vtkFixedPointVolumeRayCastMapper&quot;]},lA={vtkAxesActor:{build:RS.newInstance,update:JS},vtkRenderWindow:{build:av.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(QS).filter((e=>&quot;removeRenderer&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),JS(e,t,n),kS(e,t,n)}},vtkRenderer:{build:Qh.newInstance,update:function(e,t,n){JS(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=$S(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(QS).filter((e=>&quot;removeViewProp&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{const t=n.getInstance(e).get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:El.newInstance,update:JS},vtkCamera:{build:Bh.newInstance,update:eA},vtkPolyData:{build:gu.newInstance,update:oA},vtkImageData:{build:fl.newInstance,update:aA},vtkMapper:{build:nc.newInstance,update:JS},vtkGlyph3DMapper:{build:pC.newInstance,update:JS},vtkProperty:{build:ds.newInstance,update:JS},vtkActor:{build:hs.newInstance,update:JS},vtkLight:{build:kh.newInstance,update:JS},vtkColorTransferFunction:{build:oC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Tu.newInstance,update:JS},vtkVolume:{build:RC.newInstance,update:JS},vtkVolumeMapper:{build:NC.newInstance,update:JS},vtkVolumeProperty:{build:AC.newInstance,update:JS},vtkImageSlice:{build:$C.newInstance,update:JS},vtkImageMapper:{build:oS.newInstance,update:JS},vtkImageProperty:{build:zC.newInstance,update:JS},vtkPiecewiseFunction:{build:vC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:Fu.newInstance,update:JS},vtkScalarBarActor:{build:Op.newInstance,update:JS}};function cA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&YS(),Object.keys(lA).forEach((e=>{const t=lA[e];iA(e,t.build,t.update)}))}function uA(){Object.keys(sA).forEach((e=>{sA[e].forEach((t=>{GS[t]=GS[e]}))}))}cA(),uA(),HS.vtkPVLight={};var dA={build:XS,update:qS,genericUpdater:JS,oneTimeGenericUpdater:eA,setTypeMapping:iA,clearTypeMapping:YS,getSupportedTypes:function(){return Object.keys(GS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return ZS();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete zS[e]})),r},updateRenderWindow:function(e,t,n){return qS(&quot;vtkRenderWindow&quot;,e,t,n)},excludeInstance:function(e,t,n){HS[e]={key:t,value:n}},setDefaultMapping:cA,applyDefaultAliases:uA,alwaysUpdateCamera:function(){iA(&quot;vtkCamera&quot;,Bh.newInstance),uA()}};const pA={};function fA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if(&quot;string&quot;==typeof t&&(i=Dm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log(&quot;Error getting data array:&quot;),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use &quot;setArrayFetcher&quot; to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function gA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function mA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Dt(t,n,&quot;progressEvent&quot;),Dt(t,n,&quot;progressDone&quot;),t}function hA(){const e={};let t=&quot;default&quot;;return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function vA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;default&quot;,t=pA[e];return t||(t={...fA(),...gA(),...mA(),...hA()},pA[e]=t),t}function yA(e,t){let n=-1,r=100;const o=e=>e.get(&quot;managedInstanceId&quot;).managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get(&quot;synchronizedViewId&quot;).synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),dA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){dA.clearOneTimeUpdaters(a())}}}function TA(e,t){t.classHierarchy.push(&quot;vtkSynchronizableRenderWindow&quot;),t.synchronizerContext||(t.synchronizerContext=vA(t.synchronizerContextName));const n=yA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const bA={synchronizerContextName:&quot;default&quot;,synchronizerContext:null,synchronizedViewId:null};function xA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bA,n),av.extend(e,t),bt(e,t,[&quot;synchronizerContext&quot;]),TA(e,t)}var CA={newInstance:Et(xA,&quot;vtkSynchronizableRenderWindow&quot;),extend:xA,getSynchronizerContext:vA,setSynchronizerContext:function(e,t){pA[e]=t},clearSynchronizerContext:function(e){if(e&&pA[e]&&delete pA[e],!e){const e=Object.keys(pA);for(let t=0;t<e.length;t++)delete pA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;default&quot;;const n=yA(e,vA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:gA,createArrayHandler:fA,createProgressHandler:mA,createSceneMtimeHandler:hA,vtkObjectManager:dA};const{vtkErrorMacro:SA,vtkDebugMacro:AA}=jt;let IA=0;function wA(e){const t=document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`);return t?t.innerHTML:null}function PA(e){return&quot;/&quot;===e[0]?e.substr(1):e}const OA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=wA(PA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=wA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=PA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;)),s=wA(i);if(null===s)a(new Error(`No such array ${i}`));else{if(&quot;string&quot;===n.dataType){let e=atob(s);r.compression&&(e=yh(mh(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Dm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(AA(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&SA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--IA&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};Vm(&quot;html&quot;,(e=>OA));const{vtkErrorMacro:RA,vtkDebugMacro:MA}=jt;function DA(e){return function(e){return&quot;/&quot;===e[0]?e.substr(1):e}(function(e){return new URL(e,&quot;http://any&quot;).pathname}(e))}const EA=function(e){let t=!1,n=0,r=null,o=&quot;&quot;;var a;return(a=e.zipContent,new Promise(((e,t)=>{&quot;string&quot;==typeof a?e(function(e,t){if(t){for(var n=new Bm(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(hh)return hh.encode(e);var o=e.length,a=new Bm(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new Bm(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return oh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error(&quot;Invalid datatype to unpack.&quot;))}))).then((n=>{r=Ch(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith(&quot;index.json&quot;)&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\\.json$/,&quot;&quot;),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||RA(&quot;ERROR!!! zip not ready...&quot;);const u=DA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join(&quot;/&quot;));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if(&quot;string&quot;!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&(&quot;string&quot;===e.dataType||&quot;JSON&quot;===e.dataType?e.buffer=yh(mh(new Uint8Array(e.buffer))):e.buffer=mh(new Uint8Array(e.buffer)).buffer),&quot;JSON&quot;===e.ref.encode?e.values=JSON.parse(e.buffer):(Ah!==e.ref.encode&&Ah&&(MA(`Swap bytes of ${e.name}`),Ih(e.buffer,vs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&RA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(yh(mh(r))):JSON.parse(r),n()}}(i,s.compression,d);e(yh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];if(a.compression){if(&quot;gz&quot;===a.compression){const e=yh(mh(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error(&quot;Invalid compression&quot;))}return Promise.resolve(JSON.parse(yh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(yh(Ch(s))):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(yh(s))},fetchImage(e,n){const a=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=Mm(i.buffer);n.src=`data:image/${function(e){const t=e.split(&quot;.&quot;).pop().toLowerCase();return&quot;jpg&quot;===t?&quot;jpeg&quot;:t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(mh(s).buffer):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(s.buffer)}}};Vm(&quot;zip&quot;,(e=>EA(e)));var VA=n(892),LA=n.n(VA),BA=n(760),NA=n.n(BA),_A=n(311),FA=n.n(_A),kA=n(192),GA=n.n(kA),UA=n(60),zA=n.n(UA),WA=n(865),HA=n.n(WA),jA=n(34),KA={};KA.styleTagTransform=HA(),KA.setAttributes=GA(),KA.insert=FA().bind(null,&quot;head&quot;),KA.domAPI=NA(),KA.insertStyleElement=zA(),LA()(jA.Z,KA);var $A=jA.Z&&jA.Z.locals?jA.Z.locals:void 0;let qA=!0;function XA(e){e.preventDefault(),e.stopPropagation()}function YA(e,t){qA=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=Hx.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:&quot;100%&quot;,width:&quot;100%&quot;,position:&quot;absolute&quot;}}).getRenderWindow(),o=CA.getSynchronizerContext(),a=CA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement(&quot;div&quot;);n.setAttribute(&quot;class&quot;,$A.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?Mh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Lm(&quot;zip&quot;,{zipContent:t,callback:e=>{r.fetchJSON(null,&quot;index.json&quot;).then(i)}})})):Mh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Lm(&quot;zip&quot;,{zipContent:t.file,callback:t=>{e.fetchJSON(null,&quot;index.json&quot;).then(i)}})}else if(t.base64Str){const e=Dm(t.base64Str),n=Lm(&quot;zip&quot;,{zipContent:e,callback:e=>{n.fetchJSON(null,&quot;index.json&quot;).then(i)}})}}function ZA(e){qA=!1;const t=document.querySelector(&quot;.content&quot;),n=document.querySelector(&quot;body&quot;),r=e||t||n;r!==e?(r.classList.add($A.fullScreen),n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;):(n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;);const o=document.createElement(&quot;div&quot;);o.innerHTML=`<div class=&quot;${$A.bigFileDrop}&quot;/><input type=&quot;file&quot; accept=&quot;.zip,.vtksz&quot; style=&quot;display: none;&quot;/>`,r.appendChild(o);const a=o.querySelector(&quot;input&quot;);function i(e){XA(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(&quot;.&quot;).slice(-1)[0];YA(r,{file:n[0],ext:e})}}a.addEventListener(&quot;change&quot;,i),o.addEventListener(&quot;drop&quot;,i),o.addEventListener(&quot;click&quot;,(e=>a.click())),o.addEventListener(&quot;dragover&quot;,XA)}const QA=Hv();if(QA.url||QA.fileURL){const e=document.querySelector(&quot;.content&quot;),t=document.querySelector(&quot;body&quot;),n=e||t;n&&(n.classList.add($A.fullScreen),t.style.margin=&quot;0&quot;,t.style.padding=&quot;0&quot;),qA=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>YA(n,QA)))}setTimeout((()=>{qA&&ZA()}),100),window.OfflineLocalView={initLocalFileLoader:ZA,load:YA}},793:function(e){&quot;use strict&quot;;e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=&quot;&quot;,r=void 0!==t[5];return t[4]&&(n+=&quot;@supports (&quot;.concat(t[4],&quot;) {&quot;)),t[2]&&(n+=&quot;@media &quot;.concat(t[2],&quot; {&quot;)),r&&(n+=&quot;@layer&quot;.concat(t[5].length>0?&quot; &quot;.concat(t[5]):&quot;&quot;,&quot; {&quot;)),n+=e(t),r&&(n+=&quot;}&quot;),t[2]&&(n+=&quot;}&quot;),t[4]&&(n+=&quot;}&quot;),n})).join(&quot;&quot;)},t.i=function(e,n,r,o,a){&quot;string&quot;==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]=&quot;@layer&quot;.concat(u[5].length>0?&quot; &quot;.concat(u[5]):&quot;&quot;,&quot; {&quot;).concat(u[1],&quot;}&quot;)),u[5]=a),n&&(u[2]?(u[1]=&quot;@media &quot;.concat(u[2],&quot; {&quot;).concat(u[1],&quot;}&quot;),u[2]=n):u[2]=n),o&&(u[4]?(u[1]=&quot;@supports (&quot;.concat(u[4],&quot;) {&quot;).concat(u[1],&quot;}&quot;),u[4]=o):u[4]=&quot;&quot;.concat(o)),t.push(u))}},t}},490:function(e){&quot;use strict&quot;;e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['&quot;].*['&quot;]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/[&quot;'() \\t\\n]|(%20)/.test(e)||t.needQuotes?'&quot;'.concat(e.replace(/&quot;/g,'\\\\&quot;').replace(/\\n/g,&quot;\\\\n&quot;),'&quot;'):e):e}},22:function(e){&quot;use strict&quot;;e.exports=function(e){return e[1]}},145:function(e,t,n){&quot;use strict&quot;;var r=n(426),o=&quot;function&quot;==typeof Symbol&&&quot;symbol&quot;==typeof Symbol(&quot;foo&quot;),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,&quot;x&quot;,{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||&quot;function&quot;==typeof(o=r)&&&quot;[object Function]&quot;===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){&quot;use strict&quot;;e.exports=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;var e;try{e=this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window;if(&quot;object&quot;==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){&quot;use strict&quot;;e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&&quot;object&quot;==typeof t&&&quot;object&quot;==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){&quot;use strict&quot;;&quot;undefined&quot;!=typeof self?e.exports=self:&quot;undefined&quot;!=typeof window?e.exports=window:e.exports=Function(&quot;return this&quot;)()},177:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){&quot;use strict&quot;;var r=n(491);e.exports=function(){return&quot;object&quot;==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,&quot;globalThis&quot;);t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,&quot;globalThis&quot;,{configurable:!0,enumerable:!1,value:e,writable:!0})}else&quot;object&quot;==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){&quot;use strict&quot;;var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},&quot;toString&quot;),c=s.call((function(){}),&quot;prototype&quot;),u=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if(&quot;undefined&quot;==typeof window)return!1;for(var e in window)try{if(!p[&quot;$&quot;+e]&&o.call(window,e)&&null!==window[e]&&&quot;object&quot;==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&&quot;object&quot;==typeof e,n=&quot;[object Function]&quot;===a.call(e),r=i(e),s=t&&&quot;[object String]&quot;===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError(&quot;Object.keys called on a non-object&quot;);var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&&quot;prototype&quot;===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if(&quot;undefined&quot;==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&&quot;constructor&quot;===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){&quot;use strict&quot;;var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){&quot;use strict&quot;;var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r=&quot;[object Arguments]&quot;===n;return r||(r=&quot;[object Array]&quot;!==n&&null!==e&&&quot;object&quot;==typeof e&&&quot;number&quot;==typeof e.length&&e.length>=0&&&quot;[object Function]&quot;===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(&quot; &quot;),n.s1=r(&quot; &quot;),n.s2=r(&quot; &quot;),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+=&quot;\\0&quot;,r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=&quot;&quot;+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,&quot;global&quot;in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&&quot;object&quot;==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:&quot;string&quot;==o?e:e+&quot;\\0&quot;}function v(e,t){for(var n,r=e+&quot;&quot;,o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}(&quot;undefined&quot;!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){&quot;use strict&quot;;var t=[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r=&quot;&quot;;for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join(&quot;&quot;)}function l(e){return/[\\u0080-\\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a(&quot;hello&quot;)),&quot;undefined&quot;==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff=&quot;&quot;,this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){&quot;use strict&quot;;var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,&quot;.viewer-module-fullScreen_bbk9Y {\\n  position: absolute;\\n  width: 100vw;\\n  height: 100vh;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  z-index: -1;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\n\\n.viewer-module-fullParentSize_ETopO {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n}\\n\\n.viewer-module-bigFileDrop_aqCgh {\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  background-color: white;\\n  background-image: url(&quot;+d+&quot;);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n  background-size: contain;\\n  border-radius: 10px;\\n  width: 50px;\\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\\n  cursor: pointer;\\n}\\n\\n.viewer-module-progress_cYjQJ {\\n  flex: none;\\n  font-size: 50px;\\n  color: black;\\n  z-index: 1;\\n  background: rgba(128,128,128,.5);\\n  padding: 20px;\\n  border-radius: 10px;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\n&quot;,&quot;&quot;]),u.locals={fullScreen:&quot;viewer-module-fullScreen_bbk9Y&quot;,fullParentSize:&quot;viewer-module-fullParentSize_ETopO&quot;,bigFileDrop:&quot;viewer-module-bigFileDrop_aqCgh&quot;,progress:&quot;viewer-module-progress_cYjQJ&quot;},t.Z=u},396:function(e,t,n){var r=n(13),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){&quot;use strict&quot;;var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d=&quot;&quot;.concat(c,&quot; &quot;).concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){&quot;use strict&quot;;var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error(&quot;Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.&quot;);r.appendChild(n)}},60:function(e){&quot;use strict&quot;;e.exports=function(e){var t=document.createElement(&quot;style&quot;);return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){&quot;use strict&quot;;e.exports=function(e){var t=n.nc;t&&e.setAttribute(&quot;nonce&quot;,t)}},760:function(e){&quot;use strict&quot;;e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r=&quot;&quot;;n.supports&&(r+=&quot;@supports (&quot;.concat(n.supports,&quot;) {&quot;)),n.media&&(r+=&quot;@media &quot;.concat(n.media,&quot; {&quot;));var o=void 0!==n.layer;o&&(r+=&quot;@layer&quot;.concat(n.layer.length>0?&quot; &quot;.concat(n.layer):&quot;&quot;,&quot; {&quot;)),r+=n.css,o&&(r+=&quot;}&quot;),n.media&&(r+=&quot;}&quot;),n.supports&&(r+=&quot;}&quot;);var a=n.sourceMap;a&&&quot;undefined&quot;!=typeof btoa&&(r+=&quot;\\n/*# sourceMappingURL=data:application/json;base64,&quot;.concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))),&quot; */&quot;)),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){&quot;use strict&quot;;e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){&quot;use strict&quot;;e.exports=n.p+&quot;138e7b1469f64156810a.jpg&quot;},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error(&quot;define cannot be used indirect&quot;)},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;try{return this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){&quot;undefined&quot;!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p=&quot;&quot;,n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();\n<\/script>\n<script>\nvar container = document.querySelector('.content');\nvar base64Str = &quot;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&quot;;\n\nOfflineLocalView.load(container, { base64Str });\n<\/script>\n</body>\n</html>\n\" class=\"pyvista\" style=\"width: 99%; height: 600px; border: 1px solid rgb(221,221,221);\"></iframe>"}}, "614f72315b1f457b8a71db5e7f264c3a": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLStyleModel", "state": {"description_width": "", "font_size": null, "text_color": null}}, "96d18187666041edb5c2d88aa9e95135": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {}}, "c8da0b965bda4808b6a894d3e68a1242": {"model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "model_name": "HTMLModel", "state": {"layout": "IPY_MODEL_eaa799de3c784f098ed404ea8a023ba6", "style": "IPY_MODEL_614f72315b1f457b8a71db5e7f264c3a", "value": "<iframe srcdoc=\"<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;/>\n    <meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;>\n  </head>\n  <body>\n    <div class=&quot;content&quot;></div>\n<script type=&quot;text/javascript&quot;>\n!function(){var e={334:function(){const e=document.querySelector(&quot;head&quot;);e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement(&quot;link&quot;);n.setAttribute(&quot;rel&quot;,&quot;icon&quot;),n.setAttribute(&quot;href&quot;,`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute(&quot;sizes&quot;,`${t}x${t}`),n.setAttribute(&quot;type&quot;,&quot;image/png&quot;),e.appendChild(n)}))},13:function(e,t,n){&quot;use strict&quot;;n.r(t),n.d(t,{initLocalFileLoader:function(){return ZA},load:function(){return YA}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return E},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return D},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ee},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return De},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i=&quot;undefined&quot;!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],D=r[2],E=Math.hypot(R,M,D);return E<a?null:(R*=E=1/E,M*=E,D*=E,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+D*o,C=D*R*s-M*o,S=R*M*s-D*o,A=M*M*s+i,I=D*M*s+R*o,w=R*D*s+M*o,P=M*D*s-R*o,O=D*D*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),E(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,D=(1-(p+v))*C,E=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=D,e[6]=E,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+D*I+L*w),e[14]=n[2]+w-(R*A+E*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return&quot;mat4(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;, &quot;+e[9]+&quot;, &quot;+e[10]+&quot;, &quot;+e[11]+&quot;, &quot;+e[12]+&quot;, &quot;+e[13]+&quot;, &quot;+e[14]+&quot;, &quot;+e[15]+&quot;)&quot;}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],D=t[12],E=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-D)<=a*Math.max(1,Math.abs(m),Math.abs(D))&&Math.abs(h-E)<=a*Math.max(1,Math.abs(h),Math.abs(E))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return&quot;mat3(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;)&quot;}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function De(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=De,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error(&quot;Invalid VTK object&quot;),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&&quot;object&quot;==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol(&quot;void&quot;),$e={};function qe(){}[&quot;log&quot;,&quot;debug&quot;,&quot;info&quot;,&quot;warn&quot;,&quot;error&quot;,&quot;time&quot;,&quot;timeEnd&quot;,&quot;group&quot;,&quot;groupEnd&quot;].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty(&quot;log&quot;)?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st(&quot;_&quot;===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=[&quot;TB&quot;,&quot;GB&quot;,&quot;MB&quot;,&quot;KB&quot;];let o=Number(e),a=&quot;B&quot;;for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot; &quot;;const n=[];let r=e;for(;r>1e3;)n.push((&quot;000&quot;+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),&quot;classHierarchy&quot;in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He(&quot;vtkObject&quot;);function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==[&quot;mtime&quot;].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||&quot;_&quot;===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(&quot;, &quot;)}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if(&quot;object&quot;==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(&quot;string&quot;==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError(&quot;Set Enum with invalid string argument&quot;)}if(&quot;number&quot;==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError(&quot;Set Enum outside numeric range&quot;)}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError(&quot;Set Enum with invalid argument (String/Number)&quot;)}},object(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(!ke()(t[n.name],o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}return!1}}};function Ct(e){if(&quot;object&quot;==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError(&quot;No setter for field&quot;)}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{&quot;object&quot;==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et(&quot;instance deleted - cannot call any method&quot;);else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=&quot; input ports. To add more input ports, use addInputConnection()&quot;,void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et(&quot;instance deleted - cannot call any method&quot;),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):o(e,i())},e.addInputConnection=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:&quot;Scalars&quot;;for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol(&quot;Event abort&quot;);function Dt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et(&quot;instance deleted - cannot call any method&quot;);const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA(&quot;vtkObject&quot;)}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt=&quot;__root__&quot;;function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=&quot;&quot;+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,[&quot;proxyId&quot;,&quot;proxyGroup&quot;,&quot;proxyName&quot;]),At(e,t,[&quot;proxyManager&quot;]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if(&quot;application&quot;===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,&quot;application&quot;),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return&quot;detail&quot;in e&&(n=e.detail),&quot;wheelDelta&quot;in e&&(n=-e.wheelDelta/120),&quot;wheelDeltaY&quot;in e&&(n=-e.wheelDeltaY/120),&quot;wheelDeltaX&quot;in e&&(t=-e.wheelDeltaX/120),&quot;axis&quot;in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,&quot;deltaY&quot;in e&&(o=e.deltaY),&quot;deltaX&quot;in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Dt,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Et,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Dt,newInstance:Et,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push(&quot;vtkViewNode&quot;),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)r.setVisited(!0);else{const r=e.createViewNode(n);r&&(r.setParent(e),r.setVisited(!0),t._renderableChildMap.set(n,r),t.children.push(r))}},e.addMissingNodes=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r],a=t._renderableChildMap.get(o);if(void 0!==a)a.setVisited(!0);else{const n=e.createViewNode(o);n&&(n.setParent(e),n.setVisited(!0),t._renderableChildMap.set(o,n),t.children.push(n))}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];-1===t.children.indexOf(o)&&(o.setParent(e),t.children.push(o)),o.setVisited(!0)}},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t(&quot;Cannot create view nodes without my own factory&quot;),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),t._renderableChildMap=new Map,jt.get(e,t,[&quot;visited&quot;]),jt.setGet(e,t,[&quot;_parent&quot;,&quot;renderable&quot;,&quot;myFactory&quot;]),jt.getArray(e,t,[&quot;children&quot;]),jt.moveToProtected(e,t,[&quot;parent&quot;]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,&quot;vtkViewNode&quot;),extend:Yt,PASS_TYPES:[&quot;Build&quot;,&quot;Render&quot;]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push(&quot;vtkViewNodeFactory&quot;),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s},e.registerOverride=(e,n)=>{t.overrides[e]=n}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,&quot;vtkViewNodeFactory&quot;),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push(&quot;vtkOpenGLViewNodeFactory&quot;)}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,&quot;vtkOpenGLViewNodeFactory&quot;),extend:sn};function cn(e,t){t.classHierarchy.push(&quot;vtkOpenGLCamera&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,[&quot;context&quot;,&quot;keyMatrixTime&quot;]),cn(e,t)}));rn(&quot;vtkCamera&quot;,dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderer&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn(&quot;No lights are on, creating one.&quot;),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();t.context.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,[&quot;shaderCache&quot;]),At(e,t,[&quot;selector&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),fn(e,t)}),&quot;vtkOpenGLRenderer&quot;);function hn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor&quot;),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkRenderer&quot;,mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor2D&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn(&quot;vtkActor&quot;,yn);const bn={context:null,activeTextures:null};const xn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function Dn(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function En(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn(&quot;vtkActor2D&quot;,xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn=&quot;\\\\s*([+-]?\\\\d+)\\\\s*&quot;,Jn=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*&quot;,er=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*&quot;,tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\\\(${Qn},${Qn},${Qn}\\\\)$`),rr=new RegExp(`^rgb\\\\(${er},${er},${er}\\\\)$`),or=new RegExp(`^rgba\\\\(${Qn},${Qn},${Qn},${Jn}\\\\)$`),ar=new RegExp(`^rgba\\\\(${er},${er},${er},${Jn}\\\\)$`),ir=new RegExp(`^hsl\\\\(${Jn},${er},${er}\\\\)$`),sr=new RegExp(`^hsla\\\\(${Jn},${er},${er},${Jn}\\\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+&quot;&quot;).trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):&quot;transparent&quot;===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?&quot;rgb(&quot;:&quot;rgba(&quot;}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?&quot;)&quot;:`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?&quot;0&quot;:&quot;&quot;)+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?&quot;hsl(&quot;:&quot;hsla(&quot;}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?&quot;)&quot;:`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Dr=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+&quot;&quot;}}return r.gamma=e,r}(1);function Er(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+&quot;&quot;}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&&quot;object&quot;==typeof e||(e={}),null!==t&&&quot;object&quot;==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Er((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Er((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,Fr=new RegExp(_r.source,&quot;g&quot;);function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+=&quot;&quot;,t+=&quot;&quot;;(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+&quot;&quot;}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join(&quot;&quot;)})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||&quot;boolean&quot;===r?Rr(t):(&quot;number&quot;===r?Br:&quot;string&quot;===r?(n=dr(t))?(t=n,Dr):kr:t instanceof dr?Dr:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:&quot;function&quot;!=typeof t.valueOf&&&quot;function&quot;!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error(&quot;invalid format: &quot;+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?&quot; &quot;:e.fill+&quot;&quot;,this.align=void 0===e.align?&quot;>&quot;:e.align+&quot;&quot;,this.sign=void 0===e.sign?&quot;-&quot;:e.sign+&quot;&quot;,this.symbol=void 0===e.symbol?&quot;&quot;:e.symbol+&quot;&quot;,this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?&quot;&quot;:e.type+&quot;&quot;}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf(&quot;e&quot;))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1];return o<0?&quot;0.&quot;+new Array(-o).join(&quot;0&quot;)+r:r.length>o+1?r.slice(0,o+1)+&quot;.&quot;+r.slice(o+1):r+new Array(o-r.length+2).join(&quot;0&quot;)}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?&quot;0&quot;:&quot;&quot;)+(void 0===this.width?&quot;&quot;:Math.max(1,0|this.width))+(this.comma?&quot;,&quot;:&quot;&quot;)+(void 0===this.precision?&quot;&quot;:&quot;.&quot;+Math.max(0,0|this.precision))+(this.trim?&quot;~&quot;:&quot;&quot;)+this.type};var ao={&quot;%&quot;:(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+&quot;&quot;,d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString(&quot;en&quot;).replace(/,/g,&quot;&quot;):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join(&quot;0&quot;):a>0?r.slice(0,a)+&quot;.&quot;+r.slice(a):&quot;0.&quot;+new Array(1-a).join(&quot;0&quot;)+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=[&quot;y&quot;,&quot;z&quot;,&quot;a&quot;,&quot;f&quot;,&quot;p&quot;,&quot;n&quot;,&quot;\u00b5&quot;,&quot;m&quot;,&quot;&quot;,&quot;k&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;,&quot;Z&quot;,&quot;Y&quot;];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?&quot;,f&quot;:r)).type){case&quot;s&quot;:var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case&quot;&quot;:case&quot;e&quot;:case&quot;g&quot;:case&quot;p&quot;:case&quot;r&quot;:null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-(&quot;e&quot;===r.type));break;case&quot;f&quot;:case&quot;%&quot;:null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*(&quot;%&quot;===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+&quot;&quot;,function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?&quot;&quot;:e.currency[0]+&quot;&quot;,a=void 0===e.currency?&quot;&quot;:e.currency[1]+&quot;&quot;,i=void 0===e.decimal?&quot;.&quot;:e.decimal+&quot;&quot;,s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?&quot;%&quot;:e.percent+&quot;&quot;,c=void 0===e.minus?&quot;\u2212&quot;:e.minus+&quot;&quot;,u=void 0===e.nan?&quot;NaN&quot;:e.nan+&quot;&quot;;function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;&quot;n&quot;===y?(m=!0,y=&quot;g&quot;):ao[y]||(void 0===h&&(h=12),v=!0,y=&quot;g&quot;),(f||&quot;0&quot;===t&&&quot;=&quot;===n)&&(f=!0,t=&quot;0&quot;,n=&quot;=&quot;);var T=&quot;$&quot;===p?o:&quot;#&quot;===p&&/[boxX]/.test(y)?&quot;0&quot;+y.toLowerCase():&quot;&quot;,b=&quot;$&quot;===p?a:/[%p]/.test(y)?l:&quot;&quot;,x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if(&quot;c&quot;===y)S=x(e)+S,e=&quot;&quot;;else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case&quot;.&quot;:o=t=r;break;case&quot;0&quot;:0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&&quot;+&quot;!==d&&(A=!1),p=(A?&quot;(&quot;===d?d:c:&quot;-&quot;===d||&quot;(&quot;===d?&quot;&quot;:d)+p,S=(&quot;s&quot;===y?po[8+Qr/3]:&quot;&quot;)+S+(A&&&quot;(&quot;===d?&quot;)&quot;:&quot;&quot;),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):&quot;&quot;;switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=&quot;&quot;),n){case&quot;<&quot;:e=p+e+S+w;break;case&quot;=&quot;:e=p+w+e+S;break;case&quot;^&quot;:e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+&quot;&quot;},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type=&quot;f&quot;,e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:&quot;,&quot;,grouping:[3],currency:[&quot;$&quot;,&quot;&quot;]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Do,ceil:Eo,min:Vo,max:Lo}=Math;const Bo=Ao(&quot;ceilLog2&quot;),No=Ao(&quot;factorial&quot;);function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao(&quot;gaussian&quot;);function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes(&quot;e&quot;))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split(&quot;e&quot;);let r=&quot;&quot;;return+n[1]+t>0&&(r=&quot;+&quot;),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co(&quot;vtkMath::Jacobi: Error extracting eigenfunctions&quot;),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co(&quot;Unable to factor linear system&quot;),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co(&quot;Unable to factor linear system&quot;),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Da(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Ea=Ao(&quot;GetScalarTypeFittingRange&quot;),Va=Ao(&quot;GetAdjustedScalarRange&quot;);const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Do,ceil:Eo,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo(&quot;Number of columns of A must match number of rows of B.&quot;);const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co(&quot;Matrix has 0 determinant&quot;),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co(&quot;Insufficient number of samples. Underdetermined.&quot;),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co(&quot;Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()&quot;),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Da,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Ea,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;#&quot;;return`${t}${e.map(Ga).join(&quot;&quot;)}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(&quot;, &quot;)})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};const Wa=1e-6,Ha=&quot;coincide&quot;,ja=&quot;disjoint&quot;;function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?&quot;x&quot;:i[1]>i[2]?&quot;y&quot;:&quot;z&quot;;const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case&quot;x&quot;:l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case&quot;y&quot;:l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case&quot;z&quot;:l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha};function Ja(e,t){t.classHierarchy.push(&quot;vtkPlane&quot;),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}const ei={normal:[0,0,1],origin:[0,0,0]};function ti(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ei,n),jt.obj(e,t),jt.setGetArray(e,t,[&quot;normal&quot;,&quot;origin&quot;],3),Ja(e,t)}var ni={newInstance:jt.newInstance(ti,&quot;vtkPlane&quot;),extend:ti,...Qa};const ri=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function oi(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ai(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ii(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function si(e){return ii(e,ri)}function li(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function ci(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)li(e,...t[n]);else for(let n=0;n<t.length;n+=3)li(e,...t.slice(n,n+3));return e}function ui(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function fi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function gi(e,t,n,r){return!!ai(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function mi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function hi(e,t){return e[2*t+1]-e[2*t]}function vi(e){return[hi(e,0),hi(e,1),hi(e,2)]}function yi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function bi(e){return e.slice(4,6)}function xi(e){const t=vi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function Ci(e){if(ai(e)){const t=vi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Si(e){return[e[0],e[2],e[4]]}function Ai(e){return[e[1],e[3],e[5]]}function Ii(e,t){return e<=0&&t>=0||e>=0&&t<=0}function wi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Pi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=wi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return si(n),ci(n,r)}function Ri(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Mi(e,t,n,r){const o=[].concat(ri),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Di(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ni.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!ai(e)||!ai(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Li(e,t){if(!ai(e)||!ai(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Bi(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Ni(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ni.evaluate(n,t,l)}let i=2;for(;i--&&!(Ii(o[r[i][0]],o[r[i][4]])&&Ii(o[r[i][1]],o[r[i][5]])&&Ii(o[r[i][2]],o[r[i][6]])&&Ii(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class _i{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ri))}getBounds(){return this.bounds}equals(e){return oi(this.bounds,e)}isValid(){return ai(this.bounds)}setBounds(e){return ii(this.bounds,e)}reset(){return si(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return li(this.bounds,...t)}addPoints(e){return ci(this.bounds,e)}addBounds(e,t,n,r,o,a){return ui(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return di(this.bounds,e,t,n)}setMaxPoint(e,t,n){return pi(this.bounds,e,t,n)}inflate(e){return fi(this.bounds,e)}scale(e,t,n){return gi(this.bounds,e,t,n)}getCenter(){return mi(this.bounds)}getLength(e){return hi(this.bounds,e)}getLengths(){return vi(this.bounds)}getMaxLength(){return xi(this.bounds)}getDiagonalLength(){return Ci(this.bounds)}getMinPoint(){return Si(this.bounds)}getMaxPoint(){return Ai(this.bounds)}getXRange(){return yi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return bi(this.bounds)}getCorners(e){return wi(this.bounds,e)}computeCornerPoints(e,t){return Pi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Mi(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Ri(this.bounds,e)}cutWithPlane(e,t){return Ni(this.bounds,e,t)}intersectBox(e,t,n,r){return Di(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Li(this.bounds,e)}containsPoint(e,t,n){return Bi(this.bounds,e,t,n)}contains(e){return Li(this.bounds,e)}}var Fi,ki={newInstance:function(e){const t=e&&e.bounds;return new _i(t)},equals:oi,isValid:ai,setBounds:ii,reset:si,addPoint:li,addPoints:ci,addBounds:ui,setMinPoint:di,setMaxPoint:pi,inflate:fi,scale:gi,scaleAboutCenter:function(e,t,n,r){if(!ai(e))return!1;const o=mi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],gi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:mi,getLength:hi,getLengths:vi,getMaxLength:xi,getDiagonalLength:Ci,getMinPoint:Si,getMaxPoint:Ai,getXRange:yi,getYRange:Ti,getZRange:bi,getCorners:wi,computeCornerPoints:Pi,computeLocalBounds:Mi,transformBounds:Oi,computeScale3:Ri,cutWithPlane:Ni,intersectBox:Di,intersectPlane:Ei,intersect:Vi,intersects:Li,containsPoint:Bi,contains:function(e,t){return!!Li(e,t)&&!!Bi(e,...Si(t))&&!!Bi(e,...Ai(t))},INIT_BOUNDS:ri};function Gi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Ui(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function zi(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function Wi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Fi=new i(4),i!=Float32Array&&(Fi[0]=0,Fi[1]=0,Fi[2]=0,Fi[3]=0);var Hi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),Ui(),Ui(),ie();var ji={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Ki}=ji;function $i(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function qi(e,t){t.classHierarchy.push(&quot;vtkProp&quot;),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=$i(&quot;pick&quot;),e.hasKey=$i(&quot;hasKey&quot;),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Ki.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Ki.DISPLAY)}const Xi={allocatedRenderTime:10,coordinateSystem:Ki.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function Yi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xi,n),jt.obj(e,t),jt.get(e,t,[&quot;estimatedRenderTime&quot;,&quot;allocatedRenderTime&quot;]),jt.setGet(e,t,[&quot;_parentProp&quot;,&quot;coordinateSystem&quot;,&quot;dragable&quot;,&quot;pickable&quot;,&quot;renderTimeMultiplier&quot;,&quot;useBounds&quot;,&quot;visibility&quot;]),jt.moveToProtected(e,t,[&quot;parentProp&quot;]),qi(e,t)}var Zi={newInstance:jt.newInstance(Yi,&quot;vtkProp&quot;),extend:Yi,...ji};function Qi(e,t){t.classHierarchy.push(&quot;vtkProp3D&quot;),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Ui();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=Ui();zi(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>ki.getCenter(t.bounds),e.getLength=()=>ki.getLength(t.bounds),e.getXRange=()=>ki.getXRange(t.bounds),e.getYRange=()=>ki.getYRange(t.bounds),e.getZRange=()=>ki.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const Ji={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Zi.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,[&quot;bounds&quot;,&quot;isIdentity&quot;]),jt.getArray(e,t,[&quot;orientation&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;position&quot;,&quot;scale&quot;],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,Qi(e,t)}var ts={newInstance:jt.newInstance(es,&quot;vtkProp3D&quot;),extend:es};const ns={FLAT:0,GOURAUD:1,PHONG:2},rs={POINTS:0,WIREFRAME:1,SURFACE:2};var os={Shading:ns,Representation:rs,Interpolation:ns};const{Representation:as,Interpolation:is}=os;function ss(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ls(e,t){t.classHierarchy.push(&quot;vtkProperty&quot;),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ss(&quot;ComputeCompositeColor&quot;),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ss(&quot;AddShaderVariable&quot;),e.setInterpolationToFlat=()=>e.setInterpolation(is.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(is.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(is.PHONG),e.getInterpolationAsString=()=>jt.enumToString(is,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(as.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(as.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(as.POINTS),e.getRepresentationAsString=()=>jt.enumToString(as,t.representation)}const cs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:is.GOURAUD,representation:as.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function us(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cs,n),jt.obj(e,t),jt.setGet(e,t,[&quot;lighting&quot;,&quot;interpolation&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;metallic&quot;,&quot;roughness&quot;,&quot;normalStrength&quot;,&quot;emission&quot;,&quot;baseIOR&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;opacity&quot;,&quot;edgeVisibility&quot;,&quot;lineWidth&quot;,&quot;pointSize&quot;,&quot;backfaceCulling&quot;,&quot;frontfaceCulling&quot;,&quot;representation&quot;,&quot;diffuseTexture&quot;,&quot;metallicTexture&quot;,&quot;roughnessTexture&quot;,&quot;normalTexture&quot;,&quot;ambientOcclusionTexture&quot;,&quot;emissionTexture&quot;]),jt.setGetArray(e,t,[&quot;ambientColor&quot;,&quot;specularColor&quot;,&quot;diffuseColor&quot;,&quot;edgeColor&quot;],3),ls(e,t)}var ds={newInstance:jt.newInstance(us,&quot;vtkProperty&quot;),extend:us,...os};const{vtkDebugMacro:ps}=jt;function fs(e,t){t.classHierarchy.push(&quot;vtkActor&quot;);const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ds.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){ps(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.concat();const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const gs={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gs,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;backfaceProperty&quot;,&quot;forceOpaque&quot;,&quot;forceTranslucent&quot;,&quot;mapper&quot;]),fs(e,t)}var hs={newInstance:jt.newInstance(ms,&quot;vtkActor&quot;),extend:ms};const vs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},ys={VOID:&quot;&quot;,CHAR:&quot;Int8Array&quot;,SIGNED_CHAR:&quot;Int8Array&quot;,UNSIGNED_CHAR:&quot;Uint8Array&quot;,SHORT:&quot;Int16Array&quot;,UNSIGNED_SHORT:&quot;Uint16Array&quot;,INT:&quot;Int32Array&quot;,UNSIGNED_INT:&quot;Uint32Array&quot;,FLOAT:&quot;Float32Array&quot;,DOUBLE:&quot;Float64Array&quot;};var Ts={DefaultDataType:ys.FLOAT,DataTypeByteSize:vs,VtkDataTypes:ys};const{vtkErrorMacro:bs}=Kt,{DefaultDataType:xs}=Ts,Cs=1e-6;function Ss(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function As(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ss(r,0,1)}return Ss(e,t<0?0:t,n)}function Is(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function ws(e){return Object.prototype.toString.call(e).slice(8,-1)}const Ps={computeRange:As,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ss,getDataType:ws,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Os(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push(&quot;vtkDataArray&quot;),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=As(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Cs;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Ds({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=ws(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||bs(&quot;numberOfComponents must match&quot;);const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Rs={name:&quot;&quot;,numberOfComponents:1,dataType:xs,rangeTuple:[0,0]};function Ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Rs,n),!t.empty&&!t.values&&!t.size)throw new TypeError(&quot;Cannot create vtkDataArray object without: size > 0, values&quot;);if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=ws(t.values)),yt(e,t),St(e,t,[&quot;name&quot;,&quot;numberOfComponents&quot;]),t.size%t.numberOfComponents!=0)throw new RangeError(&quot;model.size is not a multiple of model.numberOfComponents&quot;);Os(e,t)}const Ds=Et(Ms,&quot;vtkDataArray&quot;);var Es={newInstance:Ds,extend:Ms,...Ps,...Ts};function Vs(e,t){t.classHierarchy.push(&quot;vtkAbstractMapper&quot;),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA(&quot;vtkPlane&quot;)&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Ls={clippingPlanes:[]};var Bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ls,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),Vs(e,t)};function Ns(e,t){e.getBounds=()=>(jt.vtkErrorMacro(&quot;vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED&quot;),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=ki.isValid(n)?ki.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return ki.getDiagonalLength(t)}}const _s=e=>({bounds:[...ki.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var Fs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_s(n)),Bs(e,t,n),jt.setGet(e,t,[&quot;viewSpecificProperties&quot;]),Ns(e,t)};const{vtkErrorMacro:ks,vtkWarningMacro:Gs}=jt;function Us(e,t){t.classHierarchy.push(&quot;vtkFieldData&quot;);const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>&quot;number&quot;==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():&quot;&quot;},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else ks(&quot;Unhandled case in passData&quot;);else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Es.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Gs(&quot;Unexpected case in interpolateData&quot;)}else t.insertTuples(s.getTuples());else ks(&quot;Unhandled case in interpolateData&quot;);else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Es.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const zs={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Ws(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zs,n),jt.obj(e,t),Us(e,t)}var Hs={newInstance:jt.newInstance(Ws,&quot;vtkFieldData&quot;),extend:Ws};const js={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ks={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:js,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:&quot;vtkGhostType&quot;};const{AttributeTypes:$s,AttributeCopyOperations:qs}=Ks,{vtkWarningMacro:Xs}=jt;function Ys(e,t){const n=[&quot;Scalars&quot;,&quot;Vectors&quot;,&quot;Normals&quot;,&quot;TCoords&quot;,&quot;Tensors&quot;,&quot;GlobalIds&quot;,&quot;PedigreeIds&quot;];function r(e){let t=n.find((t=>$s[t.toUpperCase()]===e||&quot;number&quot;!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push(&quot;vtkDataSetAttributes&quot;);const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&&quot;PEDIGREEIDS&quot;===a.toUpperCase()&&!n.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if(&quot;PEDIGREEIDS&quot;!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA(&quot;vtkDataArray&quot;))return Xs(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(qs).filter((e=>&quot;ALLCOPY&quot;!==e)).forEach((e=>{t.copyAttributeFlags[qs[e]]=Object.keys($s).filter((e=>&quot;NUM_ATTRIBUTES&quot;!==e)).reduce(((e,t)=>(e[$s[t]]=!0,e)),[])})),t.copyAttributeFlags[qs.COPYTUPLE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.INTERPOLATE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.COPYTUPLE][$s.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||&quot;vtkDataArray&quot;!==t.dataArrays[n].type||e.addArray(Es.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const Zs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Qs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zs,n),Hs.extend(e,t,n),jt.setGet(e,t,[&quot;activeScalars&quot;,&quot;activeNormals&quot;,&quot;activeTCoords&quot;,&quot;activeVectors&quot;,&quot;activeTensors&quot;,&quot;activeGlobalIds&quot;,&quot;activePedigreeIds&quot;]),t.arrays||(t.arrays={}),Ys(e,t)}var Js={newInstance:jt.newInstance(Qs,&quot;vtkDataSetAttributes&quot;),extend:Qs,...Ks};const el=[&quot;pointData&quot;,&quot;cellData&quot;,&quot;fieldData&quot;];function tl(e,t){t.classHierarchy.push(&quot;vtkDataSet&quot;),el.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Js.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),el.forEach((n=>{t[n]=Js.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const nl={};function rl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nl,n),jt.obj(e,t),jt.setGet(e,t,el),tl(e,t)}var ol={newInstance:jt.newInstance(rl,&quot;vtkDataSet&quot;),extend:rl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const al={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var il={StructuredType:al};const{StructuredType:sl}=il;var ll={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?sl.EMPTY:3===t?sl.XYZ_GRID:2===t?e[0]===e[1]?sl.YZ_PLANE:e[2]===e[3]?sl.XZ_PLANE:sl.XY_PLANE:1===t?e[0]<e[1]?sl.X_LINE:e[2]<e[3]?sl.Y_LINE:sl.Z_LINE:sl.SINGLE_POINT},...il};const{vtkErrorMacro:cl}=jt;function ul(e,t){t.classHierarchy.push(&quot;vtkImageData&quot;),e.setExtent=function(){if(t.deleted)return cl(&quot;instance deleted - cannot call any method&quot;),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=ll.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)cl(&quot;instance deleted - cannot call any method&quot;);else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void cl(&quot;Bad dimension specification&quot;);n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return cl(&quot;Requesting a point from an empty image.&quot;),null;const o=new Float64Array(3);switch(t.dataDescription){case al.EMPTY:return null;case al.SINGLE_POINT:break;case al.X_LINE:o[0]=n;break;case al.Y_LINE:o[1]=n;break;case al.Z_LINE:o[2]=n;break;case al.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case al.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case al.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case al.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:cl(&quot;Invalid dataDescription&quot;)}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>ki.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>ki.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>ki.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];ki.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Da(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Da(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return cl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return cl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const dl={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:al.EMPTY};function pl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dl,n),ol.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,[&quot;indexToWorld&quot;,&quot;worldToIndex&quot;]),jt.setGetArray(e,t,[&quot;origin&quot;,&quot;spacing&quot;],3),jt.setGetArray(e,t,[&quot;direction&quot;],9),jt.getArray(e,t,[&quot;extent&quot;],6),ul(e,t)}var fl={newInstance:jt.newInstance(pl,&quot;vtkImageData&quot;),extend:pl};const gl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var ml={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:gl},hl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:vl,VectorMode:yl}=ml,{VtkDataTypes:Tl}=Es,{ColorMode:bl}=hl,{vtkErrorMacro:xl}=jt;function Cl(e){return e}function Sl(e){return Math.floor(255*e+.5)}function Al(e,t){t.classHierarchy.push(&quot;vtkScalarsToColors&quot;),e.setVectorModeToMagnitude=()=>e.setVectorMode(yl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(yl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(yl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)xl(&quot;Values and annotations do not have the same number of tuples so ignoring&quot;);else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===bl.DEFAULT&&t.getDataType()===Tl.UNSIGNED_CHAR||n===bl.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:&quot;vtkDataArray&quot;,name:&quot;temp&quot;,numberOfComponents:4,dataType:Tl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Es.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,vl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,vl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===yl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==yl.MAGNITUDE||1!==c&&1!==s||(i=yl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case yl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case yl.RGBCOLORS:break;case yl.MAGNITUDE:default:{const o=Es.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Sl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Tl.UNSIGNED_CHAR)return n;const i=Es.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Tl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=Cl;switch(n.getDataType()!==Tl.FLOAT&&n.getDataType()!==Tl.DOUBLE||(s=Sl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return xl(&quot;Cannot convert colors&quot;),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==bl.DEFAULT||n.getDataType()!==Tl.UNSIGNED_CHAR)&&r!==bl.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Il={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:yl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function wl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Il,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,[&quot;vectorSize&quot;,&quot;vectorComponent&quot;,&quot;vectorMode&quot;,&quot;alpha&quot;,&quot;indexedLookup&quot;]),jt.setArray(e,t,[&quot;mappingRange&quot;],2),jt.getArray(e,t,[&quot;mappingRange&quot;]),Al(e,t)}var Pl={newInstance:jt.newInstance(wl,&quot;vtkScalarsToColors&quot;),extend:wl,...ml};const{vtkErrorMacro:Ol}=jt;function Rl(e,t){t.classHierarchy.push(&quot;vtkLookupTable&quot;),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Ol(&quot;Expected 4 components for RGBA colors&quot;),!1;if(n.getDataType()!==ys.UNSIGNED_CHAR)return Ol(&quot;Expected unsigned char values for RGBA colors&quot;),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ml={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Dl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ml,n),Pl.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,[&quot;buildTime&quot;]),jt.setGet(e,t,[&quot;numberOfColors&quot;,&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;]),jt.setArray(e,t,[&quot;alphaRange&quot;,&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;],2),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;,&quot;alphaRange&quot;,&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),Rl(e,t)}var El={newInstance:jt.newInstance(Dl,&quot;vtkLookupTable&quot;),extend:Dl};let Vl=1,Ll=0;const Bl=[&quot;VTK_RESOLVE_OFF&quot;,&quot;VTK_RESOLVE_POLYGON_OFFSET&quot;];function Nl(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;Ll=e}var _l={getResolveCoincidentTopologyAsString:function(){return Bl[Ll]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Vl},getResolveCoincidentTopology:function(){return Ll},setResolveCoincidentTopology:Nl,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){Vl=e},setResolveCoincidentTopologyToDefault:function(){Nl(0)},setResolveCoincidentTopologyToOff:function(){Nl(0)},setResolveCoincidentTopologyToPolygonOffset:function(){Nl(1)}};function Fl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=(e,r)=>{t[n.key]={factor:e,offset:r}}}))}const kl=[&quot;Polygon&quot;,&quot;Line&quot;,&quot;Point&quot;],Gl={};Fl(Gl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},kl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Ul={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,[&quot;resolveCoincidentTopology&quot;]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(_l).forEach((t=>{e[t]=_l[t]})),Object.keys(Gl).forEach((t=>{e[t]=Gl[t]})),Fl(e,t.topologyOffset,kl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=Gl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:Gl,otherStaticMethods:_l,CATEGORIES:kl};const zl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Wl={PassTypes:zl};const{FieldAssociations:Hl}=ol,{staticOffsetAPI:jl,otherStaticMethods:Kl}=Ul,{ColorMode:$l,ScalarMode:ql,GetArray:Xl}=hl,{VectorMode:Yl}=ml,{VtkDataTypes:Zl}=Es;function Ql(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Jl(e,t){t.classHierarchy.push(&quot;vtkMapper&quot;),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString($l,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(ql,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===ql.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===ql.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===ql.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===ql.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_FIELD_DATA){const t=e.getFieldData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==a){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(n))e.mapScalarsToTexture(o,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},e.scalarToTextureCoordinate=(e,t,n)=>{let r=.5,o=1;return _a(e)||(o=.49,r=(e-t)*n,r>1e3?r=1e3:r<-1e3&&(r=-1e3)),{texCoordS:r,texCoordT:o}},e.createColorTextureCoordinates=(t,n,r,o,a,i,s,l,c)=>{const u=(i[1]-i[0])/l,d=[];d[0]=i[0]-u,d[1]=i[1]+u;const p=1/(d[1]-d[0]),f=n.getData(),g=t.getData();let m=0,h=0;if(a<0||a>=o)for(let t=0;t<r;++t){let t=0;for(let e=0;e<o;++e)t+=g[m]*g[m],m++;let n=Math.sqrt(t);c&&(n=El.applyLogScale(n,s,i));const r=e.scalarToTextureCoordinate(n,d[0],p);f[h]=r.texCoordS,f[h+1]=r.texCoordT,h+=2}else{m+=a;for(let t=0;t<r;++t){let t=g[m];c&&(t=El.applyLogScale(t,s,i));const n=e.scalarToTextureCoordinate(t,d[0],p);f[h]=n.texCoordS,f[h+1]=n.texCoordT,h+=2,m+=o}}},e.mapScalarsToTexture=(n,r)=>{const o=t.lookupTable.getRange(),a=t.lookupTable.usingLogScale();a&&El.getLogRange(o,o);const i=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==r){t.lookupTable.setAlpha(r),t.colorTextureMap=null,t.lookupTable.build();let e=t.lookupTable.getNumberOfAvailableColors();e>4094&&(e=4094),e<64&&(e=64),e+=2;const n=(o[1]-o[0])/(e-2),s=new Float64Array(2*e);for(let t=0;t<e;++t)s[t]=o[0]+t*n-n/2,a&&(s[t]=10**s[t]);for(let t=0;t<e;++t)s[t+e]=NaN;t.colorTextureMap=fl.newInstance(),t.colorTextureMap.setExtent(0,e-1,0,1,0,0);const l=Es.newInstance({numberOfComponents:1,values:s});t.colorTextureMap.getPointData().setScalars(t.lookupTable.mapScalars(l,t.colorMode,0)),t.lookupTable.setAlpha(i)}if(!t.colorCoordinates||e.getMTime()>t.colorCoordinates.getMTime()||e.getInputData(0).getMTime()>t.colorCoordinates.getMTime()||t.lookupTable.getMTime()>t.colorCoordinates.getMTime()){t.colorCoordinates=null;const r=n.getNumberOfComponents(),i=n.getNumberOfTuples();t.colorCoordinates=Es.newInstance({numberOfComponents:2,values:new Float32Array(2*i)});let s=t.lookupTable.getVectorComponent();t.lookupTable.getVectorMode()===Yl.MAGNITUDE&&n.getNumberOfComponents()>1&&(s=-1),e.createColorTextureCoordinates(n,t.colorCoordinates,i,r,s,o,t.lookupTable.getRange(),t.colorTextureMap.getPointData().getScalars().getNumberOfTuples()/2-2,a)}},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=n=>{if(!t.interpolateScalarsBeforeMapping)return!1;if(t.lookupTable&&t.lookupTable.getIndexedLookup())return!1;const r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName),o=r.scalars;return!(!o||r.cellFlag||t.colorMode===$l.DEFAULT&&o.getDataType()===Zl.UNSIGNED_CHAR||t.colorMode===$l.DIRECT_SCALARS)},e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=Ql(&quot;AcquireInvertibleLookupTable&quot;),e.valueToColor=Ql(&quot;ValueToColor&quot;),e.colorToValue=Ql(&quot;ColorToValue&quot;),e.useInvertibleColorFor=Ql(&quot;UseInvertibleColorFor&quot;),e.clearInvertibleColor=Ql(&quot;ClearInvertibleColor&quot;),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(zl.ID_LOW24),o=e.getRawPixelBuffer(zl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Hl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Hl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===zl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(zl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===zl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t],n*=256,n+=r[t+1],n*=256,n+=r[t+2];const a=s[n];e.getPixelBuffer(zl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const ec={colorMapColors:null,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function tc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ec,n),Fs(e,t,n),jt.get(e,t,[&quot;colorCoordinates&quot;,&quot;colorMapColors&quot;,&quot;colorTextureMap&quot;,&quot;selectionWebGLIdsToVTKIds&quot;]),jt.setGet(e,t,[&quot;colorByArrayName&quot;,&quot;arrayAccessMode&quot;,&quot;colorMode&quot;,&quot;fieldDataTupleId&quot;,&quot;interpolateScalarsBeforeMapping&quot;,&quot;lookupTable&quot;,&quot;populateSelectionSettings&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;useLookupTableScalarRange&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),Ul.implementCoincidentTopologyMethods(e,t),Jl(e,t)}var nc={newInstance:jt.newInstance(tc,&quot;vtkMapper&quot;),extend:tc,...jl,...Kl,...hl};function rc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function oc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const ac={extractCellSizes:rc,getNumberOfCells:oc};function ic(e,t){t.classHierarchy.push(&quot;vtkCellArray&quot;);const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=oc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=rc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function sc(e){return{empty:!0,numberOfComponents:1,dataType:ys.UNSIGNED_INT,...e}}function lc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Es.extend(e,t,sc(n)),ic(e,t)}var cc={newInstance:jt.newInstance(lc,&quot;vtkCellArray&quot;),extend:lc,...ac};const{vtkErrorMacro:uc}=jt,dc=[1,-1,1,-1,1,-1];function pc(e,t){t.classHierarchy.push(&quot;vtkPoints&quot;),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return uc(`getBounds called on an array with components of\\n        ${e.getNumberOfComponents()}`),dc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const fc={empty:!0,numberOfComponents:3,dataType:ys.FLOAT,bounds:[1,-1,1,-1,1,-1]};function gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fc,n),Es.extend(e,t,n),pc(e,t)}var mc={newInstance:jt.newInstance(gc,&quot;vtkPoints&quot;),extend:gc};function hc(e,t){t.classHierarchy.push(&quot;vtkCell&quot;),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro(&quot;vtkCell.evaluatePosition is not implemented.&quot;)}}const vc={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function yc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vc,n),jt.obj(e,t),t.points||(t.points=mc.newInstance()),jt.get(e,t,[&quot;points&quot;,&quot;pointsIds&quot;]),hc(e,t)}var Tc={newInstance:jt.newInstance(yc,&quot;vtkCell&quot;),extend:yc};function bc(e,t){t.classHierarchy.push(&quot;vtkCellLinks&quot;),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA(&quot;vtkPolyData&quot;)){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Tc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Tc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const xc={array:null,maxId:0,extend:0};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),jt.obj(e,t),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,&quot;vtkCellLinks&quot;),extend:Cc};const Ac=0,Ic=1,wc=2,Pc=3,Oc=4,Rc=5,Mc=6,Dc=7,Ec=9,Vc=21,Lc=41,Bc=42,Nc=[&quot;vtkEmptyCell&quot;,&quot;vtkVertex&quot;,&quot;vtkPolyVertex&quot;,&quot;vtkLine&quot;,&quot;vtkPolyLine&quot;,&quot;vtkTriangle&quot;,&quot;vtkTriangleStrip&quot;,&quot;vtkPolygon&quot;,&quot;vtkPixel&quot;,&quot;vtkQuad&quot;,&quot;vtkTetra&quot;,&quot;vtkVoxel&quot;,&quot;vtkHexahedron&quot;,&quot;vtkWedge&quot;,&quot;vtkPyramid&quot;,&quot;vtkPentagonalPrism&quot;,&quot;vtkHexagonalPrism&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkQuadraticEdge&quot;,&quot;vtkQuadraticTriangle&quot;,&quot;vtkQuadraticQuad&quot;,&quot;vtkQuadraticTetra&quot;,&quot;vtkQuadraticHexahedron&quot;,&quot;vtkQuadraticWedge&quot;,&quot;vtkQuadraticPyramid&quot;,&quot;vtkBiQuadraticQuad&quot;,&quot;vtkTriQuadraticHexahedron&quot;,&quot;vtkQuadraticLinearQuad&quot;,&quot;vtkQuadraticLinearWedge&quot;,&quot;vtkBiQuadraticQuadraticWedge&quot;,&quot;vtkBiQuadraticQuadraticHexahedron&quot;,&quot;vtkBiQuadraticTriangle&quot;,&quot;vtkCubicLine&quot;,&quot;vtkQuadraticPolygon&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkConvexPointSet&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkParametricCurve&quot;,&quot;vtkParametricSurface&quot;,&quot;vtkParametricTriSurface&quot;,&quot;vtkParametricQuadSurface&quot;,&quot;vtkParametricTetraRegion&quot;,&quot;vtkParametricHexRegion&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkHigherOrderEdge&quot;,&quot;vtkHigherOrderTriangle&quot;,&quot;vtkHigherOrderQuad&quot;,&quot;vtkHigherOrderPolygon&quot;,&quot;vtkHigherOrderTetrahedron&quot;,&quot;vtkHigherOrderWedge&quot;,&quot;vtkHigherOrderPyramid&quot;,&quot;vtkHigherOrderHexahedron&quot;],_c={getClassNameFromTypeId:function(e){return e<Nc.length?Nc[e]:&quot;UnknownClass&quot;},getTypeIdFromClassName:function(e){return Nc.findIndex(e)},isLinear:function(e){return e<Vc||e===Lc||e===Bc},hasSubCells:function(e){return e===Mc||e===Oc||e===wc}};function Fc(e,t){t.classHierarchy.push(&quot;vtkCellTypes&quot;),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Ac},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const kc={size:0,maxId:-1,extend:1e3};function Gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kc,n),jt.obj(e,t),jt.get(e,t,[&quot;size&quot;,&quot;maxId&quot;,&quot;extend&quot;]),jt.getArray(e,t,[&quot;typeArray&quot;,&quot;locationArray&quot;]),Fc(e,t)}var Uc={newInstance:jt.newInstance(Gc,&quot;vtkCellTypes&quot;),extend:Gc,..._c},zc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Wc}=zc;function Hc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Hc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Wc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Wc.YES_INTERSECTION:Wc.NO_INTERSECTION}const Kc={distanceToLine:Hc,intersection:jc};function $c(e,t){t.classHierarchy.push(&quot;vtkLine&quot;),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Wc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Hc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Hc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Hc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Hc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const qc={orientations:null};function Xc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qc,n),Tc.extend(e,t,n),jt.setGet(e,t,[&quot;orientations&quot;]),$c(e,t)}var Yc={newInstance:jt.newInstance(Xc,&quot;vtkLine&quot;),extend:Xc,...Kc,...zc};function Zc(e,t){t.classHierarchy.push(&quot;vtkPointSet&quot;),t.points?t.points=We(t.points):t.points=mc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=mc.newInstance(),t.points.shallowCopy(e.getPoints())}}const Qc={};function Jc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qc,n),ol.extend(e,t,n),jt.setGet(e,t,[&quot;points&quot;]),Zc(e,t)}var eu={newInstance:jt.newInstance(Jc,&quot;vtkPointSet&quot;),extend:Jc};function tu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function nu(e,t,n,r){tu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const ru={computeNormalDirection:tu,computeNormal:nu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];nu(e,t,n,d),nu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,D=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ni.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ni.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(D=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[D],P[D]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function ou(e,t){t.classHierarchy.push(&quot;vtkTriangle&quot;),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(nu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ni.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=Yc.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),tu(l,c,u,d),ni.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=Yc.distanceToLine(e,c,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Yc.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Yc.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Yc.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const au={};function iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,au,n),Tc.extend(e,t,n),ou(e,t)}var su={newInstance:jt.newInstance(iu,&quot;vtkTriangle&quot;),extend:iu,...ru};const lu=[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;],{vtkWarningMacro:cu}=jt,uu={[Pc]:Yc,[Oc]:Yc,[Rc]:su};function du(e,t){t.classHierarchy.push(&quot;vtkPolyData&quot;),lu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\\w|[A-Z]|\\b\\w)/g,(e=>e.toUpperCase())).replace(/\\s+/g,&quot;&quot;)}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=cc.newInstance()})),e.getNumberOfCells=()=>lu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),lu.forEach((n=>{t[n]=cc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?wc:Ic,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Oc:Pc,1===t&&cu(&quot;Building VTK_LINE &quot;,n,&quot; with only one point, but VTK_LINE needs at least two points. Check the input.&quot;),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=Rc;break;case 4:l[n]=Ec;break;default:l[n]=Dc}t<3&&cu(&quot;Building VTK_TRIANGLE &quot;,n,&quot; with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.&quot;),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Mc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Uc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Sc.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Ic:case wc:o=t.verts;break;case Pc:case Oc:o=t.lines;break;case Rc:case Ec:case Dc:o=t.polys;break;case Mc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||uu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const pu={};function fu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pu,n),eu.extend(e,t,n),jt.get(e,t,[&quot;cells&quot;,&quot;links&quot;]),jt.setGet(e,t,[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;]),du(e,t)}var gu={newInstance:jt.newInstance(fu,&quot;vtkPolyData&quot;),extend:fu};function mu(e,t){t.classHierarchy.push(&quot;vtkTexture&quot;),e.imageLoaded=()=>{t.image.removeEventListener(&quot;load&quot;,e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener(&quot;load&quot;,e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext(&quot;2d&quot;).getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement(&quot;canvas&quot;);e.width=t.image.width,e.height=t.image.height;const n=e.getContext(&quot;2d&quot;);return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const hu={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hu,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,[&quot;canvas&quot;,&quot;image&quot;,&quot;jsImageData&quot;,&quot;imageLoaded&quot;,&quot;resizable&quot;]),jt.setGet(e,t,[&quot;repeat&quot;,&quot;edgeClamp&quot;,&quot;interpolate&quot;,&quot;mipLevel&quot;]),mu(e,t)}const yu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Tu={newInstance:jt.newInstance(vu,&quot;vtkTexture&quot;),extend:vu,...yu};const bu=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],xu=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Cu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Su=[0,1,0,1,0,1,0,1,2,2,2,2],Au=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Iu=new Float64Array(3),wu=new Float64Array(3),Pu=new Float64Array(3),Ou=new Float64Array(3),Ru=new Float64Array(3),Mu=new Float64Array(3),Du=new Float64Array(16);function Eu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Vu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],Vn(Pu,Iu,r),Pu[0]+=.1,Vn(wu,Pu,o),Pn(Ru,wu,Iu),Pu[0]-=.1,Pu[1]+=.1,Vn(wu,Pu,o),Pn(Mu,wu,Iu);for(let e=0;e<3;e++)Ru[e]/=.05*u[0],Mu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],a[0]<-.5?On(Pu,Ru,a[0]*i-l.width):a[0]>.5?On(Pu,Ru,a[0]*i):On(Pu,Ru,a[0]*i-l.width/2),wn(Iu,Iu,Pu),On(Pu,Mu,a[1]*i-l.height/2),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Pu,Ru,l.width),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Pu,Mu,l.height),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Pu,Ru,l.width),Pn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(Du,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Iu[0]=f[3*u],Iu[1]=f[3*u+1],Iu[2]=f[3*u+2],Vn(Pu,Iu,n),Iu[0]=f[3*u+3],Iu[1]=f[3*u+4],Iu[2]=f[3*u+5],Vn(Ou,Iu,n),Pn(Pu,Pu,Ou);const r=[Pu[0],Pu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Lu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,[&quot;renderable&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;tmActor&quot;,&quot;ticks&quot;]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],Vu(e,t)}),&quot;vtkCubeAxesActorHelper&quot;);function Bu(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActor&quot;),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=ki.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Iu[s]=t.dataBounds[a]-.1*r*bu[a][s],Iu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Iu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Pu,Iu,e),Iu[s]=t.dataBounds[a],Vn(Ou,Iu,e),Pn(Pu,Ou,Pu),Mn(Pu,Pu),i=Pu[2]>o,t.camera.getParallelProjection()||(Mn(Ou,Ou),i=Dn(Ou,Pu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Au[t][0]].length+2*r[Au[t][1]].length,a+=r[Au[t][0]].length+r[Au[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Cu[e][0],l[3*u+2]=Cu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Au[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Au[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Su[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=xu[a][e];if(1===n[d]){const e=Su[d],n=3*Cu[d][0],p=3*Cu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Au[a][0]]=.5*(t.dataBounds[2*Au[a][0]]+t.dataBounds[2*Au[a][0]+1]),s[3*l+Au[a][1]]=.5*(t.dataBounds[2*Au[a][1]]+t.dataBounds[2*Au[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[xu[e][t]]++;const a=[],i=[];for(let e=0;e<3;e++){const n=go().domain([t.dataBounds[2*e],t.dataBounds[2*e+1]]);a[e]=n.ticks(5);const r=n.tickFormat(5);i[e]=a[e].map(r)}e.updatePolyData(r,n,a),e.updateTextData(r,n,a,i),(o||t.forceUpdate)&&e.updateTextureAtlas(i)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Eu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Eu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Eu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),ki.setBounds(t.bounds,t.gridActor.getBounds()),ki.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function Nu(e){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...ki.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:12,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},...e}}function _u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nu(n)),hs.extend(e,t,n),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=[&quot;X-Axis&quot;,&quot;Y-Axis&quot;,&quot;Z-Axis&quot;],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.tmTexture=Tu.newInstance(),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=nc.newInstance(),t.polyData=gu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=hs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=gu.newInstance(),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;boundsScaleFactor&quot;,&quot;faceVisibilityAngle&quot;,&quot;gridLines&quot;,&quot;tickLabelPixelOffset&quot;]),jt.setGetArray(e,t,[&quot;dataBounds&quot;],6),jt.setGetArray(e,t,[&quot;axisLabels&quot;],3),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;camera&quot;,&quot;tmTexture&quot;,&quot;textValues&quot;,&quot;textPolyData&quot;,&quot;tickCounts&quot;,&quot;gridActor&quot;]),Bu(e,t)}var Fu={newInstance:jt.newInstance(_u,&quot;vtkCubeAxesActor&quot;),extend:_u,newCubeAxesActorHelper:Lu};function ku(e,t){t.classHierarchy.push(&quot;vtkOpenGLCubeAxesActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gu={};const Uu=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=Fu.newCubeAxesActorHelper(),ku(e,t)}),&quot;vtkOpenGLCubeAxesActor&quot;);rn(&quot;vtkCubeAxesActor&quot;,Uu);const zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Wu={ObjectType:zu};const{ObjectType:Hu}=Wu;function ju(e,t){function n(e){switch(e){case Hu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Hu.TEXTURE_BUFFER:if(&quot;TEXTURE_BUFFER&quot;in t.context)return t.context.TEXTURE_BUFFER;case Hu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push(&quot;vtkOpenGLBufferObject&quot;);let r=null,o=null,a=!0,i=&quot;&quot;;e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i=&quot;Trying to upload array buffer to incompatible buffer.&quot;,!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const Ku={objectType:Hu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function $u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ku,n),jt.obj(e,t),jt.get(e,t,[&quot;_openGLRenderWindow&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),ju(e,t)}var qu={newInstance:jt.newInstance($u),extend:$u,...Wu};const{vtkErrorMacro:Xu}=jt;function Yu(e,t){t.classHierarchy.push(&quot;vtkOpenGLCellArrayBufferObject&quot;),e.setType(zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=qu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n){for(let r=0;r<e;++r)f(t[n+r])},linesToWireframe(e,t,n){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1])},polysToWireframe(e,t,n){if(e>2)for(let r=0;r<e;++r)f(t[n+r]),f(t[n+(r+1)%e])},stripsToWireframe(e,t,n){if(e>2){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1]);for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+2])}},polysToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+0]),f(t[n+r+1]),f(t[n+r+2])},stripsToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+1+r%2]),f(t[n+r+1+(r+1)%2])}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===rs.POINTS||&quot;verts&quot;===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===rs.WIREFRAME||&quot;lines&quot;===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,D=0,E=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];D+=n*n;const r=.5*(t[1]+t[0]);E+=r*r}const V=D>0&&(Math.abs(E)/D>1e6||Math.abs(Math.log10(D))>3||0===D&&E>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;)C(A[e],A,e+1),e+=A[e]+1,T++;return t.elementCount=w,e.upload(O,zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,Ui(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):Xu(&quot;Wrong type for coordScale, expected vec3 or null&quot;):Xu(&quot;Wrong type for coordShift, expected vec3 or null&quot;)}}const Zu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function Qu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zu,n),qu.extend(e,t,n),jt.setGet(e,t,[&quot;colorBO&quot;,&quot;elementCount&quot;,&quot;stride&quot;,&quot;colorBOStride&quot;,&quot;vertexOffset&quot;,&quot;normalOffset&quot;,&quot;tCoordOffset&quot;,&quot;tCoordComponents&quot;,&quot;colorOffset&quot;,&quot;colorComponents&quot;,&quot;customData&quot;]),jt.get(e,t,[&quot;coordShift&quot;,&quot;coordScale&quot;,&quot;coordShiftAndScaleEnabled&quot;,&quot;inverseShiftAndScaleMatrix&quot;]),Yu(e,t)}var Ju={newInstance:jt.newInstance(Qu),extend:Qu};const{vtkErrorMacro:ed}=jt;function td(e,t){t.classHierarchy.push(&quot;vtkShader&quot;),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||&quot;Unknown&quot;===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e=&quot;Fragment&quot;===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return ed(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const nd={shaderType:&quot;Unknown&quot;,source:&quot;&quot;,error:&quot;&quot;,handle:0,dirty:!1,context:null};function rd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nd,n),jt.obj(e,t),jt.setGet(e,t,[&quot;shaderType&quot;,&quot;source&quot;,&quot;error&quot;,&quot;handle&quot;,&quot;context&quot;]),td(e,t)}var od={newInstance:jt.newInstance(rd,&quot;vtkShader&quot;),extend:rd};const{vtkErrorMacro:ad}=jt;function id(e,t){t.classHierarchy.push(&quot;vtkShaderProgram&quot;),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(ad(`Links failed: ${t.error}`),0):(ad(t.error),0):(ad(t.fragmentShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.fragmentShader.getError()),0):(ad(t.vertexShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),ad(t.vertexShader.getError()),0),e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error=&quot;Program has not been initialized, and/or does not have shaders.&quot;,!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return ad(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return ad(&quot;attempt to find uniform when the shader program is not linked&quot;),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error=&quot;Shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===n.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error=&quot;Could not create shader program.&quot;,!1;t.handle=e,t.linked=!1}return&quot;Vertex&quot;===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),&quot;Fragment&quot;===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error=&quot;shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===e.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;switch(0===t.handle&&(t.error=&quot;This shader program has not been initialized yet.&quot;),e.getShaderType()){case&quot;Vertex&quot;:return t.vertexShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case&quot;Fragment&quot;:return t.fragmentShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const sd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:&quot;&quot;,handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=od.newInstance(),t.vertexShader.setShaderType(&quot;Vertex&quot;),t.fragmentShader=od.newInstance(),t.fragmentShader.setShaderType(&quot;Fragment&quot;),t.geometryShader=od.newInstance(),t.geometryShader.setShaderType(&quot;Geometry&quot;),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;error&quot;,&quot;handle&quot;,&quot;compiled&quot;,&quot;bound&quot;,&quot;md5Hash&quot;,&quot;vertexShader&quot;,&quot;fragmentShader&quot;,&quot;geometryShader&quot;,&quot;linked&quot;]),id(e,t)}var cd={newInstance:jt.newInstance(ld,&quot;vtkShaderProgram&quot;),extend:ld,substitute:function(e,t,n,r){const o=&quot;string&quot;==typeof n?n:n.join(&quot;\\n&quot;),a=!1===r?t:new RegExp(t,&quot;g&quot;),i=e.replace(a,o);return{replace:i!==o,result:i}}};function ud(e,t){t.classHierarchy.push(&quot;vtkOpenGLVertexArrayObject&quot;),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;)),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension(&quot;OES_vertex_array_object&quot;),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const dd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,[&quot;supported&quot;]),jt.setGet(e,t,[&quot;forceEmulation&quot;]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,&quot;vtkOpenGLVertexArrayObject&quot;),extend:pd};const gd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function md(e,t){t.classHierarchy.push(&quot;vtkOpenGLHelper&quot;),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===rs.POINTS||n===gd.Points?t.context.POINTS:e===rs.WIREFRAME||n===gd.Lines||n===gd.TrisEdges||n===gd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f(&quot;viewportSize&quot;,o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf(&quot;lineWidthStepSize&quot;,t/Math.ceil(t)),e.getProgram().setUniformf(&quot;halfLineWidth&quot;,n)}t.primitiveType===gd.Points||r.getProperty().getRepresentation()===rs.POINTS?e.getProgram().setUniformf(&quot;pointSize&quot;,r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf(&quot;pointSize&quot;,e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform float pointSize;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot;  gl_PointSize = pointSize;&quot;],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform vec2 viewportSize;&quot;,&quot;uniform float lineWidthStepSize;&quot;,&quot;uniform float halfLineWidth;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot; if (halfLineWidth > 0.0)&quot;,&quot;   {&quot;,&quot;   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;&quot;,&quot;   vec4 tmpPos = gl_Position;&quot;,&quot;   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;&quot;,&quot;   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];&quot;,&quot;   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];&quot;,&quot;   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);&quot;,&quot;   }&quot;]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===gd.Points?2:t.primitiveType===gd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const hd={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,[&quot;program&quot;,&quot;shaderSourceTime&quot;,&quot;VAO&quot;,&quot;attributeUpdateTime&quot;,&quot;CABO&quot;,&quot;primitiveType&quot;,&quot;pointPicking&quot;]),t.program=cd.newInstance(),t.VAO=fd.newInstance(),t.CABO=Ju.newInstance(),md(e,t)}var yd={newInstance:jt.newInstance(vd),extend:vd,primTypes:gd};const Td={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},bd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var xd={Wrap:Td,Filter:bd};const Cd=new Float32Array(1),Sd=new Int32Array(Cd.buffer);var Ad={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Cd[0]=e;const t=Sd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};const{Wrap:Id,Filter:wd}=xd,{VtkDataTypes:Pd}=Es,{vtkDebugMacro:Od,vtkErrorMacro:Rd,vtkWarningMacro:Md}=Kt,{toHalf:Dd}=Ad;function Ed(e,t){function n(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==Pd.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==Pd.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Dd(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o}function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension(&quot;OES_texture_half_float&quot;),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Ad.toHalf(Ad.fromHalf(e[u][l+s+t])*h*(1-v)+Ad.fromHalf(e[u][l+p+t])*h*v+Ad.fromHalf(e[u][c+s+t])*m*(1-v)+Ad.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&t.oglNorm16Ext)||e!==Pd.UNSIGNED_SHORT&&e!==Pd.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);i=e&&t.openGLDataType===e.HALF_FLOAT_OES}const s=i&&(function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a);t.useHalfFloat=s}(a,c.offset,c.scale,r),t.useHalfFloat||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}t.classHierarchy.push(&quot;vtkOpenGLTexture&quot;),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent()),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(wd.LINEAR),e.setMagnificationFilter(wd.LINEAR)):(e.setMinificationFilter(wd.NEAREST),e.setMagnificationFilter(wd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Id.REPEAT),e.setWrapS(Id.REPEAT),e.setWrapT(Id.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()},e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Md(&quot;impossible case&quot;),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Od(`Unable to find suitable internal format for T=${n} NC= ${r}`),t.internalFormat),e.getDefaultInternalFormat=(e,n)=>{let r=0;return r=t._openGLRenderWindow.getDefaultTextureInternalFormat(e,n,t.oglNorm16Ext,t.useHalfFloat),r||(r||(Od(&quot;Unsupported internal texture type!&quot;),Od(`Unable to find suitable internal format for T=${e} NC= ${n}`)),r)},e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=e=>{if(t._openGLRenderWindow.getWebgl2())switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.SHORT:return t.context.SHORT;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case t.useHalfFloat&&Pd.SHORT:case t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case Pd.FLOAT:case Pd.VOID:default:return t.context.FLOAT}switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case Pd.FLOAT:case Pd.VOID:default:if(t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))return t.context.FLOAT;{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);if(e&&t.context.getExtension(&quot;OES_texture_half_float_linear&quot;))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case wd.NEAREST:return t.context.NEAREST;case wd.LINEAR:return t.context.LINEAR;case wd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case wd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case wd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case wd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Id.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Id.REPEAT:return t.context.REPEAT;case Id.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=n(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(n(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createDepthFromRaw=(n,r,a,i)=>(e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===Pd.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=r,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0):(Rd(&quot;Failed to determine texture parameters.&quot;),!1)),e.create2DFromImage=n=>{if(e.getOpenGLDataType(Pd.UNSIGNED_CHAR),e.getInternalFormat(Pd.UNSIGNED_CHAR,4),e.getFormat(Pd.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const r=!(t._openGLRenderWindow.getWebgl2()||Fo(n.width)&&Fo(n.height)),a=document.createElement(&quot;canvas&quot;);a.width=r?_o(n.width):n.width,a.height=r?_o(n.height):n.height,t.width=a.width,t.height=a.height;const i=a.getContext(&quot;2d&quot;);i.translate(0,a.height),i.scale(1,-1),i.drawImage(n,0,0,n.width,n.height,0,0,a.width,a.height);const s=a;return o(Pd.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Pd.UNSIGNED_CHAR,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Es.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.create3DFromRaw=(a,i,s,l,c,u)=>{if(e.getOpenGLDataType(c),e.getInternalFormat(c,l),e.getFormat(c,l),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=r(n(c,[u],!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(c)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=d[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,d[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,d[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(c,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Es.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=n*r*i,g=[],m=[];for(let e=0;e<c;++e)g[e]=0,m[e]=1;t.volumeInfo={scale:m,offset:g,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i};const h=structuredClone(p);if(t._openGLRenderWindow.getWebgl2()){if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=32767;return e.create3DFromRaw(n,r,i,c,u,d)}if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.UNSIGNED_SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=65535;return e.create3DFromRaw(n,r,i,c,u,d)}if(u===Pd.FLOAT||t.useHalfFloat&&(u===Pd.SHORT||u===Pd.UNSIGNED_SHORT))return e.create3DFromRaw(n,r,i,c,u,d);if(u===Pd.UNSIGNED_CHAR){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=255;return e.create3DFromRaw(n,r,i,c,u,d)}const o=new Float32Array(f*c);t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;let a=0;const s=h.scale.map((e=>1/e));for(let e=0;e<f;e++)for(let e=0;e<c;e++)o[a]=(d[a]-h.offset[e])*s[e],a++;return e.create3DFromRaw(n,r,i,c,Pd.FLOAT,o)}let v=(e,t,n,r,o)=>{e[t]=n},y=Pd.UNSIGNED_CHAR;if(u===Pd.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)?(y=Pd.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=Pd.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return Rd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===Pd.FLOAT||c>=3)&&(T=4096);let b=1,x=1;f>T*T&&(b=Math.ceil(Math.sqrt(f/(T*T))),x=b);let C=Math.sqrt(f)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===Pd.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1}const Vd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Id.CLAMP_TO_EDGE,wrapT:Id.CLAMP_TO_EDGE,wrapR:Id.CLAMP_TO_EDGE,minificationFilter:wd.NEAREST,magnificationFilter:wd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,useHalfFloat:!0,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0};function Ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,[&quot;format&quot;,&quot;openGLDataType&quot;]),At(e,t,[&quot;keyMatrixTime&quot;,&quot;minificationFilter&quot;,&quot;magnificationFilter&quot;,&quot;wrapS&quot;,&quot;wrapT&quot;,&quot;wrapR&quot;,&quot;generateMipmap&quot;,&quot;oglNorm16Ext&quot;]),bt(e,t,[&quot;width&quot;,&quot;height&quot;,&quot;volumeInfo&quot;,&quot;components&quot;,&quot;handle&quot;,&quot;target&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),Ot(0,t,[&quot;openGLRenderWindow&quot;]),Ed(e,t)}const Bd=Et(Ld,&quot;vtkOpenGLTexture&quot;);var Nd={newInstance:Bd,extend:Ld,...xd};rn(&quot;vtkTexture&quot;,Bd);var _d=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexMC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\nvoid main()\\n{\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::PrimID::Impl\\n\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,Fd=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the polydata mappers fragment shader\\n\\nuniform int PrimitiveIDOffset;\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// optional color passed in from the vertex shader, vertexColor\\n//VTK::Color::Dec\\n\\n// optional surface normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// Depth Peeling Support\\n//VTK::DepthPeeling::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// label outline \\n//VTK::LabelOutline::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n//VTK::LabelOutlineHelperFunction\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::Color::Impl\\n\\n  // Generate the normal if we are not passed in one\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Light::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,kd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::Coincident::Dec&quot;,[&quot;uniform float cfactor;&quot;,&quot;uniform float coffset;&quot;]).result,t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;&quot;).result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=cd.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=cd.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;&quot;).result),n.Fragment=e}}},Gd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=cd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&&quot;&quot;!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&&quot;&quot;!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Ud}=ol,{primTypes:zd}=yd,{Representation:Wd,Shading:Hd}=ds,{ScalarMode:jd}=nc,{Filter:Kd,Wrap:$d}=Nd,{vtkErrorMacro:qd}=Kt,Xd={type:&quot;StartEvent&quot;},Yd={type:&quot;EndEvent&quot;},{CoordinateSystem:Zd}=Zi;function Qd(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType(&quot;vtkOpenGLActor&quot;),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=zd.Start;e<zd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let l=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;,&quot;uniform vec3 ambientColorUniform;&quot;,&quot;uniform vec3 diffuseColorUniform;&quot;];s&&(l=l.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let c=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];s&&(c=c.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),c=c.concat([&quot;  ambientColor = ambientColorUniform;&quot;,&quot;  diffuseColor = diffuseColorUniform;&quot;,&quot;  opacity = opacityUniform;&quot;]),s&&(c=c.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 scalarColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput =  scalarColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?t.renderable.getInterpolateScalarsBeforeMapping()&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);&quot;,&quot;  diffuseColor = texColor.rgb;&quot;,&quot;  ambientColor = texColor.rgb;&quot;,&quot;  opacity = opacity*texColor.a;&quot;])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat([&quot;uniform float opacityUniformBF; // the fragment opacity&quot;,&quot;uniform float ambientIntensityBF; // the material ambient&quot;,&quot;uniform float diffuseIntensityBF; // the material diffuse&quot;,&quot;uniform vec3 ambientColorUniformBF; // ambient material color&quot;,&quot;uniform vec3 diffuseColorUniformBF; // diffuse material color&quot;]),s?(l=l.concat([&quot;uniform float specularIntensityBF; // the material specular intensity&quot;,&quot;uniform vec3 specularColorUniformBF; // intensity weighted color&quot;,&quot;uniform float specularPowerUniformBF;&quot;]),c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  specularColor = specularIntensityBF * specularColorUniformBF;&quot;,&quot;  specularPower = specularPowerUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])):c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat([&quot;uniform samplerBuffer texture1;&quot;])),i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c).result):i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),i=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);let s=[];switch(a){case 0:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 1:o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  float df = max(0.0, normalVCVSOutput.z);&quot;,&quot;  float sf = pow(df, specularPower);&quot;,&quot;  vec3 diffuseL = df * diffuseColor;&quot;,&quot;  vec3 specularL = sf * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,&quot;    {&quot;,`    float sf = sign(df)*pow(max(1e-5,\\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\\n                                                  normalize(-vertexVC.xyz))),\\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  vec3 vertLightDirectionVC;&quot;,&quot;  float attenuation;&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([&quot;  attenuation = 1.0;&quot;,`  if (lightPositional${e} == 0)`,&quot;    {&quot;,`      vertLightDirectionVC = lightDirectionVC${e};`,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,&quot;    float distanceVC = length(vertLightDirectionVC);&quot;,&quot;    vertLightDirectionVC = normalize(vertLightDirectionVC);&quot;,&quot;    attenuation = 1.0 /&quot;,`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,&quot;    // per OpenGL standard cone angle is 90 or less for a spot light&quot;,`    if (lightConeAngle${e} <= 90.0)`,&quot;      {&quot;,`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,&quot;      // if inside the cone&quot;,`      if (coneDot >= cos(radians(lightConeAngle${e})))`,&quot;        {&quot;,`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,&quot;        }&quot;,&quot;      else&quot;,&quot;        {&quot;,&quot;        attenuation = 0.0;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));&quot;,`    diffuseL += ((df) * lightColor${e});`,&quot;    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)&quot;,&quot;      {&quot;,`      float sf = sign(df)*attenuation*pow(max(1e-5,\\n                                                           dot(reflect(lightDirectionVC${e},\\n                                                                       normalVCVSOutput),\\n                                                               normalize(-vertexVC.xyz))),\\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=cd.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;default:qd(&quot;bad light complexity&quot;)}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * normalMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Dec&quot;,[&quot;in vec3 normalVCVSOutput[];&quot;,&quot;out vec3 normalVCGSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCGSOutput = normalVCVSOutput[i];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;varying vec3 normalVCVSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalVCVSOutput);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.haveCellNormals?(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform mat3 normalMatrix;&quot;,&quot;uniform samplerBuffer textureN;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalMatrix *&quot;,&quot;    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput;&quot;,&quot;  if (abs(fdx.x) > 0.0)&quot;,&quot;    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }&quot;,&quot;  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}&quot;]).result):(a=cd.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;&quot;]).result,a=cd.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=cd.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;  fdx = normalize(fdx);&quot;,&quot;  fdy = normalize(fdy);&quot;,&quot;  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));&quot;,&quot;  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;,&quot;  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(o=cd.substitute(o,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCVSOutput = MCVCMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;in vec4 vertexVCVSOutput[];&quot;,&quot;out vec4 vertexVCGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCGSOutput = vertexVCVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;&quot;]).result):(o=cd.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,o=cd.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,a&&a.length>=1)switch(i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}}else switch(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;&quot;).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec3 tcoordVCVSOutput[];&quot;,&quot;out vec3 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec3 tcoordVCVSOutput;&quot;,&quot;uniform samplerCube texture1;&quot;]).result,i){case 1:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`varying float clipDistancesVSOutput[${e}];`]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()||o.getEdgeVisibility()&&o.getRepresentation()===Wd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===zd.Points||o.getRepresentation()===Wd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===zd.Lines||o.getRepresentation()===Wd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==zd.Tris&&e!==zd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==zd.TrisEdges&&e!==zd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform int picking;&quot;,&quot;//VTK::Picking::Dec&quot;]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==zl.ID_LOW24&&t.lastSelectionState!==zl.ID_HIGH24||(a=cd.substitute(a,&quot;//VTK::Picking::Dec&quot;,[&quot;flat out int vertexIDVSOutput;\\n&quot;,&quot;uniform int VertexIDOffset;\\n&quot;]).result,a=cd.substitute(a,&quot;//VTK::Picking::Impl&quot;,&quot;  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;flat in int vertexIDVSOutput;\\n&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,[&quot;  int idx = vertexIDVSOutput;&quot;,&quot;//VTK::Picking::Impl&quot;]).result),t.lastSelectionState){case zl.ID_LOW24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);&quot;).result;break;case zl.ID_HIGH24:o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);&quot;).result;break;default:o=cd.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;uniform vec3 mapperIndex;&quot;).result,o=cd.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===Hd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),h=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&n.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),n.getProgram().isUniformUsed(&quot;VertexIDOffset&quot;)&&n.getProgram().setUniformi(&quot;VertexIDOffset&quot;,t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;normalMC&quot;)&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;normalMC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd(&quot;Error setting normalMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;normalMC&quot;),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||qd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||qd(&quot;Error setting tcoordMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),n.getProgram().isAttributeUsed(&quot;scalarColor&quot;)&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),&quot;scalarColor&quot;,n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||qd(&quot;Error setting scalarColor in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;scalarColor&quot;),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,r)}t.internalColorTexture&&n.getProgram().isUniformUsed(&quot;texture1&quot;)&&n.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi(&quot;picking&quot;,i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===Zd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4)}else s.setUniformMatrix(&quot;MCPCMatrix&quot;,n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed(&quot;MCVCMatrix&quot;)&&s.setUniformMatrix(&quot;MCVCMatrix&quot;,n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed(&quot;normalMatrix&quot;)&&s.setUniformMatrix3x3(&quot;normalMatrix&quot;,n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf(&quot;opacityUniform&quot;,i),o.setUniform3fArray(&quot;ambientColorUniform&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniform&quot;,l),o.setUniformf(&quot;ambient&quot;,c),o.setUniformf(&quot;diffuse&quot;,u);const f=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray(&quot;specularColorUniform&quot;,g),o.setUniformf(&quot;specularPowerUniform&quot;,p),o.setUniformf(&quot;specular&quot;,d),o.isUniformUsed(&quot;ambientIntensityBF&quot;)){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf(&quot;ambientIntensityBF&quot;,c),o.setUniformf(&quot;diffuseIntensityBF&quot;,u),o.setUniformf(&quot;opacityUniformBF&quot;,i),o.setUniform3fArray(&quot;ambientColorUniformBF&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniformBF&quot;,l),f<1)return;o.setUniformf(&quot;specularIntensityBF&quot;,d),o.setUniform3fArray(&quot;specularColorUniformBF&quot;,g),o.setUniformf(&quot;specularPowerUniformBF&quot;,p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():zl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Wd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===zl.ID_LOW24||t.lastSelectionState===zl.ID_HIGH24);for(let i=zd.Start;i<zd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===zd.TrisEdges||i===zd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(Xd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Yd),!t.currentInput)return void qd(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(null===o)return;t.renderable.mapScalars(o,1);const a=t.renderable.getColorMapColors();t.haveCellScalars=!1;const i=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(i!==jd.USE_CELL_DATA&&i!==jd.USE_CELL_FIELD_DATA&&i!==jd.USE_FIELD_DATA&&o.getPointData().getScalars()||i===jd.USE_POINT_FIELD_DATA||!a||(t.haveCellScalars=!0));let s=r.getProperty().getInterpolation()!==Hd.FLAT?o.getPointData().getNormals():null;null===s&&o.getCellData().getNormals()&&(t.haveCellNormals=!0,s=o.getCellData().getNormals());const l=r.getProperty().getRepresentation();let c=o.getPointData().getTCoords();if(t.openGLActor.getActiveTextures()||(c=null),t.renderable.getColorCoordinates()){c=t.renderable.getColorCoordinates(),t.internalColorTexture||(t.internalColorTexture=Nd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Kd.NEAREST),e.setMagnificationFilter(Kd.NEAREST),e.setWrapS($d.CLAMP_TO_EDGE),e.setWrapT($d.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${o.getMTime()}A${l}B${o.getMTime()}C${s?s.getMTime():1}D${a?a.getMTime():1}E${r.getProperty().getEdgeVisibility()}F${c?c.getMTime():1}`;if(t.VBOBuildString!==u){const n={points:o.getPoints(),normals:s,tcoords:c,colors:a,cellOffset:0,vertexOffset:0,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>o.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const i=[{inRep:&quot;verts&quot;,cells:o.getVerts()},{inRep:&quot;lines&quot;,cells:o.getLines()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()},{inRep:&quot;polys&quot;,cells:o.getPolys()},{inRep:&quot;strips&quot;,cells:o.getStrips()}],d=r.getProperty().getEdgeVisibility()&&l===Wd.SURFACE;for(let e=zd.Start;e<zd.End;e++)e!==zd.TrisEdges&&e!==zd.TriStripsEdges?(n.cellOffset+=t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,l,n,t.selectionWebGLIdsToVTKIds),n.vertexOffset+=t.primitives[e].getCABO().getElementCount()):d?t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,Wd.WIREFRAME,{...n,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[e].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&(t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),e.updateMaximumPointCellIds()),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Jd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:zl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function ep(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jd,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=zd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=zd.Start;e<zd.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),Qd(e,t)}const tp=Et(ep,&quot;vtkOpenGLPolyDataMapper&quot;);var np={newInstance:tp,extend:ep};rn(&quot;vtkMapper&quot;,tp);const{ColorMode:rp,ScalarMode:op,GetArray:ap}=hl;function ip(e,t){t.classHierarchy.push(&quot;vtkMapper2D&quot;),e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString(rp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(op,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===op.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===op.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===op.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===op.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_FIELD_DATA){const t=e.getFieldData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const sp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function lp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sp,n),Bs(e,t,n),jt.get(e,t,[&quot;colorMapColors&quot;]),jt.setGet(e,t,[&quot;arrayAccessMode&quot;,&quot;colorByArrayName&quot;,&quot;colorMode&quot;,&quot;lookupTable&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;transformCoordinate&quot;,&quot;useLookupTableScalarRange&quot;,&quot;viewSpecificProperties&quot;,&quot;customShaderAttributes&quot;]),jt.setGetArray(e,t,[&quot;scalarRange&quot;],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),ip(e,t)}var cp={newInstance:jt.newInstance(lp,&quot;vtkMapper2D&quot;),extend:lp};const up=1,{primTypes:dp}=yd,{ScalarMode:pp}=cp,{vtkErrorMacro:fp}=Kt,gp={type:&quot;StartEvent&quot;},mp={type:&quot;EndEvent&quot;};function hp(e,t){t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper2D&quot;),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType(&quot;vtkOpenGLActor2D&quot;),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model Coordinates\\n// WC - WC world coordinates\\n// VC - View Coordinates\\n// DC - Display Coordinates\\n\\nin vec4 vertexWC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nuniform mat4 WCVCMatrix;  // World to view matrix\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  gl_Position = WCVCMatrix*vertexWC;\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::PositionVC::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nuniform int PrimitiveIDOffset;\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Scalar coloring\\n//VTK::Color::Dec\\n\\n// Depth Peeling\\n//VTK::DepthPeeling::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Color::Impl\\n  //VTK::TCoord::Impl\\n\\n  //VTK::DepthPeeling::Impl\\n  //VTK::Picking::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=dp.Start;e<dp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(gp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(mp),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):fp(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==pp.USE_CELL_DATA&&a!==pp.USE_CELL_FIELD_DATA&&a!==pp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===pp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=mc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[dp.Points].getCABO().createVBO(r.getVerts(),&quot;verts&quot;,i,a),a.cellOffset+=t.primitives[dp.Lines].getCABO().createVBO(r.getLines(),&quot;lines&quot;,i,a),a.cellOffset+=t.primitives[dp.Tris].getCABO().createVBO(r.getPolys(),&quot;polys&quot;,i,a),a.cellOffset+=t.primitives[dp.TriStrips].getCABO().createVBO(r.getStrips(),&quot;strips&quot;,i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=dp.Start;a<dp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform samplerBuffer texture1;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);&quot;]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 diffuseColor;&quot;,&quot;out vec4 fcolorVSOutput;&quot;]).result,o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorVSOutput = diffuseColor;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput[];\\n&quot;,&quot;out vec4 fcolorGSOutput;&quot;]).result,a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;fcolorGSOutput = fcolorVSOutput[i];&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 fcolorVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = fcolorVSOutput;&quot;]).result):(i=cd.substitute(i,&quot;//VTK::Color::Dec&quot;,[&quot;uniform vec4 diffuseColor;&quot;]).result,i=cd.substitute(i,&quot;//VTK::Color::Impl&quot;,[&quot;gl_FragData[0] = diffuseColor;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordMC;&quot;,&quot;out float tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput[];\\n&quot;,&quot;out float tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,[&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));&quot;]).result):2===a&&(n=cd.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordMC;&quot;,&quot;out vec2 tcoordVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];\\n&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);&quot;]).result),t.haveCellScalars&&(r=cd.substitute(r,&quot;//VTK::PrimID::Impl&quot;,[&quot;gl_PrimitiveID = gl_PrimitiveIDIn;&quot;]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=cd.substitute(r,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&e.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),e.getProgram().isAttributeUsed(&quot;vertexWC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;vertexWC&quot;,e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||fp(&quot;Error setting vertexWC in shader VAO.&quot;)),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||fp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;tcoordMC&quot;,e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||fp(&quot;Error setting tcoordMC in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),t.internalColorTexture&&e.getProgram().isUniformUsed(&quot;texture1&quot;)&&e.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi(&quot;picking&quot;,a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f(&quot;diffuseColor&quot;,i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===up?-1:1,x[15]=1,m(x,x),a.setUniformMatrix(&quot;WCVCMatrix&quot;,(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const vp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const yp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=dp,t.tmpMat4=g(new Float64Array(16));for(let e=dp.Start;e<dp.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,[&quot;context&quot;]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),hp(e,t)}),&quot;vtkOpenGLPolyDataMapper2D&quot;);rn(&quot;vtkMapper2D&quot;,yp);const{VectorMode:Tp}=Pl;function bp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function xp(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Cp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Sp(e,t){t.classHierarchy.push(&quot;vtkScalarBarActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;;const n={},r=new Map;let o=0,a=1;bp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,bp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),&quot;NaN&quot;,&quot;Below&quot;,&quot;Above&quot;];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{bp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s(&quot;NaN&quot;,[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s(&quot;Below&quot;,[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s(&quot;ticks&quot;,t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s(&quot;Above&quot;,[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p=&quot;vertical&quot;===a?[1,0]:[0,1];&quot;vertical&quot;===a?(d[0]=l.width,d[1]=-l.height,&quot;middle&quot;===o[0]?n[1]-=l.width/2:&quot;right&quot;===o[0]&&(n[1]-=l.width),&quot;middle&quot;===o[1]?n[0]+=l.height/2:&quot;top&quot;===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,&quot;middle&quot;===o[0]?n[0]-=l.width/2:&quot;right&quot;===o[0]&&(n[0]-=l.width),&quot;middle&quot;===o[1]?n[1]-=l.height/2:&quot;top&quot;===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?[&quot;right&quot;,&quot;middle&quot;]:[&quot;middle&quot;,&quot;bottom&quot;];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;top&quot;],&quot;vertical&quot;,[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];&quot;ticks&quot;===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,&quot;horizontal&quot;,g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,&quot;horizontal&quot;,g,c)}const b=Es.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Tp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Es.newInstance({numberOfComponents:i,values:c,name:&quot;Scalars&quot;});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Ap=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;tickLabelPixelOffset&quot;,&quot;renderable&quot;,&quot;topTitle&quot;,&quot;ticks&quot;,&quot;tickStrings&quot;]),jt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;lastTickBounds&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;barActor&quot;,&quot;tmActor&quot;]),jt.getArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.barMapper=nc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=gu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=hs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Tu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Sp(e,t)}),&quot;vtkScalarBarActorHelper&quot;);function Ip(e,t){t.classHierarchy.push(&quot;vtkScalarBarActor&quot;),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(xp(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Cp())}}function wp(e){return{automated:!0,autoLayout:null,axisLabel:&quot;Scalar Value&quot;,barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:14,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function Pp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wp(n)),t.autoLayout||(t.autoLayout=xp(0,t)),t.generateTicks||(t.generateTicks=Cp()),hs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,[&quot;automated&quot;,&quot;autoLayout&quot;,&quot;axisTitlePixelOffset&quot;,&quot;axisLabel&quot;,&quot;scalarsToColors&quot;,&quot;tickLabelPixelOffset&quot;,&quot;generateTicks&quot;,&quot;drawNanAnnotation&quot;,&quot;drawBelowRangeSwatch&quot;,&quot;drawAboveRangeSwatch&quot;]),jt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;]),jt.getArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;]),jt.setArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;],2),Ip(e,t)}var Op={newInstance:jt.newInstance(Pp,&quot;vtkScalarBarActor&quot;),extend:Pp,newScalarBarActorHelper:Ap};function Rp(e,t){t.classHierarchy.push(&quot;vtkOpenGLScalarBarActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Mp={};const Dp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Op.newScalarBarActorHelper(),Rp(e,t)}),&quot;vtkOpenGLScalarBarActor&quot;);rn(&quot;vtkScalarBarActor&quot;,Dp);const{vtkErrorMacro:Ep}=Kt;function Vp(e,t){t.classHierarchy.push(&quot;vtkOpenGLSkybox&quot;),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi(&quot;sbtexture&quot;,n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix(&quot;IMCPCMatrix&quot;,a),&quot;box&quot;===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f(&quot;camPos&quot;,e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Es.newInstance({numberOfComponents:3,values:e});n.setName(&quot;points&quot;);const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),&quot;box&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec3 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = wpos.xyz/wpos.w;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec3 TexCoords;\\n             uniform samplerCube sbtexture;\\n             uniform vec3 camPos;\\n             void main () {\\n               // skybox looks from inside out\\n               // which means we have to adjust\\n               // our tcoords. Otherwise text would\\n               // be flipped\\n               vec3 tc = normalize(TexCoords - camPos);\\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\\n               {\\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\\n               }\\n               else\\n               {\\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\\n               }\\n               gl_FragData[0] = textureCube(sbtexture, tc);\\n             }&quot;,&quot;&quot;)),&quot;background&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec2 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec2 TexCoords;\\n             uniform sampler2D sbtexture;\\n             void main () {\\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\\n             }&quot;,&quot;&quot;)),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),&quot;vertexMC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Ep(&quot;Error setting vertexMC in shader VAO.&quot;));const e=t.renderable.getTextures();e.length||Ep(&quot;vtkSkybox requires a texture map&quot;),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Lp={context:null};const Bp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lp,n),Zt.extend(e,t,n),t.openGLTexture=Nd.newInstance(),t.tris=yd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bt(e,t,[&quot;activeTextures&quot;]),Vp(e,t)}));rn(&quot;vtkSkybox&quot;,Bp);const{FieldAssociations:Np}=ol;function _p(e,t){t.classHierarchy.push(&quot;vtkHardwareSelector&quot;),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const Fp={fieldAssociation:Np.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function kp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fp,n),jt.obj(e,t),jt.setGet(e,t,[&quot;fieldAssociation&quot;,&quot;captureZValues&quot;]),_p(e,t)}var Gp={newInstance:jt.newInstance(kp,&quot;vtkHardwareSelector&quot;),extend:kp};function Up(e,t){t.classHierarchy.push(&quot;vtkFramebuffer&quot;),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling saveCurrentBindings&quot;);const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling restorePreviousBindings&quot;);const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et(&quot;you must set the OpenGLRenderWindow before calling create&quot;)},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et(&quot;you must set the OpenGLRenderWindow before calling setColorBuffer&quot;);let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et(&quot;you must set the OpenGLRenderWindow before calling removeColorBuffer&quot;);let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et(&quot;Attaching depth buffer textures to fbo requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling setDepthBuffer&quot;)},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et(&quot;Attaching depth buffer textures to framebuffers requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling removeDepthBuffer&quot;)},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>{const e=[0,0];return null!==t.glFramebuffer&&(e[0]=t.glFramebuffer.width,e[1]=t.glFramebuffer.height),e},e.populateFramebuffer=()=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling populateFrameBuffer&quot;);e.bind();const n=t.context,r=Nd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(bd.LINEAR),r.setMagnificationFilter(bd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,ys.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const zp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Wp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zp,n),yt(e,t),t.colorBuffers&&et(&quot;you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.&quot;),t.colorBuffers=[],It(e,t,[&quot;colorBuffers&quot;]),Up(e,t)}var Hp={newInstance:Et(Wp,&quot;vtkFramebuffer&quot;),extend:Wp};function jp(e,t){t.classHierarchy.push(&quot;vtkSelectionNode&quot;),e.getBounds=()=>t.points.getBounds()}const Kp={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function $p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kp,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,[&quot;contentType&quot;,&quot;fieldType&quot;,&quot;properties&quot;,&quot;selectionList&quot;]),jp(e,t)}var qp={newInstance:jt.newInstance($p,&quot;vtkSelectionNode&quot;),extend:$p,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Xp}=Wl,{SelectionContent:Yp,SelectionField:Zp}=qp,{FieldAssociations:Qp}=ol,{vtkErrorMacro:Jp}=jt;function ef(e){return`${e.propID} ${e.compositeID}`}function tf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function nf(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function rf(e,t){let n=t;return n<<=24,n|=e,n}function of(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=nf(n[0],n[1],e.pixBuffer[Xp.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=nf(n[0],n[1],e.pixBuffer[Xp.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Xp.ID_LOW24]&&0===tf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area))return a;const s=nf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area),l=nf(n[0],n[1],e.pixBuffer[Xp.ID_HIGH24],e.area);return a.attributeID=rf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=of(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=of(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=of(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function af(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=qp.newInstance();switch(l.setContentType(Yp.INDICES),e){case Qp.FIELD_ASSOCIATION_CELLS:l.setFieldType(Zp.CELL);break;case Qp.FIELD_ASSOCIATION_POINTS:l.setFieldType(Zp.POINT);break;default:Jp(&quot;Unknown field association&quot;)}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function sf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=of(e,[n,t],0,u);if(r&&r.valid){const t=ef(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return af(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function lf(e,t){t.classHierarchy.push(&quot;vtkOpenGLHardwareSelector&quot;),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e[0]!==n[0]||e[1]!==n[1]?(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer()):t.framebuffer.bind()}else t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return sf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return Jp(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:&quot;StartEvent&quot;}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();for(e.beginSelection(),t.currentPass=Xp.MIN_KNOWN_PASS;t.currentPass<=Xp.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Xp.ACTOR_PASS&&&quot;function&quot;==typeof n[0].requestDepth&&&quot;function&quot;==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),e.processPixelBuffers());return e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:&quot;EndEvent&quot;}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Xp.ID_HIGH24){if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Xp.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if(&quot;function&quot;==typeof e[0].requestDepth&&&quot;function&quot;==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=nf(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Xp.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Xp.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(Xp,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=nf(e[0],e[1],t.pixBuffer[Xp.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=nf(e[0],e[1],t.pixBuffer[Xp.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Xp.ID_LOW24]&&0===tf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area))return a;const s=nf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area),l=nf(e[0],e[1],t.pixBuffer[Xp.ID_HIGH24],t.area);return a.attributeID=rf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=ef(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return af(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const cf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cf,n),Gp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,[&quot;area&quot;],4),jt.setGet(e,t,[&quot;_renderer&quot;,&quot;currentPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;maximumPointId&quot;,&quot;maximumCellId&quot;]),jt.setGetArray(e,t,[&quot;propColorValue&quot;],3),jt.moveToProtected(e,t,[&quot;renderer&quot;,&quot;openGLRenderWindow&quot;]),jt.event(e,t,&quot;event&quot;),lf(e,t)}var df={newInstance:jt.newInstance(uf,&quot;vtkOpenGLHardwareSelector&quot;),extend:uf,...Wl};const{vtkErrorMacro:pf}=Kt,{Representation:ff}=ds,{ObjectType:gf}=qu,{PassTypes:mf}=df,hf={type:&quot;StartEvent&quot;},vf={type:&quot;EndEvent&quot;};function yf(e,t){t.classHierarchy.push(&quot;vtkOpenGLGlyph3DMapper&quot;);const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(hf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(vf),!t.currentInput)return void pf(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=cd.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;attribute mat3 gNormal;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * gNormal * normalMC;&quot;]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;];a&&(i=i.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let s=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];a&&(s=s.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),s=s.concat([&quot;  opacity = opacityUniform;&quot;]),a&&(s=s.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),t.drawingEdges||(i=i.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),n=cd.substitute(n,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 gColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput = gColor;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,r=cd.substitute(r,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result,s=s.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])),o=cd.substitute(o,&quot;//VTK::Color::Impl&quot;,s).result,o=cd.substitute(o,&quot;//VTK::Color::Dec&quot;,i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;vertexVCVSOutput = MCVCMatrix * gVertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result):(n=cd.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;]).result,n=cd.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=cd.substitute(n,&quot;//VTK::Picking::Dec&quot;,[&quot;attribute vec3 mapperIndexVS;&quot;,&quot;varying vec3 mapperIndexVSOutput;&quot;]).result,n=cd.substitute(n,&quot;//VTK::Picking::Impl&quot;,&quot;  mapperIndexVSOutput = mapperIndexVS;&quot;).result,e.Vertex=n,t=cd.substitute(t,&quot;//VTK::Picking::Dec&quot;,[&quot;varying vec3 mapperIndexVSOutput;&quot;,&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,t=cd.substitute(t,&quot;//VTK::Picking::Impl&quot;,[&quot;  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);&quot;,&quot;  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];&quot;]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3(&quot;normalMatrix&quot;,t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix(&quot;MCVCMatrix&quot;,t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray(&quot;ambientColorUniform&quot;,t.tmpColor),u.setUniform3fArray(&quot;diffuseColorUniform&quot;,t.tmpColor)}c&&u.setUniform3fArray(&quot;mapperIndex&quot;,c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===ff.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===mf.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed(&quot;normalMatrix&quot;),v=g.isUniformUsed(&quot;MCVCMatrix&quot;);if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed(&quot;gMatrix&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,&quot;gMatrix&quot;,0,64,t.context.FLOAT,4,!1,1)||pf(&quot;Error setting gMatrix in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gMatrix&quot;),e.getProgram().isAttributeUsed(&quot;gNormal&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,&quot;gNormal&quot;,0,36,t.context.FLOAT,3,!1,1)||pf(&quot;Error setting gNormal in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gNormal&quot;),e.getProgram().isAttributeUsed(&quot;gColor&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,&quot;gColor&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting gColor in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gColor&quot;),e.getProgram().isAttributeUsed(&quot;mapperIndexVS&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,&quot;mapperIndexVS&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf(&quot;Error setting mapperIndexVS in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;mapperIndexVS&quot;),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=qu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=qu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=qu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=qu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,gf.ARRAY_BUFFER),t.normalBuffer.upload(n,gf.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),gf.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,gf.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Tf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const bf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),np.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),yf(e,t)}),&quot;vtkOpenGLGlyph3DMapper&quot;);rn(&quot;vtkGlyph3DMapper&quot;,bf);const{vtkErrorMacro:xf}=jt;class Cf{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Sf(e,t){t.classHierarchy.push(&quot;vtkClosedPolyLineToSurfaceFilter&quot;),e.requestData=(e,t)=>{const n=e[0];if(!n)return void xf(&quot;Invalid or missing input&quot;);const r=gu.newInstance();r.shallowCopy(n);const o=new Cf,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(cc.newInstance({values:c,name:&quot;faces&quot;})),t[0]=r}}const Af={};function If(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Af,n),jt.obj(e,t),jt.algo(e,t,1,1),Sf(e,t)}var wf={newInstance:jt.newInstance(If,&quot;vtkClosedPolyLineToSurfaceFilter&quot;),extend:If};const{vtkErrorMacro:Pf}=Kt;function Of(e,t){t.classHierarchy.push(&quot;vtkCutter&quot;);const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Pf(&quot;Invalid or missing input&quot;);if(!t.cutFunction)return void Pf(&quot;Missing cut function&quot;);const o=gu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error(&quot;Iterator is done&quot;);r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const Rf={cutFunction:null,cutScalars:null,cutValue:0};function Mf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),yt(e,t),Rt(e,t,1,1),At(e,t,[&quot;cutFunction&quot;,&quot;cutValue&quot;]),Of(e,t)}var Df={newInstance:Et(Mf,&quot;vtkCutter&quot;),extend:Mf};const Ef=e=>e,Vf=1e-6;class Lf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Ef}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=Dn(n,r);return a>=1||(En(this.tmp,n,r),Sn(this.tmp)<Vf&&(En(this.tmp,[1,0,0],e),Sn(this.tmp)<Vf&&En(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Bf=function(){return new Lf(!0)},Nf=function(){return new Lf(!1)};const _f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],Ff=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function kf(e,t){t.classHierarchy.push(&quot;vtkCubeSource&quot;),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=gu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Es.newInstance({name:&quot;Normals&quot;,values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Es.newInstance({name:&quot;TextureCoordinates&quot;,values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Bf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Nf().translate(...t.center).apply(o),t.matrix){Nf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Nf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Gf={xLength:1,yLength:1,zLength:1,pointType:&quot;Float64Array&quot;,generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;xLength&quot;,&quot;yLength&quot;,&quot;zLength&quot;,&quot;generate3DTextureCoordinates&quot;,&quot;generateFaces&quot;,&quot;generateLines&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;rotations&quot;],3),jt.setGetArray(e,t,[&quot;matrix&quot;],16),t._polys=cc.newInstance({values:Uint16Array.from(Ff)}),t._lineCells=cc.newInstance({values:Uint16Array.from(_f)}),jt.moveToProtected(e,t,[&quot;polys&quot;,&quot;lineCells&quot;]),jt.algo(e,t,0,1),kf(e,t)}var zf={newInstance:jt.newInstance(Uf,&quot;vtkCubeSource&quot;),extend:Uf};const{vtkErrorMacro:Wf}=jt;function Hf(e,t){t.classHierarchy.push(&quot;vtkImageDataOutlineFilter&quot;);const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA(&quot;vtkImageData&quot;))return void Wf(&quot;Invalid or missing input&quot;);const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Wf(&quot;Unable to fetch spatial extents of input image.&quot;)},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const jf={};function Kf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jf,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=zf.newInstance(),jt.moveToProtected(e,t,[&quot;cubeSource&quot;,&quot;tmpOut&quot;]),Hf(e,t)}var $f={newInstance:jt.newInstance(Kf,&quot;vtkImageDataOutlineFilter&quot;),extend:Kf};let qf;function Xf(e,t){t.classHierarchy.push(&quot;vtkAbstractTransform&quot;,&quot;vtkHomogeneousTransform&quot;,&quot;vtkTransform&quot;),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>qf({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const Yf={preMultiplyFlag:!1,matrix:[...vo]};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,[&quot;preMultiplyFlag&quot;]),jt.setGetArray(e,t,[&quot;matrix&quot;],16),Xf(e,t)}qf=jt.newInstance(Zf,&quot;vtkTransform&quot;);var Qf={newInstance:qf,extend:Zf};const Jf={NEAREST:0,LINEAR:1};var eg={InterpolationType:Jf};const{vtkErrorMacro:tg}=Kt;function ng(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function rg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function og(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageResliceMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:&quot;EndEvent&quot;})):tg(&quot;No input!&quot;)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Jf.NEAREST?(t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.openGLTexture.setMinificationFilter(bd.LINEAR),t.openGLTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime(),e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(!r)return;const o=r.getPointData()?.getScalars();if(!o)return;t._scalars!==o&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=o);const a=o.getNumberOfComponents();let i=`${r.getMTime()}A${o.getMTime()}`;const s=t._openGLRenderWindow.getGraphicsResourceForObject(o);if(s?.vtkObj&&s?.hash===i&&t.openGLTextureString===i)t.openGLTexture=s.vtkObj,t.openGLTextureString=s.hash;else{t.openGLTexture||(t.openGLTexture=Nd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const e=r.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],o),t.openGLTextureString=i,o&&t._openGLRenderWindow.setGraphicsResourceForObject(o,t.openGLTexture,t.openGLTextureString)}const l=n.getProperty(),c=l.getIndependentComponents(),u=c?a:1,d=c?2*u:1,p=l.getRGBTransferFunction();i=ng(l,p,u);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===i&&t.colorTextureString===i)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(e*d*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),p){const r=new Float32Array(3*e);for(let t=0;t<u;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),c)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=i,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}const g=l.getPiecewiseFunction();i=ng(l,g,u);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(m?.vtkObj&&m?.hash===i&&t.pwfTextureString===i)t.pwfTexture=m.vtkObj,t.pwfTextureString=m.hash;else{const e=1024,n=e*d,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),g){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<u;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=i,g&&t._openGLRenderWindow.setGraphicsResourceForObject(g,t.pwfTexture,t.pwfTextureString)}const h=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==h){const e=Es.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName(&quot;points&quot;);const n=Es.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:tg(&quot;Slab mode requested without normals&quot;)}t.tris.getCABO().createVBO(n,&quot;polys&quot;,rs.SURFACE,r)}t.VBOBuildString=h,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed(&quot;texture1&quot;)&&a.setUniformi(&quot;texture1&quot;,t.openGLTexture.getTextureUnit()),a.isAttributeUsed(&quot;vertexWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexWC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting vertexWC in shader VAO.&quot;)),a.isAttributeUsed(&quot;normalWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;normalWC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg(&quot;Error setting normalWC in shader VAO.&quot;)),a.isUniformUsed(&quot;slabThickness&quot;)&&a.setUniformf(&quot;slabThickness&quot;,t.renderable.getSlabThickness()),a.isUniformUsed(&quot;spacing&quot;)&&a.setUniform3fv(&quot;spacing&quot;,t.currentInput.getSpacing()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabTrapezoid&quot;)&&a.setUniformi(&quot;slabTrapezoid&quot;,t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed(&quot;WCTCMatrix&quot;)){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix(&quot;WCTCMatrix&quot;,t.tmpMat4)}a.isUniformUsed(&quot;vboScaling&quot;)&&a.setUniform3fv(&quot;vboScaling&quot;,n.getCABO().getCoordScale()),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed(&quot;MCPCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCPCMatrix&quot;,rg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed(&quot;MCVCMatrix&quot;)&&(g(t.tmpMat4),l.setUniformMatrix(&quot;MCVCMatrix&quot;,rg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d),o.setUniform4fv(&quot;backgroundColor&quot;,t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model coordinates\\n// WC - World coordinates\\n// VC - View coordinates\\n// DC - Display coordinates\\n// TC - Texture coordinates\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvoid main()\\n{\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the gpu image mapper fragment shader\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  //VTK::TCoord::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=cd.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=cd.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform mat4 WCTCMatrix;&quot;,&quot;out vec3 fragTexCoord;&quot;]).result,o=cd.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;fragTexCoord = (WCTCMatrix * vertexWC).xyz;&quot;]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=[&quot;in vec3 fragTexCoord;&quot;,&quot;uniform highp sampler3D texture1;&quot;,&quot;uniform mat4 WCTCMatrix;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}s>0&&(u=u.concat([&quot;uniform vec3 spacing;&quot;,&quot;uniform float slabThickness;&quot;,&quot;uniform int slabType;&quot;,&quot;uniform int slabTrapezoid;&quot;,&quot;uniform vec3 vboScaling;&quot;]),u=u.concat([&quot;vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)&quot;,&quot;{&quot;,&quot;  vec4 retVal = vec4(1.0);&quot;,&quot;  if (slabType == 0) // min&quot;,&quot;  {&quot;,&quot;    retVal = min(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 1) // max&quot;,&quot;  {&quot;,&quot;    retVal = max(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 3) // sum&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  else // mean&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  return retVal;&quot;,&quot;}&quot;])),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,u).result;let d=[&quot;if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(texture1, fragTexCoord);&quot;];if(s>0&&(d=d.concat([&quot;// Get the first and last samples&quot;,&quot;int numSlices = 1;&quot;,&quot;float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;&quot;,&quot;vec3 normalxspacing = scaling * normalWCVSOutput;&quot;,&quot;float distTraveled = length(normalxspacing);&quot;,&quot;int trapezoid = 0;&quot;,&quot;while (distTraveled < slabThickness * 0.5)&quot;,&quot;{&quot;,&quot;  distTraveled += length(normalxspacing);&quot;,&quot;  float fnumSlices = float(numSlices);&quot;,&quot;  if (distTraveled > slabThickness * 0.5)&quot;,&quot;  {&quot;,&quot;    // Before stepping outside the slab, sample at the boundaries&quot;,&quot;    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;&quot;,&quot;    trapezoid = slabTrapezoid;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordNeg);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = texture(texture1, fragTCoordPos);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;}&quot;,&quot;// Finally, if slab type is *mean*, divide the sum by the numSlices&quot;,&quot;if (slabType == 2)&quot;,&quot;{&quot;,&quot;  tvalue = tvalue / float(numSlices);&quot;,&quot;}&quot;])),c){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:tg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(l){case 1:d=d.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:d=d.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=[&quot;attribute vec4 vertexWC;&quot;];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat([&quot;attribute vec3 normalWC;&quot;,&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,c).result;let u=[&quot;gl_Position = MCPCMatrix * vertexWC;&quot;];l>0&&(u=u.concat([&quot;normalWCVSOutput = normalWC;&quot;,&quot;vertexWCVSOutput = vertexWC;&quot;])),a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,u).result,a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result;let d=[];l>0&&(d=d.concat([&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),s=cd.substitute(s,&quot;//VTK::PositionVC::Dec&quot;,d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e=&quot;&quot;;const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`));const t=ue(n?.getDirection());ge(t,t);const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999||o>.999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ni.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getDimensions(),l=[0,i[0]-1,0,i[1]-1,0,i[2]-1];let c=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[c+a]=r[a],e[c+o[0]]=l[2*o[0]+n],e[c+o[1]]=l[2*o[1]+t],c+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const u=new Uint16Array(8);u[0]=3,u[1]=0,u[2]=1,u[3]=3,u[4]=3,u[5]=0,u[6]=3,u[7]=2;const d=s.getNormal();za.normalize(d);const p=new Float32Array(12);for(let e=0;e<4;++e)p[3*e]=d[0],p[3*e+1]=d[1],p[3*e+2]=d[2];t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(u,1);const f=Es.newInstance({numberOfComponents:3,values:p,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(f)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=gu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Es.newInstance({numberOfComponents:3,values:a,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(i)}else tg(&quot;Something went wrong.&quot;,&quot;A default slice plane should have been created in the beginning of&quot;,&quot;updateResliceGeometry.&quot;);t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)}}const ag={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,openGLTextureString:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1,_scalars:null};const ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ag,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=$f.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=gu.newInstance(),t.cutter=Df.newInstance(),t.lineToSurfaceFilter=wf.newInstance(),t.transform=Qf.newInstance(),bt(e,t,[&quot;openGLTexture&quot;]),og(e,t)}),&quot;vtkOpenGLImageResliceMapper&quot;);rn(&quot;vtkImageResliceMapper&quot;,ig);var sg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:lg}=Kt,{SlicingMode:cg}=sg;function ug(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function dg(e){const t=e.split(&quot;\\n&quot;),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function pg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageMapper&quot;),e.buildPass=n=>{if(n){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t.renderable.isA(&quot;vtkImageMapper&quot;)&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(n.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,a=cd.substitute(a,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result,a=cd.substitute(a,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform sampler2D labelOutlineTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform float outlineOpacity;&quot;];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}}if(i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,c).result,!0===o.getProperty().getUseLabelOutline()&&(i=cd.substitute(i,&quot;//VTK::LabelOutline::Dec&quot;,[&quot;uniform int outlineThickness;&quot;,&quot;uniform float vpWidth;&quot;,&quot;uniform float vpHeight;&quot;,&quot;uniform float vpOffsetX;&quot;,&quot;uniform float vpOffsetY;&quot;,&quot;uniform mat4 PCWCMatrix;&quot;,&quot;uniform mat4 vWCtoIDX;&quot;,&quot;uniform ivec3 imageDimensions;&quot;]).result,i=cd.substitute(i,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result,i=cd.substitute(i,&quot;//VTK::LabelOutlineHelperFunction&quot;,[&quot;#ifdef vtkImageLabelOutlineOn&quot;,&quot;vec3 fragCoordToIndexSpace(vec4 fragCoord) {&quot;,&quot;  vec4 pcPos = vec4(&quot;,&quot;    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,&quot;,&quot;    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,&quot;,&quot;    (fragCoord.z - 0.5) * 2.0,&quot;,&quot;    1.0);&quot;,&quot;&quot;,&quot;  vec4 worldCoord = PCWCMatrix * pcPos;&quot;,&quot;  vec4 vertex = (worldCoord/worldCoord.w);&quot;,&quot;&quot;,&quot;  vec3 index = (vWCtoIDX * vertex).xyz;&quot;,&quot;&quot;,&quot;  // half voxel fix for labelmapOutline&quot;,&quot;  return (index + vec3(0.5)) / vec3(imageDimensions);&quot;,&quot;}&quot;,&quot;#endif&quot;]).result),l){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];let t=[&quot;vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);&quot;];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, opacity);&quot;]);break;case 2:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:lg(&quot;Unsupported number of independent coordinates.&quot;)}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,t).result}else switch(s){case 1:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[...dg(&quot;\\n                #ifdef vtkImageLabelOutlineOn\\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); \\n                  float centerValue = texture2D(texture1, centerPosIS.xy).r;\\n                  bool pixelOnBorder = false;\\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\\n                  float opacityToUse = scalarOpacity * opacity;\\n                  int segmentIndex = int(centerValue * 255.0);\\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\\n                  int actualThickness = int(textureValue * 255.0);\\n\\n                  if (actualThickness == 0) {\\n                    gl_FragData[0] = vec4(0.0, 0.0, 1.0, 1.0);\\n                    return;\\n                  }\\n                  if (opacityToUse > 0.01) {\\n                    for (int i = -actualThickness; i <= actualThickness; i++) {\\n                      for (int j = -actualThickness; j <= actualThickness; j++) {\\n                        if (i == 0 || j == 0) {\\n                          continue;\\n                        }\\n                        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n                          gl_FragCoord.y + float(j),\\n                          gl_FragCoord.z, gl_FragCoord.w);\\n                        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n                        float value = texture2D(texture1, neighborPosIS.xy).r;\\n                        if (value != centerValue) {\\n                          pixelOnBorder = true;\\n                          break;\\n                        }\\n                      }\\n                      if (pixelOnBorder == true) {\\n                        break;\\n                      }\\n                    }\\n                    if (pixelOnBorder == true) {\\n                      gl_FragData[0] = vec4(tColor, outlineOpacity);\\n                    }\\n                    else {\\n                      gl_FragData[0] = vec4(tColor, opacityToUse);\\n                    }\\n                  }\\n                #else\\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\\n                #endif\\n                &quot;)]).result;break;case 2:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;float intensity = tcolor.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);&quot;]).result;break;case 3:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]).result;break;default:i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;]).result}t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||lg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||lg(&quot;Error setting tcoordMC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi(&quot;texture1&quot;,a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi(&quot;colorTexture1&quot;,c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi(&quot;pwfTexture1&quot;,u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;labelOutlineTexture1&quot;,p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf(&quot;outlineOpacity&quot;,e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();a.setUniform3i(&quot;imageDimensions&quot;,o[0],o[1],1),a.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const i=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,i.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const l=e.getRenderTargetSize();a.setUniformf(&quot;vpWidth&quot;,l[0]),a.setUniformf(&quot;vpHeight&quot;,l[1]);const c=e.getRenderTargetOffset();a.setUniformf(&quot;vpOffsetX&quot;,c[0]/l[0]),a.setUniformf(&quot;vpOffsetY&quot;,c[1]/l[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf(&quot;opacity&quot;,o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):lg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=ug(l,f,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.vtkObj&&m?.hash===g&&t.colorTextureString===g)t.colorTexture=m.vtkObj,t.colorTextureString=m.hash;else{const e=1024,n=new Uint8Array(e*p*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST)):(t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR)),f){const r=new Float32Array(3*e);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),u)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,p,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=g,f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,t.colorTextureString)}const h=l.getPiecewiseFunction(),v=ug(l,h,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.vtkObj&&y?.hash===v&&t.pwfTextureString===v)t.pwfTexture=y.vtkObj,t.pwfTextureString=y.hash;else{const e=1024,n=e*p,r=new Uint8Array(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),h){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<d;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),u)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,p,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=v,h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,t.pwfTextureString)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA(&quot;vtkImageArrayMapper&quot;)?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===cg.I&&(S=x-C[0]),T===cg.J&&(S=x-C[2]),T!==cg.K&&T!==cg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Nd.newInstance({resizable:!0}),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(new Set([1,3,4]).has(s)&&i===ys.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.NEAREST)):t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST)):(4!==s||i!==ys.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(bd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(bd.LINEAR)),t.openGLTexture.setWrapS(Td.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Td.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[cg.X,cg.Y,cg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===cg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===cg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===cg.K||T===cg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):lg(&quot;Reformat slicing not yet supported.&quot;);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);m?.vtkObj?(t.openGLTexture=m.vtkObj,t.VBOBuildString=m.hash):(t._scalars!==g&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=g),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t._openGLRenderWindow.setGraphicsResourceForObject(g,t.openGLTexture,t.VBOBuildString)),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Es.newInstance({numberOfComponents:3,values:r});h.setName(&quot;points&quot;);const v=Es.newInstance({numberOfComponents:2,values:l});v.setName(&quot;tcoords&quot;);const y=new Uint16Array(8);y[0]=3,y[1]=0,y[2]=1,y[3]=3,y[4]=3,y[5]=0,y[6]=3,y[7]=2;const C=Es.newInstance({numberOfComponents:1,values:y});t.tris.getCABO().createVBO(C,&quot;polys&quot;,rs.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=e=>{t.labelOutlineThicknessTexture||(t.labelOutlineThicknessTexture=Nd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]}}const fg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,_scalars:null};const gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fg,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),pg(e,t)}),&quot;vtkOpenGLImageMapper&quot;);rn(&quot;vtkAbstractImageMapper&quot;,gg);const{vtkErrorMacro:mg}=jt;function hg(e,t,n){if(t.apply(e)){const t=e.getIndependentComponents();return`${e.getMTime()}-${t}-${n}`}return&quot;0&quot;}function vg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageCPRMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow))},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentImageDataInput,o=t.currentCenterlineInput;n.getProperty().getInterpolationType()===Jf.NEAREST?(t.volumeTexture.setMinificationFilter(bd.NEAREST),t.volumeTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.volumeTexture.setMinificationFilter(bd.LINEAR),t.volumeTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR));const a=r.getMTime();if(t.volumeTextureTime!==a){const e=r.getDimensions(),n=r.getPointData().getScalars();if(!n)return;t.volumeTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.volumeTexture.releaseGraphicsResources(t._openGLRenderWindow),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromRaw(e[0],e[1],e[2],n.getNumberOfComponents(),n.getDataType(),n.getData(),t.renderable.getPreferSizeOverAccuracy()),t.volumeTextureTime=a}const i=r.getPointData()&&r.getPointData().getScalars();if(!i)return;const s=i.getNumberOfComponents(),l=n.getProperty(),c=l.getIndependentComponents(),u=c?s:1,d=c?2*u:1,p=hg(l,l.getRGBTransferFunction,u);if(t.colorTextureString!==p){const e=1024,n=new Uint8Array(e*d*3);let r=l.getRGBTransferFunction();if(r){const o=new Float32Array(3*e);for(let t=0;t<u;t++){r=l.getRGBTransferFunction(t);const a=r.getRange();if(r.getTable(a[0],a[1],e,o,1),c)for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r],n[t*e*6+r+3*e]=255*o[r];else for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=p}const f=hg(l,l.getPiecewiseFunction,u);if(t.pwfTextureString!==f){const e=1024,n=e*d,r=new Uint8Array(n);let o=l.getPiecewiseFunction();if(t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),o){const r=new Float32Array(n),a=new Float32Array(e);for(let t=0;t<u;++t)if(o=l.getPiecewiseFunction(t),null===o)r.fill(1);else{const n=o.getRange();if(o.getTable(n[0],n[1],e,a,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=a[n],r[t*e*2+n+e]=a[n];else for(let n=0;n<e;n++)r[t*e*2+n]=a[n]}t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=f}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<o.getMTime()){const e=o.getNumberOfPoints(),n=e<=1?0:e-1,r=o.getDistancesToFirstPoint(),a=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,a-r[e],0],t),t+=3,s.set([l,a-r[e],0],t),t+=3,s.set([l,a-r[e+1],0],t),t+=3,s.set([0,a-r[e+1],0],t),t+=3;const c=Es.newInstance({numberOfComponents:3,values:s});c.setName(&quot;points&quot;);const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Es.newInstance({numberOfComponents:1,values:u}),p=o.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Es.newInstance({numberOfComponents:3,values:f,name:&quot;centerlinePosition&quot;}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Es.newInstance({numberOfComponents:1,values:v,name:&quot;quadIndex&quot;})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getCenterlineTangentDirections(),r=new Float32Array(3*i),o=new Float32Array(3*i);for(let t=0,a=0;t<n;++t){const n=3*t;for(let t=0;t<4;++t)r[a+0]=e[n+0],r[a+1]=e[n+1],r[a+2]=e[n+2],o[a+0]=e[n+3],o[a+1]=e[n+4],o[a+2]=e[n+5],a+=3}const a=Es.newInstance({numberOfComponents:3,values:r,name:&quot;centerlineTopDirection&quot;}),s=Es.newInstance({numberOfComponents:3,values:o,name:&quot;centerlineBotDirection&quot;});y.push(a,s)}t.tris.getCABO().createVBO(d,&quot;polys&quot;,rs.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=cd.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result;const s=[&quot;attribute vec3 centerlinePosition;&quot;,&quot;attribute float quadIndex;&quot;,&quot;uniform float width;&quot;,&quot;out vec2 quadOffsetVSOutput;&quot;,&quot;out vec3 centerlinePosVSOutput;&quot;],l=t.renderable.getUseUniformOrientation();l?s.push(&quot;out vec3 centerlineDirVSOutput;&quot;,&quot;uniform vec3 centerlineDirection;&quot;):s.push(&quot;out vec3 centerlineTopDirVSOutput;&quot;,&quot;out vec3 centerlineBotDirVSOutput;&quot;,&quot;out float centerlineAngleVSOutput;&quot;,&quot;attribute vec3 centerlineTopDirection;&quot;,&quot;attribute vec3 centerlineBotDirection;&quot;),a=cd.substitute(a,&quot;//VTK::Color::Dec&quot;,s).result;const c=[&quot;quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);&quot;,&quot;centerlinePosVSOutput = centerlinePosition;&quot;];l?c.push(&quot;centerlineDirVSOutput = centerlineDirection;&quot;):c.push(&quot;vec3 sumVec = centerlineTopDirection + centerlineBotDirection;&quot;,&quot;float sumLen2 = dot(sumVec, sumVec);&quot;,&quot;float diffLen2 = 4.0 - sumLen2;&quot;,&quot;if (diffLen2 < 0.001) {&quot;,&quot;  // vectors are too close to each other, use lerp&quot;,&quot;  centerlineAngleVSOutput = -1.0; // use negative angle as a flag for lerp&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection;&quot;,&quot;} else if (sumLen2 == 0.0) {&quot;,&quot;  // vector are opposite to each other, don't make a choice for the user&quot;,&quot;  // use slerp without direction, it will display the centerline color on each row of pixel&quot;,&quot;  centerlineAngleVSOutput = 0.0;&quot;,&quot;  centerlineTopDirVSOutput = vec3(0.0);&quot;,&quot;  centerlineBotDirVSOutput = vec3(0.0);&quot;,&quot;} else {&quot;,&quot;  // use slerp&quot;,&quot;  centerlineAngleVSOutput = 2.0 * atan(sqrt(diffLen2/sumLen2));&quot;,&quot;  float sinAngle = sin(centerlineAngleVSOutput);&quot;,&quot;  centerlineTopDirVSOutput = centerlineTopDirection / sinAngle;&quot;,&quot;  centerlineBotDirVSOutput = centerlineBotDirection / sinAngle;&quot;,&quot;}&quot;),a=cd.substitute(a,&quot;//VTK::Color::Impl&quot;,c).result;const u=t.volumeTexture.getComponents(),d=o.getProperty().getIndependentComponents();let p=[&quot;uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates&quot;,&quot;in vec2 quadOffsetVSOutput;&quot;,&quot;in vec3 centerlinePosVSOutput;&quot;,&quot;uniform highp sampler3D volumeTexture;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;];l?p.push(&quot;in vec3 centerlineDirVSOutput;&quot;):p.push(&quot;in vec3 centerlineTopDirVSOutput;&quot;,&quot;in vec3 centerlineBotDirVSOutput;&quot;,&quot;in float centerlineAngleVSOutput;&quot;);const f=t.renderable.getCenterPoint();if(f&&p.push(&quot;uniform vec3 globalCenterPoint;&quot;),d){for(let e=1;e<u;e++)p=p.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(u){case 1:p=p.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:p=p.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,p).result;let g=[];if(l?g.push(&quot;vec3 interpolatedCenterlineDir = centerlineDirVSOutput;&quot;):g.push(&quot;vec3 interpolatedCenterlineDir;&quot;,&quot;if (centerlineAngleVSOutput < 0.0) {&quot;,&quot;  // Lerp&quot;,&quot;  interpolatedCenterlineDir = quadOffsetVSOutput.y * centerlineTopDirVSOutput + (1.0 - quadOffsetVSOutput.y) * centerlineBotDirVSOutput;&quot;,&quot;} else {&quot;,&quot;  // Slerp&quot;,&quot;  float topInterpolationAngle = quadOffsetVSOutput.y * centerlineAngleVSOutput;&quot;,&quot;  float botInterpolationAngle = centerlineAngleVSOutput - topInterpolationAngle;&quot;,&quot;  interpolatedCenterlineDir = sin(topInterpolationAngle) * centerlineTopDirVSOutput + sin(botInterpolationAngle) * centerlineBotDirVSOutput;&quot;,&quot;}&quot;,&quot;// Slerp should give a normalized vector but when sin(angle) is small, rounding error occurs&quot;,&quot;// Normalize for both lerp and slerp&quot;,&quot;interpolatedCenterlineDir = normalize(interpolatedCenterlineDir);&quot;),f?g.push(&quot;float baseOffset = dot(interpolatedCenterlineDir, globalCenterPoint - centerlinePosVSOutput);&quot;,&quot;float horizontalOffset = quadOffsetVSOutput.x + baseOffset;&quot;):g.push(&quot;float horizontalOffset = quadOffsetVSOutput.x;&quot;),g.push(&quot;vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * interpolatedCenterlineDir;&quot;,&quot;vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;&quot;,&quot;if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = texture(volumeTexture, volumePosTC);&quot;),d){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<u;++t)g=g.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(u){case 1:g=g.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:g=g.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:mg(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(u){case 1:g=g.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:g=g.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:g=g.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,g).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=cd.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=cd.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=cd.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||mg(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getCABO().getCustomData().forEach((e=>{e&&n.getProgram().isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),e.name,e.offset,n.getCABO().getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&mg(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const a=t.volumeTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;volumeTexture&quot;,a),n.getProgram().setUniformf(&quot;width&quot;,t.renderable.getWidth()),n.getProgram().setUniform4f(&quot;backgroundColor&quot;,...t.renderable.getBackgroundColor()),n.getProgram().isUniformUsed(&quot;centerlineDirection&quot;)){const e=t.renderable.getUniformDirection();n.getProgram().setUniform3fArray(&quot;centerlineDirection&quot;,e)}if(n.getProgram().isUniformUsed(&quot;globalCenterPoint&quot;)){const e=t.renderable.getCenterPoint();n.getProgram().setUniform3fArray(&quot;globalCenterPoint&quot;,e)}const i=t.currentImageDataInput,s=i.getWorldToIndex(),l=P(new Float32Array(16),Rn([],i.getDimensions())),c=oe(l,l,s);if(n.getProgram().setUniformMatrix(&quot;MCTCMatrix&quot;,c),t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}if(n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)}}const yg={currentRenderPass:null,volumeTexture:null,volumeTextureTime:0,colorTexture:null,colorTextureString:null,pwfTexture:null,pwfTextureString:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Tg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yg,n),Zt.extend(e,t,n),kd(e,t,n),jt.algo(e,t,2,0),t.tris=yd.newInstance(),t.volumeTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.pwfTexture=Nd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),vg(e,t)}),&quot;vtkOpenGLImageCPRMapper&quot;);function bg(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageSlice&quot;),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn(&quot;vtkImageCPRMapper&quot;,Tg);const xg={context:null,keyMatrixTime:null,keyMatrices:null};const Cg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,[&quot;context&quot;]),bg(e,t)}),&quot;vtkOpenGLImageSlice&quot;);function Sg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolume&quot;),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn(&quot;vtkImageSlice&quot;,Cg);const Ag={};const Ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ag,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,[&quot;context&quot;]),Sg(e,t)}),&quot;vtkOpenGLVolume&quot;);rn(&quot;vtkVolume&quot;,Ig);const wg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},Pg={FRACTIONAL:0,PROPORTIONAL:1};var Og={InterpolationType:wg,OpacityMode:Pg};const Rg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5};var Mg={BlendMode:Rg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Dg,vtkErrorMacro:Eg}=Kt;function Vg(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return&quot;0&quot;}function Lg(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolumeMapper&quot;),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType(&quot;vtkOpenGLVolume&quot;);const n=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const r=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera()),e.renderPiece(r,n)}},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\n\\nvarying vec3 vertexVCVSOutput;\\nuniform mat4 PCVCMatrix;\\n\\nuniform float dcxmin;\\nuniform float dcxmax;\\nuniform float dcymin;\\nuniform float dcymax;\\n\\nvoid main()\\n{\\n  // dcsmall is the device coords reduced to the\\n  // x y area covered by the volume\\n  vec4 dcsmall = vec4(\\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\\n    vertexDC.z,\\n    vertexDC.w);\\n  vec4 vcpos = PCVCMatrix * dcsmall;\\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\\n  gl_Position = dcsmall;\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkVolumeFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the volume mappers fragment shader\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvarying vec3 vertexVCVSOutput;\\n\\n// first declare the settings from the mapper\\n// that impact the code paths in here\\n\\n// always set vtkNumComponents 1,2,3,4\\n//VTK::NumComponents\\n\\n// possibly define vtkTrilinearOn\\n//VTK::TrilinearOn\\n\\n// possibly define vtkIndependentComponents\\n//VTK::IndependentComponentsOn\\n\\n// possibly define any \\&quot;proportional\\&quot; components\\n//VTK::vtkProportionalComponents\\n\\n// Define the blend mode to use\\n#define vtkBlendMode //VTK::BlendMode\\n\\n// Possibly define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n#ifdef vtkImageLabelOutlineOn\\n\\nuniform float outlineOpacity;\\nuniform float vpWidth;\\nuniform float vpHeight;\\nuniform float vpOffsetX;\\nuniform float vpOffsetY;\\nuniform mat4 PCWCMatrix;\\nuniform mat4 vWCtoIDX;\\n#endif\\n\\n// define vtkLightComplexity\\n//VTK::LightComplexity\\n#if vtkLightComplexity > 0\\nuniform float vSpecularPower;\\nuniform float vAmbient;\\nuniform float vDiffuse;\\nuniform float vSpecular;\\n//VTK::Light::Dec\\n#endif\\n\\n//VTK::VolumeShadowOn\\n//VTK::SurfaceShadowOn\\n//VTK::localAmbientOcclusionOn\\n//VTK::LAO::Dec\\n//VTK::VolumeShadow::Dec\\n\\n// define vtkComputeNormalFromOpacity\\n//VTK::vtkComputeNormalFromOpacity\\n\\n// possibly define vtkGradientOpacityOn\\n//VTK::GradientOpacityOn\\n#ifdef vtkGradientOpacityOn\\nuniform float goscale0;\\nuniform float goshift0;\\nuniform float gomin0;\\nuniform float gomax0;\\n#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\nuniform float goscale1;\\nuniform float goshift1;\\nuniform float gomin1;\\nuniform float gomax1;\\n#if vtkNumComponents >= 3\\nuniform float goscale2;\\nuniform float goshift2;\\nuniform float gomin2;\\nuniform float gomax2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float goscale3;\\nuniform float goshift3;\\nuniform float gomin3;\\nuniform float gomax3;\\n#endif\\n#endif\\n#endif\\n\\n// if you want to see the raw tiled\\n// data in webgl1 uncomment the following line\\n// #define debugtile\\n\\n// camera values\\nuniform float camThick;\\nuniform float camNear;\\nuniform float camFar;\\nuniform int cameraParallel;\\n\\n// values describing the volume geometry\\nuniform vec3 vOriginVC;\\nuniform vec3 vSpacing;\\nuniform ivec3 volumeDimensions; // 3d texture dimensions\\nuniform vec3 vPlaneNormal0;\\nuniform float vPlaneDistance0;\\nuniform vec3 vPlaneNormal1;\\nuniform float vPlaneDistance1;\\nuniform vec3 vPlaneNormal2;\\nuniform float vPlaneDistance2;\\nuniform vec3 vPlaneNormal3;\\nuniform float vPlaneDistance3;\\nuniform vec3 vPlaneNormal4;\\nuniform float vPlaneDistance4;\\nuniform vec3 vPlaneNormal5;\\nuniform float vPlaneDistance5;\\n\\n//VTK::ClipPlane::Dec\\n\\n// opacity and color textures\\nuniform sampler2D otexture;\\nuniform float oshift0;\\nuniform float oscale0;\\nuniform sampler2D ctexture;\\nuniform float cshift0;\\nuniform float cscale0;\\n\\n// jitter texture\\nuniform sampler2D jtexture;\\nuniform sampler2D ttexture;\\n\\n\\n// some 3D texture values\\nuniform float sampleDistance;\\nuniform vec3 vVCToIJK;\\n\\n// the heights defined below are the locations\\n// for the up to four components of the tfuns\\n// the tfuns have a height of 2XnumComps pixels so the\\n// values are computed to hit the middle of the two rows\\n// for that component\\n#ifdef vtkIndependentComponentsOn\\n#if vtkNumComponents == 2\\nuniform float mix0;\\nuniform float mix1;\\n#define height0 0.25\\n#define height1 0.75\\n#endif\\n#if vtkNumComponents == 3\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\n#define height0 0.17\\n#define height1 0.5\\n#define height2 0.83\\n#endif\\n#if vtkNumComponents == 4\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\nuniform float mix3;\\n#define height0 0.125\\n#define height1 0.375\\n#define height2 0.625\\n#define height3 0.875\\n#endif\\n#endif\\n\\n#if vtkNumComponents >= 2\\nuniform float oshift1;\\nuniform float oscale1;\\nuniform float cshift1;\\nuniform float cscale1;\\n#endif\\n#if vtkNumComponents >= 3\\nuniform float oshift2;\\nuniform float oscale2;\\nuniform float cshift2;\\nuniform float cscale2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float oshift3;\\nuniform float oscale3;\\nuniform float cshift3;\\nuniform float cscale3;\\n#endif\\n\\nuniform vec4 ipScalarRangeMin;\\nuniform vec4 ipScalarRangeMax;\\n\\n// declaration for intermixed geometry\\n//VTK::ZBuffer::Dec\\n\\n//=======================================================================\\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\\nvec3 rayDirVC;\\nfloat sampleDistanceISVS;\\nfloat sampleDistanceIS;\\n\\n#define SQRT3    1.7321\\n#define INV4PI   0.0796\\n#define EPSILON  0.001\\n#define PI       3.1415\\n#define PI2      9.8696\\n\\n//=======================================================================\\n// Webgl2 specific version of functions\\n#if __VERSION__ == 300\\n\\nuniform highp sampler3D texture1;\\n\\nvec4 getTextureValue(vec3 pos)\\n{\\n  vec4 tmp = texture(texture1, pos);\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.a = tmp.g;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n  return tmp;\\n}\\n\\n//=======================================================================\\n// WebGL1 specific version of functions\\n#else\\n\\nuniform sampler2D texture1;\\n\\nuniform float texWidth;\\nuniform float texHeight;\\nuniform int xreps;\\nuniform int xstride;\\nuniform int ystride;\\n\\n// if computing trilinear values from multiple z slices\\n#ifdef vtkTrilinearOn\\nvec4 getTextureValue(vec3 ijk)\\n{\\n  float zoff = 1.0/float(volumeDimensions.z);\\n  vec4 val1 = getOneTextureValue(ijk);\\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\\n\\n  float indexZ = float(volumeDimensions)*ijk.z;\\n  float zmix =  indexZ - floor(indexZ);\\n\\n  return mix(val1, val2, zmix);\\n}\\n\\nvec4 getOneTextureValue(vec3 ijk)\\n#else // nearest or fast linear\\nvec4 getTextureValue(vec3 ijk)\\n#endif\\n{\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n#ifdef debugtile\\n  vec2 tpos = vec2(ijk.x, ijk.y);\\n  vec4 tmp = texture2D(texture1, tpos);\\n  tmp.a = 1.0;\\n\\n#else\\n  int z = int(ijk.z * tdims.z);\\n  int yz = z / xreps;\\n  int xz = z - yz*xreps;\\n\\n  int tileWidth = volumeDimensions.x/xstride;\\n  int tileHeight = volumeDimensions.y/ystride;\\n\\n  xz *= tileWidth;\\n  yz *= tileHeight;\\n\\n  float ni = float(xz) + (ijk.x*float(tileWidth));\\n  float nj = float(yz) + (ijk.y*float(tileHeight));\\n\\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\\n\\n  vec4 tmp = texture2D(texture1, tpos);\\n\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.g = tmp.a;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n#endif\\n\\n  return tmp;\\n}\\n\\n// End of Webgl1 specific code\\n//=======================================================================\\n#endif\\n\\n//=======================================================================\\n// transformation between VC and IS space\\n\\n// convert vector position from idx to vc\\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\\nvec3 IStoVC(vec3 posIS){\\n  vec3 posVC = posIS / vVCToIJK;\\n  return posVC.x * vPlaneNormal0 +\\n         posVC.y * vPlaneNormal2 +\\n         posVC.z * vPlaneNormal4 +\\n         vOriginVC;\\n}\\n\\n// convert vector position from vc to idx\\nvec3 VCtoIS(vec3 posVC){\\n  posVC = posVC - vOriginVC;\\n  posVC = vec3(\\n    dot(posVC, vPlaneNormal0),\\n    dot(posVC, vPlaneNormal2),\\n    dot(posVC, vPlaneNormal4));\\n  return posVC * vVCToIJK;\\n}\\n#endif\\n\\n//Rotate vector to view coordinate\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\nvoid rotateToViewCoord(inout vec3 dirIS){\\n  dirIS.xyz =\\n    dirIS.x * vPlaneNormal0 +\\n    dirIS.y * vPlaneNormal2 +\\n    dirIS.z * vPlaneNormal4;\\n}\\n\\n//Rotate vector to idx coordinate\\nvec3 rotateToIDX(vec3 dirVC){\\n  vec3 dirIS;\\n  dirIS.xyz = vec3(\\n    dot(dirVC, vPlaneNormal0),\\n    dot(dirVC, vPlaneNormal2),\\n    dot(dirVC, vPlaneNormal4));\\n  return dirIS;\\n}\\n#endif\\n\\n//=======================================================================\\n// Given a normal compute the gradient opacity factors\\nfloat computeGradientOpacityFactor(\\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\\n{\\n#if defined(vtkGradientOpacityOn)\\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\\n#else\\n  return 1.0;\\n#endif\\n}\\n\\n//=======================================================================\\n// compute the normal and gradient magnitude for a position, uses forward difference\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\n#ifdef vtkClippingPlanesOn\\n  void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\\n  {\\n    vec3 g1VC[3];\\n    for (int i = 0; i < 3; ++i)\\n    {\\n      g1VC[i] = IStoVC(texPos[i]);\\n    }\\n    vec3 posVC = IStoVC(pos);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      for (int j = 0; j < 3; ++j)\\n      {\\n        if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\\n        {\\n          g1[j] = 0.0;\\n        }\\n      }\\n    }\\n  }\\n#endif\\n\\n  #ifdef vtkComputeNormalFromOpacity\\n    #ifdef vtkGradientOpacityOn\\n      vec4 computeDensityNormal(float gradientMag, vec3 scalarInterp[2])\\n      {\\n    #else\\n      //if gradient opacity not on but using density gradient\\n      vec4 computeDensityNormal(vec3 scalarInterp[2])\\n      {\\n    #endif\\n        vec3 opacityG1, opacityG2;\\n        opacityG1.x = texture2D(otexture, vec2(scalarInterp[0].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.y = texture2D(otexture, vec2(scalarInterp[0].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG1.z = texture2D(otexture, vec2(scalarInterp[0].z * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.x = texture2D(otexture, vec2(scalarInterp[1].x * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.y = texture2D(otexture, vec2(scalarInterp[1].y * oscale0 + oshift0, 0.5)).r;\\n        opacityG2.z = texture2D(otexture, vec2(scalarInterp[1].z * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n        float gradOpacityFactor = 1.0f;\\n        if (gradientMag >= 0.0){\\n          gradOpacityFactor = computeGradientOpacityFactor(gradientMag, goscale0, goshift0, gomin0, gomax0);\\n        }\\n        opacityG1.xyz *= gradOpacityFactor;\\n        opacityG2.xyz *= gradOpacityFactor;\\n    #endif\\n\\n        vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\\n        // divide by spacing\\n        opacityG.xyz /= vSpacing;\\n        opacityG.w = length(opacityG.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(opacityG.xyz);\\n        if (length(opacityG.xyz) > 0.0) {\\n          return vec4(normalize(opacityG.xyz),opacityG.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n\\n      vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2])\\n      {\\n        vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n        vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n        vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n        vec3 texPosPVec[3];\\n        texPosPVec[0] = pos + xvec;\\n        texPosPVec[1] = pos + yvec;\\n        texPosPVec[2] = pos + zvec;\\n        vec3 texPosNVec[3];\\n        texPosNVec[0] = pos - xvec;\\n        texPosNVec[1] = pos - yvec;\\n        texPosNVec[2] = pos - zvec;\\n        vec3 g1, g2;\\n\\n        scalarInterp[0].x = getTextureValue(texPosPVec[0]).a;\\n        scalarInterp[0].y = getTextureValue(texPosPVec[1]).a;\\n        scalarInterp[0].z = getTextureValue(texPosPVec[2]).a;\\n        scalarInterp[1].x = getTextureValue(texPosNVec[0]).a;\\n        scalarInterp[1].y = getTextureValue(texPosNVec[1]).a;\\n        scalarInterp[1].z = getTextureValue(texPosNVec[2]).a;\\n\\n        #ifdef vtkClippingPlanesOn\\n          adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\\n          adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\\n        #endif\\n        vec4 result;\\n        result.x = scalarInterp[0].x - scalarInterp[1].x;\\n        result.y = scalarInterp[0].y - scalarInterp[1].y;\\n        result.z = scalarInterp[0].z - scalarInterp[1].z;\\n        // divide by spacing\\n        result.xyz /= vSpacing;\\n        result.w = length(result.xyz);\\n        // rotate to View Coords\\n        rotateToViewCoord(result.xyz);\\n        if (length(result.xyz) > 0.0) {\\n          return vec4(normalize(result.xyz),result.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n  #endif\\n\\n  vec4 computeNormal(vec3 pos, vec3 tstep)\\n  {\\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\\n    vec3 texPosPVec[3];\\n    texPosPVec[0] = pos + xvec;\\n    texPosPVec[1] = pos + yvec;\\n    texPosPVec[2] = pos + zvec;\\n    vec3 texPosNVec[3];\\n    texPosNVec[0] = pos - xvec;\\n    texPosNVec[1] = pos - yvec;\\n    texPosNVec[2] = pos - zvec;\\n    vec3 g1, g2;\\n    g1.x = getTextureValue(texPosPVec[0]).a;\\n    g1.y = getTextureValue(texPosPVec[1]).a;\\n    g1.z = getTextureValue(texPosPVec[2]).a;\\n    g2.x = getTextureValue(texPosNVec[0]).a;\\n    g2.y = getTextureValue(texPosNVec[1]).a;\\n    g2.z = getTextureValue(texPosNVec[2]).a;\\n    #ifdef vtkClippingPlanesOn\\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\\n    #endif\\n    vec4 result;\\n    result = vec4(g1 - g2, -1.0);\\n    // divide by spacing\\n    result.xyz /= vSpacing;\\n    result.w = length(result.xyz);\\n    if (result.w > 0.0){\\n      // rotate to View Coords\\n      rotateToViewCoord(result.xyz);\\n      return vec4(normalize(result.xyz),result.w);\\n    } else {\\n      return vec4(0.0);\\n    }\\n  }\\n#endif\\n\\n#ifdef vtkImageLabelOutlineOn\\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\\n  vec4 pcPos = vec4(\\n    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\\n    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\\n    (fragCoord.z - 0.5) * 2.0,\\n    1.0);\\n\\n  vec4 worldCoord = PCWCMatrix * pcPos;\\n  vec4 vertex = (worldCoord/worldCoord.w);\\n\\n  vec3 index = (vWCtoIDX * vertex).xyz;\\n\\n  // half voxel fix for labelmapOutline\\n  return (index + vec3(0.5)) / vec3(volumeDimensions);\\n}\\n#endif\\n\\n//=======================================================================\\n// compute the normals and gradient magnitudes for a position\\n// for independent components\\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\\n{\\n  mat4 result;\\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\\n\\n  // divide by spacing\\n  distX /= vSpacing.x;\\n  distY /= vSpacing.y;\\n  distZ /= vSpacing.z;\\n\\n  mat3 rot;\\n  rot[0] = vPlaneNormal0;\\n  rot[1] = vPlaneNormal2;\\n  rot[2] = vPlaneNormal4;\\n\\n#if !defined(vtkComponent0Proportional)\\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\\n  result[0].a = length(result[0].xyz);\\n  result[0].xyz *= rot;\\n  if (result[0].w > 0.0)\\n  {\\n    result[0].xyz /= result[0].w;\\n  }\\n#endif\\n\\n// optionally compute the 2nd component\\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\\n  result[1].a = length(result[1].xyz);\\n  result[1].xyz *= rot;\\n  if (result[1].w > 0.0)\\n  {\\n    result[1].xyz /= result[1].w;\\n  }\\n#endif\\n\\n// optionally compute the 3rd component\\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\\n  result[2].a = length(result[2].xyz);\\n  result[2].xyz *= rot;\\n  if (result[2].w > 0.0)\\n  {\\n    result[2].xyz /= result[2].w;\\n  }\\n#endif\\n\\n// optionally compute the 4th component\\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\\n  result[3].a = length(result[3].xyz);\\n  result[3].xyz *= rot;\\n  if (result[3].w > 0.0)\\n  {\\n    result[3].xyz /= result[3].w;\\n  }\\n#endif\\n\\n  return result;\\n}\\n\\n//=======================================================================\\n// global shadow - secondary ray\\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\\nfloat random()\\n{\\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\\n  uint pcg_state = floatBitsToUint(jitter);\\n  uint state = pcg_state;\\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\\n}\\n#endif\\n\\n#ifdef VolumeShadowOn\\n// henyey greenstein phase function\\nfloat phase_function(float cos_angle)\\n{\\n  // divide by 2.0 instead of 4pi to increase intensity\\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\\n}\\n\\n// Computes the intersection between a ray and a box\\nstruct Hit\\n{\\n  float tmin;\\n  float tmax;\\n};\\n\\nstruct Ray\\n{\\n  vec3 origin;\\n  vec3 dir;\\n  vec3 invDir;\\n};\\n\\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\\n{\\n  vec3 tbot = r.invDir * (boundMin - r.origin);\\n  vec3 ttop = r.invDir * (boundMax - r.origin);\\n  vec3 tmin = min(ttop, tbot);\\n  vec3 tmax = max(ttop, tbot);\\n  vec2 t = max(tmin.xx, tmin.yz);\\n  float t0 = max(t.x, t.y);\\n  t = min(tmax.xx, tmax.yz);\\n  float t1 = min(t.x, t.y);\\n  hit.tmin = t0;\\n  hit.tmax = t1;\\n  return t1 > max(t0,0.0);\\n}\\n\\n// As BBoxIntersect requires the inverse of the ray coords,\\n// this function is used to avoid numerical issues\\nvoid safe_0_vector(inout Ray ray)\\n{\\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\\n}\\n\\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\\n{\\n  float shadow = 1.0;\\n  float opacity = 0.0;\\n\\n  // modify sample distance with a random number between 1.5 and 3.0\\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\\n\\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\\n\\n  // compute the start and end points for the ray\\n  Ray ray;\\n  Hit hit;\\n  ray.origin = posIS;\\n  ray.dir = lightDirNormIS;\\n  safe_0_vector(ray);\\n  ray.invDir = 1.0/ray.dir;\\n\\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\\n  {\\n    return 1.0;\\n  }\\n  float maxdist = hit.tmax;\\n\\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\\n  maxdist = min(maxdist,maxgi);\\n  if(maxdist < EPSILON) {\\n    return 1.0;\\n  }\\n\\n  // support gradient opacity\\n  #ifdef vtkGradientOpacityOn\\n    vec4 normal;\\n  #endif\\n\\n  float current_dist = 0.0;\\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\\n  float clamped_step = 0.0;\\n\\n  vec4 scalar = vec4(0.0);\\n  while(current_dist < maxdist)\\n  {\\n#ifdef vtkClippingPlanesOn\\n    vec3 posVC = IStoVC(posIS);\\n    for (int i = 0; i < clip_numPlanes; ++i)\\n    {\\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\\n      {\\n        current_dist = maxdist;\\n      }\\n    }\\n#endif\\n    scalar = getTextureValue(posIS);\\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn\\n      normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    shadow *= 1.0 - opacity;\\n\\n    // optimization: early termination\\n    if (shadow < EPSILON){\\n      return 0.0;\\n    }\\n\\n    clamped_step = min(maxdist - current_dist, current_step);\\n    posIS += clamped_step * lightDirNormIS;\\n    current_dist += current_step;\\n  }\\n\\n  return shadow;\\n}\\n\\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\\n{\\n  vec3 vertLight = vec3(0.0);\\n  vec3 secondary_contrib = vec3(0.0);\\n  // here we assume only positional light, no effect of cones\\n  for (int i = 0; i < lightNum; i++)\\n  {\\n    #if(vtkLightComplexity==3)\\n      if (lightPositional[i] == 1){\\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\\n      }else{\\n        vertLight = - lightDirectionVC[i];\\n      }\\n    #else\\n      vertLight = - lightDirectionVC[i];\\n    #endif\\n    // here we assume achromatic light, only intensity\\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\\n    float phase_attenuation = 0.5;\\n    if (abs(anisotropy) > EPSILON){\\n      phase_attenuation = phase_function(dDotL);\\n    }\\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\\n    secondary_contrib += tColor * vAmbient;\\n  }\\n  return secondary_contrib;\\n}\\n#endif\\n\\n//=======================================================================\\n// local ambient occlusion\\n#ifdef localAmbientOcclusionOn\\nvec3 sample_direction_uniform(int i)\\n{\\n  float rand = random() * 0.5;\\n  float theta = PI2 * (kernelSample[i][0] + rand);\\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\\n}\\n\\n// return a matrix that transform startDir into z axis; startDir should be normalized\\nmat3 zBaseRotationalMatrix(vec3 startDir){\\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\\n  float cosA = startDir.z;\\n  float k = 1.0 / (1.0 + cosA);\\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\\n  return matrix;\\n}\\n\\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\\n  // apply LAO only at selected locations, otherwise return full brightness\\n  if (normal.w > 0.0 && op > 0.05){\\n    float total_transmittance = 0.0;\\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\\n    vec3 currPos, randomDirStep;\\n    float weight, transmittance, opacity;\\n    for (int i = 0; i < kernelSize; i++)\\n    {\\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\\n      currPos = posIS;\\n      transmittance = 1.0;\\n      for (int j = 0; j < kernelRadius ; j++){\\n        currPos += randomDirStep;\\n        // check if it's at clipping plane, if so return full brightness\\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\\n          #ifdef vtkGradientOpacityOn\\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n          #endif\\n          transmittance *= 1.0 - opacity;\\n        }\\n        else{\\n          break;\\n        }\\n      }\\n      total_transmittance += transmittance / float(kernelRadius) * weight;\\n\\n      // early termination if fully translucent\\n      if (total_transmittance > 1.0 - EPSILON){\\n        return 1.0;\\n      }\\n    }\\n    // average transmittance and reduce variance\\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\\n  } else {\\n    return 1.0;\\n  }\\n}\\n#endif\\n\\n//=======================================================================\\n// surface light contribution\\n#if vtkLightComplexity > 0\\n  void applyLighting(inout vec3 tColor, vec4 normal)\\n  {\\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\\n    vec3 specular = vec3(0.0, 0.0, 0.0);\\n    float df, sf = 0.0;\\n    for (int i = 0; i < lightNum; i++){\\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\\n        diffuse += df * lightColor[i];\\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\\n        specular += sf * lightColor[i];\\n    }\\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\\n  }\\n  #ifdef SurfaceShadowOn\\n  #if vtkLightComplexity < 3\\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float ndotL,vdotR;\\n        vertLightDirection = lightDirectionVC[i];\\n        ndotL = dot(normal.xyz, vertLightDirection);\\n        if (ndotL < 0.0 && twoSidedLighting)\\n        {\\n          ndotL = -ndotL;\\n        }\\n        if (ndotL > 0.0)\\n        {\\n          diffuse += ndotL * lightColor[i];\\n          //specular\\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n          if (vdotR > 0.0)\\n          {\\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n          }\\n        }\\n        #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n        #endif\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #else\\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif\\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float distance,attenuation,ndotL,vdotR;\\n        vec3 lightDir;\\n        if (lightPositional[i] == 1){\\n          lightDir = lightDirectionVC[i];\\n          vertLightDirection = posVC - lightPositionVC[i];\\n          distance = length(vertLightDirection);\\n          vertLightDirection = normalize(vertLightDirection);\\n          attenuation = 1.0 / (lightAttenuation[i].x\\n                              + lightAttenuation[i].y * distance\\n                              + lightAttenuation[i].z * distance * distance);\\n          // per OpenGL standard cone angle is 90 or less for a spot light\\n          if (lightConeAngle[i] <= 90.0){\\n            float coneDot = dot(vertLightDirection, lightDir);\\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\\n            }\\n            else {\\n              attenuation = 0.0;\\n            }\\n          }\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * attenuation * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        } else {\\n          vertLightDirection = lightDirectionVC[i];\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif\\n        }\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #endif\\n  #endif\\n#endif\\n\\n//=======================================================================\\n// Given a texture value compute the color and opacity\\n//\\nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\\n{\\n#ifdef vtkImageLabelOutlineOn\\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\\n  vec4 centerValue = getTextureValue(centerPosIS);\\n  bool pixelOnBorder = false;\\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\\n\\n  // Get alpha of segment from opacity function.\\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n  int segmentIndex = int(centerValue.r * 255.0);\\n  \\n  // Use texture sampling for outlineThickness\\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\\n\\n  int actualThickness = int(textureValue * 255.0);\\n\\n  if (actualThickness == 0) {\\n    return vec4(0, 0, 1, 1);\\n  }\\n\\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\\n  // Saves a bunch of needless checks on the background.\\n  // TODO define epsilon when building shader?\\n  if (float(tColor.a) > 0.01) {\\n    for (int i = -actualThickness; i <= actualThickness; i++) {\\n      for (int j = -actualThickness; j <= actualThickness; j++) {\\n        if (i == 0 || j == 0) {\\n          continue;\\n        }\\n\\n        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n          gl_FragCoord.y + float(j),\\n          gl_FragCoord.z, gl_FragCoord.w);\\n\\n        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n        vec4 value = getTextureValue(neighborPosIS);\\n\\n        // If any of my neighbours are not the same value as I\\n        // am, this means I am on the border of the segment.\\n        // We can break the loops\\n        if (any(notEqual(value, centerValue))) {\\n          pixelOnBorder = true;\\n          break;\\n        }\\n      }\\n\\n      if (pixelOnBorder == true) {\\n        break;\\n      }\\n    }\\n\\n    // If I am on the border, I am displayed at full opacity\\n    if (pixelOnBorder == true) {\\n      tColor.a = outlineOpacity;\\n    }\\n  }\\n\\n#else\\n  // compute the normal and gradient magnitude if needed\\n  // We compute it as a vec4 if possible otherwise a mat4\\n  //\\n  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);\\n\\n  // compute the normal vectors as needed\\n  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\\n      #if !defined(vtkComponent0Proportional)\\n        vec4 normal0 = normalMat[0];\\n      #endif\\n      #if !defined(vtkComponent1Proportional)\\n        vec4 normal1 = normalMat[1];\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          vec4 normal2 = normalMat[2];\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            vec4 normal3 = normalMat[3];\\n          #endif\\n        #endif\\n      #endif\\n    #else\\n      vec4 normalLight;\\n      #ifdef vtkComputeNormalFromOpacity\\n        vec3 scalarInterp[2];\\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp);\\n        if (length(normal0)>0.0){\\n          #ifdef vtkGradientOpacityOn\\n            normalLight = computeDensityNormal(normal0.w, scalarInterp);\\n          #else\\n            normalLight = computeDensityNormal(scalarInterp);\\n          #endif\\n          if (length(normalLight) == 0.0){\\n            normalLight = normal0;\\n          }\\n        }\\n      #else\\n        vec4 normal0 = computeNormal(posIS, tstep);\\n        normalLight = normal0;\\n      #endif\\n    #endif\\n  #endif\\n\\n  // compute gradient opacity factors as needed\\n  #if defined(vtkGradientOpacityOn)\\n    #if !defined(vtkComponent0Proportional)\\n      goFactor.x =\\n        computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      #if !defined(vtkComponent1Proportional)\\n        goFactor.y =\\n          computeGradientOpacityFactor(normal1.a, goscale1, goshift1, gomin1, gomax1);\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          goFactor.z =\\n            computeGradientOpacityFactor(normal2.a, goscale2, goshift2, gomin2, gomax2);\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            goFactor.w =\\n              computeGradientOpacityFactor(normal3.a, goscale3, goshift3, gomin3, gomax3);\\n          #endif\\n        #endif\\n      #endif\\n    #endif\\n  #endif\\n\\n  // single component is always independent\\n  #if vtkNumComponents == 1\\n    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n    if (tColor.a < EPSILON){\\n      return vec4(0.0);\\n    }\\n  #endif\\n\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));\\n    #if !defined(vtkComponent0Proportional)\\n      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n      tColor *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));\\n    #endif\\n\\n    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\\n    #if !defined(vtkComponent1Proportional)\\n      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n      tColor1 *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));\\n    #endif\\n\\n    #if vtkNumComponents >= 3\\n      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\\n      #if !defined(vtkComponent2Proportional)\\n        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n      #else\\n        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n        tColor2 *= pwfValue;\\n        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));\\n      #endif\\n\\n      #if vtkNumComponents >= 4\\n        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\\n        #if !defined(vtkComponent3Proportional)\\n          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n        #else\\n          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n          tColor3 *= pwfValue;\\n          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));\\n        #endif\\n      #endif\\n    #endif\\n  #else // then not independent\\n\\n  #if vtkNumComponents == 2\\n    float lum = tValue.r * cscale0 + cshift0;\\n    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\\n    vec4 tColor = vec4(lum, lum, lum, alpha);\\n  #endif\\n  #if vtkNumComponents == 3\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\\n  #endif\\n  #if vtkNumComponents == 4\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\\n  #endif\\n  #endif // dependent\\n\\n  // apply lighting if requested as appropriate\\n  #if vtkLightComplexity > 0\\n    #if !defined(vtkComponent0Proportional)\\n      #if vtkNumComponents == 1\\n        #ifdef SurfaceShadowOn\\n            #if vtkLightComplexity < 3\\n                vec3 tColorS = applyLightingDirectional(posIS, tColor, normalLight);\\n            #else\\n                vec3 tColorS = applyLightingPositional(posIS, tColor, normalLight, IStoVC(posIS));\\n            #endif\\n        #endif\\n\\n        #ifdef VolumeShadowOn\\n          vec3 tColorVS = applyShadowRay(tColor.rgb, posIS, rayDirVC);\\n          #ifdef SurfaceShadowOn\\n            float vol_coef = volumetricScatteringBlending * (1.0 - tColor.a / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\\n            tColor.rgb = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\\n          #else\\n            tColor.rgb = tColorVS;\\n          #endif\\n        #else\\n            tColor.rgb = tColorS;\\n        #endif\\n\\n      #else\\n        applyLighting(tColor.rgb, normal0);\\n      #endif\\n    #endif\\n\\n    #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n      #if !defined(vtkComponent1Proportional)\\n        applyLighting(tColor1, normal1);\\n      #endif\\n    #if vtkNumComponents >= 3\\n      #if !defined(vtkComponent2Proportional)\\n        applyLighting(tColor2, normal2);\\n      #endif\\n    #if vtkNumComponents >= 4\\n      #if !defined(vtkComponent3Proportional)\\n        applyLighting(tColor3, normal3);\\n      #endif\\n    #endif\\n    #endif\\n    #endif\\n  #endif\\n\\n// perform final independent blend as needed\\n#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n  tColor.rgb += tColor1;\\n#if vtkNumComponents >= 3\\n  tColor.rgb += tColor2;\\n#if vtkNumComponents >= 4\\n  tColor.rgb += tColor3;\\n#endif\\n#endif\\n#endif\\n\\n#endif\\nreturn tColor;\\n}\\n\\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\\n  bool withinRange = false;\\n  #if vtkNumComponents == 1\\n    if (val.r >= min.r && val.r <= max.r) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2\\n     if (val.r >= min.r && val.r <= max.r &&\\n        val.g >= min.g && val.g <= max.g) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3\\n    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\\n        all(lessThanEqual(val, ipScalarRangeMax))) {\\n      withinRange = true;\\n    }\\n  #endif\\n  return withinRange;\\n}\\n\\n//=======================================================================\\n// Apply the specified blend mode operation along the ray's path.\\n//\\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\\n{\\n  vec3 tstep = 1.0/tdims;\\n\\n  // start slightly inside and apply some jitter\\n  vec3 delta = endIS - posIS;\\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\\n  float raySteps = length(delta)/sampleDistanceIS;\\n\\n  // avoid 0.0 jitter\\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\\n  float stepsTraveled = jitter;\\n\\n  // local vars for the loop\\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\\n  vec4 tValue;\\n  vec4 tColor;\\n\\n  // if we have less than one step then pick the middle point\\n  // as our value\\n  // if (raySteps <= 1.0)\\n  // {\\n  //   posIS = (posIS + endIS)*0.5;\\n  // }\\n\\n  // Perform initial step at the volume boundary\\n  // compute the scalar\\n  tValue = getTextureValue(posIS);\\n\\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\\n    // now map through opacity and color\\n    tColor = getColorForValue(tValue, posIS, tstep);\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\\n      gl_FragData[0] = tColor;\\n      return;\\n    }\\n\\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n\\n      float mix = (1.0 - color.a);\\n\\n      // this line should not be needed but nvidia seems to not handle\\n      // the break correctly on windows/chrome 58 angle\\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\\n\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n      stepsTraveled++;\\n      posIS += stepIS;\\n      if (color.a > 0.99) { color.a = 1.0; break; }\\n    }\\n\\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\\n    {\\n      posIS = endIS;\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\\n\\n      float mix = (1.0 - color.a);\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n    }\\n\\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\\n  #endif\\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\\n    // Find maximum/minimum intensity along the ray.\\n\\n    // Define the operation we will use (min or max)\\n    #if vtkBlendMode == 1\\n    #define OP max\\n    #else\\n    #define OP min\\n    #endif\\n\\n    // If the clipping range is shorter than the sample distance\\n    // we can skip the sampling loop along the ray.\\n    if (raySteps <= 1.0)\\n    {\\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\\n      return;\\n    }\\n\\n    vec4 value = tValue;\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // Update the maximum value if necessary\\n      value = OP(tValue, value);\\n\\n      // Otherwise, continue along the ray\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n    tValue = getTextureValue(posIS);\\n    value = OP(tValue, value);\\n\\n    // Now map through opacity and color\\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\\n    vec4 sum = vec4(0.);\\n\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n    }\\n\\n    if (raySteps <= 1.0) {\\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\\n      // Notes:\\n      // - We are comparing all values in the texture to see if any of them\\n      //   are outside of the scalar range. In the future we might want to allow\\n      //   scalar ranges for each component.\\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n        // Sum the values across each step in the path\\n        sum += tValue;\\n      }\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n\\n    // compute the scalar\\n    tValue = getTextureValue(posIS);\\n\\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n\\n      stepsTraveled++;\\n    }\\n\\n    #if vtkBlendMode == 3 // Average\\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\\n    #endif\\n\\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 5 // RADON\\n    float normalizedRayIntensity = 1.0;\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tValue = getTextureValue(posIS);\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar value\\n      tValue = getTextureValue(posIS);\\n\\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n      posIS += stepIS;\\n      stepsTraveled++;\\n    }\\n\\n    // map normalizedRayIntensity to color\\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\\n\\n  #endif\\n}\\n\\n//=======================================================================\\n// Compute a new start and end point for a given ray based\\n// on the provided bounded clipping plane (aka a rectangle)\\nvoid getRayPointIntersectionBounds(\\n  vec3 rayPos, vec3 rayDir,\\n  vec3 planeDir, float planeDist,\\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\\n  float vSize1, float vSize2)\\n{\\n  float result = dot(rayDir, planeDir);\\n  if (abs(result) < 1e-6)\\n  {\\n    return;\\n  }\\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\\n  vec3 xposVC = rayPos + rayDir*result;\\n  vec3 vxpos = xposVC - vOriginVC;\\n  vec2 vpos = vec2(\\n    dot(vxpos, vPlaneX),\\n    dot(vxpos, vPlaneY));\\n\\n  // on some apple nvidia systems this does not work\\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\\n  //     vpos.y < 0.0 || vpos.y > vSize2)\\n  // even just\\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\\n  // fails\\n  // so instead we compute a value that represents in and out\\n  //and then compute the return using this value\\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\\n\\n  tbounds = mix(\\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\\n   tbounds, // out value\\n   check);  // 0 in 1 out\\n}\\n\\n//=======================================================================\\n// given a\\n// - ray direction (rayDir)\\n// - starting point (vertexVCVSOutput)\\n// - bounding planes of the volume\\n// - optionally depth buffer values\\n// - far clipping plane\\n// compute the start/end distances of the ray we need to cast\\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\\n{\\n  vec2 dists = vec2(100.0*camFar, -1.0);\\n\\n  vec3 vSize = vSpacing*tdims;\\n\\n  // all this is in View Coordinates\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n\\n  //VTK::ClipPlane::Impl\\n\\n  // do not go behind front clipping plane\\n  dists.x = max(0.0,dists.x);\\n\\n  // do not go PAST far clipping plane\\n  float farDist = -camThick/rayDir.z;\\n  dists.y = min(farDist,dists.y);\\n\\n  // Do not go past the zbuffer value if set\\n  // This is used for intermixing opaque geometry\\n  //VTK::ZBuffer::Impl\\n\\n  return dists;\\n}\\n\\n//=======================================================================\\n// Compute the index space starting position (pos) and end\\n// position\\n//\\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\\n{\\n  // compute starting and ending values in volume space\\n  pos = vertexVCVSOutput + dists.x*rayDir;\\n  pos = pos - vOriginVC;\\n  // convert to volume basis and origin\\n  pos = vec3(\\n    dot(pos, vPlaneNormal0),\\n    dot(pos, vPlaneNormal2),\\n    dot(pos, vPlaneNormal4));\\n\\n  endPos = vertexVCVSOutput + dists.y*rayDir;\\n  endPos = endPos - vOriginVC;\\n  endPos = vec3(\\n    dot(endPos, vPlaneNormal0),\\n    dot(endPos, vPlaneNormal2),\\n    dot(endPos, vPlaneNormal4));\\n\\n  float delta = length(endPos - pos);\\n\\n  pos *= vVCToIJK;\\n  endPos *= vVCToIJK;\\n\\n  float delta2 = length(endPos - pos);\\n  sampleDistanceIS = sampleDistance*delta2/delta;\\n  #ifdef VolumeShadowOn\\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\\n  #endif\\n}\\n\\nvoid main()\\n{\\n\\n  if (cameraParallel == 1)\\n  {\\n    // Camera is parallel, so the rayDir is just the direction of the camera.\\n    rayDirVC = vec3(0.0, 0.0, -1.0);\\n  } else {\\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\\n    rayDirVC = normalize(vertexVCVSOutput);\\n  }\\n\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n  // compute the start and end points for the ray\\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\\n\\n  // do we need to composite? aka does the ray have any length\\n  // If not, bail out early\\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\\n  {\\n    discard;\\n  }\\n\\n  // IS = Index Space\\n  vec3 posIS;\\n  vec3 endIS;\\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\\n\\n  // Perform the blending operation along the ray\\n  applyBlend(posIS, endIS, tdims);\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Fragment;o.getProperty().getInterpolationType()===wg.LINEAR&&(a=cd.substitute(a,&quot;//VTK::TrilinearOn&quot;,&quot;#define vtkTrilinearOn&quot;).result),!0===o.getProperty().getUseLabelOutline()&&(a=cd.substitute(a,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result);const i=t.scalarTexture.getComponents();a=cd.substitute(a,&quot;//VTK::NumComponents&quot;,`#define vtkNumComponents ${i}`).result;const s=o.getProperty().getIndependentComponents();if(s){a=cd.substitute(a,&quot;//VTK::IndependentComponentsOn&quot;,&quot;#define vtkIndependentComponentsOn&quot;).result;const e=[];for(let t=0;t<i;t++)o.getProperty().getOpacityMode(t)===Pg.PROPORTIONAL&&e.push(`#define vtkComponent${t}Proportional`);e.length>0&&(a=cd.substitute(a,&quot;//VTK::vtkProportionalComponents&quot;,e.join(&quot;\\n&quot;)).result)}const l=t.currentInput.getSpatialExtent(),c=t.currentInput.getSpacing(),u=new Float64Array(3);In(u,(l[1]-l[0])*c[0],(l[3]-l[2])*c[1],(l[5]-l[4])*c[2]);const d=Sn(u)/e.getCurrentSampleDistance(r);a=cd.substitute(a,&quot;//VTK::MaximumSamplesValue&quot;,`${Math.ceil(d)}`).result,a=cd.substitute(a,&quot;//VTK::LightComplexity&quot;,`#define vtkLightComplexity ${t.lastLightComplexity}`).result,t.lastLightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(a=cd.substitute(a,&quot;//VTK::VolumeShadowOn&quot;,&quot;#define VolumeShadowOn&quot;).result),t.renderable.getVolumetricScatteringBlending()<1&&(a=cd.substitute(a,&quot;//VTK::SurfaceShadowOn&quot;,&quot;#define SurfaceShadowOn&quot;).result),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0&&(a=cd.substitute(a,&quot;//VTK::localAmbientOcclusionOn&quot;,&quot;#define localAmbientOcclusionOn&quot;).result)),t.gopacity=o.getProperty().getUseGradientOpacity(0);for(let e=1;s&&!t.gopacity&&e<i;++e)o.getProperty().getUseGradientOpacity(e)&&(t.gopacity=!0);t.gopacity&&(a=cd.substitute(a,&quot;//VTK::GradientOpacityOn&quot;,&quot;#define vtkGradientOpacityOn&quot;).result),t.renderable.getComputeNormalFromOpacity()&&(a=cd.substitute(a,&quot;//VTK::vtkComputeNormalFromOpacity&quot;,&quot;#define vtkComputeNormalFromOpacity&quot;).result),null!==t.zBufferTexture&&(a=cd.substitute(a,&quot;//VTK::ZBuffer::Dec&quot;,[&quot;uniform sampler2D zBufferTexture;&quot;,&quot;uniform float vpZWidth;&quot;,&quot;uniform float vpZHeight;&quot;]).result,a=cd.substitute(a,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));&quot;,&quot;float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;&quot;,&quot;zdepth = zdepth * 2.0 - 1.0;&quot;,&quot;if (cameraParallel == 0) {&quot;,&quot;zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}&quot;,&quot;else {&quot;,&quot;zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\\n&quot;,&quot;zdepth = -zdepth/rayDir.z;&quot;,&quot;dists.y = min(zdepth,dists.y);&quot;]).result),a=cd.substitute(a,&quot;//VTK::BlendMode&quot;,`${t.renderable.getBlendMode()}`).result,n.Fragment=a,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lastLightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[&quot;uniform int lightNum;&quot;,&quot;uniform bool twoSidedLighting;&quot;,`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,&quot;//VTK::Light::Dec&quot;],!1).result,3===t.lastLightComplexity&&(o=cd.substitute(o,&quot;//VTK::Light::Dec&quot;,[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=cd.substitute(o,&quot;//VTK::VolumeShadow::Dec&quot;,[&quot;uniform float volumetricScatteringBlending;&quot;,&quot;uniform float giReach;&quot;,&quot;uniform float volumeShadowSamplingDistFactor;&quot;,&quot;uniform float anisotropy;&quot;,&quot;uniform float anisotropy2;&quot;],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=cd.substitute(o,&quot;//VTK::LAO::Dec&quot;,[&quot;uniform int kernelRadius;&quot;,`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,&quot;uniform int kernelSize;&quot;],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=cd.substitute(o,&quot;//VTK::ClipPlane::Dec&quot;,[&quot;uniform vec3 vClipPlaneNormals[6];&quot;,&quot;uniform float vClipPlaneDistances[6];&quot;,&quot;uniform vec3 vClipPlaneOrigins[6];&quot;,&quot;uniform int clip_numPlanes;&quot;,&quot;//VTK::ClipPlane::Dec&quot;,&quot;#define vtkClippingPlanesOn&quot;],!1).result,o=cd.substitute(o,&quot;//VTK::ClipPlane::Impl&quot;,[`for(int i = 0; i < ${e}; i++) {`,&quot;  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);&quot;,&quot;  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];&quot;,&quot;  if (rayDirRatio == 0.0)&quot;,&quot;  {&quot;,&quot;    if (equationResult < 0.0) dists.x = dists.y;&quot;,&quot;    continue;&quot;,&quot;  }&quot;,&quot;  float result = -1.0 * equationResult / rayDirRatio;&quot;,&quot;  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);&quot;,&quot;  else dists.x = max(dists.x, result);&quot;,&quot;}&quot;,&quot;//VTK::ClipPlane::Impl&quot;],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{let a=0;o.getProperty().getShade()&&t.renderable.getBlendMode()===Rg.COMPOSITE_BLEND&&(a=0,t.numberOfLights=0,r.getLights().forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===a&&(a=1)),1===a&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(a=2),a<3&&e.getPositional()&&(a=3)})));let i=!1;t.lastLightComplexity!==a&&(t.lastLightComplexity=a,i=!0);const s=t.scalarTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=!1;const u=[];if(l){for(let e=0;e<s;e++)u.push(o.getProperty().getOpacityMode(e));u.length>0&&(c=!0)}const d=t.currentInput.getSpatialExtent(),p=t.currentInput.getSpacing(),f=new Float64Array(3);In(f,(d[1]-d[0])*p[0],(d[3]-d[2])*p[1],(d[5]-d[4])*p[2]);const g=Sn(f)/e.getCurrentSampleDistance(r),m={interpolationType:o.getProperty().getInterpolationType(),useLabelOutline:o.getProperty().getUseLabelOutline(),numComp:s,usesProportionalComponents:c,iComps:l,maxSamples:g,useGradientOpacity:o.getProperty().getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),proportionalComponents:u};return t.previousState&&t.previousState.interpolationType===m.interpolationType&&t.previousState.useLabelOutline===m.useLabelOutline&&t.previousState.numComp===m.numComp&&t.previousState.usesProportionalComponents===m.usesProportionalComponents&&t.previousState.iComps===m.iComps&&t.previousState.maxSamples===m.maxSamples&&t.previousState.useGradientOpacity===m.useGradientOpacity&&t.previousState.blendMode===m.blendMode&&function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(t.previousState.proportionalComponents,m.proportionalComponents)?!!(0===n.getProgram()?.getHandle()||i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||!!t.lastZBufferTexture!=!!t.zBufferTexture||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime())&&(t.lastZBufferTexture=t.zBufferTexture,!0):(t.previousState={...m},!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed(&quot;vertexDC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexDC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified()),a.setUniformi(&quot;texture1&quot;,t.scalarTexture.getTextureUnit()),a.setUniformf(&quot;sampleDistance&quot;,e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange(),l=[],c=[];for(let e=0;e<4;e++)l[e]=s[0]*i.dataComputedScale[e]+i.dataComputedOffset[e],c[e]=s[1]*i.dataComputedScale[e]+i.dataComputedOffset[e],l[e]=(l[e]-i.offset[e])/i.scale[e],c[e]=(c[e]-i.offset[e])/i.scale[e];if(a.setUniform4f(&quot;ipScalarRangeMin&quot;,l[0],l[1],l[2],l[3]),a.setUniform4f(&quot;ipScalarRangeMax&quot;,c[0],c[1],c[2],c[3]),null!==t.zBufferTexture){a.setUniformi(&quot;zBufferTexture&quot;,t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf(&quot;vpZWidth&quot;,e[0]),a.setUniformf(&quot;vpZHeight&quot;,e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf(&quot;camThick&quot;,c[1]-c[0]),s.setUniformf(&quot;camNear&quot;,c[0]),s.setUniformf(&quot;camFar&quot;,c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf(&quot;dcxmin&quot;,g),s.setUniformf(&quot;dcxmax&quot;,m),s.setUniformf(&quot;dcymin&quot;,v),s.setUniformf(&quot;dcymax&quot;,y),s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f(&quot;vSpacing&quot;,x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f(&quot;vOriginVC&quot;,p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Dg(`The number of steps required ${Math.ceil(A)} is larger than the\\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\\n        Please either change the\\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f(&quot;vVCToIJK&quot;,I[0],I[1],I[2]),s.setUniform3i(&quot;volumeDimensions&quot;,d[0],d[1],d[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf(&quot;texWidth&quot;,t.scalarTexture.getWidth()),s.setUniformf(&quot;texHeight&quot;,t.scalarTexture.getHeight()),s.setUniformi(&quot;xreps&quot;,e.xreps),s.setUniformi(&quot;xstride&quot;,e.xstride),s.setUniformi(&quot;ystride&quot;,e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*Dn(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(o.getProperty().getUseLabelOutline()){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf(&quot;vpWidth&quot;,u[0]),s.setUniformf(&quot;vpHeight&quot;,u[1]);const d=e.getRenderTargetOffset();s.setUniformf(&quot;vpOffsetX&quot;,d[0]/u[0]),s.setUniformf(&quot;vpOffsetY&quot;,d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix(&quot;PCVCMatrix&quot;,t.projectionToView),0===t.lastLightComplexity)return;let O=0;const R=[],M=[],D=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],D[0+3*O]=-.5*w[0],D[1+3*O]=-.5*w[1],D[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi(&quot;twoSidedLighting&quot;,r.getTwoSidedLighting()),s.setUniformi(&quot;lightNum&quot;,O),s.setUniform3fv(&quot;lightColor&quot;,R),s.setUniform3fv(&quot;lightDirectionVC&quot;,M),s.setUniform3fv(&quot;lightHalfAngleVC&quot;,D),3===t.lastLightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv(&quot;lightPositionVC&quot;,e),s.setUniform3fv(&quot;lightAttenuation&quot;,n),s.setUniformfv(&quot;lightConeAngle&quot;,o),s.setUniformfv(&quot;lightExponent&quot;,a),s.setUniformiv(&quot;lightPositional&quot;,i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf(&quot;giReach&quot;,t.renderable.getGlobalIlluminationReach()),s.setUniformf(&quot;volumetricScatteringBlending&quot;,t.renderable.getVolumetricScatteringBlending()),s.setUniformf(&quot;volumeShadowSamplingDistFactor&quot;,t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf(&quot;anisotropy&quot;,t.renderable.getAnisotropy()),s.setUniformf(&quot;anisotropy2&quot;,t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi(&quot;kernelSize&quot;,e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv(&quot;kernelSample&quot;,n),s.setUniformi(&quot;kernelRadius&quot;,t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi(&quot;ctexture&quot;,t.colorTexture.getTextureUnit()),o.setUniformi(&quot;otexture&quot;,t.opacityTexture.getTextureUnit()),o.setUniformi(&quot;jtexture&quot;,t.jitterTexture.getTextureUnit()),o.setUniformi(&quot;ttexture&quot;,t.labelOutlineThicknessTexture.getTextureUnit());const a=t.scalarTexture.getVolumeInfo(),i=r.getProperty(),s=t.scalarTexture.getComponents(),l=r.getProperty().getIndependentComponents();if(l&&s>=2)for(let e=0;e<s;e++)o.setUniformf(`mix${e}`,r.getProperty().getComponentWeight(e));for(let e=0;e<s;e++){const t=l?e:0,n=a.scale[e],r=i.getScalarOpacity(t).getRange(),s=n/(r[1]-r[0]),c=(a.offset[e]-r[0])/(r[1]-r[0]);o.setUniformf(`oshift${e}`,c),o.setUniformf(`oscale${e}`,s);const u=i.getRGBTransferFunction(t).getRange(),d=(a.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);o.setUniformf(`cshift${e}`,d),o.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(l)for(let e=0;e<s;++e){const t=a.scale[e];if(i.getUseGradientOpacity(e)){const n=i.getGradientOpacityMinimumOpacity(e),r=i.getGradientOpacityMaximumOpacity(e);o.setUniformf(`gomin${e}`,n),o.setUniformf(`gomax${e}`,r);const a=[i.getGradientOpacityMinimumValue(e),i.getGradientOpacityMaximumValue(e)];o.setUniformf(`goscale${e}`,t*(r-n)/(a[1]-a[0])),o.setUniformf(`goshift${e}`,-a[0]*(r-n)/(a[1]-a[0])+n)}else o.setUniformf(`gomin${e}`,1),o.setUniformf(`gomax${e}`,1),o.setUniformf(`goscale${e}`,0),o.setUniformf(`goshift${e}`,1)}else{const e=a.scale[s-1],t=i.getGradientOpacityMinimumOpacity(0),n=i.getGradientOpacityMaximumOpacity(0);o.setUniformf(&quot;gomin0&quot;,t),o.setUniformf(&quot;gomax0&quot;,n);const r=[i.getGradientOpacityMinimumValue(0),i.getGradientOpacityMaximumValue(0)];o.setUniformf(&quot;goscale0&quot;,e*(n-t)/(r[1]-r[0])),o.setUniformf(&quot;goshift0&quot;,-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===r.getProperty().getUseLabelOutline()){const e=r.getProperty().getLabelOutlineOpacity();o.setUniformf(&quot;outlineOpacity&quot;,e)}t.lastLightComplexity>0&&(o.setUniformf(&quot;vAmbient&quot;,i.getAmbient()),o.setUniformf(&quot;vDiffuse&quot;,i.getDiffuse()),o.setUniformf(&quot;vSpecular&quot;,i.getSpecular()),o.setUniformf(&quot;vSpecularPower&quot;,i.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*Dn(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv(&quot;vClipPlaneNormals&quot;,o),c.setUniformfv(&quot;vClipPlaneDistances&quot;,a),c.setUniform3fv(&quot;vClipPlaneOrigins&quot;,i),c.setUniformi(&quot;clip_numPlanes&quot;,l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===wg.NEAREST?(t.scalarTexture.setMinificationFilter(bd.NEAREST),t.scalarTexture.setMagnificationFilter(bd.NEAREST)):(t.scalarTexture.setMinificationFilter(bd.LINEAR),t.scalarTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null,null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;uniform vec2 tfactor;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),[&quot;//VTK::System::Dec&quot;,&quot;//VTK::Output::Dec&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { gl_FragData[0] = texture2D(texture1,tcoord); }&quot;].join(&quot;\\n&quot;),&quot;&quot;);const e=t.copyShader;t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg(&quot;Error setting vertexDC in copy shader VAO.&quot;)}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi(&quot;texture&quot;,n.getTextureUnit()),t.copyShader.setUniform2f(&quot;tfactor&quot;,t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Eg(&quot;No input!&quot;)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;t._scalars!==a&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=a);const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(bd.LINEAR),t.jitterTexture.setMagnificationFilter(bd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,ys.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=i.getIndependentComponents()?s:1,c=i.getScalarOpacity(),u=t._openGLRenderWindow.getGraphicsResourceForObject(c);let d=Vg(i,c,l);if(u.vtkObj&&u.hash===d&&t.opacityTextureString===d)t.opacityTexture=u.vtkObj,t.opacityTextureString=u.hash;else{const r=1024,o=2*r*l,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<l;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.releaseGraphicsResources(t._openGLRenderWindow),t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(bd.LINEAR),t.opacityTexture.setMagnificationFilter(bd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))t.opacityTexture.create2DFromRaw(r,2*l,1,ys.FLOAT,a);else{const e=new Uint8Array(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*l,1,ys.UNSIGNED_CHAR,e)}t.opacityTextureString=d,c&&t._openGLRenderWindow.setGraphicsResourceForObject(c,t.opacityTexture,t.opacityTextureString)}const p=i.getRGBTransferFunction();d=Vg(i,p,l);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===d&&t.colorTextureString===d)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8Array(2*e*l*3),r=new Float32Array(3*e);for(let t=0;t<l;++t){const o=i.getRGBTransferFunction(t),a=o.getRange();o.getTable(a[0],a[1],e,r,1);for(let o=0;o<3*e;++o)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.create2DFromRaw(e,2*l,3,ys.UNSIGNED_CHAR,n),t.colorTextureString=d,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}e.updateLabelOutlineThicknessTexture(r);const g=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(d=`${o.getMTime()}A${a.getMTime()}`,g?.vtkObj&&g?.hash===d&&t.scalarTextureString===d)t.scalarTexture=g.vtkObj,t.scalarTextureString=g.hash;else{const e=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.scalarTexture.releaseGraphicsResources(t._openGLRenderWindow),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],a,t.renderable.getPreferSizeOverAccuracy()),t.scalarTextureString=d,a&&t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,t.scalarTextureString)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Es.newInstance({numberOfComponents:3,values:e});r.setName(&quot;points&quot;);const o=Es.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,&quot;polys&quot;,rs.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=e=>{const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join(&quot;-&quot;)}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}}}const Bg={context:null,VBOBuildTime:null,scalarTexture:null,scalarTextureString:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lastLightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0,_scalars:null};const Ng=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bg,n),Zt.extend(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),t.scalarTexture=Nd.newInstance(),t.opacityTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.jitterTexture=Nd.newInstance(),t.jitterTexture.setWrapS(Td.REPEAT),t.jitterTexture.setWrapT(Td.REPEAT),t.labelOutlineThicknessTexture=Nd.newInstance(),t.framebuffer=Hp.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,[&quot;context&quot;]),Lg(e,t)}),&quot;vtkOpenGLVolumeMapper&quot;);rn(&quot;vtkVolumeMapper&quot;,Ng);const{vtkDebugMacro:_g}=Kt;function Fg(e,t){t.classHierarchy.push(&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent();const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():_g(&quot;No framebuffer to save/restore&quot;);const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const kg={};const Gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kg,n),Zt.extend(e,t,n),Fg(e,t)}),&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;);rn(&quot;vtkPixelSpaceCallbackMapper&quot;,Gg);var Ug=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtktextureObjectVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\nattribute vec2 tcoordDC;\\nvarying vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  tcoordVC = tcoordDC;\\n  gl_Position = vertexDC;\\n}\\n&quot;;const{Representation:zg}=ds;function Wg(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Nd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,&quot;Float32Array&quot;,null),s.activate(),s.sendParameters(),s.deactivate(),s}function Hg(e,t){return Wg(e,t,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE)}function jg(e,t){t.classHierarchy.push(&quot;vtkLICPingPongBufferManager&quot;),t._openGLRenderWindow?(t.quad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,zg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=Hg(t._openGLRenderWindow,t.size),t.seedTexture0=Hg(t._openGLRenderWindow,t.size),t.licTexture1=Hg(t._openGLRenderWindow,t.size),t.seedTexture1=Hg(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?Wg(t._openGLRenderWindow,t.size,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return Wg(e,t,Nd.Filter.LINEAR,Nd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error(&quot;Pass renderwindow to ping pong manager&quot;)}const Kg={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function $g(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kg,n),jt.obj(e,t),jt.get(e,t,[&quot;readIndex&quot;]),jt.setGet(e,t,[&quot;doEEPass&quot;,&quot;doVTPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;vectorTexture&quot;,&quot;maskVectorTexture&quot;,&quot;noiseTexture&quot;,&quot;framebuffer&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),jg(e,t)}var qg={newInstance:jt.newInstance($g,&quot;vtkLICPingPongBufferManager&quot;),extend:$g};const Xg=0,Yg=1,Zg=2,Qg=3,Jg=1;function em(e,t){function n(e,t){e.setUniformi(&quot;texLIC&quot;,t.getLICTextureUnit()),e.setUniformi(&quot;texSeedPts&quot;,t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push(&quot;vtkLineIntegralConvolution2D&quot;),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Hp.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t=&quot;xyzw&quot;;return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n/**\\nThis shader initializes the convolution for the LIC computation.\\n*/\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texMaskVectors;\\nuniform sampler2D texNoise;\\nuniform sampler2D texLIC;\\n\\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the *whole* domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value. this\\n// depends on the pass number.\\nvec2 getNoiseTC(vec2 vectc)\\n{\\n  // in pass 1 : convert from vector tc to noise tc\\n  // in pass 2 : use vector tc\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(vectc);\\n    }\\n  else\\n    {\\n    return vectc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the\\n// need to convert to noise texture coordinates.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 vectc = tcoordVC.st;\\n\\n  // lic => (convolution, mask, 0, step count)\\n  if (uStepNo == 0)\\n    {\\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\\n    float maskFlag;\\n    if (maskCriteria <= uMaskThreshold)\\n      {\\n      maskFlag = 1.0;\\n      }\\n    else\\n      {\\n      maskFlag = 0.0;\\n      }\\n    float noise = getNoise(vectc);\\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = texture2D(texLIC, vectc);\\n    }\\n\\n  // initial seed\\n  SeedOutput = vec4(vectc, 0.0, 1.0);\\n}\\n&quot;);const n=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// move vector field to normalized image space\\n// pre-processing for vtkLineIntegralConvolution2D\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Fragment shader used by the gaussian blur filter render pass.\\n\\nuniform sampler2D texVectors; // input texture\\nuniform vec2      uTexSize;   // size of texture\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  //VTK::LICComponentSelection::Impl\\n  V = V/uTexSize;\\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\\n}\\n&quot;,&quot;//VTK::LICComponentSelection::Impl&quot;,`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=cd.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D  texVectors;\\nuniform sampler2D  texNoise;\\nuniform sampler2D  texLIC;\\nuniform sampler2D  texSeedPts;\\n\\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\\nuniform float uStepSize;        // step size in parametric space\\n\\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n//VTK::LICVectorLookup::Impl\\n\\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\\n// are very poorly supported in webgl\\nvec2 clampToBorder(vec2 uv){\\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\\n  {\\n    return vec2(0.0, 0.0);\\n  }\\n  return getVector(uv);\\n}\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the whole domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value.\\n// in pass 1 repeatedly tile the noise texture across\\n// the computational domain.\\nvec2 getNoiseTC(vec2 tc)\\n{\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(tc);\\n    }\\n  else\\n    {\\n    return tc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the need\\n// to convert to either noise or lic texture coordinates in\\n// pass 1 and 2 respectively.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\n// fourth-order Runge-Kutta streamline integration\\n// no bounds checks are made, therefore it's essential\\n// to have the entire texture initialized to 0\\n// and set clamp to border and have border color 0\\n// an integer is set if the step was taken, keeping\\n// an accurate step count is necessary to prevent\\n// boundary artifacts. Don't count the step if\\n// all vector lookups are identically 0. This is\\n// a proxy for \\&quot;stepped outside valid domain\\&quot;\\nvec2 rk4(vec2 pt0, float dt, out bool count)\\n{\\n  count=true;\\n  float dtHalf = dt * 0.5;\\n  vec2 pt1;\\n\\n  vec2 v0 = clampToBorder(pt0);\\n  pt1 = pt0 + v0 * dtHalf;\\n\\n  vec2 v1 = clampToBorder(pt1);\\n  pt1 = pt0 + v1 * dtHalf;\\n\\n  vec2 v2 = clampToBorder(pt1);\\n  pt1 = pt0 + v2 * dt;\\n\\n  vec2 v3 = clampToBorder(pt1);\\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\\n\\n  if (vSum == vec2(0.0, 0.0))\\n    {\\n      count = false;\\n    }\\n\\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\\n\\n return pt1;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic = texture2D(texLIC, lictc);\\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\\n\\n  bool count;\\n  vec2 pt1 = rk4(pt0, uStepSize, count);\\n\\n  if (count)\\n    {\\n    // accumulate lic step\\n    // (lic, mask, 0, step count)\\n    float noise = getNoise(pt1);\\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\\n    SeedOutput = vec4(pt1, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    // keep existing values\\n    LICOutput = lic;\\n    SeedOutput = vec4(pt0, 0.0, 1.0);\\n    }\\n}\\n&quot;,&quot;//VTK::LICVectorLookup::Impl&quot;,function(){const e=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      vec2 V = texture2D( texVectors, vectc ).xy;\\n\\n      // normalize if |V| not 0\\n\\n      float lenV = length( V );\\n\\n      if ( lenV > 1.0e-8 )\\n\\n        {\\n\\n        return V/lenV;\\n\\n        }\\n\\n      else\\n\\n        {\\n\\n        return vec2( 0.0, 0.0 );\\n\\n        }\\n\\n      }\\n\\n    &quot;,t=&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      return texture2D( texVectors, vectc ).xy;\\n\\n      }\\n\\n    &quot;;return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(&quot; //VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n/**\\nThis shader finalizes the convolution for the LIC computation\\napplying the normalization. eg. if box kernel is used the this\\nis the number of steps taken.\\n*/\\n\\nuniform sampler2D texLIC;\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\\n  conv.r = conv.r/conv.a;\\n  // lic => (convolution, mask, 0, 1)\\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.CEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// gray scale contrast enhance stage implemented via histogram stretching\\n// if the min and max are tweaked it can generate out-of-range values\\n// these will be clamped in 0 to 1\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n\\nuniform sampler2D texLIC;  // most recent lic pass\\nuniform float uMin;        // min gray scale color value\\nuniform float uMaxMinDiff; // max-min\\n\\nin vec2 tcoordVC;\\n\\nvoid main( void )\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g!=0.0)\\n    {\\n    LICOutput = lic;\\n    }\\n  else\\n    {\\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\\n    LICOutput = vec4(CElic, lic.gb, 1.0);\\n    }\\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.EEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\\n// noise for pass2.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 EEOutput;\\n\\nuniform sampler2D texLIC; // most recent lic pass\\nuniform float     uDx;    // fragment size\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// kernel for simple laplace edge enhancement.\\n// p=Laplace(p)+p\\nfloat K[9] = float[9](\\n  -1.0, -1.0, -1.0,\\n  -1.0,  9.0, -1.0,\\n  -1.0, -1.0, -1.0\\n  );\\n\\n// determine if the fragment was masked\\nbool Masked(float val) { return val != 0.0; }\\n\\nvoid main(void)\\n{\\n  // tex coord neighbor offsets\\n  vec2 fragDx[9] = vec2[9](\\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\\n    );\\n\\n  vec2 lictc = tcoordVC.st;\\n\\n  // compute the convolution but don't use convovled values if\\n  // any masked fragments on the stencil. Fragments outside\\n  // the valid domain are masked during initialization, and\\n  // texture wrap parameters are clamp to border with border\\n  // color that contains masked flag\\n  float conv = 0.0;\\n  bool dontUse = false;\\n  for (int i=0; i<9; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    vec4 lic = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic.g);\\n    conv = conv + K[i] * lic.r;\\n    }\\n\\n  if (dontUse)\\n    {\\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    conv = clamp(conv, 0.0, 1.0);\\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\\n    }\\n\\n}\\n&quot;),t.AAHProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// horizontal pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDx;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.AAVProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// vertical pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\\n\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDy[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;)},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;f&&o[0]===f.getSize()[0]&&o[1]===f.getSize()[1]||(f=Hp.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=qg.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const g=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],m=1/o[0],h=1/o[1],v=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;v.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f(&quot;uTexSize&quot;,...o),e.setUniformi(&quot;texVectors&quot;,t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,0),y.setUniformf(&quot;uMaskThreshold&quot;,t.maskThreshold),y.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),y.setUniformi(&quot;texMaskVectors&quot;,t.bufs.getMaskVectorTextureUnit()),y.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:T}=t;v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,0),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...g),T.setUniformi(&quot;texVectors&quot;,t.bufs.getImageVectorTextureUnit()),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:b}=t;if(v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),r(t.bufs,o,b),t.enhancedLIC){t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDx&quot;,m),a.setUniformf(&quot;uDy&quot;,h),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,1),n(y,t.bufs),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformi(&quot;uPassNo&quot;,1),T.setUniformf(&quot;uStepSize&quot;,-d),T.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),v.readyShaderProgram(b),b.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),b.setUniformi(&quot;texSeedPts&quot;,t.bufs.getSeedTextureUnit()),r(t.bufs,o,b)}if(t.antiAlias){const e=t.AAHProgram;v.readyShaderProgram(e),e.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),e.setUniformf(&quot;uDx&quot;,m);const a=t.AAVProgram;v.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDy&quot;,h);for(let i=0;i<t.antiAlias;++i)v.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),v.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error(&quot;Invalid color range: &quot;,i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),c.setUniformf(&quot;uMin&quot;,i),c.setUniformf(&quot;uMaxMinDiff&quot;,l),r(t.bufs,o,c)}}const tm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function nm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tm,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;nuberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;componentIds&quot;,&quot;isComposite&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),em(e,t)}var rm={newInstance:jt.newInstance(nm,&quot;vtkLineIntegralConvolution2D&quot;),extend:nm};function om(e,t){t.classHierarchy.push(&quot;vtkSurfaceLICInterface&quot;)}const am={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Xg,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:Jg,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function im(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,am,n),jt.obj(e,t),jt.setGet(e,t,[&quot;enableLIC&quot;,&quot;numberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;transformVectors&quot;,&quot;maskOnSurface&quot;,&quot;maskThreshold&quot;,&quot;maskColor&quot;,&quot;maskIntensity&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;noiseTextureSize&quot;,&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;noiseGeneratorSeed&quot;,&quot;viewPortScale&quot;,&quot;rebuildNoiseTexture&quot;]),om(0,t)}var sm={newInstance:jt.newInstance(im,&quot;vtkSurfaceLICInterface&quot;),extend:im};const{Representation:lm}=ds;function cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICInterface&quot;),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get(&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;);n=r===Jg?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Nd.newInstance({wrapS:Nd.Wrap.REPEAT,wrapT:Nd.Wrap.REPEAT,minificationFilter:Nd.Filter.NEAREST,magnificationFilter:Nd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,&quot;Float32Array&quot;,d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,&quot;&quot;),e.allocateTextures=()=>{const n=Nd.Filter.NEAREST,r=Nd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Nd.newInstance({wrapS:Nd.Wrap.CLAMP_TO_EDGE,wrapT:Nd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,&quot;Float32Array&quot;,null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Nd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,&quot;Float32Array&quot;,null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=Hp.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader combines surface geometry, LIC, and  scalar colors.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 RGBOutput;\\nlayout(location = 1) out vec4 HSLOutput;\\n\\nuniform sampler2D texVectors;       // vectors, depth\\nuniform sampler2D texGeomColors;    // scalar colors + lighting\\nuniform sampler2D texLIC;           // image lic\\nuniform int       uScalarColorMode; // select between blend, and map shader\\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\\nuniform float     uMaskIntensity;   // blending factor for mask color\\nuniform vec3      uMaskColor;       // color for the masked out fragments\\n\\nin vec2 tcoordVC;\\n\\n/**\\nConvert from RGB color space into HSL colorspace.\\n*/\\nvec3 RGBToHSL(vec3 RGB)\\n{\\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\\n\\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\\n  float RGBMaxMinDiff = RGBMax - RGBMin;\\n\\n  HSL.z = (RGBMax + RGBMin) / 2.0;\\n\\n  if (RGBMaxMinDiff == 0.0)\\n    {\\n    // Gray scale\\n    HSL.x = 0.0;\\n    HSL.y = 0.0;\\n    }\\n  else\\n    {\\n    // Color\\n    if (HSL.z < 0.5)\\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\\n    else\\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\\n\\n    float dR\\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dG\\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dB\\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n\\n    if (RGB.r == RGBMax)\\n      HSL.x = dB - dG;\\n    else\\n    if (RGB.g == RGBMax)\\n      HSL.x = (1.0 / 3.0) + dR - dB;\\n    else\\n    if (RGB.b == RGBMax)\\n      HSL.x = (2.0 / 3.0) + dG - dR;\\n\\n    if (HSL.x < 0.0)\\n      HSL.x += 1.0;\\n\\n    if (HSL.x > 1.0)\\n      HSL.x -= 1.0;\\n    }\\n\\n  return HSL;\\n}\\n\\n/**\\nHelper for HSL to RGB conversion.\\n*/\\nfloat Util(float v1, float v2, float vH)\\n{\\n  if (vH < 0.0)\\n    vH += 1.0;\\n\\n  if (vH > 1.0)\\n     vH -= 1.0;\\n\\n  if ((6.0 * vH) < 1.0)\\n    return (v1 + (v2 - v1) * 6.0 * vH);\\n\\n  if ((2.0 * vH) < 1.0)\\n    return (v2);\\n\\n  if ((3.0 * vH) < 2.0)\\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\\n\\n  return v1;\\n}\\n\\n/**\\nConvert from HSL space into RGB space.\\n*/\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  if (HSL.y == 0.0)\\n    {\\n    // Gray\\n    RGB.r = HSL.z;\\n    RGB.g = HSL.z;\\n    RGB.b = HSL.z;\\n    }\\n  else\\n    {\\n    // Chromatic\\n    float v2;\\n    if (HSL.z < 0.5)\\n      v2 = HSL.z * (1.0 + HSL.y);\\n    else\\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\\n\\n    float v1 = 2.0 * HSL.z - v2;\\n\\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\\n    RGB.g = Util(v1, v2, HSL.x);\\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\\n    }\\n\\n  return RGB.rgb;\\n}\\n\\nvoid main()\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n\\n  // depth is used to determine which fragment belong to us\\n  // and we can change\\n  float depth = texture2D(texVectors, tcoordVC.st).a;\\n\\n  vec3 fragColorRGB;\\n  float valid;\\n  if (depth > 1.0e-3)\\n    {\\n    // we own it\\n    // shade LIC'ed geometry, or apply mask\\n    if (lic.g!=0.0)\\n      {\\n      // it's masked\\n      // apply fragment mask\\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\\n      valid = 0.0;\\n      }\\n    else\\n      {\\n      if (uScalarColorMode==0)\\n        {\\n        // blend with scalars\\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\\n        }\\n      else\\n        {\\n        // multiply with scalars\\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\\n        }\\n      if (lic.b != 0.0)\\n        {\\n        // didn't have the required guard pixels\\n        // don't consider it in min max estimation\\n        // for histpgram stretching\\n        valid = 0.0;\\n        }\\n      else\\n        {\\n        // ok to use in min/max estimates for histogram\\n        // stretching\\n        valid = 1.0;\\n        }\\n      }\\n    }\\n  else\\n    {\\n    // we don't own it\\n    // pass through scalars\\n    fragColorRGB = geomColor.rgb;\\n    valid = 0.0;\\n    }\\n\\n  // if no further stages this texture is\\n  // copied to the screen\\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\\n\\n  // if further stages, move to hsl space for contrast\\n  // enhancement. encoding validity saves moving a texture to the cpu\\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\\n  HSLOutput = vec4(fragColorHSL, valid);\\n}\\n&quot;),t.licCopyPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader copies fragments and depths to the output buffer\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texDepth;     // z values from vertex shader\\nuniform sampler2D texRGBColors; // final rgb LIC colors\\n\\nin vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\\n\\n  // since we render a screen aligned quad\\n  // we're going to be writing fragments\\n  // not touched by the original geometry\\n  // it's critical not to modify those\\n  // fragments.\\n  if (gl_FragDepth == 1.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;),t.enhanceContrastPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// color contrast enhance stage implemented via histogram stretching\\n// on lightness channel. if the min and max are tweaked it can generate\\n// out-of-range values these will be clamped in 0 to 1\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texGeomColors; // scalars + lighting\\nuniform sampler2D texLIC;        // image lic, mask\\nuniform sampler2D texHSLColors;  // hsla colors\\n\\nuniform float     uLMin;         // min lightness over all fragments\\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\\n\\nin vec2 tcoordVC;\\n\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  float v;\\n  float h = HSL.x;\\n  float sl = HSL.y;\\n  float l = HSL.z;\\n\\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\\n  if (v <= 0.0) {\\n    RGB = vec3(0.0,0.0,0.0);\\n  } else {\\n    float m;\\n    int sextant;\\n    float fract, vsf, mid1, mid2;\\n\\n    m = l + l - v;\\n    h *= 6.0;\\n    sextant = int(h);\\n    fract = h - float(sextant);\\n\\n    vsf = (v - m) * fract;\\n    mid1 = m + vsf;\\n    mid2 = v - vsf;\\n    switch (sextant) {\\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\\n    }\\n  }\\n  return RGB;\\n}\\n\\nvoid main()\\n{\\n  // lookup hsl color , mask\\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\\n\\n  // don't modify masked fragments (masked => lic.g==1)\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g==0.0)\\n    {\\n    // normalize lightness channel\\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\\n    }\\n\\n  // back into rgb space\\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\\n\\n  // add alpha\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n  fragColor.a = geomColor.a;\\n\\n  gl_FragData[0] = fragColor;\\n}\\n&quot;),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,lm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=rm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi(&quot;texDepth&quot;,t.depthTexture.getTextureUnit()),r.setUniformi(&quot;texRGBColors&quot;,t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi(&quot;texVectors&quot;,t.vectorImage.getTextureUnit()),o.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get(&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;maskIntensity&quot;,&quot;maskColor&quot;,&quot;enhanceContrast&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;);if(o.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),o.setUniformi(&quot;uScalarColorMode&quot;,a),o.setUniformf(&quot;uLICIntensity&quot;,i),o.setUniformf(&quot;uMapBias&quot;,s),o.setUniformf(&quot;uMaskIntensity&quot;,l),o.setUniform3f(&quot;uMaskColor&quot;,...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===Zg||u===Qg){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit()),s.setUniformi(&quot;texHSLColors&quot;,t.HSLColorImage.getTextureUnit()),s.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),s.setUniformf(&quot;uLMin&quot;,o),s.setUniformf(&quot;uLMaxMinDiff&quot;,i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get(&quot;stepSize&quot;,&quot;numberOfSteps&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;transformVectors&quot;),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error(&quot;Failed to compute image LIC&quot;),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const um={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function dm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,um,n),sm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;reallocateTextures&quot;,&quot;licInterface&quot;,&quot;size&quot;]),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cm(e,t)}var pm={newInstance:jt.newInstance(dm,&quot;vtkSurfaceLICInterface&quot;),extend:dm};const{vtkErrorMacro:fm}=Kt;function gm(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICMapper&quot;);const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=cd.substitute(s,&quot;//VTK::Output::Dec&quot;,[&quot;//VTK::Output::Dec&quot;,&quot;layout(location = 2) out vec4 vectorTexture;&quot;,&quot;layout(location = 3) out vec4 maskVectorTexture;&quot;]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=cd.substitute(i,&quot;//VTK::TCoord::Dec&quot;,[`attribute vec3 ${n};`,&quot;out vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,i=cd.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[`licOutput = ${n};`,&quot;//VTK::TCoord::Impl&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform int uMaskOnSurface;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;in vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,s=cd.substitute(s,&quot;//VTK::TCoord::Impl&quot;,[&quot;// projected vectors&quot;,&quot;  vec3 tcoordLIC = normalMatrix * licOutput;&quot;,&quot;  vec3 normN = normalize(normalVCVSOutput);&quot;,&quot;  float k = dot(tcoordLIC, normN);&quot;,&quot;  vec3 projected = (tcoordLIC - k*normN);&quot;,&quot;  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;// vectors for fragment masking&quot;,&quot;  if (uMaskOnSurface == 0)&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(licOutput, 1.0);&quot;,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;    }&quot;,&quot;//VTK::TCoord::Impl&quot;],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi(&quot;uMaskOnSurface&quot;,t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(fm(&quot;SurfaceLICMapper Requires WebGL 2&quot;),a=!1),t.context.getExtension(&quot;EXT_color_buffer_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)||(fm(&quot;SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions.&quot;),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(fm(&quot;No input&quot;),a=!1);let i=t.renderable.getLicInterface();i||(i=sm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=pm.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(fm(&quot;No vector input array&quot;),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const mm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const hm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mm,n),np.extend(e,t,n),gm(e,t),At(e,t,[&quot;openGLLicInterface&quot;])}),&quot;vtkOpenGLSurfaceLICMapper&quot;);rn(&quot;vtkSurfaceLICMapper&quot;,hm);const{vtkErrorMacro:vm}=Kt;function ym(e,t){t.classHierarchy.push(&quot;vtkOpenGLSphereMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkSphereMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Spheres\\n\\nattribute vec4 vertexMC;\\nattribute vec2 offsetMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\n\\nuniform int cameraParallel;\\nuniform float scaleFactor;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  // compute the projected vertex position\\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\\n\\n  // make the triangle face the camera\\n  if (cameraParallel == 0)\\n    {\\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\\n    vec3 base1 = cross(base2,dir);\\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\\n    }\\n  else\\n    {\\n    // add in the offset\\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\\n    }\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;\\n&quot;]).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform float invertedDepth;\\n&quot;,&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float b = 2.0*dot(EyePos,EyeDir);\\n&quot;,&quot;  float c = dot(EyePos,EyePos) - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t = (-b - invertedDepth*sqrt(d))*0.5;\\n&quot;,&quot;    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\\n&quot;,&quot;    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;offsetMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||vm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isUniformUsed(&quot;invertedDepth&quot;)&&e.getProgram().setUniformf(&quot;invertedDepth&quot;,t.invert?-1:1),e.getProgram().isUniformUsed(&quot;scaleFactor&quot;)){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf(&quot;scaleFactor&quot;,t.renderable.getScaleFactor()):e.getProgram().setUniformf(&quot;scaleFactor&quot;,1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),o.isUniformUsed(&quot;MCVCMatrix&quot;))if(r.getIsIdentity())o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,n)}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Tm={};const bm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tm,n),np.extend(e,t,n),ym(e,t)}),&quot;vtkOpenGLSphereMapper&quot;);rn(&quot;vtkSphereMapper&quot;,bm);const{vtkErrorMacro:xm}=Kt;function Cm(e,t){t.classHierarchy.push(&quot;vtkOpenGLStickMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkStickMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Sticks\\n\\nattribute vec4 vertexMC;\\nattribute vec3 orientMC;\\nattribute vec4 offsetMC;\\nattribute float radiusMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying float lengthVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\nvarying vec3 orientVCVSOutput;\\n\\nuniform int cameraParallel;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = radiusMC;\\n  lengthVCVSOutput = length(orientMC);\\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\\n\\n  // make sure it is pointing out of the screen\\n  if (orientVCVSOutput.z < 0.0)\\n    {\\n    orientVCVSOutput = -orientVCVSOutput;\\n    }\\n\\n  // make the basis\\n  vec3 xbase;\\n  vec3 ybase;\\n  vec3 dir = vec3(0.0,0.0,1.0);\\n  if (cameraParallel == 0)\\n    {\\n    dir = normalize(-vertexVCVSOutput.xyz);\\n    }\\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\\n    {\\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\\n    ybase = cross(xbase,orientVCVSOutput);\\n    }\\n  else\\n    {\\n    xbase = normalize(cross(orientVCVSOutput,dir));\\n    ybase = cross(orientVCVSOutput,xbase);\\n    }\\n\\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\\n    radiusVCVSOutput*offsets.x*xbase +\\n    radiusVCVSOutput*offsets.y*ybase +\\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Fd,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,&quot;varying vec4 vertexVCVSOutput;&quot;).result,i=cd.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,&quot;  vec4 vertexVC = vertexVCVSOutput;\\n&quot;).result,i=cd.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 orientVCVSOutput;\\n&quot;,&quot;varying float lengthVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=cd.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  vec3 base1;\\n&quot;,&quot;  if (abs(orientVCVSOutput.z) < 0.99) {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\\n&quot;,&quot;  vec3 base2 = cross(orientVCVSOutput,base1);\\n&quot;,&quot;  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\\n&quot;,&quot;  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n&quot;,&quot;  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n&quot;,&quot;  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*a*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t =  (-b - sqrt(d))/(2.0*a);\\n&quot;,&quot;    float tz = EyePos.z + t*EyeDir.z;\\n&quot;,&quot;    vec3 iPoint = EyePos + t*EyeDir;\\n&quot;,&quot;    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\\n&quot;,&quot;      float t2 = (-b + sqrt(d))/(2.0*a);\\n&quot;,&quot;      float tz2 = EyePos.z + t2*EyeDir.z;\\n&quot;,&quot;      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\\n&quot;,&quot;      else {\\n&quot;,&quot;        normalVCVSOutput = orientVCVSOutput;\\n&quot;,&quot;        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\\n&quot;,&quot;        iPoint = EyePos + t3*EyeDir;\\n&quot;,&quot;        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;        }\\n&quot;,&quot;      }\\n&quot;,&quot;    else {\\n&quot;,&quot;      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\\n&quot;,&quot;      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;      }\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=cd.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed(&quot;orientMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;orientMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||xm(&quot;Error setting 'orientMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),&quot;offsetMC&quot;,0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||xm(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;radiusMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;radiusMC&quot;,24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||xm(&quot;Error setting 'radiusMC' in shader VAO.&quot;))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),r.getIsIdentity())o.isUniformUsed(&quot;MCVCMatrix&quot;)&&o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc),o.isUniformUsed(&quot;normalMatrix&quot;)&&o.setUniformMatrix3x3(&quot;normalMatrix&quot;,i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed(&quot;MCVCMatrix&quot;)){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,t)}if(o.isUniformUsed(&quot;normalMatrix&quot;)){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3(&quot;normalMatrix&quot;,t)}}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():xm([&quot;Error setting orientationArray.\\n&quot;,&quot;You have to specify the stick orientation&quot;]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,zu.ARRAY_BUFFER),a.getColorBO().upload(g,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Sm={};const Am=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sm,n),np.extend(e,t,n),Cm(e,t)}),&quot;vtkOpenGLStickMapper&quot;);rn(&quot;vtkStickMapper&quot;,Am);const Im=[];Im[&quot;-&quot;.charCodeAt(0)]=62,Im[&quot;_&quot;.charCodeAt(0)]=63;const wm=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;for(let e=0;e<wm.length;e++)Im[wm.charCodeAt(e)]=e;function Pm(e){return void 0!==Im[e.charCodeAt(0)]}function Om(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<18;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<12;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<6;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<10;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<4;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<2;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error(&quot;BASE64: remain 1 should not happen&quot;)}return u}function Rm(e,t,n){const r=(e<<16)+(t<<8)+n;return wm[r>>18]+wm[r>>12&63]+wm[r>>6&63]+wm[63&r]}function Mm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Rm(t[n],t[n+1],t[n+2])}if(n>0){const e=Rm(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join(&quot;&quot;)}var Dm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)Pm(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):&quot;=&quot;===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Om(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Em={};function Vm(e,t){Em[e]=t}var Lm=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;http&quot;,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Em[e](t)},Bm=Uint8Array,Nm=Uint16Array,_m=Uint32Array,Fm=new Bm([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),km=new Bm([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Gm=new Bm([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Um=function(e,t){for(var n=new Nm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new _m(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},zm=Um(Fm,2),Wm=zm[0],Hm=zm[1];Wm[28]=258,Hm[258]=28;for(var jm=Um(km,0),Km=jm[0],$m=(jm[1],new Nm(32768)),qm=0;qm<32768;++qm){var Xm=(43690&qm)>>>1|(21845&qm)<<1;Xm=(61680&(Xm=(52428&Xm)>>>2|(13107&Xm)<<2))>>>4|(3855&Xm)<<4,$m[qm]=((65280&Xm)>>>8|(255&Xm)<<8)>>>1}var Ym=function(e,t,n){for(var r=e.length,o=0,a=new Nm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Nm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Nm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[$m[d]>>>l]=c}else for(i=new Nm(r),o=0;o<r;++o)e[o]&&(i[o]=$m[s[e[o]-1]++]>>>15-e[o]);return i},Zm=new Bm(288);for(qm=0;qm<144;++qm)Zm[qm]=8;for(qm=144;qm<256;++qm)Zm[qm]=9;for(qm=256;qm<280;++qm)Zm[qm]=7;for(qm=280;qm<288;++qm)Zm[qm]=8;var Qm=new Bm(32);for(qm=0;qm<32;++qm)Qm[qm]=5;var Jm=Ym(Zm,9,1),eh=Ym(Qm,5,1),th=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},nh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},rh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},oh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Nm:4==e.BYTES_PER_ELEMENT?_m:Bm)(n-t);return r.set(e.subarray(t,n)),r},ah=[&quot;unexpected EOF&quot;,&quot;invalid block type&quot;,&quot;invalid length/literal&quot;,&quot;invalid distance&quot;,&quot;stream finished&quot;,&quot;no stream handler&quot;,,&quot;no callback&quot;,&quot;invalid UTF-8 data&quot;,&quot;extra field too long&quot;,&quot;date not in range 1980-2099&quot;,&quot;filename too long&quot;,&quot;stream finishing&quot;,&quot;invalid zip data&quot;],ih=function(e,t,n){var r=new Error(t||ah[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,ih),!n)throw r;return r},sh=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new Bm(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new Bm(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new Bm(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=nh(e,c,1);var h=nh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&ih(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=Jm,p=eh,f=9,g=5;else if(2==h){var T=nh(e,c,31)+257,b=nh(e,c+10,15)+4,x=T+nh(e,c+5,31)+1;c+=14;for(var C=new Bm(x),S=new Bm(19),A=0;A<b;++A)S[Gm[A]]=nh(e,c+3*A,7);c+=3*b;var I=th(S),w=(1<<I)-1,P=Ym(S,I,1);for(A=0;A<x;){var O,R=P[nh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,D=0;for(16==O?(D=3+nh(e,c,3),c+=2,M=C[A-1]):17==O?(D=3+nh(e,c,7),c+=3):18==O&&(D=11+nh(e,c,127),c+=7);D--;)C[A++]=M}}var E=C.subarray(0,T),V=C.subarray(T);f=th(E),g=th(V),d=Ym(E,f,1),p=Ym(V,g,1)}else ih(1);if(c>m){a&&ih(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[rh(e,c)&L])>>>4;if((c+=15&M)>m){a&&ih(0);break}if(M||ih(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Fm[A=_-257];F=nh(e,c,(1<<k)-1)+Wm[A],c+=k}var G=p[rh(e,c)&B],U=G>>>4;if(G||ih(3),c+=15&G,V=Km[U],U>3&&(k=km[U],V+=rh(e,c)&(1<<k)-1,c+=k),c>m){a&&ih(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:oh(t,0,u)},lh=new Bm(0),ch=function(e,t){return e[t]|e[t+1]<<8},uh=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},dh=function(e,t){return uh(e,t)+4294967296*uh(e,t+4)};function ph(e,t){return sh(e,t)}function fh(e,t){return sh(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||ih(6,&quot;invalid gzip data&quot;);var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new Bm((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function gh(e,t){return sh(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&ih(6,&quot;invalid zlib data&quot;),32&n[1]&&ih(6,&quot;invalid zlib data: preset dictionaries not supported&quot;),e.subarray(2,-4)),t);var n}function mh(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?fh(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?ph(e,t):gh(e,t)}var hh=&quot;undefined&quot;!=typeof TextEncoder&&new TextEncoder,vh=&quot;undefined&quot;!=typeof TextDecoder&&new TextDecoder;try{vh.decode(lh,{stream:!0})}catch(e){}function yh(e,t){if(t){for(var n=&quot;&quot;,r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(vh)return vh.decode(e);var o=function(e){for(var t=&quot;&quot;,n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,oh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&ih(8),a}var Th=function(e,t){return t+30+ch(e,t+26)+ch(e,t+28)},bh=function(e,t,n){var r=ch(e,t+28),o=yh(e.subarray(t+46,t+46+r),!(2048&ch(e,t+8))),a=t+46+r,i=uh(e,t+20),s=n&&4294967295==i?xh(e,a):[i,uh(e,t+24),uh(e,t+42)],l=s[0],c=s[1],u=s[2];return[ch(e,t+10),l,c,o,a+ch(e,t+30)+ch(e,t+32),u]},xh=function(e,t){for(;1!=ch(e,t);t+=4+ch(e,t+2));return[dh(e,t+12),dh(e,t+4),dh(e,t+20)]};function Ch(e,t){for(var n={},r=e.length-22;101010256!=uh(e,r);--r)(!r||e.length-r>65558)&&ih(13);var o=ch(e,r+8);if(!o)return{};var a=uh(e,r+16),i=4294967295==a;i&&(r=uh(e,r-12),101075792!=uh(e,r)&&ih(13),o=uh(e,r+32),a=uh(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=bh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Th(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=ph(e.subarray(h,h+d),new Bm(p)):ih(14,&quot;unknown compression type &quot;+u):n[f]=oh(e,h,h+d))}return n}function Sh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?&quot;LittleEndian&quot;:2712847316===n[0]?&quot;BigEndian&quot;:null}&quot;function&quot;==typeof queueMicrotask?queueMicrotask:&quot;function&quot;==typeof setTimeout&&setTimeout;var Ah=Sh(),Ih=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:wh,vtkDebugMacro:Ph}=jt;let Oh=0;function Rh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener(&quot;progress&quot;,n.progressCallback),r}const Mh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;);const s=Rh(&quot;GET&quot;,i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(Ph(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&wh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||&quot;string&quot;!==n.dataType?&quot;arraybuffer&quot;:&quot;text&quot;,s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(yh(mh(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&&quot;gz&quot;!==n.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Rh(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(yh(mh(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&&quot;gz&quot;!==t.compression&&(wh(&quot;Supported algorithms are: [gz]&quot;),wh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Rh(&quot;GET&quot;,e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(mh(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType=&quot;arraybuffer&quot;,o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};Vm(&quot;http&quot;,(e=>Mh));const{vtkDebugMacro:Dh}=jt;function Eh(e,t){t.classHierarchy.push(&quot;vtkCamera&quot;);const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Dh(&quot;Distance is set to minimum.&quot;);const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Gi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Gi(o,[...t.position,1],n),Gi(a,[...t.focalPoint,1],n),Gi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Dh(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=Hi(e[0],e[1],e[2],e[3]),n=Ui(),r=Hi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],Wi(r,t,r),Wi(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error(&quot;Off-Axis projection is not supported at this time&quot;);{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=Ui();zi(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const Vh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Lh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vh,n),jt.obj(e,t),jt.get(e,t,[&quot;distance&quot;]),jt.setGet(e,t,[&quot;parallelProjection&quot;,&quot;useHorizontalViewAngle&quot;,&quot;viewAngle&quot;,&quot;parallelScale&quot;,&quot;useOffAxisProjection&quot;,&quot;freezeFocalPoint&quot;,&quot;physicalScale&quot;]),jt.getArray(e,t,[&quot;directionOfProjection&quot;,&quot;viewPlaneNormal&quot;,&quot;position&quot;,&quot;focalPoint&quot;]),jt.setGetArray(e,t,[&quot;clippingRange&quot;,&quot;windowCenter&quot;],2),jt.setGetArray(e,t,[&quot;viewUp&quot;,&quot;screenBottomLeft&quot;,&quot;screenBottomRight&quot;,&quot;screenTopRight&quot;,&quot;physicalTranslation&quot;,&quot;physicalViewUp&quot;,&quot;physicalViewNorth&quot;],3),Eh(e,t)}var Bh={newInstance:jt.newInstance(Lh,&quot;vtkCamera&quot;),extend:Lh};function Nh(e,t){t.classHierarchy.push(&quot;vtkLight&quot;);const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType(&quot;HeadLight&quot;)},e.setLightTypeToCameraLight=()=>{e.setLightType(&quot;CameraLight&quot;)},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType(&quot;SceneLight&quot;)},e.lightTypeIsHeadLight=()=>&quot;HeadLight&quot;===t.lightType,e.lightTypeIsSceneLight=()=>&quot;SceneLight&quot;===t.lightType,e.lightTypeIsCameraLight=()=>&quot;CameraLight&quot;===t.lightType}const _h={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:&quot;SceneLight&quot;,shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_h,n),jt.obj(e,t),jt.setGet(e,t,[&quot;intensity&quot;,&quot;switch&quot;,&quot;positional&quot;,&quot;exponent&quot;,&quot;coneAngle&quot;,&quot;coneFalloff&quot;,&quot;transformMatrix&quot;,&quot;lightType&quot;,&quot;shadowAttenuation&quot;,&quot;attenuationValues&quot;]),jt.setGetArray(e,t,[&quot;color&quot;,&quot;position&quot;,&quot;focalPoint&quot;,&quot;attenuationValues&quot;],3),Nh(e,t)}var kh={newInstance:jt.newInstance(Fh,&quot;vtkLight&quot;),extend:Fh,LIGHT_TYPES:[&quot;HeadLight&quot;,&quot;CameraLight&quot;,&quot;SceneLight&quot;]};const{vtkErrorMacro:Gh}=jt;function Uh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push(&quot;vtkViewport&quot;),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Gh(&quot;call displayToView on your view instead&quot;),e.viewToDisplay=()=>Gh(&quot;callviewtodisplay on your view instead&quot;),e.getSize=()=>Gh(&quot;call getSize on your View instead&quot;),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=(&quot;PickPropFrom&quot;,()=>Gh(&quot;vtkViewport::PickPropFrom - NOT IMPLEMENTED&quot;))}const zh={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function Wh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zh,n),jt.obj(e,t),jt.event(e,t,&quot;event&quot;),jt.setGetArray(e,t,[&quot;viewport&quot;],4),jt.setGetArray(e,t,[&quot;background&quot;,&quot;background2&quot;],3),Uh(e,t)}var Hh={newInstance:jt.newInstance(Wh,&quot;vtkViewport&quot;),extend:Wh};const{vtkDebugMacro:jh,vtkErrorMacro:Kh,vtkWarningMacro:$h}=Kt;function qh(e){return()=>Kh(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function Xh(e,t){t.classHierarchy.push(&quot;vtkRenderer&quot;);const n={type:&quot;ComputeVisiblePropBoundsEvent&quot;,renderer:e},r={type:&quot;ResetCameraClippingRangeEvent&quot;,renderer:e},o={type:&quot;ResetCameraEvent&quot;,renderer:e};e.updateCamera=()=>(t.activeCamera||(jh(&quot;No cameras are on, creating one.&quot;),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Kh(&quot;light has unknown light type&quot;,e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=qh(&quot;allocateTime&quot;),e.updateGeometry=qh(&quot;updateGeometry&quot;),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{jh(e.getClassName(),e,&quot;setting Layer to &quot;,n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:&quot;ActiveCameraEvent&quot;,camera:n}),!0),e.makeCamera=()=>{const t=Bh.newInstance();return e.invokeEvent({type:&quot;CreateCameraEvent&quot;,camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=kh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Kh(&quot;WorldToView: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Kh(&quot;ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=ki.INIT_BOUNDS[0],t.allBounds[1]=ki.INIT_BOUNDS[1],t.allBounds[2]=ki.INIT_BOUNDS[2],t.allBounds[3]=ki.INIT_BOUNDS[3],t.allBounds[4]=ki.INIT_BOUNDS[4],t.allBounds[5]=ki.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),jh(&quot;Can't compute bounds, no 3D props are visible&quot;)),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return jh(&quot;Cannot reset camera!&quot;),!1;let i=null;if(!e.getActiveCamera())return Kh(&quot;Trying to reset non-existent camera&quot;),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&($h(&quot;Resetting view-up since view plane normal is parallel&quot;),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return jh(&quot;Cannot reset camera clipping range!&quot;),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Kh(&quot;Trying to reset clipping range of non-existent camera&quot;),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const Yh={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Zh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Yh,n),Hh.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,[&quot;_renderWindow&quot;,&quot;allocatedRenderTime&quot;,&quot;timeFactor&quot;,&quot;lastRenderTimeInSeconds&quot;,&quot;numberOfPropsRendered&quot;,&quot;lastRenderingUsedDepthPeeling&quot;,&quot;selector&quot;]),At(e,t,[&quot;twoSidedLighting&quot;,&quot;lightFollowCamera&quot;,&quot;automaticLightCreation&quot;,&quot;erase&quot;,&quot;draw&quot;,&quot;nearClippingPlaneTolerance&quot;,&quot;clippingRangeExpansion&quot;,&quot;backingStore&quot;,&quot;interactive&quot;,&quot;layer&quot;,&quot;preserveColorBuffer&quot;,&quot;preserveDepthBuffer&quot;,&quot;useDepthPeeling&quot;,&quot;occlusionRatio&quot;,&quot;maximumNumberOfPeels&quot;,&quot;delegate&quot;,&quot;backgroundTexture&quot;,&quot;texturedBackground&quot;,&quot;environmentTexture&quot;,&quot;environmentTextureDiffuseStrength&quot;,&quot;environmentTextureSpecularStrength&quot;,&quot;useEnvironmentTextureAsBackground&quot;,&quot;useShadows&quot;,&quot;pass&quot;]),It(e,t,[&quot;actors&quot;,&quot;volumes&quot;,&quot;lights&quot;]),Pt(e,t,[&quot;background&quot;],4,1),Ot(0,t,[&quot;renderWindow&quot;]),Xh(e,t)}var Qh={newInstance:Et(Zh,&quot;vtkRenderer&quot;),extend:Zh};const Jh=Object.create(null);function ev(e,t){Jh[e]=t}function tv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Jh[e]&&Jh[e](t)}function nv(e,t){t.classHierarchy.push(&quot;vtkRenderWindow&quot;),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return tv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6;const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join(&quot;\\n&quot;),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))}}const rv={defaultViewAPI:&quot;WebGL&quot;,renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1};function ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rv,n),jt.obj(e,t),jt.setGet(e,t,[&quot;interactor&quot;,&quot;numberOfLayers&quot;,&quot;_views&quot;,&quot;defaultViewAPI&quot;]),jt.get(e,t,[&quot;neverRendered&quot;]),jt.getArray(e,t,[&quot;renderers&quot;]),jt.moveToProtected(e,t,[&quot;views&quot;]),jt.event(e,t,&quot;completion&quot;),nv(e,t)}var av={newInstance:jt.newInstance(ov,&quot;vtkRenderWindow&quot;),extend:ov,registerViewConstructor:ev,listViewAPIs:function(){return Object.keys(Jh)},newAPISpecificView:tv};const iv={Unknown:0,LeftController:1,RightController:2},sv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var lv={Device:iv,Input:sv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:cv,Input:uv}=lv,{vtkWarningMacro:dv,vtkErrorMacro:pv,normalizeWheel:fv,vtkOnceErrorMacro:gv}=jt,mv={ctrlKey:!1,altKey:!1,shiftKey:!1},hv={&quot;xr-standard&quot;:[uv.Trigger,uv.Grip,uv.TrackPad,uv.Thumbstick,uv.A,uv.B]},vv=[&quot;StartAnimation&quot;,&quot;Animation&quot;,&quot;EndAnimation&quot;,&quot;PointerEnter&quot;,&quot;PointerLeave&quot;,&quot;MouseEnter&quot;,&quot;MouseLeave&quot;,&quot;StartMouseMove&quot;,&quot;MouseMove&quot;,&quot;EndMouseMove&quot;,&quot;LeftButtonPress&quot;,&quot;LeftButtonRelease&quot;,&quot;MiddleButtonPress&quot;,&quot;MiddleButtonRelease&quot;,&quot;RightButtonPress&quot;,&quot;RightButtonRelease&quot;,&quot;KeyPress&quot;,&quot;KeyDown&quot;,&quot;KeyUp&quot;,&quot;StartMouseWheel&quot;,&quot;MouseWheel&quot;,&quot;EndMouseWheel&quot;,&quot;StartPinch&quot;,&quot;Pinch&quot;,&quot;EndPinch&quot;,&quot;StartPan&quot;,&quot;Pan&quot;,&quot;EndPan&quot;,&quot;StartRotate&quot;,&quot;Rotate&quot;,&quot;EndRotate&quot;,&quot;Button3D&quot;,&quot;Move3D&quot;,&quot;StartPointerLock&quot;,&quot;EndPointerLock&quot;,&quot;StartInteraction&quot;,&quot;Interaction&quot;,&quot;EndInteraction&quot;,&quot;AnimationFrameRateUpdate&quot;];function yv(e){e.cancelable&&e.preventDefault()}function Tv(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function bv(e,t){t.classHierarchy.push(&quot;vtkRenderWindowInteractor&quot;);const n=new Set,r=new Map;let o=1;function a(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{pv(&quot;you want to call setView(view) instead of setRenderWindow on a vtk.js interactor&quot;)},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>dv(&quot;empty event loop&quot;),e.getCurrentRenderer=()=>(t.currentRenderer||a(0,0),t.currentRenderer);const i=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),o=n.getBoundingClientRect(),i=n.width/o.width,s=n.height/o.height,l={x:i*(e.clientX-o.left),y:s*(o.height-e.clientY+o.top),z:0};return(r.size<=1||!t.currentRenderer)&&a(l.x,l.y),l};function s(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function l(e){const t=s(e);return{key:e.key,keyCode:e.charCode,...t}}function c(e){return e.pointerType||&quot;&quot;}function u(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.bindEvents=n=>{t.container=n,n.addEventListener(&quot;contextmenu&quot;,yv),n.addEventListener(&quot;wheel&quot;,e.handleWheel),n.addEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.addEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.addEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.addEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.addEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.addEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.addEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.addEventListener(&quot;keypress&quot;,e.handleKeyPress),document.addEventListener(&quot;keydown&quot;,e.handleKeyDown),document.addEventListener(&quot;keyup&quot;,e.handleKeyUp),document.addEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),n.style.touchAction=&quot;none&quot;,n.style.userSelect=&quot;none&quot;,n.style.webkitTapHighlightColor=&quot;rgba(0,0,0,0)&quot;},e.unbindEvents=()=>{const{container:n}=t;n.removeEventListener(&quot;contextmenu&quot;,yv),n.removeEventListener(&quot;wheel&quot;,e.handleWheel),n.removeEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.removeEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.removeEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.removeEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.removeEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.removeEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.removeEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),document.removeEventListener(&quot;keypress&quot;,e.handleKeyPress),document.removeEventListener(&quot;keydown&quot;,e.handleKeyDown),document.removeEventListener(&quot;keyup&quot;,e.handleKeyUp),document.removeEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),t.container=null,r.clear()},e.handleKeyPress=t=>{const n=l(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=l(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=l(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerEnterEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...s(t),position:i(t),deviceType:c(t)};e.pointerLeaveEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&yv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),r.has(n.pointerId)&&dv(&quot;[RenderWindowInteractor] duplicate pointerId detected&quot;),r.set(n.pointerId,{pointerId:n.pointerId,position:i(n)}),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(r.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&yv(n),r.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(r.has(t.pointerId))switch(r.delete(t.pointerId),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(r.has(t.pointerId)&&(r.get(t.pointerId).position=i(t)),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:pv(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=r=>{void 0!==r?n.has(r)?dv(&quot;requester is already registered for animating&quot;):(n.add(r),t.animationRequest||1!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):pv(&quot;undefined requester, can not start animating&quot;)},e.extendAnimation=r=>{const o=Date.now()+r;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==n.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(r){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.has(r))n.delete(r),t.animationRequest&&0===n.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=r&&r.getClassName?r.getClassName():r;dv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==n.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=n.gamepad,s=n.handedness;if(i){i.index in t.lastGamepadValues||(t.lastGamepadValues[i.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<i.buttons.length;++r)r in t.lastGamepadValues[i.index][s].buttons||(t.lastGamepadValues[i.index][s].buttons[r]=!1),t.lastGamepadValues[i.index][s].buttons[r]!==i.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,pressed:i.buttons[r].pressed,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController,input:hv[i.mapping]&&hv[i.mapping][r]?hv[i.mapping][r]:uv.Trigger}),t.lastGamepadValues[i.index][s].buttons[r]=i.buttons[r].pressed),t.lastGamepadValues[i.index][s].buttons[r]&&null!=a&&e.move3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,device:&quot;left&quot;===n.handedness?cv.LeftController:cv.RightController})}}))},e.handleMouseMove=n=>{const r={...s(n),position:i(n),deviceType:c(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const r=Date.now();t._animationFrameCount++,r-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(r-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=r,t._animationFrameCount=1),e.animationEvent(),u(),n.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{yv(n);const r={...fv(n),...s(n),position:i(n),deviceType:c(n)};0===t.wheelTimeoutID&&(o=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=o,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...s(t),position:i(t),deviceType:c(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:pv(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);if(2===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture(&quot;TouchStart&quot;,t)}else if(1===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const o=[...r.values()];if(t.recognizeGestures&&o.length>1){const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const o=[...r.values()];if(t.recognizeGestures)if(0===o.length){const t={...s(mv),position:i(n),deviceType:c(n)};e.leftButtonReleaseEvent(t)}else if(1===o.length){const t=Tv(r);e.recognizeGesture(&quot;TouchEnd&quot;,t);const a={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonPressEvent(a)}else{const t=Tv(r);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===o.length){const t={...s(mv),position:o[0].position,deviceType:c(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||u()},vv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void gv(&quot;\\n          Can not forward events without a current renderer on the interactor.\\n        &quot;);const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),&quot;TouchStart&quot;===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture=&quot;Start&quot;);if(&quot;TouchEnd&quot;===n)return&quot;Pinch&quot;===t.currentGesture&&(e.render(),e.endPinchEvent()),&quot;Rotate&quot;===t.currentGesture&&(e.render(),e.endRotateEvent()),&quot;Pan&quot;===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture=&quot;Start&quot;,void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,&quot;TouchMove&quot;===n)if(&quot;Start&quot;===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture=&quot;Pinch&quot;;const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture=&quot;Rotate&quot;;const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture=&quot;Pan&quot;;const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if(&quot;Rotate&quot;===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if(&quot;Pinch&quot;===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if(&quot;Pan&quot;===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e};const d=e.delete;e.delete=()=>{for(;n.size;)e.cancelAnimation(n.values().next().value);void 0!==document.hidden&&document.removeEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange),t.container&&e.unbindEvents(),d()},void 0!==document.hidden&&document.addEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange,!1)}const xv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:&quot;Start&quot;,animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,&quot;RenderEvent&quot;),vv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,[&quot;initialized&quot;,&quot;container&quot;,&quot;interactorStyle&quot;,&quot;lastFrameTime&quot;,&quot;recentAnimationFrameRate&quot;,&quot;_view&quot;]),jt.setGet(e,t,[&quot;lightFollowCamera&quot;,&quot;enabled&quot;,&quot;enableRender&quot;,&quot;recognizeGestures&quot;,&quot;desiredUpdateRate&quot;,&quot;stillUpdateRate&quot;,&quot;picker&quot;,&quot;preventDefaultOnPointerDown&quot;,&quot;preventDefaultOnPointerUp&quot;,&quot;mouseScrollDebounceByPass&quot;]),jt.moveToProtected(e,t,[&quot;view&quot;]),bv(e,t)}var Sv={newInstance:jt.newInstance(Cv,&quot;vtkRenderWindowInteractor&quot;),extend:Cv,handledEvents:vv,...lv};const{vtkErrorMacro:Av,VOID:Iv}=jt;function wv(e,t){t.classHierarchy.push(&quot;vtkInteractorObserver&quot;);const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Sv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):Iv),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Av(&quot;\\n          The interactor must be set before subscribing to events\\n        &quot;)),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const Pv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pv,n),jt.obj(e,t),jt.event(e,t,&quot;InteractionEvent&quot;),jt.event(e,t,&quot;StartInteractionEvent&quot;),jt.event(e,t,&quot;EndInteractionEvent&quot;),jt.get(e,t,[&quot;_interactor&quot;,&quot;enabled&quot;]),jt.setGet(e,t,[&quot;priority&quot;,&quot;processEvents&quot;]),jt.moveToProtected(e,t,[&quot;interactor&quot;]),wv(e,t)}var Rv={newInstance:jt.newInstance(Ov,&quot;vtkInteractorObserver&quot;),extend:Ov,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},Mv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Dv}=Mv,Ev={Rotate:Dv.IS_ROTATE,Pan:Dv.IS_PAN,Spin:Dv.IS_SPIN,Dolly:Dv.IS_DOLLY,CameraPose:Dv.IS_CAMERA_POSE,WindowLevel:Dv.IS_WINDOW_LEVEL,Slice:Dv.IS_SLICE};function Vv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyle&quot;),Object.keys(Ev).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Dv.IS_NONE&&(t.state=Ev[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:&quot;StartInteractionEvent&quot;}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Ev[n]&&(t.state=Dv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:&quot;EndInteractionEvent&quot;}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case&quot;r&quot;:case&quot;R&quot;:e.pokedRenderer.resetCamera(),n.render();break;case&quot;w&quot;:case&quot;W&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case&quot;s&quot;:case&quot;S&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case&quot;v&quot;:case&quot;V&quot;:r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Lv={state:Dv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function Bv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lv,n),Rv.extend(e,t,n),Vv(e,t)}var Nv={newInstance:jt.newInstance(Bv,&quot;vtkInteractorStyle&quot;),extend:Bv,...Mv};const{States:_v}=Mv;function Fv(e,t){t.classHierarchy.push(&quot;vtkInteractorStyleTrackballCamera&quot;),e.handleMouseMove=n=>{const r=n.position,o=n.pokedRenderer;switch(t.state){case _v.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case _v.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad?!n||n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad||t.state!==_v.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===_v.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const t=e.pokedRenderer.getActiveCamera(),n=t.getPhysicalTranslation(),r=.025*t.getPhysicalScale(),o=t.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);t.setPhysicalTranslation(n[0]+o[0]*r,n[1]+o[1]*r,n[2]+o[2]*r)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case _v.IS_DOLLY:e.endDolly();break;case _v.IS_PAN:e.endPan();break;case _v.IS_SPIN:e.endSpin();break;case _v.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(n.pokedRenderer,n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=n.pokedRenderer.getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(n.pokedRenderer,o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(n.pokedRenderer,o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(n.pokedRenderer,o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&n.pokedRenderer.updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=e.pokedRenderer.getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(n.pokedRenderer,r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const kv={motionFactor:10,zoomFactor:10};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Nv.extend(e,t,n),jt.setGet(e,t,[&quot;motionFactor&quot;,&quot;zoomFactor&quot;]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,&quot;vtkInteractorStyleTrackballCamera&quot;),extend:Gv};function zv(e){return e}function Wv(e){return null===e||&quot;null&quot;===e?null:&quot;true&quot;===e||&quot;false&quot;!==e&&(void 0!==e&&&quot;undefined&quot;!==e?&quot;[&quot;===e[0]&&&quot;]&quot;===e[e.length-1]?e.substring(1,e.length-1).split(&quot;,&quot;).map((e=>Wv(e.trim()))):&quot;&quot;===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var Hv=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?Wv:zv,o=(t||&quot;&quot;).replace(/#.*/,&quot;&quot;).replace(&quot;?&quot;,&quot;&quot;).split(&quot;&&quot;);return o.forEach((e=>{const[t,o]=e.split(&quot;=&quot;).map((e=>decodeURIComponent(e)));t&&(n[t]=!o||r(o))})),n};function jv(e,t){t.classHierarchy.push(&quot;vtkRenderPass&quot;),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const Kv={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),jt.obj(e,t),jt.get(e,t,[&quot;currentOperation&quot;]),jt.setGet(e,t,[&quot;delegates&quot;,&quot;_currentParent&quot;,&quot;preDelegateOperations&quot;,&quot;postDelegateOperations&quot;]),jt.moveToProtected(e,t,[&quot;currentParent&quot;]),jv(e,t)}var qv={newInstance:jt.newInstance($v,&quot;vtkRenderPass&quot;),extend:$v};const{Representation:Xv}=ds,{vtkErrorMacro:Yv}=jt;function Zv(e){const t=cd.substitute(e.Fragment,&quot;//VTK::RenderPassFragmentShader::Impl&quot;,&quot;\\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\\n      gl_FragData[1].r = weight;\\n    &quot;,!1);e.Fragment=t.result}function Qv(e,t){t.classHierarchy.push(&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Es.newInstance({numberOfComponents:3,values:e});o.setName(&quot;points&quot;);const a=Es.newInstance({numberOfComponents:2,values:n});a.setName(&quot;tcoords&quot;);const i=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,&quot;polys&quot;,Xv.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Nd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,&quot;Float32Array&quot;,null),t.translucentRTexture=Nd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,&quot;Float32Array&quot;,null),t.translucentZTexture=Nd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],&quot;Float32Array&quot;,null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;attribute vec2 tcoordTC;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = tcoordTC; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),&quot;//VTK::System::Dec\\n\\nin vec2 tcoord;\\n\\nuniform sampler2D translucentRTexture;\\nuniform sampler2D translucentRGBATexture;\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\\n  float t2Color = texture(translucentRTexture, tcoord).r;\\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\\n}\\n&quot;,&quot;&quot;)},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;tcoordTC&quot;,t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||Yv(&quot;Error setting vertexDC in copy shader VAO.&quot;)},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension(&quot;EXT_color_buffer_half_float&quot;)&&!i.getExtension(&quot;EXT_color_buffer_float&quot;))return e.setCurrentOperation(&quot;translucentPass&quot;),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation(&quot;opaqueZBufferPass&quot;),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation(&quot;translucentPass&quot;),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi(&quot;translucentRGBATexture&quot;,t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi(&quot;translucentRTexture&quot;,t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate()},e.getShaderReplacement=()=>t._supported?Zv:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const Jv={framebuffer:null,copyShader:null,tris:null};function ey(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jv,n),qv.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),jt.get(e,t,[&quot;framebuffer&quot;]),Qv(e,t)}var ty={newInstance:jt.newInstance(ey,&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),extend:ey};function ny(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];if(s.getDraw()&&s.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=Hp.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation(&quot;zBufferPass&quot;),i.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation(&quot;opaquePass&quot;),i.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=ty.newInstance()),t.translucentPass.traverse(n,i,e)),t.volumeCount>0&&(e.setCurrentOperation(&quot;volumePass&quot;),i.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation(&quot;overlayPass&quot;),i.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const ry={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ry,n),qv.extend(e,t,n),jt.get(e,t,[&quot;framebuffer&quot;,&quot;opaqueActorCount&quot;,&quot;translucentActorCount&quot;,&quot;volumeCount&quot;]),ny(e,t)}var ay={newInstance:jt.newInstance(oy,&quot;vtkForwardPass&quot;),extend:oy},iy=n(594),sy=n.n(iy);const ly=[&quot;lastShaderProgramBound&quot;,&quot;context&quot;,&quot;_openGLRenderWindow&quot;];function cy(e,t){t.classHierarchy.push(&quot;vtkShaderCache&quot;),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=cd.substitute(o,&quot;VSOut&quot;,&quot;GSOut&quot;).result);const a=t._openGLRenderWindow.getWebgl2();let i=&quot;\\n&quot;,s=&quot;#version 100\\n&quot;;a?s=&quot;#version 300 es\\n#define attribute in\\n#define textureCube texture\\n#define texture2D texture\\n#define textureCubeLod textureLod\\n#define texture2DLod textureLod\\n&quot;:(t.context.getExtension(&quot;OES_standard_derivatives&quot;),t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(i=&quot;#extension GL_EXT_frag_depth : enable\\n&quot;),t.context.getExtension(&quot;EXT_shader_texture_lod&quot;)&&(i+=&quot;#extension GL_EXT_shader_texture_lod : enable\\n#define textureCubeLod textureCubeLodEXT\\n#define texture2DLod texture2DLodEXT&quot;)),o=cd.substitute(o,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,a?&quot;&quot;:&quot;#extension GL_OES_standard_derivatives : enable\\n&quot;,i,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;let l=cd.substitute(e,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;if(a){l=cd.substitute(l,&quot;varying&quot;,&quot;out&quot;).result,o=cd.substitute(o,&quot;varying&quot;,&quot;in&quot;).result;let e=&quot;&quot;,t=0;for(;o.includes(`gl_FragData[${t}]`);)o=cd.substitute(o,`gl_FragData\\\\[${t}\\\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\\n`,t++;o=cd.substitute(o,&quot;//VTK::Output::Dec&quot;,e).result}return{VSSource:l,FSSource:o,GSSource:cd.substitute(r,&quot;//VTK::System::Dec&quot;,s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=sy().hash(o);if(!(a in t.shaderPrograms)){const o=cd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const uy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,ly),jt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),cy(e,t)}var py={newInstance:jt.newInstance(dy,&quot;vtkShaderCache&quot;),extend:dy};const{vtkErrorMacro:fy}=jt;function gy(e,t){t.classHierarchy.push(&quot;vtkOpenGLTextureUnitManager&quot;),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&fy(&quot;some texture units  were not properly released&quot;);t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const my={context:null,numberOfTextureUnits:0,textureUnits:0};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,[&quot;numberOfTextureUnits&quot;]),jt.setGet(e,t,[&quot;context&quot;]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,&quot;vtkOpenGLTextureUnitManager&quot;),extend:hy};function yy(e,t){t.classHierarchy.push(&quot;vtkRenderWindowViewNode&quot;),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro(&quot;not implemented&quot;)},e.createSelector=()=>{jt.vtkErrorMacro(&quot;not implemented&quot;)}}const Ty={size:void 0,selector:void 0};function by(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ty,n),t.size||(t.size=[300,300]),jt.getArray(e,t,[&quot;size&quot;],2),jt.get(e,t,[&quot;selector&quot;]),Zt.extend(e,t,n),yy(e,t)}var xy={newInstance:jt.newInstance(by,&quot;vtkRenderWindowViewNode&quot;),extend:by};const{vtkDebugMacro:Cy,vtkErrorMacro:Sy}=jt,Ay={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Iy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let wy=0;const Py=[];function Oy(){wy++,Py.forEach((e=>e(wy)))}function Ry(){wy--,Py.forEach((e=>e(wy)))}function My(e){e.preventDefault()}function Dy(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderWindow&quot;);const n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if(&quot;__getUnderlyingContext&quot;===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}();e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener(&quot;webglcontextlost&quot;,My,!1),t.canvas.addEventListener(&quot;webglcontextrestored&quot;,e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow(e)}))}},e.initialize=()=>{if(!t.initialized){t.context=e.get3DContext(),t.textureUnitManager=vy.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND),t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Sy(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.activeFramebuffer?t.activeFramebuffer.getSize():t.size,e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:&quot;high-performance&quot;},r=null;const o=&quot;undefined&quot;!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext(&quot;webgl2&quot;,e),r&&(t.webgl2=!0,Cy(&quot;using webgl2&quot;))),r||(Cy(&quot;using webgl1&quot;),r=t.canvas.getContext(&quot;webgl&quot;,e)||t.canvas.getContext(&quot;experimental-webgl&quot;,e)),new Proxy(r,n)},e.restoreContext=()=>{const t=qv.newInstance();t.setCurrentOperation(&quot;Release&quot;),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?Sy(&quot;Hardware does not support the number of textures defined.&quot;):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case ys.CHAR:case ys.SIGNED_CHAR:case ys.UNSIGNED_CHAR:return 1;case n:case r:case ys.UNSIGNED_SHORT:case ys.SHORT:case ys.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case ys.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&ys.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&ys.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return t.context.R16F;case 2:return t.context.RG16F;case 3:return t.context.RGB16F;default:return t.context.RGBA16F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Ay,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension(&quot;OES_texture_float&quot;),o=n.getExtension(&quot;OES_texture_half_float&quot;),a=n.getExtension(&quot;WEBGL_debug_renderer_info&quot;),i=n.getExtension(&quot;WEBGL_draw_buffers&quot;),s=n.getExtension(&quot;EXT_texture_filter_anisotropic&quot;)||n.getExtension(&quot;WEBKIT_EXT_texture_filter_anisotropic&quot;),l=[[&quot;Max Vertex Attributes&quot;,&quot;MAX_VERTEX_ATTRIBS&quot;,n.getParameter(n.MAX_VERTEX_ATTRIBS)],[&quot;Max Varying Vectors&quot;,&quot;MAX_VARYING_VECTORS&quot;,n.getParameter(n.MAX_VARYING_VECTORS)],[&quot;Max Vertex Uniform Vectors&quot;,&quot;MAX_VERTEX_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],[&quot;Max Fragment Uniform Vectors&quot;,&quot;MAX_FRAGMENT_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],[&quot;Max Fragment Texture Image Units&quot;,&quot;MAX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],[&quot;Max Vertex Texture Image Units&quot;,&quot;MAX_VERTEX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],[&quot;Max Combined Texture Image Units&quot;,&quot;MAX_COMBINED_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],[&quot;Max 2D Texture Size&quot;,&quot;MAX_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_TEXTURE_SIZE)],[&quot;Max Cube Texture Size&quot;,&quot;MAX_CUBE_MAP_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],[&quot;Max Texture Anisotropy&quot;,&quot;MAX_TEXTURE_MAX_ANISOTROPY_EXT&quot;,s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],[&quot;Point Size Range&quot;,&quot;ALIASED_POINT_SIZE_RANGE&quot;,n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(&quot; - &quot;)],[&quot;Line Width Range&quot;,&quot;ALIASED_LINE_WIDTH_RANGE&quot;,n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(&quot; - &quot;)],[&quot;Max Viewport Dimensions&quot;,&quot;MAX_VIEWPORT_DIMS&quot;,n.getParameter(n.MAX_VIEWPORT_DIMS).join(&quot; - &quot;)],[&quot;Max Renderbuffer Size&quot;,&quot;MAX_RENDERBUFFER_SIZE&quot;,n.getParameter(n.MAX_RENDERBUFFER_SIZE)],[&quot;Framebuffer Red Bits&quot;,&quot;RED_BITS&quot;,n.getParameter(n.RED_BITS)],[&quot;Framebuffer Green Bits&quot;,&quot;GREEN_BITS&quot;,n.getParameter(n.GREEN_BITS)],[&quot;Framebuffer Blue Bits&quot;,&quot;BLUE_BITS&quot;,n.getParameter(n.BLUE_BITS)],[&quot;Framebuffer Alpha Bits&quot;,&quot;ALPHA_BITS&quot;,n.getParameter(n.ALPHA_BITS)],[&quot;Framebuffer Depth Bits&quot;,&quot;DEPTH_BITS&quot;,n.getParameter(n.DEPTH_BITS)],[&quot;Framebuffer Stencil Bits&quot;,&quot;STENCIL_BITS&quot;,n.getParameter(n.STENCIL_BITS)],[&quot;Framebuffer Subpixel Bits&quot;,&quot;SUBPIXEL_BITS&quot;,n.getParameter(n.SUBPIXEL_BITS)],[&quot;MSAA Samples&quot;,&quot;SAMPLES&quot;,n.getParameter(n.SAMPLES)],[&quot;MSAA Sample Buffers&quot;,&quot;SAMPLE_BUFFERS&quot;,n.getParameter(n.SAMPLE_BUFFERS)],[&quot;Supported Formats for UByte Render Targets     &quot;,&quot;UNSIGNED_BYTE RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.UNSIGNED_BYTE)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.UNSIGNED_BYTE)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.UNSIGNED_BYTE)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Half Float Render Targets&quot;,&quot;HALF FLOAT RENDER TARGET FORMATS&quot;,[o&&Iy(n,n.RGBA,o.HALF_FLOAT_OES)?&quot;RGBA&quot;:&quot;&quot;,o&&Iy(n,n.RGB,o.HALF_FLOAT_OES)?&quot;RGB&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?&quot;LUMINANCE&quot;:&quot;&quot;,o&&Iy(n,n.ALPHA,o.HALF_FLOAT_OES)?&quot;ALPHA&quot;:&quot;&quot;,o&&Iy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Full Float Render Targets&quot;,&quot;FLOAT RENDER TARGET FORMATS&quot;,[r&&Iy(n,n.RGBA,n.FLOAT)?&quot;RGBA&quot;:&quot;&quot;,r&&Iy(n,n.RGB,n.FLOAT)?&quot;RGB&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE,n.FLOAT)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&Iy(n,n.ALPHA,n.FLOAT)?&quot;ALPHA&quot;:&quot;&quot;,r&&Iy(n,n.LUMINANCE_ALPHA,n.FLOAT)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Max Multiple Render Targets Buffers&quot;,&quot;MAX_DRAW_BUFFERS_WEBGL&quot;,i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],[&quot;High Float Precision in Vertex Shader&quot;,&quot;HIGH_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Vertex Shader&quot;,&quot;MEDIUM_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Vertex Shader&quot;,&quot;LOW_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Float Precision in Fragment Shader&quot;,&quot;HIGH_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Fragment Shader&quot;,&quot;MEDIUM_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Fragment Shader&quot;,&quot;LOW_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Vertex Shader&quot;,&quot;HIGH_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Vertex Shader&quot;,&quot;MEDIUM_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Vertex Shader&quot;,&quot;LOW_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Fragment Shader&quot;,&quot;HIGH_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Fragment Shader&quot;,&quot;MEDIUM_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Fragment Shader&quot;,&quot;LOW_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Supported Extensions&quot;,&quot;EXTENSIONS&quot;,n.getSupportedExtensions().join(&quot;<br/>\\t\\t\\t\\t\\t    &quot;)],[&quot;WebGL Renderer&quot;,&quot;RENDERER&quot;,n.getParameter(n.RENDERER)],[&quot;WebGL Vendor&quot;,&quot;VENDOR&quot;,n.getParameter(n.VENDOR)],[&quot;WebGL Version&quot;,&quot;VERSION&quot;,n.getParameter(n.VERSION)],[&quot;Shading Language Version&quot;,&quot;SHADING_LANGUAGE_VERSION&quot;,n.getParameter(n.SHADING_LANGUAGE_VERSION)],[&quot;Unmasked Renderer&quot;,&quot;UNMASKED_RENDERER&quot;,a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],[&quot;Unmasked Vendor&quot;,&quot;UNMASKED_VENDOR&quot;,a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],[&quot;WebGL Version&quot;,&quot;WEBGL_VERSION&quot;,t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}()},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=df.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((function(){t.canvas.removeEventListener(&quot;webglcontextlost&quot;,My),t.canvas.removeEventListener(&quot;webglcontextrestored&quot;,e.restoreContext)}),e.delete,e.setViewStream,Ry),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.getGraphicsResourceForObject=e=>e?{vtkObj:t._graphicsResources.get(e),hash:t._graphicsResourceHash.get(e)}:null,e.setGraphicsResourceForObject=(e,n,r)=>{e&&(t._graphicsResources.set(e,n),t._graphicsResourceHash.set(e,r))},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach(((t,n)=>{e+=t.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResourcesForObject=n=>!!n&&(t._graphicsResources.get(n)?.releaseGraphicsResources(e),t._graphicsResources.delete(n)&&t._graphicsResourceHash.delete(n)),e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach(((t,n)=>{t.releaseGraphicsResources(e)})),t._graphicsResources.clear(),t._graphicsResourceHash.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))}}const Ey={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1};const Vy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),xy.extend(e,t,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,Oy(),t.selector||(t.selector=df.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,t._textureResourceIds=new Map,t._graphicsResources=new Map,t._graphicsResourceHash=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Vy),t.shaderCache=py.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=ay.newInstance(),jt.event(e,t,&quot;imageReady&quot;),jt.get(e,t,[&quot;shaderCache&quot;,&quot;textureUnitManager&quot;,&quot;webgl2&quot;,&quot;useBackgroundImage&quot;,&quot;activeFramebuffer&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;defaultToWebgl2&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Dy(e,t)}),&quot;vtkOpenGLRenderWindow&quot;);function Ly(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderModule&quot;),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}ev(&quot;WebGL&quot;,Vy);const By={device:null,handle:null};function Ny(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,By,n),jt.obj(e,t),jt.get(e,t,[&quot;lastCameraMTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;handle&quot;]),Ly(e,t)}var _y={newInstance:jt.newInstance(Ny,&quot;vtkWebGPUShaderModule&quot;),extend:Ny};function Fy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderCache&quot;),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=_y.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const ky={shaderModules:null,device:null,window:null};function Gy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ky,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;,&quot;window&quot;]),Fy(e,t)}var Uy={newInstance:jt.newInstance(Gy,&quot;vtkWebGPUShaderCache&quot;),extend:Gy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join(&quot;\\n&quot;):n;let a=!1;-1!==e.search(t)&&(a=!0);let i=&quot;&quot;;r&&(i=&quot;g&quot;);const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function zy(e,t){t.classHierarchy.push(&quot;vtkWebGPUBindGroup&quot;),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join(&quot;\\n&quot;)}}const Wy={device:null,handle:null,label:null};function Hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;label&quot;,&quot;device&quot;,&quot;arrayInformation&quot;]),zy(e,t)}var jy={newInstance:jt.newInstance(Hy),extend:Hy};function Ky(e,t){t.classHierarchy.push(&quot;vtkWebGPUPipeline&quot;),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);&quot;vertex&quot;===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint=&quot;main&quot;),&quot;fragment&quot;===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint=&quot;main&quot;)}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const $y={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$y,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,[&quot;handle&quot;,&quot;pipelineDescription&quot;]),At(e,t,[&quot;device&quot;,&quot;renderEncoder&quot;,&quot;topology&quot;,&quot;vertexState&quot;]),Ky(e,t)}var Xy={newInstance:Et(qy,&quot;vtkWebGPUPipeline&quot;),extend:qy};function Yy(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderDescription&quot;),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push(&quot;};&quot;),o=n,r[r.length-1]+=&quot;,&quot;,r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Input&quot;,r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push(&quot;};&quot;),o=o.concat(e),t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Output&quot;,[`-> ${t.type}Output`]).result}t.code=Uy.substitute(t.code,&quot;//VTK::IOStructs::Dec&quot;,o).result}}const Zy={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function Qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zy,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,[&quot;type&quot;,&quot;hash&quot;,&quot;code&quot;]),jt.getArray(e,t,[&quot;outputTypes&quot;,&quot;outputNames&quot;,&quot;outputInterpolations&quot;]),Yy(e,t)}var Jy={newInstance:jt.newInstance(Qy,&quot;vtkWebGPUShaderDescription&quot;),extend:Qy};const eT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;sint&quot;},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;uint&quot;},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:&quot;sint&quot;},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:&quot;float&quot;},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;uint&quot;},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;sint&quot;},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:&quot;uint&quot;},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:&quot;sint&quot;},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:&quot;uint&quot;},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:&quot;sint&quot;},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:&quot;float&quot;},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;rgba8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;uint&quot;},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;sint&quot;},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;bgra8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:&quot;float&quot;},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:&quot;uint&quot;},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:&quot;sint&quot;},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:&quot;uint&quot;},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:&quot;sint&quot;},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:&quot;float&quot;},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:&quot;uint&quot;},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:&quot;sint&quot;},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:&quot;unfilterable-float&quot;},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;depth&quot;},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:&quot;depth&quot;},&quot;depth24plus-stencil8&quot;:{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:&quot;mixed&quot;},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;depth&quot;}};var tT=function(e){return!e||e.length<6?0:e in eT==1?eT[e]:(et(`unknown format ${e}`),null)},nT=function(e){if(!e||e.length<5)return 0;let t=1;&quot;x&quot;===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},rT=function(e){if(!e||e.length<5)return 0;let t;if(&quot;f&quot;===e[0])t=&quot;Float&quot;;else if(&quot;s&quot;===e[0])t=&quot;Int&quot;;else{if(&quot;u&quot;!==e[0])return void et(`unknown format ${e}`);t=&quot;Uint&quot;}const n=e.split(&quot;x&quot;)[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+=&quot;Array&quot;,t;et(`unknown format ${e}`)},oT=function(e){let t;if(&quot;f&quot;===e[0]||&quot;n&quot;===e[1])t=&quot;f32&quot;;else if(&quot;s&quot;===e[0]&&&quot;i&quot;===e[1])t=&quot;i32&quot;;else{if(&quot;u&quot;!==e[0]||&quot;i&quot;!==e[1])return void et(`unknown format ${e}`);t=&quot;u32&quot;}let n=1;return&quot;x&quot;===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},aT=function(e){if(!e)return 0;let t=1;return&quot;vec&quot;===e.substring(0,3)?t=Number(e[3]):&quot;mat&quot;===e.substring(0,3)&&(t=e[3]*e[5]),4*t},iT=function(e){if(e)return e.includes(&quot;f32&quot;)?&quot;Float32Array&quot;:e.includes(&quot;i32&quot;)?&quot;Int32Array&quot;:e.includes(&quot;u32&quot;)?&quot;Uint32Array&quot;:void et(`unknown format ${e}`)};function sT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function lT(e,t){t.classHierarchy.push(&quot;vtkWebGPUVertexInput&quot;),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:&quot;vertex&quot;,o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(sT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e=&quot;&quot;,n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=oT(a.format);n>0&&(e+=&quot;,\\n&quot;),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const cT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function uT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,[&quot;created&quot;,&quot;device&quot;,&quot;handle&quot;,&quot;indexBuffer&quot;]),lT(e,t)}var dT={newInstance:Et(uT,&quot;vtkWebGPUVertexInput&quot;),extend:uT};const pT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  // var vertex: vec4<f32> = vertexBC;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n&quot;,fT=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function gT(e,t){t.classHierarchy.push(&quot;vtkWebGPUSimpleMapper&quot;),e.generateShaderDescriptions=(n,r,o)=>{const a=Jy.newInstance({type:&quot;vertex&quot;,hash:n,code:t.vertexShaderTemplate}),i=Jy.newInstance({type:&quot;fragment&quot;,hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp(&quot;//VTK::[^:]*::&quot;,&quot;g&quot;),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];&quot;replaceShaderIOStructs&quot;!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.replaceShaderCode(null,n),t.getShaderDescription(&quot;fragment&quot;).replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set(&quot;replaceShaderRenderEncoder&quot;,e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderRenderer&quot;,e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);s.addBuiltinInput(&quot;bool&quot;,&quot;@builtin(front_facing) frontFacing&quot;),i=s.getCode(),i=Uy.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderMapper&quot;,e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;    output.Position = rendererUBO.SCPCMatrix*vertexBC;&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription(&quot;vertex&quot;).addOutput(&quot;vec2<f32>&quot;,&quot;tcoordVS&quot;)},t.shaderReplacements.set(&quot;replaceShaderTCoord&quot;,e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=Xy.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const mT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:&quot;triangle-list&quot;,UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function hT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=dT.newInstance(),t.bindGroup=jy.newInstance({label:&quot;mapperBG&quot;}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||fT,t.vertexShaderTemplate=t.vertexShaderTemplate||pT,t.shaderReplacements=new Map,jt.get(e,t,[&quot;pipeline&quot;,&quot;vertexInput&quot;]),jt.setGet(e,t,[&quot;additionalBindables&quot;,&quot;device&quot;,&quot;fragmentShaderTemplate&quot;,&quot;interpolate&quot;,&quot;numberOfInstances&quot;,&quot;numberOfVertices&quot;,&quot;pipelineHash&quot;,&quot;shaderReplacements&quot;,&quot;SSBO&quot;,&quot;textureViews&quot;,&quot;topology&quot;,&quot;UBO&quot;,&quot;vertexShaderTemplate&quot;,&quot;WebGPURenderer&quot;]),gT(e,t)}var vT={newInstance:jt.newInstance(hT,&quot;vtkWebGPUSimpleMapper&quot;),extend:hT};function yT(e,t){t.classHierarchy.push(&quot;vtkWebGPUFullScreenQuad&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;),r.addOutput(&quot;vec4<f32>&quot;,&quot;vertexVC&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;,&quot;output.vertexVC = vec4<f32>(vertexBC, 1);&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,[&quot;vertexBC&quot;]),t.numberOfVertices=6}}const TT={};function bT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,TT,n),vT.extend(e,t,n),yT(e,t)}var xT={newInstance:jt.newInstance(bT,&quot;vtkWebGPUFullScreenQuad&quot;),extend:bT};const CT=[&quot;setBindGroup&quot;,&quot;setIndexBuffer&quot;,&quot;setVertexBuffer&quot;,&quot;draw&quot;,&quot;drawIndexed&quot;];function ST(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderEncoder&quot;),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!(&quot;depthStencil&quot;in n))console.log(&quot;mismatched depth attachments&quot;),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\\n${o}\\n versus pipeline\\n${a}\\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<CT.length;n++)e[CT[n]]=function(){return t.handle[CT[n]](...arguments)}}const AT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function IT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}],depthStencilAttachment:{view:void 0,depthLoadOp:&quot;clear&quot;,depthClearValue:0,depthStoreOp:&quot;store&quot;}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = computedColor;&quot;]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater-equal&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}},t.colorTextureViews=[],bt(e,t,[&quot;boundPipeline&quot;,&quot;colorTextureViews&quot;]),At(e,t,[&quot;depthTextureView&quot;,&quot;description&quot;,&quot;handle&quot;,&quot;label&quot;,&quot;pipelineHash&quot;,&quot;pipelineSettings&quot;,&quot;replaceShaderCodeFunction&quot;]),ST(e,t)}var wT={newInstance:Et(IT,&quot;vtkWebGPURenderEncoder&quot;),extend:IT},PT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const OT=[&quot;getMappedRange&quot;,&quot;mapAsync&quot;,&quot;unmap&quot;];function RT(e,t){t.classHierarchy.push(&quot;vtkWebGPUBuffer&quot;),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<OT.length;n++)e[OT[n]]=function(){return t.handle[OT[n]](...arguments)}}const MT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;strideInBytes&quot;,&quot;device&quot;,&quot;arrayInformation&quot;,&quot;label&quot;,&quot;sourceTime&quot;]),RT(e,t)}var ET={newInstance:jt.newInstance(DT),extend:DT,...PT};const{Representation:VT}=ds,{PrimitiveTypes:LT}=PT;class BT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function NT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function _T(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=NT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=NT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=NT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=NT(n,o,t),n.ibo[n.iboId++]=a}function FT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let kT;const GT=new Uint32Array(1),UT=new Uint32Array(2),zT=new Uint32Array(3),WT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)GT[0]=t[n+a],kT(GT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)UT[0]=t[n+a],UT[1]=t[n+(a+1)%e],kT(UT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o);for(let a=0;a<e-2;a++)UT[0]=t[n+a],UT[1]=t[n+a+2],kT(UT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n],zT[1]=t[n+a+1],zT[2]=t[n+a+2],kT(zT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n+a],zT[1]=t[n+a+1+a%2],zT[2]=t[n+a+1+(a+1)%2],kT(zT,r,o)}};function HT(e,t){t.classHierarchy.push(&quot;vtkWebGPUIndexBuffer&quot;),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case LT.Points:return&quot;points&quot;;case LT.Lines:return&quot;lines&quot;;case LT.Triangles:case LT.TriangleEdges:return&quot;polys&quot;;case LT.TriangleStripEdges:case LT.TriangleStrips:return&quot;strips&quot;;default:return&quot;&quot;}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new BT};let d=null;d=o===VT.POINTS||r===LT.Points?WT.anythingToPoints:o===VT.WIREFRAME||r===LT.Lines?WT[`${l}ToWireframe`]:WT[`${l}ToSurface`],kT=FT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format=&quot;uint16&quot;):(u.ibo=new Uint32Array(u.iboSize),e.format=&quot;uint32&quot;),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),kT=_T,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const jT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function KT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jT,n),ET.extend(e,t,n),jt.setGet(e,t,[&quot;flatIdToPointId&quot;,&quot;flatIdToCellId&quot;,&quot;flatSize&quot;,&quot;indexCount&quot;]),HT(e,t)}var $T={newInstance:jt.newInstance(KT),extend:KT,...PT};const{BufferUsage:qT}=PT,{vtkErrorMacro:XT}=Kt,{VtkDataTypes:YT}=Es;function ZT(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,&quot;packExtra&quot;)&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function QT(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function JT(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===qT.Index&&(n=$T.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=ET.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===qT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===qT.PointArray){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=ZT(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?&quot;flat&quot;:&quot;perspective&quot;}])}if(e.usage===qT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=QT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=ZT(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:&quot;flat&quot;}])}return e.usage===qT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push(&quot;vtkWebGPUBufferManager&quot;),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case YT.UNSIGNED_CHAR:t=&quot;uint8&quot;;break;case YT.FLOAT:t=&quot;float32&quot;;break;case YT.UNSIGNED_INT:t=&quot;uint32&quot;;break;case YT.INT:t=&quot;sint32&quot;;break;case YT.DOUBLE:t=&quot;float32&quot;;break;case YT.UNSIGNED_SHORT:t=&quot;uint16&quot;;break;case YT.SHORT:t=&quot;sin16&quot;;break;default:t=&quot;float32&quot;}switch(e.getNumberOfComponents()){case 2:t+=&quot;x2&quot;;break;case 3:t.includes(&quot;32&quot;)||XT(`unsupported x3 type for ${t}`),t+=&quot;x3&quot;;break;case 4:t+=&quot;x4&quot;}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:qT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=ET.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:&quot;float32x3&quot;}]),t.fullScreenQuadBuffer}}const eb={device:null,fullScreenQuadBuffer:null};function tb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eb,n),yt(e,t),At(e,t,[&quot;device&quot;]),JT(e,t)}var nb={newInstance:Et(tb),extend:tb,...PT};function rb(e,t){t.classHierarchy.push(&quot;vtkWebGPUSampler&quot;),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:&quot;clamp-to-edge&quot;,t.options.addressModeV=n.addressModeV?n.addressModeV:&quot;clamp-to-edge&quot;,t.options.addressModeW=n.addressModeW?n.addressModeW:&quot;clamp-to-edge&quot;,t.options.magFilter=n.magFilter?n.magFilter:&quot;nearest&quot;,t.options.minFilter=n.minFilter?n.minFilter:&quot;nearest&quot;,t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:&quot;nearest&quot;,t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const ob={device:null,handle:null,label:null,options:null};function ab(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ob,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;options&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;]),rb(e,t)}var ib={newInstance:jt.newInstance(ab),extend:ab};function sb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTextureView&quot;),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r=&quot;f32&quot;;&quot;sint&quot;===t.bindGroupLayoutEntry.texture.sampleType?r=&quot;i32&quot;:&quot;uint&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(r=&quot;u32&quot;);let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return&quot;depth&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=ib.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const lb={texture:null,handle:null,sampler:null,label:null};function cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:&quot;float&quot;,viewDimension:&quot;2d&quot;}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,[&quot;bindGroupTime&quot;,&quot;texture&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;sampler&quot;]),sb(e,t)}var ub={newInstance:jt.newInstance(cb),extend:cb};const{BufferUsage:db}=nb;function pb(e,t){t.classHierarchy.push(&quot;vtkWebGPUTexture&quot;),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?&quot;2d&quot;:&quot;3d&quot;;t.format=n.format?n.format:&quot;rgba8unorm&quot;,t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:&quot;rgba8unorm&quot;,t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format=&quot;rgba8unorm&quot;,n.flip=!0,n.nativeArray=n.jsImageData.data);const o=tT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&&quot;float&quot;===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?&quot;Uint16Array&quot;:i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Ad.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement(&quot;canvas&quot;);e.width=n.image.width,e.height=n.image.height;const t=e.getContext(&quot;2d&quot;);t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Tu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:db.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:db.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=tT(t.format);return 2===e.elementSize&&&quot;float&quot;===e.sampleType?1:255},e.getNumberOfComponents=()=>tT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?&quot;2d&quot;:&quot;3d&quot;);const o=ub.newInstance({label:n});return o.create(e,r),o}}const fb={device:null,handle:null,buffer:null,ready:!1,label:null};function gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fb,n),jt.obj(e,t),jt.get(e,t,[&quot;handle&quot;,&quot;ready&quot;,&quot;width&quot;,&quot;height&quot;,&quot;depth&quot;,&quot;format&quot;,&quot;usage&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;label&quot;]),pb(e,t)}var mb={newInstance:jt.newInstance(gb),extend:gb};function hb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOpaquePass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;opaquePassColor&quot;}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView(&quot;opaquePassColorTexture&quot;);t.renderEncoder.setColorTextureView(0,n),t.depthFormat=&quot;depth32float&quot;,t.depthTexture=mb.newInstance({label:&quot;opaquePassDepth&quot;}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;opaquePassDepthTexture&quot;);t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;opaquePass&quot;),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=wT.newInstance({label:&quot;OpaquePass&quot;}),t.renderEncoder.setPipelineHash(&quot;op&quot;)}}const vb={renderEncoder:null,colorTexture:null,depthTexture:null};function yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vb,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),hb(e,t)}var Tb={newInstance:jt.newInstance(yb,&quot;vtkWebGPUOpaquePass&quot;),extend:yb};function bb(e,t){t.classHierarchy.push(&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=mb.newInstance({label:&quot;translucentPassColor&quot;}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView(&quot;oitpColorTexture&quot;);t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=mb.newInstance({label:&quot;translucentPassAccumulate&quot;}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView(&quot;oitpAccumTexture&quot;);t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=xT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash(&quot;oitpfsq&quot;),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\\n  if (reveal == 1.0) { discard; }\\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\\n  var total: f32 = max(tcolor.a, 0.01);\\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;)}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;translucentPass&quot;),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=wT.newInstance({label:&quot;translucentRender&quot;});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:void 0,clearValue:[1,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}],e.depthStencilAttachment={view:void 0,depthLoadOp:&quot;load&quot;,depthStoreOp:&quot;store&quot;},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addOutput(&quot;f32&quot;,&quot;outAccum&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);&quot;,&quot;output.outColor = vec4<f32>(computedColor.rgb*w, w);&quot;,&quot;output.outAccum = computedColor.a;&quot;]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash(&quot;oitpr&quot;),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!1,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;zero&quot;,dstFactor:&quot;one-minus-src&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=wT.newInstance({label:&quot;translucentFinal&quot;}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash(&quot;oitpf&quot;),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})}}const xb={colorTextureView:null,depthTextureView:null};function Cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),bb(e,t)}var Sb={newInstance:jt.newInstance(Cb,&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),extend:Cb};const{BufferUsage:Ab}=nb,{vtkErrorMacro:Ib}=jt;function wb(e,t){t.classHierarchy.push(&quot;vtkWebGPUUniformBuffer&quot;),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Ib(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:aT(n),offset:-1,nativeType:iT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Ab.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join(&quot;\\n&quot;)}}const Pb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function Ob(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;uniform&quot;}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,[&quot;binding&quot;,&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;,&quot;sizeInBytes&quot;]),wb(e,t)}var Rb={newInstance:jt.newInstance(Ob,&quot;vtkWebGPUUniformBuffer&quot;),extend:Ob};const{BufferUsage:Mb}=nb,{vtkErrorMacro:Db}=jt;function Eb(e,t){t.classHierarchy.push(&quot;vtkWebGPUStorageBuffer&quot;),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void Db(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=aT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:iT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Mb.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\\n};\\nstruct ${t.label}Struct\\n{\\n  values: array<${t.label}StructEntry>,\\n};\\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\\n`),r.join(&quot;\\n&quot;)},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Vb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function Lb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;read-only-storage&quot;}},jt.get(e,t,[&quot;bindGroupTime&quot;]),jt.setGet(e,t,[&quot;device&quot;,&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;numberOfInstances&quot;,&quot;sizeInBytes&quot;]),Eb(e,t)}var Bb={newInstance:jt.newInstance(Lb,&quot;vtkWebGPUStorageBuffer&quot;),extend:Lb};const Nb=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Volume::TraverseDec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\\n{\\n  // todo multicomponent support\\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\\n}\\n\\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\\n{\\n  var result: vec4<f32>;\\n\\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\\n  result.w = 0.0;\\n\\n  // divide by spacing as that is our delta\\n  result = result / volumeSSBO.values[vNum].spacing;\\n  // now we have a gradient in unit tcoords\\n\\n  var grad: f32 = length(result.xyz);\\n  if (grad > 0.0)\\n  {\\n    // rotate to View Coords, needed for lighting and shading\\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\\n    result = nMat * result;\\n    result = result / length(result);\\n  }\\n\\n  // store gradient magnitude in .w\\n  result.w = grad;\\n\\n  return result;\\n}\\n\\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\\n{\\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n\\n  // convert to tcoords and reject if outside the volume\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\\n\\n  var scalar: f32 = getTextureValue(vTex, tpos);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n\\n  var gofactor: f32 = 1.0;\\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    normal = getGradient(vTex, tpos, vNum, scalar);\\n    if (componentSSBO.values[cNum].gomin <  1.0)\\n    {\\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\\n    }\\n  }\\n\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n\\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    color = color*abs(normal.z);\\n  }\\n\\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\\n\\n  return outColor;\\n}\\n\\n// adjust the start and end point of a raycast such that it intersects the unit cube.\\n// This function is used to take a raycast starting point and step vector\\n// and numSteps and return the startijng and ending steps for intersecting the\\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\\n// and bound it to intersecting the texture.\\n//\\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\\n{\\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\\n\\n  // move tpos to the start of the volume\\n  var adjust: f32 =\\n    min(\\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\\n      min(\\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\\n  if (adjust < 0.0)\\n  {\\n    result.x = result.x - adjust;\\n  }\\n\\n  // adjust length to the end\\n  adjust =\\n    max(\\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\\n      max(\\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\\n  if (adjust > 0.0)\\n  {\\n    result.y = result.y - adjust;\\n  }\\n\\n  return result;\\n}\\n\\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\\n{\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n  return vec4<f32>(color.rgb, opacity);\\n}\\n\\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var maxVal: f32 = -1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar > maxVal)\\n    {\\n      maxVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\\n}\\n\\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var minVal: f32 = 1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar < minVal)\\n    {\\n      minVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\\n}\\n\\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var avgVal: f32 = 0.0;\\n  var sampleCount: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      avgVal = avgVal + sample;\\n      sampleCount = sampleCount + 1.0;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  if (sampleCount <= 0.0)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\\n}\\n\\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var sumVal: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      sumVal = sumVal + sample;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\\n}\\n\\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\\n{\\n  // initial ray position is at the beginning\\n  var rayPosSC: vec4<f32> = minPosSC;\\n\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var curDist: f32 = 0.0;\\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n  var sampleColor: vec4<f32>;\\n//VTK::Volume::TraverseCalls\\n\\n  loop\\n  {\\n    // for each volume, sample and accumulate color\\n//VTK::Volume::CompositeCalls\\n\\n    // increment position\\n    curDist = curDist + mapperUBO.SampleDistance;\\n    rayPosSC = rayPosSC + rayStepSC;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayLengthSC) { break; }\\n    if (computedColor.a > 0.98) { break; }\\n  }\\n  return computedColor;\\n}\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\\n\\n  // discard empty rays\\n  if (rayMax <= rayMin) { discard; }\\n  else\\n  {\\n    // compute start and end ray positions in view coordinates\\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\\n\\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\\n    rayStepSC.w = 0.0;\\n\\n    var computedColor: vec4<f32>;\\n\\n//VTK::Volume::Loop\\n\\n//VTK::RenderEncoder::Impl\\n  }\\n\\n  return output;\\n}\\n&quot;,_b=new Float64Array(16),Fb=new Float64Array(16);function kb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePassFSQ&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=Uy.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;]).result,r.setCode(o),t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription(&quot;fragment&quot;);let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===Rg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push(&quot;    computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;)):(s.push(`  sampleColor = traverseVals[${e}];`),s.push(&quot;  computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;));a=Uy.substitute(a,&quot;//VTK::Volume::CompositeCalls&quot;,i).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseCalls&quot;,s).result,a=Uy.substitute(a,&quot;//VTK::Volume::TraverseDec&quot;,[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===Rg.COMPOSITE_BLEND?l=!0:n===Rg.MAXIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.MINIMUM_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.AVERAGE_INTENSITY_BLEND?a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===Rg.ADDITIVE_INTENSITY_BLEND&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result)}l&&(a=Uy.substitute(a,&quot;//VTK::Volume::Loop&quot;,[&quot;    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);&quot;]).result),o.setCode(a)},t.shaderReplacements.set(&quot;replaceShaderVolume&quot;,e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8Array(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;rgba8unorm&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;tfunTexture&quot;);t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;r16float&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;ofunTexture&quot;);t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(_b),b(_b,_b,o);const p=n.getMatrix();m(Fb,p),h(Fb,Fb),T(_b,Fb,_b);const f=d.getWorldToIndex();T(_b,f,_b);const v=d.getDimensions();g(Fb),x(Fb,Fb,[1/v[0],1/v[1],1/v[2]]),T(_b,Fb,_b);for(let t=0;t<16;t++)a[16*e+t]=_b[t];h(_b,_b);for(let t=0;t<4;t++)i[16*e+4*t]=_b[4*t],i[16*e+4*t+1]=_b[4*t+1],i[16*e+4*t+2]=_b[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry(&quot;SCTCMatrix&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;planeNormals&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;shade&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;tstep&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;spacing&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;ipScalarRange&quot;,&quot;vec4<f32>&quot;),t.SSBO.setAllInstancesFromArray(&quot;SCTCMatrix&quot;,a),t.SSBO.setAllInstancesFromArray(&quot;planeNormals&quot;,i),t.SSBO.setAllInstancesFromArray(&quot;shade&quot;,l),t.SSBO.setAllInstancesFromArray(&quot;tstep&quot;,s),t.SSBO.setAllInstancesFromArray(&quot;spacing&quot;,c),t.SSBO.setAllInstancesFromArray(&quot;ipScalarRange&quot;,u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=tT(l),u={scale:[255],offset:[0]};2===c.elementSize&&&quot;float&quot;===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry(&quot;cScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;cShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomin&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomax&quot;,&quot;f32&quot;),t.componentSSBO.setAllInstancesFromArray(&quot;cScale&quot;,d),t.componentSSBO.setAllInstancesFromArray(&quot;cShift&quot;,p),t.componentSSBO.setAllInstancesFromArray(&quot;oScale&quot;,f),t.componentSSBO.setAllInstancesFromArray(&quot;oShift&quot;,v),t.componentSSBO.setAllInstancesFromArray(&quot;goScale&quot;,A),t.componentSSBO.setAllInstancesFromArray(&quot;goShift&quot;,S),t.componentSSBO.setAllInstancesFromArray(&quot;gomin&quot;,y),t.componentSSBO.setAllInstancesFromArray(&quot;gomax&quot;,C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue(&quot;SampleDistance&quot;,r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=ib.newInstance({label:&quot;clampSampler&quot;}),t.clampSampler.create(t.device,{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}))},e.computePipelineHash=()=>{t.pipelineHash=&quot;volfsq&quot;;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Gb={volumes:null,rowLength:1024,lastVolumeLength:0};function Ub(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gb,n),xT.extend(e,t,n),t.fragmentShaderTemplate=Nb,t.UBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t.UBO.addEntry(&quot;SampleDistance&quot;,&quot;f32&quot;),t.SSBO=Bb.newInstance({label:&quot;volumeSSBO&quot;}),t.componentSSBO=Bb.newInstance({label:&quot;componentSSBO&quot;}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),kb(e,t)}var zb={newInstance:jt.newInstance(Ub,&quot;vtkWebGPUVolumePassFSQ&quot;),extend:Ub};const{Representation:Wb}=ds,{BufferUsage:Hb,PrimitiveTypes:jb}=nb,Kb=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],$b=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::VolumePass::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::VolumePass::Impl\\n\\n  // use the maximum (closest) of the current value and the zbuffer\\n  // the blend func will then take the min to find the farthest stop value\\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;;function qb(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePass&quot;),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=zb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=xT.newInstance(),t._volumeCopyQuad.setPipelineHash(&quot;volpassfsq&quot;),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._copyUBO=Rb.newInstance({label:&quot;mapperUBO&quot;}),t._copyUBO.addEntry(&quot;tscale&quot;,&quot;vec2<f32>&quot;),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray(&quot;tscale&quot;,[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray(&quot;tscale&quot;,[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:Hb.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:jb.Triangles,representation:Wb.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:Hb.PointArray,format:&quot;float32x4&quot;,hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,[&quot;vertexBC&quot;]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+Kb[e][0],l[n++]=r+Kb[e][1],l[n++]=r+Kb[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation(&quot;volumeDepthRangePass&quot;),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=wT.newInstance({label:&quot;VolumePass DepthRange&quot;}),t._depthRangeEncoder.setPipelineHash(&quot;volr&quot;),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor1&quot;),t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor2&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);&quot;,&quot;output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);&quot;]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:null,clearValue:[1,1,1,1],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;}}}]}}),t._depthRangeTexture=mb.newInstance({label:&quot;volumePassMaxDepth&quot;}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView(&quot;maxTexture&quot;);t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=mb.newInstance({label:&quot;volumePassDepthMin&quot;}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView(&quot;minTexture&quot;);t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=mb.newInstance({label:&quot;volumePassColor&quot;}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;bgra8unorm&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView(&quot;volumePassColorTexture&quot;),t._colorTextureView.addSampler(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._clearEncoder=wT.newInstance({label:&quot;VolumePass Clear&quot;}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._clearEncoder.setPipelineHash(&quot;volpf&quot;),t._clearEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=wT.newInstance({label:&quot;volumePassCopy&quot;}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._copyEncoder.setPipelineHash(&quot;volcopypf&quot;),t._copyEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=wT.newInstance({label:&quot;volumePassMerge&quot;}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash(&quot;volpf&quot;),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const Xb={colorTextureView:null,depthTextureView:null,volumes:null};function Yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xb,n),qv.extend(e,t,n),t._mapper=vT.newInstance(),t._mapper.setFragmentShaderTemplate($b),t._mapper.getShaderReplacements().set(&quot;replaceShaderVolumePass&quot;,((e,t,n)=>{t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)})),t._boundsPoly=gu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),qb(e,t)}var Zb={newInstance:jt.newInstance(Yb,&quot;vtkWebGPUVolumePass&quot;),extend:Yb};function Qb(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e),t.opaquePass||(t.opaquePass=Tb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Sb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=Zb.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=wT.newInstance({label:&quot;forwardPassBlit&quot;}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._finalBlitEncoder.setPipelineHash(&quot;fpf&quot;),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcfactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}}),t._fsqSampler=ib.newInstance({label:&quot;finalPassSampler&quot;}),t._fsqSampler.create(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._fullScreenQuad=xT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash(&quot;fpfsq&quot;),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0),vec4<f32>(0.0),vec4<f32>(1.0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._finalBlitOutputTextureView=ub.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const Jb={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jb,n),qv.extend(e,t,n),jt.setGet(e,t,[&quot;opaquePass&quot;,&quot;translucentPass&quot;,&quot;volumePass&quot;]),Qb(e,t)}var tx={newInstance:jt.newInstance(ex,&quot;vtkForwardPass&quot;),extend:ex};const{VtkDataTypes:nx}=Es;function rx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format=&quot;r&quot;;break;case 2:e.format=&quot;rg&quot;;break;default:e.format=&quot;rgba&quot;}switch(e.dataArray.getDataType()){case nx.UNSIGNED_CHAR:e.format+=&quot;8unorm&quot;;break;case nx.FLOAT:case nx.UNSIGNED_INT:case nx.INT:case nx.DOUBLE:case nx.UNSIGNED_SHORT:case nx.SHORT:default:e.format+=&quot;16float&quot;}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format=&quot;rgba8unorm&quot;),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=mb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push(&quot;vtkWebGPUTextureManager&quot;),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const ox={handle:null,device:null};function ax(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ox,n),jt.obj(e,t),jt.setGet(e,t,[&quot;device&quot;]),rx(e,t)}var ix={newInstance:jt.newInstance(ax),extend:ax};class sx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&&quot;object&quot;==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function lx(e,t){t.classHierarchy.push(&quot;vtkWebGPUDevice&quot;),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro(&quot;layout not found&quot;),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro(&quot;attempt to cache an object without a hash&quot;),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const cx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cx,n),yt(e,t),At(e,t,[&quot;handle&quot;]),bt(e,t,[&quot;bufferManager&quot;,&quot;shaderCache&quot;,&quot;textureManager&quot;]),t.objectCache=new sx,t.shaderCache=Uy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=nb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=ix.newInstance(),t.textureManager.setDevice(e),t.pipelines={},lx(e,t)}var dx={newInstance:Et(ux,&quot;vtkWebGPUDevice&quot;),extend:ux};function px(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelectionPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:&quot;hardwareSelectorColor&quot;}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;rgba32uint&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView(&quot;hardwareSelectColorTexture&quot;);t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=mb.newInstance({label:&quot;hardwareSelectorDepth&quot;}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;depth32float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;hardwareSelectDepthTexture&quot;);t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation(&quot;cameraPass&quot;),r.traverse(e),e.setCurrentOperation(&quot;opaquePass&quot;),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=wT.newInstance({label:&quot;HardwareSelectionPass&quot;}),t.selectionRenderEncoder.setPipelineHash(&quot;sel&quot;),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<u32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=Uy.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);&quot;]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba32uint&quot;,blend:void 0}]}})}}const fx={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function gx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fx,n),qv.extend(e,t,n),jt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),px(e,t)}var mx={newInstance:jt.newInstance(gx,&quot;vtkWebGPUHardwareSelectionPass&quot;),extend:gx};const{SelectionContent:hx,SelectionField:vx}=qp,{FieldAssociations:yx}=ol,{vtkErrorMacro:Tx}=jt;function bx(e){return`${e.propID} ${e.compositeID}`}function xx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Cx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=xx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=xx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Cx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Cx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Cx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Cx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Cx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Sx(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelector&quot;),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Tx(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=ET.newInstance({label:&quot;hardwareSelectColorBuffer&quot;});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=ET.newInstance({label:&quot;hardwareSelectDepthBuffer&quot;}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:&quot;depth-only&quot;},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Cx(e,[n,t],0,u);if(r){const t=bx(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=qp.newInstance();switch(i.setContentType(hx.INDICES),e){case yx.FIELD_ASSOCIATION_CELLS:i.setFieldType(vx.CELL);break;case yx.FIELD_ASSOCIATION_POINTS:i.setFieldType(vx.POINT);break;default:Tx(&quot;Unknown field association&quot;)}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Ax={};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),Gp.extend(e,t,n),t._selectionPass=mx.newInstance(),jt.setGet(e,t,[&quot;_WebGPURenderWindow&quot;]),jt.moveToProtected(e,t,[&quot;WebGPURenderWindow&quot;]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,&quot;vtkWebGPUHardwareSelector&quot;),extend:Ix};const Px=Object.create(null);function Ox(e,t){t.classHierarchy.push(&quot;vtkWebGPUViewNodeFactory&quot;)}const Rx={};function Mx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rx,n),t.overrides=Px,tn.extend(e,t,n),Ox(0,t)}var Dx={newInstance:jt.newInstance(Mx,&quot;vtkWebGPUViewNodeFactory&quot;),extend:Mx};const{vtkErrorMacro:Ex}=jt,Vx={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};function Lx(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderWindow&quot;),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:&quot;premultiplied&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Ex(&quot;WebGPU is not enabled.&quot;);e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Ex(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:&quot;high-performance&quot;}),t.deleted||(t.device=dx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext(&quot;webgpu&quot;))},e.releaseGraphicsResources=()=>{const n=qv.newInstance();n.setCurrentOperation(&quot;Release&quot;),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Vx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=ET.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Ad.fromHalf(r.colorValues[o]),s[n+1]=255*Ad.fromHalf(r.colorValues[o+1]),s[n+2]=255*Ad.fromHalf(r.colorValues[o+2]),s[n+3]=255*Ad.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=wx.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Bx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Nx=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,xy.extend(e,t,n),t.myFactory=Dx.newInstance(),t.myFactory.registerOverride(&quot;vtkRenderWindow&quot;,Nx),t.renderPasses[0]=tx.newInstance(),t.selector||(t.selector=wx.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,&quot;imageReady&quot;),jt.event(e,t,&quot;initialized&quot;),jt.get(e,t,[&quot;commandEncoder&quot;,&quot;device&quot;,&quot;presentationFormat&quot;,&quot;useBackgroundImage&quot;,&quot;xrSupported&quot;]),jt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;device&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),jt.setGetArray(e,t,[&quot;size&quot;],2),jt.event(e,t,&quot;windowResizeEvent&quot;),Lx(e,t)}),&quot;vtkWebGPURenderWindow&quot;);ev(&quot;WebGPU&quot;,Nx);const _x=Hv(),Fx={margin:&quot;0&quot;,padding:&quot;0&quot;,position:&quot;absolute&quot;,top:&quot;0&quot;,left:&quot;0&quot;,width:&quot;100%&quot;,height:&quot;100%&quot;,overflow:&quot;hidden&quot;},kx={position:&quot;absolute&quot;,left:&quot;25px&quot;,top:&quot;25px&quot;,backgroundColor:&quot;white&quot;,borderRadius:&quot;5px&quot;,listStyle:&quot;none&quot;,padding:&quot;5px 10px&quot;,margin:&quot;0&quot;,display:&quot;block&quot;,border:&quot;solid 1px black&quot;,maxWidth:&quot;calc(100% - 70px)&quot;,maxHeight:&quot;calc(100% - 60px)&quot;,overflow:&quot;auto&quot;};function Gx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Ux(e,t){t.classHierarchy.push(&quot;vtkFullScreenRenderWindow&quot;);const n=document.querySelector(&quot;body&quot;);t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement(&quot;div&quot;),Gx(t.container,t.containerStyle||Fx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height=&quot;100%&quot;,n.style.height=&quot;100%&quot;,n.style.padding=&quot;0&quot;,n.style.margin=&quot;0&quot;),t.renderWindow=av.newInstance(),t.renderer=Qh.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(_x.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Sv.newInstance(),t.interactor.setInteractorStyle(Uv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?&quot;block&quot;:&quot;none&quot;)},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement(&quot;div&quot;),Gx(t.controlContainer,t.controlPanelStyle||kx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener(&quot;keypress&quot;,(t=>{&quot;c&quot;===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}))},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener(&quot;resize&quot;,e.resize),e.resize()}const zx={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Wx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zx,n),jt.obj(e,t),jt.get(e,t,[&quot;renderWindow&quot;,&quot;renderer&quot;,&quot;apiSpecificRenderWindow&quot;,&quot;interactor&quot;,&quot;rootContainer&quot;,&quot;container&quot;,&quot;controlContainer&quot;]),Ux(e,t)}var Hx={newInstance:jt.newInstance(Wx),extend:Wx},jx={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:Kx,Scale:$x}=jx,{ScalarMappingTarget:qx}=Pl,{vtkDebugMacro:Xx,vtkErrorMacro:Yx,vtkWarningMacro:Zx}=jt;function Qx(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Jx(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function eC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];Qx(o,i),Qx(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Jx(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Jx(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function tC(e,t){t.classHierarchy.push(&quot;vtkColorTransferFunction&quot;),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Yx(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(s<0||s>1)return Yx(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===$x.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Do(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===Kx.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===Kx.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;,t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===Kx.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===Kx.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx(&quot;ColorSpace set to invalid value.&quot;);for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Yx(&quot;Attempting to lookup a value with no points in the function&quot;),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Yx(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Yx(&quot;Index out of range!&quot;),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>t.indexedLookup&&e.getSize()?e.getSize():t.tableSize?t.tableSize:16777216,e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void Yx(&quot;attempt to set zero width color range&quot;);const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):Xx(&quot;Transfer Function Has No Points!&quot;)},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void Zx(&quot;Transfer Function Has No Points!&quot;);const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===qx.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===qx.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===qx.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===qx.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=Kx[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Yx(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=Kx.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const nC={clamping:!0,colorSpace:Kx.RGB,hSVWrap:!0,scale:$x.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function rC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nC,n),Pl.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,[&quot;buildTime&quot;,&quot;mappingRange&quot;]),jt.setGet(e,t,[&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;,&quot;colorSpace&quot;,&quot;discretize&quot;,&quot;numberOfValues&quot;]),jt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),jt.getArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),tC(e,t)}var oC={newInstance:jt.newInstance(rC,&quot;vtkColorTransferFunction&quot;),extend:rC,...jx},aC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:iC,ScaleModes:sC}=aC,{vtkErrorMacro:lC}=jt;function cC(e,t){t.classHierarchy.push(&quot;vtkGlyph3DMapper&quot;),e.getOrientationModeAsString=()=>jt.enumToString(iC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(iC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(iC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(iC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(sC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(sC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(sC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(sC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===sC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(lC(&quot;Cannot scale by components since scale array does not have 3 components.&quot;),a=null);const l=r.getBounds(),c=[];ki.getCorners(l,c),t.bounds[0]=ki.INIT_BOUNDS[0],t.bounds[1]=ki.INIT_BOUNDS[1],t.bounds[2]=ki.INIT_BOUNDS[2],t.bounds[3]=ki.INIT_BOUNDS[3],t.bounds[4]=ki.INIT_BOUNDS[4],t.bounds[5]=ki.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case iC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case iC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case iC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case sC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case sC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case sC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const uC={orient:!0,orientationMode:iC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:sC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function dC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uC,n),nc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,[&quot;orient&quot;,&quot;orientationMode&quot;,&quot;orientationArray&quot;,&quot;scaleArray&quot;,&quot;scaleFactor&quot;,&quot;scaleMode&quot;,&quot;scaling&quot;]),jt.get(e,t,[&quot;colorArray&quot;,&quot;matrixArray&quot;,&quot;normalArray&quot;,&quot;buildTime&quot;]),cC(e,t)}var pC={newInstance:jt.newInstance(dC,&quot;vtkGlyph3DMapper&quot;),extend:dC,...aC};const{vtkErrorMacro:fC}=jt;function gC(e,t){t.classHierarchy.push(&quot;vtkPiecewiseFunction&quot;),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return&quot;Constant&quot;;case 1:return&quot;NonDecreasing&quot;;case 2:return&quot;NonIncreasing&quot;;default:return&quot;Varied&quot;}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(fC(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return fC(&quot;Index out of range!&quot;),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return fC(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(a<0||a>1)return fC(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const mC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function hC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,[&quot;allowDuplicateScalars&quot;,&quot;clamping&quot;]),jt.setArray(e,t,[&quot;range&quot;],2),jt.getArray(e,t,[&quot;range&quot;]),gC(e,t)}var vC={newInstance:jt.newInstance(hC,&quot;vtkPiecewiseFunction&quot;),extend:hC};const{InterpolationType:yC,OpacityMode:TC}=Og,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push(&quot;vtkVolumeProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(bC(&quot;Bad index - must be between 0 and 3&quot;),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=vC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=oC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=vC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return bC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(bC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(yC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(yC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(yC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(yC,t.interpolationType),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const CC={independentComponents:!0,interpolationType:yC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,CC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:TC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;shade&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,&quot;vtkVolumeProperty&quot;),extend:SC,...Og};const{vtkDebugMacro:IC}=jt;function wC(e,t){t.classHierarchy.push(&quot;vtkVolume&quot;),e.getVolumes=()=>e,e.makeProperty=AC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){IC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e));const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const PC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),wC(e,t)}var RC={newInstance:jt.newInstance(OC,&quot;vtkVolume&quot;),extend:OC};const{BlendMode:MC,FilterMode:DC}=Mg,EC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=vC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function VC(e,t){t.classHierarchy.push(&quot;vtkVolumeMapper&quot;);const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(MC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(MC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(MC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(MC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(MC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(MC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(MC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn(&quot;setAverageIPScalarRange is deprecated use setIpScalarRange&quot;),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(DC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(DC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(DC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(DC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Do(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const LC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:MC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:DC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LC,n),Bs(e,t,n),jt.setGet(e,t,[&quot;sampleDistance&quot;,&quot;imageSampleDistance&quot;,&quot;maximumSamplesPerRay&quot;,&quot;autoAdjustSampleDistances&quot;,&quot;initialInteractionScale&quot;,&quot;interactionSampleDistanceFactor&quot;,&quot;blendMode&quot;,&quot;filterMode&quot;,&quot;preferSizeOverAccuracy&quot;,&quot;computeNormalFromOpacity&quot;,&quot;volumetricScatteringBlending&quot;,&quot;globalIlluminationReach&quot;,&quot;volumeShadowSamplingDistFactor&quot;,&quot;anisotropy&quot;,&quot;localAmbientOcclusion&quot;,&quot;LAOKernelSize&quot;,&quot;LAOKernelRadius&quot;]),jt.setGetArray(e,t,[&quot;ipScalarRange&quot;],2),jt.event(e,t,&quot;lightingActivated&quot;),VC(e,t)}var NC={newInstance:jt.newInstance(BC,&quot;vtkVolumeMapper&quot;),extend:BC,...EC};const{InterpolationType:_C}=eg,{vtkErrorMacro:FC}=jt;function kC(e,t){t.classHierarchy.push(&quot;vtkImageProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return FC(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(FC(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(_C.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(_C.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(_C,t.interpolationType)}const GC={independentComponents:!1,interpolationType:_C.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function UC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,GC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;colorWindow&quot;,&quot;colorLevel&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;opacity&quot;,&quot;useLookupTableScalarRange&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;]),jt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),kC(e,t)}var zC={newInstance:jt.newInstance(UC,&quot;vtkImageProperty&quot;),extend:UC};const{vtkDebugMacro:WC}=jt;function HC(e,t){t.classHierarchy.push(&quot;vtkImageSlice&quot;),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=zC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){WC(&quot;Recomputing bounds...&quot;),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),ki.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!ki.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),ki.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const jC={mapper:null,property:null,bounds:[...ki.INIT_BOUNDS]};function KC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,[&quot;property&quot;]),jt.setGet(e,t,[&quot;mapper&quot;]),jt.getArray(e,t,[&quot;bounds&quot;],6),HC(e,t)}var $C={newInstance:jt.newInstance(KC,&quot;vtkImageSlice&quot;),extend:KC};function qC(e,t){t.classHierarchy.push(&quot;vtkAbstractImageMapper&quot;),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro(&quot;vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED&quot;),Fa())}const XC={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var YC=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,XC,n),Fs(e,t,n),jt.setGet(e,t,[&quot;slice&quot;,&quot;useCustomExtents&quot;]),jt.setGetArray(e,t,[&quot;customDisplayExtent&quot;],6),jt.setGetArray(e,t,[&quot;backgroundColor&quot;],4),qC(e,t)};function ZC(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA(&quot;vtkImageArrayMapper&quot;)?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ni.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:QC,otherStaticMethods:JC}=Ul,{SlicingMode:eS}=sg;function tS(e,t){function n(){let n;switch(t.slicingMode){case eS.X:n=0;break;case eS.Y:n=1;break;case eS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push(&quot;vtkImageMapper&quot;),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case eS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case eS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case eS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case eS.I:l=Ma(a[0],i[0],i[1]);break;case eS.J:l=Ma(a[1],i[2],i[3]);break;case eS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case eS.I:case eS.J:case eS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case eS.X:e.setSlice(r[0]);break;case eS.Y:e.setSlice(r[1]);break;case eS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(eS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(eS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(eS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(eS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(eS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(eS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case eS.X:n[0]=1;break;case eS.Y:n[1]=1;break;case eS.Z:n[2]=1;break;case eS.I:ea(r,[1,0,0],n);break;case eS.J:ea(r,[0,1,0],n);break;case eS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==eS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case eS.I:r[0]=a,r[1]=a;break;case eS.J:r[2]=a,r[3]=a;break;case eS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case eS.I:a[0]=s-r,a[1]=s+r;break;case eS.J:a[2]=s-r,a[3]=s+r;break;case eS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const nS={slicingMode:eS.NONE,closestIJKAxis:{ijkMode:eS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function rS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nS,n),YC(e,t,n),jt.get(e,t,[&quot;slicingMode&quot;]),jt.setGet(e,t,[&quot;closestIJKAxis&quot;,&quot;renderToRectangle&quot;,&quot;sliceAtFocalPoint&quot;,&quot;preferSizeOverAccuracy&quot;]),Ul.implementCoincidentTopologyMethods(e,t),tS(e,t)}var oS={newInstance:jt.newInstance(rS,&quot;vtkImageMapper&quot;),extend:rS,...QC,...JC,...sg};const{vtkErrorMacro:aS}=jt;function iS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function sS(e,t){t.classHierarchy.push(&quot;vtkAppendPolyData&quot;),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void aS(&quot;No input specified.&quot;);if(1===o)return void(r[0]=n[0]);const a=gu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===js.SINGLE?s=ys.FLOAT:t.outputPointsPrecision===js.DOUBLE&&(s=ys.DOUBLE);const v=mc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Es.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Es.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Es.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),iS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),iS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),iS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),iS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const lS={outputPointsPrecision:js.DEFAULT};function cS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lS,n),jt.setGet(e,t,[&quot;outputPointsPrecision&quot;]),jt.obj(e,t),jt.algo(e,t,1,1),sS(e,t)}var uS={newInstance:jt.newInstance(cS,&quot;vtkAppendPolyData&quot;),extend:cS};function dS(e,t){t.classHierarchy.push(&quot;vtkConeSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Nf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=gu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const pS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:&quot;Float64Array&quot;};function fS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),dS(e,t)}var gS={newInstance:jt.newInstance(fS,&quot;vtkConeSource&quot;),extend:fS};function mS(e,t){t.classHierarchy.push(&quot;vtkCylinderSource&quot;),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Es.newInstance({numberOfComponents:3,values:u,name:&quot;Normals&quot;}),p=new Float32Array(2*a),f=Es.newInstance({numberOfComponents:2,values:p,name:&quot;TCoords&quot;}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Nf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=gu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const hS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:&quot;Float64Array&quot;};function vS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;height&quot;,&quot;initAngle&quot;,&quot;otherRadius&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),jt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),jt.algo(e,t,0,1),mS(e,t)}var yS={newInstance:jt.newInstance(vS,&quot;vtkCylinderSource&quot;),extend:vS};function TS(e,t){t.classHierarchy.push(&quot;vtkArrowSource&quot;),e.requestData=function(e,n){if(t.deleted)return;const r=yS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Bf().rotateZ(-90).apply(a).apply(i);const s=gS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Nf().translate(1-.5*t.tipLength,0,0).apply(c);const u=uS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Nf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Nf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Nf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const bS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:&quot;Float64Array&quot;};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.obj(e,t),jt.setGet(e,t,[&quot;tipResolution&quot;,&quot;tipRadius&quot;,&quot;tipLength&quot;,&quot;shaftResolution&quot;,&quot;shaftRadius&quot;,&quot;invert&quot;]),jt.setGetArray(e,t,[&quot;direction&quot;],3),jt.algo(e,t,0,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,&quot;vtkArrowSource&quot;),extend:xS};function SS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Bf().translate(...n).apply(e.getPoints().getData())}function AS(e,t){const n=e.getPoints().getBounds(),r=[0,0,0];r[t]=-n[2*t],Bf().translate(...r).apply(e.getPoints().getData())}function IS(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8Array(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Es.newInstance({name:&quot;color&quot;,numberOfComponents:3,values:a}))}function wS(e,t){t.classHierarchy.push(&quot;vtkAxesActor&quot;);const n=nc.newInstance();e.setMapper(n),e.update=()=>{const e=CS.newInstance({direction:[1,0,0],...t.config}).getOutputData();t.config.recenter?SS(e):AS(e,0),IS(e,...t.xAxisColor);const r=CS.newInstance({direction:[0,1,0],...t.config}).getOutputData();t.config.recenter?SS(r):AS(r,1),IS(r,...t.yAxisColor);const o=CS.newInstance({direction:[0,0,1],...t.config}).getOutputData();t.config.recenter?SS(o):AS(o,2),IS(o,...t.zAxisColor);const a=uS.newInstance();a.setInputData(e),a.addInputData(r),a.addInputData(o),n.setInputConnection(a.getOutputPort())},e.update();const r=jt.debounce(e.update,0),{setConfig:o,setXAxisColor:a,setYAxisColor:i,setZAxisColor:s}=e;e.setConfig=e=>!!o(e)&&(r(),!0),e.setXAxisColor=e=>!!a(e)&&(r(),!0),e.setYAxisColor=e=>!!i(e)&&(r(),!0),e.setZAxisColor=e=>!!s(e)&&(r(),!0)}const PS={config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1},xAxisColor:[255,0,0],yAxisColor:[255,255,0],zAxisColor:[0,128,0]};function OS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PS,n),hs.extend(e,t,n),jt.setGet(e,t,[&quot;config&quot;]),jt.setGetArray(e,t,[&quot;xAxisColor&quot;,&quot;yAxisColor&quot;,&quot;zAxisColor&quot;],3,255),wS(e,t)}var RS={newInstance:jt.newInstance(OS,&quot;vtkAxesActor&quot;),extend:OS};const MS=&quot;resetcamera&quot;,DS=&quot;orientation&quot;,ES={MODE_RESET_CAMERA:MS,MODE_ORIENTATION:DS,MODE_SAME:&quot;same&quot;};function VS(e,t){t.classHierarchy.push(&quot;vtkCameraSynchronizer&quot;);const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName(&quot;position&quot;),s=e.getReferenceByName(&quot;focalPoint&quot;),l=e.getReferenceByName(&quot;viewUp&quot;),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===DS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===MS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const LS={mode:DS,focalPoint:[0,0,0],distance:6.8,active:!0};function BS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LS,n),yt(e,t),At(e,t,[&quot;mode&quot;,&quot;active&quot;,&quot;srcRenderer&quot;,&quot;dstRenderer&quot;,&quot;distance&quot;]),Pt(e,t,[&quot;focalPoint&quot;],3,0),VS(e,t)}var NS={newInstance:Et(BS,&quot;vtkCameraSynchronizer&quot;),extend:BS,SynchronizationMode:ES};const _S={},FS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=NS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:NS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var kS=function(e,t,n){const r=e.get(&quot;synchronizedViewId&quot;).synchronizedViewId;if(!t.behaviors||!r)return;_S[r]||(_S[r]={});const o=_S[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=NS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];FS[e.type]?o[r]=new FS[e.type](n,e):console.log(&quot;No mapping for&quot;,e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const GS={},US=/instance:\\${([^}]+)}/,zS={},WS=[],HS={},jS={vtkPoints:mc,vtkCellArray:cc,vtkDataArray:Es};function KS(e){return e.map((e=>US.exec(e))).filter((e=>e)).map((e=>e[1]))}function $S(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),$S(e,t)})),t}function qS(e,t,n,r){if(!t)return Promise.reject(new Error(&quot;No instance provided.&quot;));const o=GS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function XS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=GS[e];return n&&n.build?n.build(t):(console.log(&quot;No builder for&quot;,e),null)}function YS(){Object.keys(GS).forEach((e=>{delete GS[e]}))}function ZS(){Object.keys(zS).forEach((e=>{delete zS[e]}))}function QS(e){if(1===e[1].length)return-1===WS.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===WS.indexOf(e[1][n]);return t}function JS(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(HS[r]){const{key:n,value:o}=HS[r];if(!n||e.properties[n]===o)return void WS.push((e=>`instance:\\${${e}}`)(t))}let o=n.getInstance(t);o||(o=XS(r,{managedInstanceId:t}),n.registerInstance(t,o)),qS(r,o,e,n)})),t.calls&&t.calls.filter(QS).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=US.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:&quot;addArray&quot;,a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:&quot;vtkDataArray&quot;,l=jS[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log(&quot;Error fetching array&quot;,JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error(&quot;Error in array handling for state&quot;,JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function eA(e,t,n){zS[t.id]||JS(e,t,n),zS[t.id]=!0}function tA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function nA(e){const t=e.name?`_${e.name}`:&quot;&quot;;return`${e.hash}_${e.dataType}${t}`}function rA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=nA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=nA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),tA(t.getPointData(),i.pointData),tA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=JS(t,s,r);return r.end(),l}}const oA=rA([&quot;points&quot;,&quot;polys&quot;,&quot;verts&quot;,&quot;lines&quot;,&quot;strips&quot;]),aA=rA([]);function iA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:JS;XS||qS?GS[e]={build:t,update:n}:delete GS[e]}const sA={vtkMapper:[&quot;vtkOpenGLPolyDataMapper&quot;,&quot;vtkCompositePolyDataMapper2&quot;,&quot;vtkDataSetMapper&quot;],vtkProperty:[&quot;vtkOpenGLProperty&quot;],vtkRenderer:[&quot;vtkOpenGLRenderer&quot;],vtkCamera:[&quot;vtkOpenGLCamera&quot;],vtkColorTransferFunction:[&quot;vtkPVDiscretizableColorTransferFunction&quot;],vtkActor:[&quot;vtkOpenGLActor&quot;,&quot;vtkPVLODActor&quot;],vtkLight:[&quot;vtkOpenGLLight&quot;,&quot;vtkPVLight&quot;],vtkTexture:[&quot;vtkOpenGLTexture&quot;],vtkImageMapper:[&quot;vtkOpenGLImageSliceMapper&quot;],vtkVolumeMapper:[&quot;vtkFixedPointVolumeRayCastMapper&quot;]},lA={vtkAxesActor:{build:RS.newInstance,update:JS},vtkRenderWindow:{build:av.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(QS).filter((e=>&quot;removeRenderer&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),JS(e,t,n),kS(e,t,n)}},vtkRenderer:{build:Qh.newInstance,update:function(e,t,n){JS(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=$S(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(QS).filter((e=>&quot;removeViewProp&quot;===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{const t=n.getInstance(e).get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:El.newInstance,update:JS},vtkCamera:{build:Bh.newInstance,update:eA},vtkPolyData:{build:gu.newInstance,update:oA},vtkImageData:{build:fl.newInstance,update:aA},vtkMapper:{build:nc.newInstance,update:JS},vtkGlyph3DMapper:{build:pC.newInstance,update:JS},vtkProperty:{build:ds.newInstance,update:JS},vtkActor:{build:hs.newInstance,update:JS},vtkLight:{build:kh.newInstance,update:JS},vtkColorTransferFunction:{build:oC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Tu.newInstance,update:JS},vtkVolume:{build:RC.newInstance,update:JS},vtkVolumeMapper:{build:NC.newInstance,update:JS},vtkVolumeProperty:{build:AC.newInstance,update:JS},vtkImageSlice:{build:$C.newInstance,update:JS},vtkImageMapper:{build:oS.newInstance,update:JS},vtkImageProperty:{build:zC.newInstance,update:JS},vtkPiecewiseFunction:{build:vC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:Fu.newInstance,update:JS},vtkScalarBarActor:{build:Op.newInstance,update:JS}};function cA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&YS(),Object.keys(lA).forEach((e=>{const t=lA[e];iA(e,t.build,t.update)}))}function uA(){Object.keys(sA).forEach((e=>{sA[e].forEach((t=>{GS[t]=GS[e]}))}))}cA(),uA(),HS.vtkPVLight={};var dA={build:XS,update:qS,genericUpdater:JS,oneTimeGenericUpdater:eA,setTypeMapping:iA,clearTypeMapping:YS,getSupportedTypes:function(){return Object.keys(GS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return ZS();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete zS[e]})),r},updateRenderWindow:function(e,t,n){return qS(&quot;vtkRenderWindow&quot;,e,t,n)},excludeInstance:function(e,t,n){HS[e]={key:t,value:n}},setDefaultMapping:cA,applyDefaultAliases:uA,alwaysUpdateCamera:function(){iA(&quot;vtkCamera&quot;,Bh.newInstance),uA()}};const pA={};function fA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if(&quot;string&quot;==typeof t&&(i=Dm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log(&quot;Error getting data array:&quot;),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use &quot;setArrayFetcher&quot; to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function gA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function mA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Dt(t,n,&quot;progressEvent&quot;),Dt(t,n,&quot;progressDone&quot;),t}function hA(){const e={};let t=&quot;default&quot;;return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function vA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;default&quot;,t=pA[e];return t||(t={...fA(),...gA(),...mA(),...hA()},pA[e]=t),t}function yA(e,t){let n=-1,r=100;const o=e=>e.get(&quot;managedInstanceId&quot;).managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get(&quot;synchronizedViewId&quot;).synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),dA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){dA.clearOneTimeUpdaters(a())}}}function TA(e,t){t.classHierarchy.push(&quot;vtkSynchronizableRenderWindow&quot;),t.synchronizerContext||(t.synchronizerContext=vA(t.synchronizerContextName));const n=yA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const bA={synchronizerContextName:&quot;default&quot;,synchronizerContext:null,synchronizedViewId:null};function xA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bA,n),av.extend(e,t),bt(e,t,[&quot;synchronizerContext&quot;]),TA(e,t)}var CA={newInstance:Et(xA,&quot;vtkSynchronizableRenderWindow&quot;),extend:xA,getSynchronizerContext:vA,setSynchronizerContext:function(e,t){pA[e]=t},clearSynchronizerContext:function(e){if(e&&pA[e]&&delete pA[e],!e){const e=Object.keys(pA);for(let t=0;t<e.length;t++)delete pA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;default&quot;;const n=yA(e,vA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:gA,createArrayHandler:fA,createProgressHandler:mA,createSceneMtimeHandler:hA,vtkObjectManager:dA};const{vtkErrorMacro:SA,vtkDebugMacro:AA}=jt;let IA=0;function wA(e){const t=document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`);return t?t.innerHTML:null}function PA(e){return&quot;/&quot;===e[0]?e.substr(1):e}const OA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=wA(PA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=wA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=PA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;)),s=wA(i);if(null===s)a(new Error(`No such array ${i}`));else{if(&quot;string&quot;===n.dataType){let e=atob(s);r.compression&&(e=yh(mh(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Dm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(AA(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&SA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--IA&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};Vm(&quot;html&quot;,(e=>OA));const{vtkErrorMacro:RA,vtkDebugMacro:MA}=jt;function DA(e){return function(e){return&quot;/&quot;===e[0]?e.substr(1):e}(function(e){return new URL(e,&quot;http://any&quot;).pathname}(e))}const EA=function(e){let t=!1,n=0,r=null,o=&quot;&quot;;var a;return(a=e.zipContent,new Promise(((e,t)=>{&quot;string&quot;==typeof a?e(function(e,t){if(t){for(var n=new Bm(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(hh)return hh.encode(e);var o=e.length,a=new Bm(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new Bm(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return oh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error(&quot;Invalid datatype to unpack.&quot;))}))).then((n=>{r=Ch(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith(&quot;index.json&quot;)&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\\.json$/,&quot;&quot;),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||RA(&quot;ERROR!!! zip not ready...&quot;);const u=DA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join(&quot;/&quot;));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if(&quot;string&quot;!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&(&quot;string&quot;===e.dataType||&quot;JSON&quot;===e.dataType?e.buffer=yh(mh(new Uint8Array(e.buffer))):e.buffer=mh(new Uint8Array(e.buffer)).buffer),&quot;JSON&quot;===e.ref.encode?e.values=JSON.parse(e.buffer):(Ah!==e.ref.encode&&Ah&&(MA(`Swap bytes of ${e.name}`),Ih(e.buffer,vs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&RA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(yh(mh(r))):JSON.parse(r),n()}}(i,s.compression,d);e(yh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];if(a.compression){if(&quot;gz&quot;===a.compression){const e=yh(mh(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error(&quot;Invalid compression&quot;))}return Promise.resolve(JSON.parse(yh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(yh(Ch(s))):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(yh(s))},fetchImage(e,n){const a=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=Mm(i.buffer);n.src=`data:image/${function(e){const t=e.split(&quot;.&quot;).pop().toLowerCase();return&quot;jpg&quot;===t?&quot;jpeg&quot;:t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(mh(s).buffer):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(s.buffer)}}};Vm(&quot;zip&quot;,(e=>EA(e)));var VA=n(892),LA=n.n(VA),BA=n(760),NA=n.n(BA),_A=n(311),FA=n.n(_A),kA=n(192),GA=n.n(kA),UA=n(60),zA=n.n(UA),WA=n(865),HA=n.n(WA),jA=n(34),KA={};KA.styleTagTransform=HA(),KA.setAttributes=GA(),KA.insert=FA().bind(null,&quot;head&quot;),KA.domAPI=NA(),KA.insertStyleElement=zA(),LA()(jA.Z,KA);var $A=jA.Z&&jA.Z.locals?jA.Z.locals:void 0;let qA=!0;function XA(e){e.preventDefault(),e.stopPropagation()}function YA(e,t){qA=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=Hx.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:&quot;100%&quot;,width:&quot;100%&quot;,position:&quot;absolute&quot;}}).getRenderWindow(),o=CA.getSynchronizerContext(),a=CA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement(&quot;div&quot;);n.setAttribute(&quot;class&quot;,$A.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?Mh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Lm(&quot;zip&quot;,{zipContent:t,callback:e=>{r.fetchJSON(null,&quot;index.json&quot;).then(i)}})})):Mh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Lm(&quot;zip&quot;,{zipContent:t.file,callback:t=>{e.fetchJSON(null,&quot;index.json&quot;).then(i)}})}else if(t.base64Str){const e=Dm(t.base64Str),n=Lm(&quot;zip&quot;,{zipContent:e,callback:e=>{n.fetchJSON(null,&quot;index.json&quot;).then(i)}})}}function ZA(e){qA=!1;const t=document.querySelector(&quot;.content&quot;),n=document.querySelector(&quot;body&quot;),r=e||t||n;r!==e?(r.classList.add($A.fullScreen),n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;):(n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;);const o=document.createElement(&quot;div&quot;);o.innerHTML=`<div class=&quot;${$A.bigFileDrop}&quot;/><input type=&quot;file&quot; accept=&quot;.zip,.vtksz&quot; style=&quot;display: none;&quot;/>`,r.appendChild(o);const a=o.querySelector(&quot;input&quot;);function i(e){XA(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(&quot;.&quot;).slice(-1)[0];YA(r,{file:n[0],ext:e})}}a.addEventListener(&quot;change&quot;,i),o.addEventListener(&quot;drop&quot;,i),o.addEventListener(&quot;click&quot;,(e=>a.click())),o.addEventListener(&quot;dragover&quot;,XA)}const QA=Hv();if(QA.url||QA.fileURL){const e=document.querySelector(&quot;.content&quot;),t=document.querySelector(&quot;body&quot;),n=e||t;n&&(n.classList.add($A.fullScreen),t.style.margin=&quot;0&quot;,t.style.padding=&quot;0&quot;),qA=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>YA(n,QA)))}setTimeout((()=>{qA&&ZA()}),100),window.OfflineLocalView={initLocalFileLoader:ZA,load:YA}},793:function(e){&quot;use strict&quot;;e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=&quot;&quot;,r=void 0!==t[5];return t[4]&&(n+=&quot;@supports (&quot;.concat(t[4],&quot;) {&quot;)),t[2]&&(n+=&quot;@media &quot;.concat(t[2],&quot; {&quot;)),r&&(n+=&quot;@layer&quot;.concat(t[5].length>0?&quot; &quot;.concat(t[5]):&quot;&quot;,&quot; {&quot;)),n+=e(t),r&&(n+=&quot;}&quot;),t[2]&&(n+=&quot;}&quot;),t[4]&&(n+=&quot;}&quot;),n})).join(&quot;&quot;)},t.i=function(e,n,r,o,a){&quot;string&quot;==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]=&quot;@layer&quot;.concat(u[5].length>0?&quot; &quot;.concat(u[5]):&quot;&quot;,&quot; {&quot;).concat(u[1],&quot;}&quot;)),u[5]=a),n&&(u[2]?(u[1]=&quot;@media &quot;.concat(u[2],&quot; {&quot;).concat(u[1],&quot;}&quot;),u[2]=n):u[2]=n),o&&(u[4]?(u[1]=&quot;@supports (&quot;.concat(u[4],&quot;) {&quot;).concat(u[1],&quot;}&quot;),u[4]=o):u[4]=&quot;&quot;.concat(o)),t.push(u))}},t}},490:function(e){&quot;use strict&quot;;e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['&quot;].*['&quot;]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/[&quot;'() \\t\\n]|(%20)/.test(e)||t.needQuotes?'&quot;'.concat(e.replace(/&quot;/g,'\\\\&quot;').replace(/\\n/g,&quot;\\\\n&quot;),'&quot;'):e):e}},22:function(e){&quot;use strict&quot;;e.exports=function(e){return e[1]}},145:function(e,t,n){&quot;use strict&quot;;var r=n(426),o=&quot;function&quot;==typeof Symbol&&&quot;symbol&quot;==typeof Symbol(&quot;foo&quot;),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,&quot;x&quot;,{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||&quot;function&quot;==typeof(o=r)&&&quot;[object Function]&quot;===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){&quot;use strict&quot;;e.exports=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;var e;try{e=this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window;if(&quot;object&quot;==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){&quot;use strict&quot;;e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&&quot;object&quot;==typeof t&&&quot;object&quot;==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){&quot;use strict&quot;;&quot;undefined&quot;!=typeof self?e.exports=self:&quot;undefined&quot;!=typeof window?e.exports=window:e.exports=Function(&quot;return this&quot;)()},177:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){&quot;use strict&quot;;var r=n(491);e.exports=function(){return&quot;object&quot;==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){&quot;use strict&quot;;var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,&quot;globalThis&quot;);t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,&quot;globalThis&quot;,{configurable:!0,enumerable:!1,value:e,writable:!0})}else&quot;object&quot;==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){&quot;use strict&quot;;var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},&quot;toString&quot;),c=s.call((function(){}),&quot;prototype&quot;),u=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if(&quot;undefined&quot;==typeof window)return!1;for(var e in window)try{if(!p[&quot;$&quot;+e]&&o.call(window,e)&&null!==window[e]&&&quot;object&quot;==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&&quot;object&quot;==typeof e,n=&quot;[object Function]&quot;===a.call(e),r=i(e),s=t&&&quot;[object String]&quot;===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError(&quot;Object.keys called on a non-object&quot;);var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&&quot;prototype&quot;===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if(&quot;undefined&quot;==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&&quot;constructor&quot;===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){&quot;use strict&quot;;var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){&quot;use strict&quot;;var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r=&quot;[object Arguments]&quot;===n;return r||(r=&quot;[object Array]&quot;!==n&&null!==e&&&quot;object&quot;==typeof e&&&quot;number&quot;==typeof e.length&&e.length>=0&&&quot;[object Function]&quot;===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(&quot; &quot;),n.s1=r(&quot; &quot;),n.s2=r(&quot; &quot;),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+=&quot;\\0&quot;,r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=&quot;&quot;+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,&quot;global&quot;in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&&quot;object&quot;==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:&quot;string&quot;==o?e:e+&quot;\\0&quot;}function v(e,t){for(var n,r=e+&quot;&quot;,o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}(&quot;undefined&quot;!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){&quot;use strict&quot;;var t=[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r=&quot;&quot;;for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join(&quot;&quot;)}function l(e){return/[\\u0080-\\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a(&quot;hello&quot;)),&quot;undefined&quot;==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff=&quot;&quot;,this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){&quot;use strict&quot;;var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,&quot;.viewer-module-fullScreen_bbk9Y {\\n  position: absolute;\\n  width: 100vw;\\n  height: 100vh;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  z-index: -1;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\n\\n.viewer-module-fullParentSize_ETopO {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n}\\n\\n.viewer-module-bigFileDrop_aqCgh {\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  background-color: white;\\n  background-image: url(&quot;+d+&quot;);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n  background-size: contain;\\n  border-radius: 10px;\\n  width: 50px;\\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\\n  cursor: pointer;\\n}\\n\\n.viewer-module-progress_cYjQJ {\\n  flex: none;\\n  font-size: 50px;\\n  color: black;\\n  z-index: 1;\\n  background: rgba(128,128,128,.5);\\n  padding: 20px;\\n  border-radius: 10px;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\n&quot;,&quot;&quot;]),u.locals={fullScreen:&quot;viewer-module-fullScreen_bbk9Y&quot;,fullParentSize:&quot;viewer-module-fullParentSize_ETopO&quot;,bigFileDrop:&quot;viewer-module-bigFileDrop_aqCgh&quot;,progress:&quot;viewer-module-progress_cYjQJ&quot;},t.Z=u},396:function(e,t,n){var r=n(13),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){&quot;use strict&quot;;var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d=&quot;&quot;.concat(c,&quot; &quot;).concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){&quot;use strict&quot;;var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error(&quot;Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.&quot;);r.appendChild(n)}},60:function(e){&quot;use strict&quot;;e.exports=function(e){var t=document.createElement(&quot;style&quot;);return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){&quot;use strict&quot;;e.exports=function(e){var t=n.nc;t&&e.setAttribute(&quot;nonce&quot;,t)}},760:function(e){&quot;use strict&quot;;e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r=&quot;&quot;;n.supports&&(r+=&quot;@supports (&quot;.concat(n.supports,&quot;) {&quot;)),n.media&&(r+=&quot;@media &quot;.concat(n.media,&quot; {&quot;));var o=void 0!==n.layer;o&&(r+=&quot;@layer&quot;.concat(n.layer.length>0?&quot; &quot;.concat(n.layer):&quot;&quot;,&quot; {&quot;)),r+=n.css,o&&(r+=&quot;}&quot;),n.media&&(r+=&quot;}&quot;),n.supports&&(r+=&quot;}&quot;);var a=n.sourceMap;a&&&quot;undefined&quot;!=typeof btoa&&(r+=&quot;\\n/*# sourceMappingURL=data:application/json;base64,&quot;.concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))),&quot; */&quot;)),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){&quot;use strict&quot;;e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){&quot;use strict&quot;;e.exports=n.p+&quot;138e7b1469f64156810a.jpg&quot;},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error(&quot;define cannot be used indirect&quot;)},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;try{return this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){&quot;undefined&quot;!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p=&quot;&quot;,n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();\n<\/script>\n<script>\nvar container = document.querySelector('.content');\nvar base64Str = &quot;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&quot;;\n\nOfflineLocalView.load(container, { base64Str });\n<\/script>\n</body>\n</html>\n\" class=\"pyvista\" style=\"width: 99%; height: 600px; border: 1px solid rgb(221,221,221);\"></iframe>"}}, "eaa799de3c784f098ed404ea8a023ba6": {"model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "model_name": "LayoutModel", "state": {}}}, "version_major": 2, "version_minor": 0}
</script></section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="TEAM_13_geometry.html" class="btn btn-neutral float-left" title="Creating the 3D geometry for TEAM problem 13" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="magnetostatics.html" class="btn btn-neutral float-right" title="Magnetostatics solution (linear case)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>
   
  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   
</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>